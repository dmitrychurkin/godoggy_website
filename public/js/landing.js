/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/dom7/dist/dom7.modular.js":
/*!************************************************!*\
  !*** ./node_modules/dom7/dist/dom7.modular.js ***!
  \************************************************/
/*! exports provided: $, addClass, removeClass, hasClass, toggleClass, attr, removeAttr, prop, data, removeData, dataset, val, transform, transition, on, off, once, trigger, transitionEnd, animationEnd, width, outerWidth, height, outerHeight, offset, hide, show, styles, css, toArray, each, forEach, filter, map, html, text, is, indexOf, index, eq, append, appendTo, prepend, prependTo, insertBefore, insertAfter, next, nextAll, prev, prevAll, siblings, parent, parents, closest, find, children, remove, detach, add, empty, scrollTo, scrollTop, scrollLeft, animate, stop, click, blur, focus, focusin, focusout, keyup, keydown, keypress, submit, change, mousedown, mousemove, mouseup, mouseenter, mouseleave, mouseout, mouseover, touchstart, touchend, touchmove, resize, scroll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$\", function() { return $; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addClass\", function() { return addClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeClass\", function() { return removeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasClass\", function() { return hasClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleClass\", function() { return toggleClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attr\", function() { return attr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeAttr\", function() { return removeAttr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prop\", function() { return prop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"data\", function() { return data; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeData\", function() { return removeData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dataset\", function() { return dataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"val\", function() { return val; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transform\", function() { return transform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transition\", function() { return transition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"on\", function() { return on; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"off\", function() { return off; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"once\", function() { return once; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trigger\", function() { return trigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transitionEnd\", function() { return transitionEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animationEnd\", function() { return animationEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"width\", function() { return width; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"outerWidth\", function() { return outerWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"height\", function() { return height; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"outerHeight\", function() { return outerHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"offset\", function() { return offset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hide\", function() { return hide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"show\", function() { return show; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"styles\", function() { return styles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"css\", function() { return css; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toArray\", function() { return toArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filter\", function() { return filter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"html\", function() { return html; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"text\", function() { return text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"is\", function() { return is; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indexOf\", function() { return indexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"index\", function() { return index; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eq\", function() { return eq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"append\", function() { return append; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"appendTo\", function() { return appendTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prepend\", function() { return prepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prependTo\", function() { return prependTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"insertBefore\", function() { return insertBefore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"insertAfter\", function() { return insertAfter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"next\", function() { return next; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nextAll\", function() { return nextAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prev\", function() { return prev; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prevAll\", function() { return prevAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"siblings\", function() { return siblings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parent\", function() { return parent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parents\", function() { return parents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closest\", function() { return closest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"find\", function() { return find; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"children\", function() { return children; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"remove\", function() { return remove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detach\", function() { return detach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollTo\", function() { return scrollTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollTop\", function() { return scrollTop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollLeft\", function() { return scrollLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animate\", function() { return animate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stop\", function() { return stop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"click\", function() { return click; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"blur\", function() { return blur; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"focus\", function() { return focus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"focusin\", function() { return focusin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"focusout\", function() { return focusout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyup\", function() { return keyup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keydown\", function() { return keydown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keypress\", function() { return keypress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"submit\", function() { return submit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"change\", function() { return change; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mousedown\", function() { return mousedown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mousemove\", function() { return mousemove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseup\", function() { return mouseup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseenter\", function() { return mouseenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseleave\", function() { return mouseleave; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseout\", function() { return mouseout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseover\", function() { return mouseover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"touchstart\", function() { return touchstart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"touchend\", function() { return touchend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"touchmove\", function() { return touchmove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resize\", function() { return resize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scroll\", function() { return scroll; });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/dist/ssr-window.esm.js\");\n/**\n * Dom7 2.1.3\n * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n * http://framework7.io/docs/dom.html\n *\n * Copyright 2019, Vladimir Kharlampidi\n * The iDangero.us\n * http://www.idangero.us/\n *\n * Licensed under MIT\n *\n * Released on: February 11, 2019\n */\n\n\nclass Dom7 {\n  constructor(arr) {\n    const self = this;\n    // Create array-like object\n    for (let i = 0; i < arr.length; i += 1) {\n      self[i] = arr[i];\n    }\n    self.length = arr.length;\n    // Return collection with methods\n    return this;\n  }\n}\n\nfunction $(selector, context) {\n  const arr = [];\n  let i = 0;\n  if (selector && !context) {\n    if (selector instanceof Dom7) {\n      return selector;\n    }\n  }\n  if (selector) {\n      // String\n    if (typeof selector === 'string') {\n      let els;\n      let tempParent;\n      const html = selector.trim();\n      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n        let toCreate = 'div';\n        if (html.indexOf('<li') === 0) toCreate = 'ul';\n        if (html.indexOf('<tr') === 0) toCreate = 'tbody';\n        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';\n        if (html.indexOf('<tbody') === 0) toCreate = 'table';\n        if (html.indexOf('<option') === 0) toCreate = 'select';\n        tempParent = ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"].createElement(toCreate);\n        tempParent.innerHTML = html;\n        for (i = 0; i < tempParent.childNodes.length; i += 1) {\n          arr.push(tempParent.childNodes[i]);\n        }\n      } else {\n        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {\n          // Pure ID selector\n          els = [ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"].getElementById(selector.trim().split('#')[1])];\n        } else {\n          // Other selectors\n          els = (context || ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"]).querySelectorAll(selector.trim());\n        }\n        for (i = 0; i < els.length; i += 1) {\n          if (els[i]) arr.push(els[i]);\n        }\n      }\n    } else if (selector.nodeType || selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"] || selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"]) {\n      // Node/element\n      arr.push(selector);\n    } else if (selector.length > 0 && selector[0].nodeType) {\n      // Array of elements or instance of Dom\n      for (i = 0; i < selector.length; i += 1) {\n        arr.push(selector[i]);\n      }\n    }\n  }\n  return new Dom7(arr);\n}\n\n$.fn = Dom7.prototype;\n$.Class = Dom7;\n$.Dom7 = Dom7;\n\nfunction unique(arr) {\n  const uniqueArray = [];\n  for (let i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n  }\n  return uniqueArray;\n}\nfunction toCamelCase(string) {\n  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());\n}\n\nfunction requestAnimationFrame(callback) {\n  if (ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].requestAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].requestAnimationFrame(callback);\n  else if (ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].webkitRequestAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].webkitRequestAnimationFrame(callback);\n  return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].setTimeout(callback, 1000 / 60);\n}\nfunction cancelAnimationFrame(id) {\n  if (ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].cancelAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].cancelAnimationFrame(id);\n  else if (ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].webkitCancelAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].webkitCancelAnimationFrame(id);\n  return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].clearTimeout(id);\n}\n\n// Classes and attributes\nfunction addClass(className) {\n  if (typeof className === 'undefined') {\n    return this;\n  }\n  const classes = className.split(' ');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);\n    }\n  }\n  return this;\n}\nfunction removeClass(className) {\n  const classes = className.split(' ');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);\n    }\n  }\n  return this;\n}\nfunction hasClass(className) {\n  if (!this[0]) return false;\n  return this[0].classList.contains(className);\n}\nfunction toggleClass(className) {\n  const classes = className.split(' ');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);\n    }\n  }\n  return this;\n}\nfunction attr(attrs, value) {\n  if (arguments.length === 1 && typeof attrs === 'string') {\n    // Get attr\n    if (this[0]) return this[0].getAttribute(attrs);\n    return undefined;\n  }\n\n  // Set attrs\n  for (let i = 0; i < this.length; i += 1) {\n    if (arguments.length === 2) {\n      // String\n      this[i].setAttribute(attrs, value);\n    } else {\n      // Object\n      // eslint-disable-next-line\n      for (const attrName in attrs) {\n        this[i][attrName] = attrs[attrName];\n        this[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction removeAttr(attr) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].removeAttribute(attr);\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction prop(props, value) {\n  if (arguments.length === 1 && typeof props === 'string') {\n    // Get prop\n    if (this[0]) return this[0][props];\n  } else {\n    // Set props\n    for (let i = 0; i < this.length; i += 1) {\n      if (arguments.length === 2) {\n        // String\n        this[i][props] = value;\n      } else {\n        // Object\n        // eslint-disable-next-line\n        for (const propName in props) {\n          this[i][propName] = props[propName];\n        }\n      }\n    }\n    return this;\n  }\n}\nfunction data(key, value) {\n  let el;\n  if (typeof value === 'undefined') {\n    el = this[0];\n    // Get value\n    if (el) {\n      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {\n        return el.dom7ElementDataStorage[key];\n      }\n\n      const dataKey = el.getAttribute(`data-${key}`);\n      if (dataKey) {\n        return dataKey;\n      }\n      return undefined;\n    }\n    return undefined;\n  }\n\n  // Set value\n  for (let i = 0; i < this.length; i += 1) {\n    el = this[i];\n    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};\n    el.dom7ElementDataStorage[key] = value;\n  }\n  return this;\n}\nfunction removeData(key) {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {\n      el.dom7ElementDataStorage[key] = null;\n      delete el.dom7ElementDataStorage[key];\n    }\n  }\n}\nfunction dataset() {\n  const el = this[0];\n  if (!el) return undefined;\n  const dataset = {}; // eslint-disable-line\n  if (el.dataset) {\n    // eslint-disable-next-line\n    for (const dataKey in el.dataset) {\n      dataset[dataKey] = el.dataset[dataKey];\n    }\n  } else {\n    for (let i = 0; i < el.attributes.length; i += 1) {\n      // eslint-disable-next-line\n      const attr = el.attributes[i];\n      if (attr.name.indexOf('data-') >= 0) {\n        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;\n      }\n    }\n  }\n  // eslint-disable-next-line\n  for (const key in dataset) {\n    if (dataset[key] === 'false') dataset[key] = false;\n    else if (dataset[key] === 'true') dataset[key] = true;\n    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;\n  }\n  return dataset;\n}\nfunction val(value) {\n  const dom = this;\n  if (typeof value === 'undefined') {\n    if (dom[0]) {\n      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {\n        const values = [];\n        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {\n          values.push(dom[0].selectedOptions[i].value);\n        }\n        return values;\n      }\n      return dom[0].value;\n    }\n    return undefined;\n  }\n\n  for (let i = 0; i < dom.length; i += 1) {\n    const el = dom[i];\n    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {\n      for (let j = 0; j < el.options.length; j += 1) {\n        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;\n      }\n    } else {\n      el.value = value;\n    }\n  }\n  return dom;\n}\n// Transforms\n// eslint-disable-next-line\nfunction transform(transform) {\n  for (let i = 0; i < this.length; i += 1) {\n    const elStyle = this[i].style;\n    elStyle.webkitTransform = transform;\n    elStyle.transform = transform;\n  }\n  return this;\n}\nfunction transition(duration) {\n  if (typeof duration !== 'string') {\n    duration = `${duration}ms`; // eslint-disable-line\n  }\n  for (let i = 0; i < this.length; i += 1) {\n    const elStyle = this[i].style;\n    elStyle.webkitTransitionDuration = duration;\n    elStyle.transitionDuration = duration;\n  }\n  return this;\n}\n// Events\nfunction on(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === 'function') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  if (!capture) capture = false;\n\n  function handleLiveEvent(e) {\n    const target = e.target;\n    if (!target) return;\n    const eventData = e.target.dom7EventData || [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    if ($(target).is(targetSelector)) listener.apply(target, eventData);\n    else {\n      const parents = $(target).parents(); // eslint-disable-line\n      for (let k = 0; k < parents.length; k += 1) {\n        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n      }\n    }\n  }\n  function handleEvent(e) {\n    const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    listener.apply(this, eventData);\n  }\n  const events = eventType.split(' ');\n  let j;\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (!targetSelector) {\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7Listeners) el.dom7Listeners = {};\n        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n        el.dom7Listeners[event].push({\n          listener,\n          proxyListener: handleEvent,\n        });\n        el.addEventListener(event, handleEvent, capture);\n      }\n    } else {\n      // Live events\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n        el.dom7LiveListeners[event].push({\n          listener,\n          proxyListener: handleLiveEvent,\n        });\n        el.addEventListener(event, handleLiveEvent, capture);\n      }\n    }\n  }\n  return this;\n}\nfunction off(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === 'function') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  if (!capture) capture = false;\n\n  const events = eventType.split(' ');\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let handlers;\n      if (!targetSelector && el.dom7Listeners) {\n        handlers = el.dom7Listeners[event];\n      } else if (targetSelector && el.dom7LiveListeners) {\n        handlers = el.dom7LiveListeners[event];\n      }\n      if (handlers && handlers.length) {\n        for (let k = handlers.length - 1; k >= 0; k -= 1) {\n          const handler = handlers[k];\n          if (listener && handler.listener === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (!listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          }\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction once(...args) {\n  const dom = this;\n  let [eventName, targetSelector, listener, capture] = args;\n  if (typeof args[1] === 'function') {\n    [eventName, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  function onceHandler(...eventArgs) {\n    listener.apply(this, eventArgs);\n    dom.off(eventName, targetSelector, onceHandler, capture);\n    if (onceHandler.dom7proxy) {\n      delete onceHandler.dom7proxy;\n    }\n  }\n  onceHandler.dom7proxy = listener;\n  return dom.on(eventName, targetSelector, onceHandler, capture);\n}\nfunction trigger(...args) {\n  const events = args[0].split(' ');\n  const eventData = args[1];\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let evt;\n      try {\n        evt = new ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].CustomEvent(event, {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true,\n        });\n      } catch (e) {\n        evt = ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"].createEvent('Event');\n        evt.initEvent(event, true, true);\n        evt.detail = eventData;\n      }\n      // eslint-disable-next-line\n      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n      el.dispatchEvent(evt);\n      el.dom7EventData = [];\n      delete el.dom7EventData;\n    }\n  }\n  return this;\n}\nfunction transitionEnd(callback) {\n  const events = ['webkitTransitionEnd', 'transitionend'];\n  const dom = this;\n  let i;\n  function fireCallBack(e) {\n    /* jshint validthis:true */\n    if (e.target !== this) return;\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\nfunction animationEnd(callback) {\n  const events = ['webkitAnimationEnd', 'animationend'];\n  const dom = this;\n  let i;\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\n// Sizing/Styles\nfunction width() {\n  if (this[0] === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"]) {\n    return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].innerWidth;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('width'));\n  }\n\n  return null;\n}\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      const styles = this.styles();\n      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));\n    }\n    return this[0].offsetWidth;\n  }\n  return null;\n}\nfunction height() {\n  if (this[0] === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"]) {\n    return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].innerHeight;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('height'));\n  }\n\n  return null;\n}\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      const styles = this.styles();\n      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));\n    }\n    return this[0].offsetHeight;\n  }\n  return null;\n}\nfunction offset() {\n  if (this.length > 0) {\n    const el = this[0];\n    const box = el.getBoundingClientRect();\n    const body = ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"].body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"] ? ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].scrollY : el.scrollTop;\n    const scrollLeft = el === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"] ? ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].scrollX : el.scrollLeft;\n    return {\n      top: (box.top + scrollTop) - clientTop,\n      left: (box.left + scrollLeft) - clientLeft,\n    };\n  }\n\n  return null;\n}\nfunction hide() {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.display = 'none';\n  }\n  return this;\n}\nfunction show() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.style.display === 'none') {\n      el.style.display = '';\n    }\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].getComputedStyle(el, null).getPropertyValue('display') === 'none') {\n      // Still not visible\n      el.style.display = 'block';\n    }\n  }\n  return this;\n}\nfunction styles() {\n  if (this[0]) return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].getComputedStyle(this[0], null);\n  return {};\n}\nfunction css(props, value) {\n  let i;\n  if (arguments.length === 1) {\n    if (typeof props === 'string') {\n      if (this[0]) return ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].getComputedStyle(this[0], null).getPropertyValue(props);\n    } else {\n      for (i = 0; i < this.length; i += 1) {\n        // eslint-disable-next-line\n        for (let prop in props) {\n          this[i].style[prop] = props[prop];\n        }\n      }\n      return this;\n    }\n  }\n  if (arguments.length === 2 && typeof props === 'string') {\n    for (i = 0; i < this.length; i += 1) {\n      this[i].style[props] = value;\n    }\n    return this;\n  }\n  return this;\n}\n\n// Dom manipulation\nfunction toArray() {\n  const arr = [];\n  for (let i = 0; i < this.length; i += 1) {\n    arr.push(this[i]);\n  }\n  return arr;\n}\n// Iterate over the collection passing elements to `callback`\nfunction each(callback) {\n  // Don't bother continuing without a callback\n  if (!callback) return this;\n  // Iterate over the current collection\n  for (let i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this[i], i, this[i]) === false) {\n      // End the loop early\n      return this;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\nfunction forEach(callback) {\n  // Don't bother continuing without a callback\n  if (!callback) return this;\n  // Iterate over the current collection\n  for (let i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this[i], this[i], i) === false) {\n      // End the loop early\n      return this;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\nfunction filter(callback) {\n  const matchedItems = [];\n  const dom = this;\n  for (let i = 0; i < dom.length; i += 1) {\n    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);\n  }\n  return new Dom7(matchedItems);\n}\nfunction map(callback) {\n  const modifiedItems = [];\n  const dom = this;\n  for (let i = 0; i < dom.length; i += 1) {\n    modifiedItems.push(callback.call(dom[i], i, dom[i]));\n  }\n  return new Dom7(modifiedItems);\n}\n// eslint-disable-next-line\nfunction html(html) {\n  if (typeof html === 'undefined') {\n    return this[0] ? this[0].innerHTML : undefined;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].innerHTML = html;\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction text(text) {\n  if (typeof text === 'undefined') {\n    if (this[0]) {\n      return this[0].textContent.trim();\n    }\n    return null;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].textContent = text;\n  }\n  return this;\n}\nfunction is(selector) {\n  const el = this[0];\n  let compareWith;\n  let i;\n  if (!el || typeof selector === 'undefined') return false;\n  if (typeof selector === 'string') {\n    if (el.matches) return el.matches(selector);\n    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n\n    compareWith = $(selector);\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n    return false;\n  } else if (selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"]) return el === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"];\n  else if (selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"]) return el === ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"];\n\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n    return false;\n  }\n  return false;\n}\nfunction indexOf(el) {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i] === el) return i;\n  }\n  return -1;\n}\nfunction index() {\n  let child = this[0];\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\n// eslint-disable-next-line\nfunction eq(index) {\n  if (typeof index === 'undefined') return this;\n  const length = this.length;\n  let returnIndex;\n  if (index > length - 1) {\n    return new Dom7([]);\n  }\n  if (index < 0) {\n    returnIndex = length + index;\n    if (returnIndex < 0) return new Dom7([]);\n    return new Dom7([this[returnIndex]]);\n  }\n  return new Dom7([this[index]]);\n}\nfunction append(...args) {\n  let newChild;\n\n  for (let k = 0; k < args.length; k += 1) {\n    newChild = args[k];\n    for (let i = 0; i < this.length; i += 1) {\n      if (typeof newChild === 'string') {\n        const tempDiv = ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"].createElement('div');\n        tempDiv.innerHTML = newChild;\n        while (tempDiv.firstChild) {\n          this[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (let j = 0; j < newChild.length; j += 1) {\n          this[i].appendChild(newChild[j]);\n        }\n      } else {\n        this[i].appendChild(newChild);\n      }\n    }\n  }\n\n  return this;\n}\n// eslint-disable-next-line\nfunction appendTo(parent) {\n  $(parent).append(this);\n  return this;\n}\nfunction prepend(newChild) {\n  let i;\n  let j;\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === 'string') {\n      const tempDiv = ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"document\"].createElement('div');\n      tempDiv.innerHTML = newChild;\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n      }\n    } else {\n      this[i].insertBefore(newChild, this[i].childNodes[0]);\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction prependTo(parent) {\n  $(parent).prepend(this);\n  return this;\n}\nfunction insertBefore(selector) {\n  const before = $(selector);\n  for (let i = 0; i < this.length; i += 1) {\n    if (before.length === 1) {\n      before[0].parentNode.insertBefore(this[i], before[0]);\n    } else if (before.length > 1) {\n      for (let j = 0; j < before.length; j += 1) {\n        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);\n      }\n    }\n  }\n}\nfunction insertAfter(selector) {\n  const after = $(selector);\n  for (let i = 0; i < this.length; i += 1) {\n    if (after.length === 1) {\n      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);\n    } else if (after.length > 1) {\n      for (let j = 0; j < after.length; j += 1) {\n        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);\n      }\n    }\n  }\n}\nfunction next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n        return new Dom7([this[0].nextElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction nextAll(selector) {\n  const nextEls = [];\n  let el = this[0];\n  if (!el) return new Dom7([]);\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($(next).is(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return new Dom7(nextEls);\n}\nfunction prev(selector) {\n  if (this.length > 0) {\n    const el = this[0];\n    if (selector) {\n      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n        return new Dom7([el.previousElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction prevAll(selector) {\n  const prevEls = [];\n  let el = this[0];\n  if (!el) return new Dom7([]);\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($(prev).is(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return new Dom7(prevEls);\n}\nfunction siblings(selector) {\n  return this.nextAll(selector).add(this.prevAll(selector));\n}\nfunction parent(selector) {\n  const parents = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode !== null) {\n      if (selector) {\n        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n      } else {\n        parents.push(this[i].parentNode);\n      }\n    }\n  }\n  return $(unique(parents));\n}\nfunction parents(selector) {\n  const parents = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    let parent = this[i].parentNode; // eslint-disable-line\n    while (parent) {\n      if (selector) {\n        if ($(parent).is(selector)) parents.push(parent);\n      } else {\n        parents.push(parent);\n      }\n      parent = parent.parentNode;\n    }\n  }\n  return $(unique(parents));\n}\nfunction closest(selector) {\n  let closest = this; // eslint-disable-line\n  if (typeof selector === 'undefined') {\n    return new Dom7([]);\n  }\n  if (!closest.is(selector)) {\n    closest = closest.parents(selector).eq(0);\n  }\n  return closest;\n}\nfunction find(selector) {\n  const foundElements = [];\n  for (let i = 0; i < this.length; i += 1) {\n    const found = this[i].querySelectorAll(selector);\n    for (let j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n  return new Dom7(foundElements);\n}\nfunction children(selector) {\n  const children = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    const childNodes = this[i].childNodes;\n\n    for (let j = 0; j < childNodes.length; j += 1) {\n      if (!selector) {\n        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);\n      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {\n        children.push(childNodes[j]);\n      }\n    }\n  }\n  return new Dom7(unique(children));\n}\nfunction remove() {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n  }\n  return this;\n}\nfunction detach() {\n  return this.remove();\n}\nfunction add(...args) {\n  const dom = this;\n  let i;\n  let j;\n  for (i = 0; i < args.length; i += 1) {\n    const toAdd = $(args[i]);\n    for (j = 0; j < toAdd.length; j += 1) {\n      dom[dom.length] = toAdd[j];\n      dom.length += 1;\n    }\n  }\n  return dom;\n}\nfunction empty() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.nodeType === 1) {\n      for (let j = 0; j < el.childNodes.length; j += 1) {\n        if (el.childNodes[j].parentNode) {\n          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);\n        }\n      }\n      el.textContent = '';\n    }\n  }\n  return this;\n}\n\nfunction scrollTo(...args) {\n  let [left, top, duration, easing, callback] = args;\n  if (args.length === 4 && typeof easing === 'function') {\n    callback = easing;\n    [left, top, duration, callback, easing] = args;\n  }\n  if (typeof easing === 'undefined') easing = 'swing';\n\n  return this.each(function animate() {\n    const el = this;\n    let currentTop;\n    let currentLeft;\n    let maxTop;\n    let maxLeft;\n    let newTop;\n    let newLeft;\n    let scrollTop; // eslint-disable-line\n    let scrollLeft; // eslint-disable-line\n    let animateTop = top > 0 || top === 0;\n    let animateLeft = left > 0 || left === 0;\n    if (typeof easing === 'undefined') {\n      easing = 'swing';\n    }\n    if (animateTop) {\n      currentTop = el.scrollTop;\n      if (!duration) {\n        el.scrollTop = top;\n      }\n    }\n    if (animateLeft) {\n      currentLeft = el.scrollLeft;\n      if (!duration) {\n        el.scrollLeft = left;\n      }\n    }\n    if (!duration) return;\n    if (animateTop) {\n      maxTop = el.scrollHeight - el.offsetHeight;\n      newTop = Math.max(Math.min(top, maxTop), 0);\n    }\n    if (animateLeft) {\n      maxLeft = el.scrollWidth - el.offsetWidth;\n      newLeft = Math.max(Math.min(left, maxLeft), 0);\n    }\n    let startTime = null;\n    if (animateTop && newTop === currentTop) animateTop = false;\n    if (animateLeft && newLeft === currentLeft) animateLeft = false;\n    function render(time = new Date().getTime()) {\n      if (startTime === null) {\n        startTime = time;\n      }\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));\n      let done;\n      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));\n      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));\n      if (animateTop && newTop > currentTop && scrollTop >= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n      if (animateTop && newTop < currentTop && scrollTop <= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (done) {\n        if (callback) callback();\n        return;\n      }\n      if (animateTop) el.scrollTop = scrollTop;\n      if (animateLeft) el.scrollLeft = scrollLeft;\n      requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n  });\n}\n// scrollTop(top, duration, easing, callback) {\nfunction scrollTop(...args) {\n  let [top, duration, easing, callback] = args;\n  if (args.length === 3 && typeof easing === 'function') {\n    [top, duration, callback, easing] = args;\n  }\n  const dom = this;\n  if (typeof top === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollTop;\n    return null;\n  }\n  return dom.scrollTo(undefined, top, duration, easing, callback);\n}\nfunction scrollLeft(...args) {\n  let [left, duration, easing, callback] = args;\n  if (args.length === 3 && typeof easing === 'function') {\n    [left, duration, callback, easing] = args;\n  }\n  const dom = this;\n  if (typeof left === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollLeft;\n    return null;\n  }\n  return dom.scrollTo(left, undefined, duration, easing, callback);\n}\n\nfunction animate(initialProps, initialParams) {\n  const els = this;\n  const a = {\n    props: Object.assign({}, initialProps),\n    params: Object.assign({\n      duration: 300,\n      easing: 'swing', // or 'linear'\n      /* Callbacks\n      begin(elements)\n      complete(elements)\n      progress(elements, complete, remaining, start, tweenValue)\n      */\n    }, initialParams),\n\n    elements: els,\n    animating: false,\n    que: [],\n\n    easingProgress(easing, progress) {\n      if (easing === 'swing') {\n        return 0.5 - (Math.cos(progress * Math.PI) / 2);\n      }\n      if (typeof easing === 'function') {\n        return easing(progress);\n      }\n      return progress;\n    },\n    stop() {\n      if (a.frameId) {\n        cancelAnimationFrame(a.frameId);\n      }\n      a.animating = false;\n      a.elements.each((index, el) => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      a.que = [];\n    },\n    done(complete) {\n      a.animating = false;\n      a.elements.each((index, el) => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      if (complete) complete(els);\n      if (a.que.length > 0) {\n        const que = a.que.shift();\n        a.animate(que[0], que[1]);\n      }\n    },\n    animate(props, params) {\n      if (a.animating) {\n        a.que.push([props, params]);\n        return a;\n      }\n      const elements = [];\n\n      // Define & Cache Initials & Units\n      a.elements.each((index, el) => {\n        let initialFullValue;\n        let initialValue;\n        let unit;\n        let finalValue;\n        let finalFullValue;\n\n        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;\n\n        elements[index] = {\n          container: el,\n        };\n        Object.keys(props).forEach((prop) => {\n          initialFullValue = ssr_window__WEBPACK_IMPORTED_MODULE_0__[\"window\"].getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');\n          initialValue = parseFloat(initialFullValue);\n          unit = initialFullValue.replace(initialValue, '');\n          finalValue = parseFloat(props[prop]);\n          finalFullValue = props[prop] + unit;\n          elements[index][prop] = {\n            initialFullValue,\n            initialValue,\n            unit,\n            finalValue,\n            finalFullValue,\n            currentValue: initialValue,\n          };\n        });\n      });\n\n      let startTime = null;\n      let time;\n      let elementsDone = 0;\n      let propsDone = 0;\n      let done;\n      let began = false;\n\n      a.animating = true;\n\n      function render() {\n        time = new Date().getTime();\n        let progress;\n        let easeProgress;\n        // let el;\n        if (!began) {\n          began = true;\n          if (params.begin) params.begin(els);\n        }\n        if (startTime === null) {\n          startTime = time;\n        }\n        if (params.progress) {\n          // eslint-disable-next-line\n          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);\n        }\n\n        elements.forEach((element) => {\n          const el = element;\n          if (done || el.done) return;\n          Object.keys(props).forEach((prop) => {\n            if (done || el.done) return;\n            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);\n            easeProgress = a.easingProgress(params.easing, progress);\n            const { initialValue, finalValue, unit } = el[prop];\n            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));\n            const currentValue = el[prop].currentValue;\n\n            if (\n              (finalValue > initialValue && currentValue >= finalValue) ||\n              (finalValue < initialValue && currentValue <= finalValue)) {\n              el.container.style[prop] = finalValue + unit;\n              propsDone += 1;\n              if (propsDone === Object.keys(props).length) {\n                el.done = true;\n                elementsDone += 1;\n              }\n              if (elementsDone === elements.length) {\n                done = true;\n              }\n            }\n            if (done) {\n              a.done(params.complete);\n              return;\n            }\n            el.container.style[prop] = currentValue + unit;\n          });\n        });\n        if (done) return;\n        // Then call\n        a.frameId = requestAnimationFrame(render);\n      }\n      a.frameId = requestAnimationFrame(render);\n      return a;\n    },\n  };\n\n  if (a.elements.length === 0) {\n    return els;\n  }\n\n  let animateInstance;\n  for (let i = 0; i < a.elements.length; i += 1) {\n    if (a.elements[i].dom7AnimateInstance) {\n      animateInstance = a.elements[i].dom7AnimateInstance;\n    } else a.elements[i].dom7AnimateInstance = a;\n  }\n  if (!animateInstance) {\n    animateInstance = a;\n  }\n\n  if (initialProps === 'stop') {\n    animateInstance.stop();\n  } else {\n    animateInstance.animate(a.props, a.params);\n  }\n\n  return els;\n}\n\nfunction stop() {\n  const els = this;\n  for (let i = 0; i < els.length; i += 1) {\n    if (els[i].dom7AnimateInstance) {\n      els[i].dom7AnimateInstance.stop();\n    }\n  }\n}\n\nconst noTrigger = ('resize scroll').split(' ');\nfunction eventShortcut(name, ...args) {\n  if (typeof args[0] === 'undefined') {\n    for (let i = 0; i < this.length; i += 1) {\n      if (noTrigger.indexOf(name) < 0) {\n        if (name in this[i]) this[i][name]();\n        else {\n          $(this[i]).trigger(name);\n        }\n      }\n    }\n    return this;\n  }\n  return this.on(name, ...args);\n}\n\nfunction click(...args) {\n  return eventShortcut.bind(this)('click', ...args);\n}\nfunction blur(...args) {\n  return eventShortcut.bind(this)('blur', ...args);\n}\nfunction focus(...args) {\n  return eventShortcut.bind(this)('focus', ...args);\n}\nfunction focusin(...args) {\n  return eventShortcut.bind(this)('focusin', ...args);\n}\nfunction focusout(...args) {\n  return eventShortcut.bind(this)('focusout', ...args);\n}\nfunction keyup(...args) {\n  return eventShortcut.bind(this)('keyup', ...args);\n}\nfunction keydown(...args) {\n  return eventShortcut.bind(this)('keydown', ...args);\n}\nfunction keypress(...args) {\n  return eventShortcut.bind(this)('keypress', ...args);\n}\nfunction submit(...args) {\n  return eventShortcut.bind(this)('submit', ...args);\n}\nfunction change(...args) {\n  return eventShortcut.bind(this)('change', ...args);\n}\nfunction mousedown(...args) {\n  return eventShortcut.bind(this)('mousedown', ...args);\n}\nfunction mousemove(...args) {\n  return eventShortcut.bind(this)('mousemove', ...args);\n}\nfunction mouseup(...args) {\n  return eventShortcut.bind(this)('mouseup', ...args);\n}\nfunction mouseenter(...args) {\n  return eventShortcut.bind(this)('mouseenter', ...args);\n}\nfunction mouseleave(...args) {\n  return eventShortcut.bind(this)('mouseleave', ...args);\n}\nfunction mouseout(...args) {\n  return eventShortcut.bind(this)('mouseout', ...args);\n}\nfunction mouseover(...args) {\n  return eventShortcut.bind(this)('mouseover', ...args);\n}\nfunction touchstart(...args) {\n  return eventShortcut.bind(this)('touchstart', ...args);\n}\nfunction touchend(...args) {\n  return eventShortcut.bind(this)('touchend', ...args);\n}\nfunction touchmove(...args) {\n  return eventShortcut.bind(this)('touchmove', ...args);\n}\nfunction resize(...args) {\n  return eventShortcut.bind(this)('resize', ...args);\n}\nfunction scroll(...args) {\n  return eventShortcut.bind(this)('scroll', ...args);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tNy9kaXN0L2RvbTcubW9kdWxhci5qcz9mNGZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBUTtBQUM3QjtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFRO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOHZCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RvbTcvZGlzdC9kb203Lm1vZHVsYXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERvbTcgMi4xLjNcbiAqIE1pbmltYWxpc3RpYyBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIERPTSBtYW5pcHVsYXRpb24sIHdpdGggYSBqUXVlcnktY29tcGF0aWJsZSBBUElcbiAqIGh0dHA6Ly9mcmFtZXdvcms3LmlvL2RvY3MvZG9tLmh0bWxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOSwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqIFRoZSBpRGFuZ2Vyby51c1xuICogaHR0cDovL3d3dy5pZGFuZ2Vyby51cy9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqXG4gKiBSZWxlYXNlZCBvbjogRmVicnVhcnkgMTEsIDIwMTlcbiAqL1xuaW1wb3J0IHsgZG9jdW1lbnQsIHdpbmRvdyB9IGZyb20gJ3Nzci13aW5kb3cnO1xuXG5jbGFzcyBEb203IHtcbiAgY29uc3RydWN0b3IoYXJyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgLy8gQ3JlYXRlIGFycmF5LWxpa2Ugb2JqZWN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHNlbGZbaV0gPSBhcnJbaV07XG4gICAgfVxuICAgIHNlbGYubGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAvLyBSZXR1cm4gY29sbGVjdGlvbiB3aXRoIG1ldGhvZHNcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGlmIChzZWxlY3RvciAmJiAhY29udGV4dCkge1xuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG4gIH1cbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAvLyBTdHJpbmdcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGVscztcbiAgICAgIGxldCB0ZW1wUGFyZW50O1xuICAgICAgY29uc3QgaHRtbCA9IHNlbGVjdG9yLnRyaW0oKTtcbiAgICAgIGlmIChodG1sLmluZGV4T2YoJzwnKSA+PSAwICYmIGh0bWwuaW5kZXhPZignPicpID49IDApIHtcbiAgICAgICAgbGV0IHRvQ3JlYXRlID0gJ2Rpdic7XG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxsaScpID09PSAwKSB0b0NyZWF0ZSA9ICd1bCc7XG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0cicpID09PSAwKSB0b0NyZWF0ZSA9ICd0Ym9keSc7XG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0ZCcpID09PSAwIHx8IGh0bWwuaW5kZXhPZignPHRoJykgPT09IDApIHRvQ3JlYXRlID0gJ3RyJztcbiAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRib2R5JykgPT09IDApIHRvQ3JlYXRlID0gJ3RhYmxlJztcbiAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPG9wdGlvbicpID09PSAwKSB0b0NyZWF0ZSA9ICdzZWxlY3QnO1xuICAgICAgICB0ZW1wUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0b0NyZWF0ZSk7XG4gICAgICAgIHRlbXBQYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXBQYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGFyci5wdXNoKHRlbXBQYXJlbnQuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY29udGV4dCAmJiBzZWxlY3RvclswXSA9PT0gJyMnICYmICFzZWxlY3Rvci5tYXRjaCgvWyAuPD46fl0vKSkge1xuICAgICAgICAgIC8vIFB1cmUgSUQgc2VsZWN0b3JcbiAgICAgICAgICBlbHMgPSBbZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3IudHJpbSgpLnNwbGl0KCcjJylbMV0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlciBzZWxlY3RvcnNcbiAgICAgICAgICBlbHMgPSAoY29udGV4dCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvci50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoZWxzW2ldKSBhcnIucHVzaChlbHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSB8fCBzZWxlY3RvciA9PT0gd2luZG93IHx8IHNlbGVjdG9yID09PSBkb2N1bWVudCkge1xuICAgICAgLy8gTm9kZS9lbGVtZW50XG4gICAgICBhcnIucHVzaChzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5sZW5ndGggPiAwICYmIHNlbGVjdG9yWzBdLm5vZGVUeXBlKSB7XG4gICAgICAvLyBBcnJheSBvZiBlbGVtZW50cyBvciBpbnN0YW5jZSBvZiBEb21cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rvci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnIucHVzaChzZWxlY3RvcltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRG9tNyhhcnIpO1xufVxuXG4kLmZuID0gRG9tNy5wcm90b3R5cGU7XG4kLkNsYXNzID0gRG9tNztcbiQuRG9tNyA9IERvbTc7XG5cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgY29uc3QgdW5pcXVlQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodW5pcXVlQXJyYXkuaW5kZXhPZihhcnJbaV0pID09PSAtMSkgdW5pcXVlQXJyYXkucHVzaChhcnJbaV0pO1xuICB9XG4gIHJldHVybiB1bmlxdWVBcnJheTtcbn1cbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCAobWF0Y2gsIGdyb3VwMSkgPT4gZ3JvdXAxLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgZWxzZSBpZiAod2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG59XG5mdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICBpZiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgZWxzZSBpZiAod2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xufVxuXG4vLyBDbGFzc2VzIGFuZCBhdHRyaWJ1dGVzXG5mdW5jdGlvbiBhZGRDbGFzcyhjbGFzc05hbWUpIHtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tqXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykgdGhpc1tqXS5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2pdICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpc1tqXS5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB0aGlzW2pdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gIGlmICghdGhpc1swXSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdGhpc1swXS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGNsYXNzTmFtZSkge1xuICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2pdICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpc1tqXS5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB0aGlzW2pdLmNsYXNzTGlzdC50b2dnbGUoY2xhc3Nlc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gYXR0cihhdHRycywgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgIC8vIEdldCBhdHRyXG4gICAgaWYgKHRoaXNbMF0pIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShhdHRycyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFNldCBhdHRyc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgLy8gU3RyaW5nXG4gICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRycywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3RcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICB0aGlzW2ldW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgdGhpc1tpXS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJzW2F0dHJOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiByZW1vdmVBdHRyKGF0dHIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhpc1tpXS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmZ1bmN0aW9uIHByb3AocHJvcHMsIHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBHZXQgcHJvcFxuICAgIGlmICh0aGlzWzBdKSByZXR1cm4gdGhpc1swXVtwcm9wc107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2V0IHByb3BzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAvLyBTdHJpbmdcbiAgICAgICAgdGhpc1tpXVtwcm9wc10gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXNbaV1bcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBkYXRhKGtleSwgdmFsdWUpIHtcbiAgbGV0IGVsO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsID0gdGhpc1swXTtcbiAgICAvLyBHZXQgdmFsdWVcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChlbC5kb203RWxlbWVudERhdGFTdG9yYWdlICYmIChrZXkgaW4gZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZSkpIHtcbiAgICAgICAgcmV0dXJuIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YUtleSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS0ke2tleX1gKTtcbiAgICAgIGlmIChkYXRhS2V5KSB7XG4gICAgICAgIHJldHVybiBkYXRhS2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFNldCB2YWx1ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBlbCA9IHRoaXNbaV07XG4gICAgaWYgKCFlbC5kb203RWxlbWVudERhdGFTdG9yYWdlKSBlbC5kb203RWxlbWVudERhdGFTdG9yYWdlID0ge307XG4gICAgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiByZW1vdmVEYXRhKGtleSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgaWYgKGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UgJiYgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldKSB7XG4gICAgICBlbC5kb203RWxlbWVudERhdGFTdG9yYWdlW2tleV0gPSBudWxsO1xuICAgICAgZGVsZXRlIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRhdGFzZXQoKSB7XG4gIGNvbnN0IGVsID0gdGhpc1swXTtcbiAgaWYgKCFlbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgZGF0YXNldCA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmIChlbC5kYXRhc2V0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgZm9yIChjb25zdCBkYXRhS2V5IGluIGVsLmRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXRbZGF0YUtleV0gPSBlbC5kYXRhc2V0W2RhdGFLZXldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgY29uc3QgYXR0ciA9IGVsLmF0dHJpYnV0ZXNbaV07XG4gICAgICBpZiAoYXR0ci5uYW1lLmluZGV4T2YoJ2RhdGEtJykgPj0gMCkge1xuICAgICAgICBkYXRhc2V0W3RvQ2FtZWxDYXNlKGF0dHIubmFtZS5zcGxpdCgnZGF0YS0nKVsxXSldID0gYXR0ci52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGZvciAoY29uc3Qga2V5IGluIGRhdGFzZXQpIHtcbiAgICBpZiAoZGF0YXNldFtrZXldID09PSAnZmFsc2UnKSBkYXRhc2V0W2tleV0gPSBmYWxzZTtcbiAgICBlbHNlIGlmIChkYXRhc2V0W2tleV0gPT09ICd0cnVlJykgZGF0YXNldFtrZXldID0gdHJ1ZTtcbiAgICBlbHNlIGlmIChwYXJzZUZsb2F0KGRhdGFzZXRba2V5XSkgPT09IGRhdGFzZXRba2V5XSAqIDEpIGRhdGFzZXRba2V5XSAqPSAxO1xuICB9XG4gIHJldHVybiBkYXRhc2V0O1xufVxuZnVuY3Rpb24gdmFsKHZhbHVlKSB7XG4gIGNvbnN0IGRvbSA9IHRoaXM7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGRvbVswXSkge1xuICAgICAgaWYgKGRvbVswXS5tdWx0aXBsZSAmJiBkb21bMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tWzBdLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGRvbVswXS5zZWxlY3RlZE9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tWzBdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBlbCA9IGRvbVtpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgZWwubXVsdGlwbGUgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZWwub3B0aW9ucy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBlbC5vcHRpb25zW2pdLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihlbC5vcHRpb25zW2pdLnZhbHVlKSA+PSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZG9tO1xufVxuLy8gVHJhbnNmb3Jtc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGVsU3R5bGUgPSB0aGlzW2ldLnN0eWxlO1xuICAgIGVsU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGVsU3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbihkdXJhdGlvbikge1xuICBpZiAodHlwZW9mIGR1cmF0aW9uICE9PSAnc3RyaW5nJykge1xuICAgIGR1cmF0aW9uID0gYCR7ZHVyYXRpb259bXNgOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZWxTdHlsZSA9IHRoaXNbaV0uc3R5bGU7XG4gICAgZWxTdHlsZS53ZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICBlbFN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuLy8gRXZlbnRzXG5mdW5jdGlvbiBvbiguLi5hcmdzKSB7XG4gIGxldCBbZXZlbnRUeXBlLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcbiAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgW2V2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcbiAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNhcHR1cmUpIGNhcHR1cmUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBoYW5kbGVMaXZlRXZlbnQoZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgY29uc3QgZXZlbnREYXRhID0gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXTtcbiAgICBpZiAoZXZlbnREYXRhLmluZGV4T2YoZSkgPCAwKSB7XG4gICAgICBldmVudERhdGEudW5zaGlmdChlKTtcbiAgICB9XG4gICAgaWYgKCQodGFyZ2V0KS5pcyh0YXJnZXRTZWxlY3RvcikpIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgZXZlbnREYXRhKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSAkKHRhcmdldCkucGFyZW50cygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHBhcmVudHMubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgaWYgKCQocGFyZW50c1trXSkuaXModGFyZ2V0U2VsZWN0b3IpKSBsaXN0ZW5lci5hcHBseShwYXJlbnRzW2tdLCBldmVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3QgZXZlbnREYXRhID0gZSAmJiBlLnRhcmdldCA/IGUudGFyZ2V0LmRvbTdFdmVudERhdGEgfHwgW10gOiBbXTtcbiAgICBpZiAoZXZlbnREYXRhLmluZGV4T2YoZSkgPCAwKSB7XG4gICAgICBldmVudERhdGEudW5zaGlmdChlKTtcbiAgICB9XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnREYXRhKTtcbiAgfVxuICBjb25zdCBldmVudHMgPSBldmVudFR5cGUuc3BsaXQoJyAnKTtcbiAgbGV0IGo7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGVsID0gdGhpc1tpXTtcbiAgICBpZiAoIXRhcmdldFNlbGVjdG9yKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2pdO1xuICAgICAgICBpZiAoIWVsLmRvbTdMaXN0ZW5lcnMpIGVsLmRvbTdMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKCFlbC5kb203TGlzdGVuZXJzW2V2ZW50XSkgZWwuZG9tN0xpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgZWwuZG9tN0xpc3RlbmVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgcHJveHlMaXN0ZW5lcjogaGFuZGxlRXZlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpdmUgZXZlbnRzXG4gICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2pdO1xuICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzKSBlbC5kb203TGl2ZUxpc3RlbmVycyA9IHt9O1xuICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XSkgZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgIGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICBwcm94eUxpc3RlbmVyOiBoYW5kbGVMaXZlRXZlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVMaXZlRXZlbnQsIGNhcHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIG9mZiguLi5hcmdzKSB7XG4gIGxldCBbZXZlbnRUeXBlLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcbiAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgW2V2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcbiAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNhcHR1cmUpIGNhcHR1cmUgPSBmYWxzZTtcblxuICBjb25zdCBldmVudHMgPSBldmVudFR5cGUuc3BsaXQoJyAnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpc1tqXTtcbiAgICAgIGxldCBoYW5kbGVycztcbiAgICAgIGlmICghdGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpc3RlbmVycykge1xuICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXRTZWxlY3RvciAmJiBlbC5kb203TGl2ZUxpc3RlbmVycykge1xuICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGsgPj0gMDsgayAtPSAxKSB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW2tdO1xuICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBoYW5kbGVyLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyICYmIGhhbmRsZXIubGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lci5kb203cHJveHkgJiYgaGFuZGxlci5saXN0ZW5lci5kb203cHJveHkgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIG9uY2UoLi4uYXJncykge1xuICBjb25zdCBkb20gPSB0aGlzO1xuICBsZXQgW2V2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFtldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gICAgdGFyZ2V0U2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gb25jZUhhbmRsZXIoLi4uZXZlbnRBcmdzKSB7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnRBcmdzKTtcbiAgICBkb20ub2ZmKGV2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIG9uY2VIYW5kbGVyLCBjYXB0dXJlKTtcbiAgICBpZiAob25jZUhhbmRsZXIuZG9tN3Byb3h5KSB7XG4gICAgICBkZWxldGUgb25jZUhhbmRsZXIuZG9tN3Byb3h5O1xuICAgIH1cbiAgfVxuICBvbmNlSGFuZGxlci5kb203cHJveHkgPSBsaXN0ZW5lcjtcbiAgcmV0dXJuIGRvbS5vbihldmVudE5hbWUsIHRhcmdldFNlbGVjdG9yLCBvbmNlSGFuZGxlciwgY2FwdHVyZSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyKC4uLmFyZ3MpIHtcbiAgY29uc3QgZXZlbnRzID0gYXJnc1swXS5zcGxpdCgnICcpO1xuICBjb25zdCBldmVudERhdGEgPSBhcmdzWzFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgY29uc3QgZWwgPSB0aGlzW2pdO1xuICAgICAgbGV0IGV2dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2dCA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICBkZXRhaWw6IGV2ZW50RGF0YSxcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZXZ0LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGV2dC5kZXRhaWwgPSBldmVudERhdGE7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGVsLmRvbTdFdmVudERhdGEgPSBhcmdzLmZpbHRlcigoZGF0YSwgZGF0YUluZGV4KSA9PiBkYXRhSW5kZXggPiAwKTtcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGVsLmRvbTdFdmVudERhdGEgPSBbXTtcbiAgICAgIGRlbGV0ZSBlbC5kb203RXZlbnREYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoY2FsbGJhY2spIHtcbiAgY29uc3QgZXZlbnRzID0gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcbiAgY29uc3QgZG9tID0gdGhpcztcbiAgbGV0IGk7XG4gIGZ1bmN0aW9uIGZpcmVDYWxsQmFjayhlKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkb20ub2ZmKGV2ZW50c1tpXSwgZmlyZUNhbGxCYWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZG9tLm9uKGV2ZW50c1tpXSwgZmlyZUNhbGxCYWNrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBhbmltYXRpb25FbmQoY2FsbGJhY2spIHtcbiAgY29uc3QgZXZlbnRzID0gWyd3ZWJraXRBbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uZW5kJ107XG4gIGNvbnN0IGRvbSA9IHRoaXM7XG4gIGxldCBpO1xuICBmdW5jdGlvbiBmaXJlQ2FsbEJhY2soZSkge1xuICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xuICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZG9tLm9mZihldmVudHNbaV0sIGZpcmVDYWxsQmFjayk7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRvbS5vbihldmVudHNbaV0sIGZpcmVDYWxsQmFjayk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuLy8gU2l6aW5nL1N0eWxlc1xuZnVuY3Rpb24gd2lkdGgoKSB7XG4gIGlmICh0aGlzWzBdID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGg7XG4gIH1cblxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5jc3MoJ3dpZHRoJykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBvdXRlcldpZHRoKGluY2x1ZGVNYXJnaW5zKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMoKTtcbiAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaGVpZ2h0KCkge1xuICBpZiAodGhpc1swXSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNzcygnaGVpZ2h0JykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBvdXRlckhlaWdodChpbmNsdWRlTWFyZ2lucykge1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHRoaXMuc3R5bGVzKCk7XG4gICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gb2Zmc2V0KCkge1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgIGNvbnN0IGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGNsaWVudFRvcCA9IGVsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICAgIGNvbnN0IGNsaWVudExlZnQgPSBlbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IGVsID09PSB3aW5kb3cgPyB3aW5kb3cuc2Nyb2xsWSA6IGVsLnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxYIDogZWwuc2Nyb2xsTGVmdDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAoYm94LnRvcCArIHNjcm9sbFRvcCkgLSBjbGllbnRUb3AsXG4gICAgICBsZWZ0OiAoYm94LmxlZnQgKyBzY3JvbGxMZWZ0KSAtIGNsaWVudExlZnQsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaGlkZSgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gc2hvdygpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzW2ldO1xuICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgPT09ICdub25lJykge1xuICAgICAgLy8gU3RpbGwgbm90IHZpc2libGVcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgaWYgKHRoaXNbMF0pIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKTtcbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gY3NzKHByb3BzLCB2YWx1ZSkge1xuICBsZXQgaTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzW2ldLnN0eWxlW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRoaXNbaV0uc3R5bGVbcHJvcHNdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBEb20gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiB0b0FycmF5KCkge1xuICBjb25zdCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgYXJyLnB1c2godGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cbi8vIEl0ZXJhdGUgb3ZlciB0aGUgY29sbGVjdGlvbiBwYXNzaW5nIGVsZW1lbnRzIHRvIGBjYWxsYmFja2BcbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGNvbnRpbnVpbmcgd2l0aG91dCBhIGNhbGxiYWNrXG4gIGlmICghY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAvLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgY29sbGVjdGlvblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAvLyBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNbaV0sIGksIHRoaXNbaV0pID09PSBmYWxzZSkge1xuICAgICAgLy8gRW5kIHRoZSBsb29wIGVhcmx5XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIGB0aGlzYCB0byBhbGxvdyBjaGFpbmVkIERPTSBvcGVyYXRpb25zXG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaykge1xuICAvLyBEb24ndCBib3RoZXIgY29udGludWluZyB3aXRob3V0IGEgY2FsbGJhY2tcbiAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBjb2xsZWN0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIC8vIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc1tpXSwgdGhpc1tpXSwgaSkgPT09IGZhbHNlKSB7XG4gICAgICAvLyBFbmQgdGhlIGxvb3AgZWFybHlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICAvLyBSZXR1cm4gYHRoaXNgIHRvIGFsbG93IGNoYWluZWQgRE9NIG9wZXJhdGlvbnNcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgY29uc3QgbWF0Y2hlZEl0ZW1zID0gW107XG4gIGNvbnN0IGRvbSA9IHRoaXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGNhbGxiYWNrLmNhbGwoZG9tW2ldLCBpLCBkb21baV0pKSBtYXRjaGVkSXRlbXMucHVzaChkb21baV0pO1xuICB9XG4gIHJldHVybiBuZXcgRG9tNyhtYXRjaGVkSXRlbXMpO1xufVxuZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG4gIGNvbnN0IG1vZGlmaWVkSXRlbXMgPSBbXTtcbiAgY29uc3QgZG9tID0gdGhpcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBtb2RpZmllZEl0ZW1zLnB1c2goY2FsbGJhY2suY2FsbChkb21baV0sIGksIGRvbVtpXSkpO1xuICB9XG4gIHJldHVybiBuZXcgRG9tNyhtb2RpZmllZEl0ZW1zKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZnVuY3Rpb24gaHRtbChodG1sKSB7XG4gIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uaW5uZXJIVE1MIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhpc1tpXS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiB0ZXh0KHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0aGlzWzBdKSB7XG4gICAgICByZXR1cm4gdGhpc1swXS50ZXh0Q29udGVudC50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhpc1tpXS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBpcyhzZWxlY3Rvcikge1xuICBjb25zdCBlbCA9IHRoaXNbMF07XG4gIGxldCBjb21wYXJlV2l0aDtcbiAgbGV0IGk7XG4gIGlmICghZWwgfHwgdHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbC5tYXRjaGVzKSByZXR1cm4gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGNvbXBhcmVXaXRoID0gJChzZWxlY3Rvcik7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBhcmVXaXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY29tcGFyZVdpdGhbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSBkb2N1bWVudCkgcmV0dXJuIGVsID09PSBkb2N1bWVudDtcbiAgZWxzZSBpZiAoc2VsZWN0b3IgPT09IHdpbmRvdykgcmV0dXJuIGVsID09PSB3aW5kb3c7XG5cbiAgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykge1xuICAgIGNvbXBhcmVXaXRoID0gc2VsZWN0b3Iubm9kZVR5cGUgPyBbc2VsZWN0b3JdIDogc2VsZWN0b3I7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBhcmVXaXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY29tcGFyZVdpdGhbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluZGV4T2YoZWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IGVsKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBpbmRleCgpIHtcbiAgbGV0IGNoaWxkID0gdGhpc1swXTtcbiAgbGV0IGk7XG4gIGlmIChjaGlsZCkge1xuICAgIGkgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHdoaWxlICgoY2hpbGQgPSBjaGlsZC5wcmV2aW91c1NpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZnVuY3Rpb24gZXEoaW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzO1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgbGV0IHJldHVybkluZGV4O1xuICBpZiAoaW5kZXggPiBsZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIG5ldyBEb203KFtdKTtcbiAgfVxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuSW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBpZiAocmV0dXJuSW5kZXggPCAwKSByZXR1cm4gbmV3IERvbTcoW10pO1xuICAgIHJldHVybiBuZXcgRG9tNyhbdGhpc1tyZXR1cm5JbmRleF1dKTtcbiAgfVxuICByZXR1cm4gbmV3IERvbTcoW3RoaXNbaW5kZXhdXSk7XG59XG5mdW5jdGlvbiBhcHBlbmQoLi4uYXJncykge1xuICBsZXQgbmV3Q2hpbGQ7XG5cbiAgZm9yIChsZXQgayA9IDA7IGsgPCBhcmdzLmxlbmd0aDsgayArPSAxKSB7XG4gICAgbmV3Q2hpbGQgPSBhcmdzW2tdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xuICAgICAgICB3aGlsZSAodGVtcERpdi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZCh0ZW1wRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5ld0NoaWxkLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZFtqXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiBhcHBlbmRUbyhwYXJlbnQpIHtcbiAgJChwYXJlbnQpLmFwcGVuZCh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBwcmVwZW5kKG5ld0NoaWxkKSB7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBuZXdDaGlsZDtcbiAgICAgIGZvciAoaiA9IHRlbXBEaXYuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkge1xuICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZSh0ZW1wRGl2LmNoaWxkTm9kZXNbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZShuZXdDaGlsZFtqXSwgdGhpc1tpXS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiBwcmVwZW5kVG8ocGFyZW50KSB7XG4gICQocGFyZW50KS5wcmVwZW5kKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShzZWxlY3Rvcikge1xuICBjb25zdCBiZWZvcmUgPSAkKHNlbGVjdG9yKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGJlZm9yZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJlZm9yZVswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLCBiZWZvcmVbMF0pO1xuICAgIH0gZWxzZSBpZiAoYmVmb3JlLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmVmb3JlLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGJlZm9yZVtqXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSwgYmVmb3JlW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEFmdGVyKHNlbGVjdG9yKSB7XG4gIGNvbnN0IGFmdGVyID0gJChzZWxlY3Rvcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhZnRlci5sZW5ndGggPT09IDEpIHtcbiAgICAgIGFmdGVyWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXNbaV0sIGFmdGVyWzBdLm5leHRTaWJsaW5nKTtcbiAgICB9IGVsc2UgaWYgKGFmdGVyLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWZ0ZXIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgYWZ0ZXJbal0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXS5jbG9uZU5vZGUodHJ1ZSksIGFmdGVyW2pdLm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5leHQoc2VsZWN0b3IpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nICYmICQodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IERvbTcoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERvbTcoW10pO1xuICAgIH1cblxuICAgIGlmICh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZykgcmV0dXJuIG5ldyBEb203KFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pO1xuICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KFtdKTtcbn1cbmZ1bmN0aW9uIG5leHRBbGwoc2VsZWN0b3IpIHtcbiAgY29uc3QgbmV4dEVscyA9IFtdO1xuICBsZXQgZWwgPSB0aGlzWzBdO1xuICBpZiAoIWVsKSByZXR1cm4gbmV3IERvbTcoW10pO1xuICB3aGlsZSAoZWwubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgY29uc3QgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKCQobmV4dCkuaXMoc2VsZWN0b3IpKSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgfSBlbHNlIG5leHRFbHMucHVzaChuZXh0KTtcbiAgICBlbCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KG5leHRFbHMpO1xufVxuZnVuY3Rpb24gcHJldihzZWxlY3Rvcikge1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgJChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb203KFtlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERvbTcoW10pO1xuICAgIH1cblxuICAgIGlmIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSByZXR1cm4gbmV3IERvbTcoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICByZXR1cm4gbmV3IERvbTcoW10pO1xuICB9XG4gIHJldHVybiBuZXcgRG9tNyhbXSk7XG59XG5mdW5jdGlvbiBwcmV2QWxsKHNlbGVjdG9yKSB7XG4gIGNvbnN0IHByZXZFbHMgPSBbXTtcbiAgbGV0IGVsID0gdGhpc1swXTtcbiAgaWYgKCFlbCkgcmV0dXJuIG5ldyBEb203KFtdKTtcbiAgd2hpbGUgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBjb25zdCBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKCQocHJldikuaXMoc2VsZWN0b3IpKSBwcmV2RWxzLnB1c2gocHJldik7XG4gICAgfSBlbHNlIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICBlbCA9IHByZXY7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KHByZXZFbHMpO1xufVxuZnVuY3Rpb24gc2libGluZ3Moc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHRoaXMubmV4dEFsbChzZWxlY3RvcikuYWRkKHRoaXMucHJldkFsbChzZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gcGFyZW50KHNlbGVjdG9yKSB7XG4gIGNvbnN0IHBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCQodGhpc1tpXS5wYXJlbnROb2RlKS5pcyhzZWxlY3RvcikpIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAkKHVuaXF1ZShwYXJlbnRzKSk7XG59XG5mdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gIGNvbnN0IHBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgcGFyZW50ID0gdGhpc1tpXS5wYXJlbnROb2RlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICgkKHBhcmVudCkuaXMoc2VsZWN0b3IpKSBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiAkKHVuaXF1ZShwYXJlbnRzKSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gIGxldCBjbG9zZXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XG4gIH1cbiAgaWYgKCFjbG9zZXN0LmlzKHNlbGVjdG9yKSkge1xuICAgIGNsb3Nlc3QgPSBjbG9zZXN0LnBhcmVudHMoc2VsZWN0b3IpLmVxKDApO1xuICB9XG4gIHJldHVybiBjbG9zZXN0O1xufVxuZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xuICBjb25zdCBmb3VuZEVsZW1lbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBmb3VuZEVsZW1lbnRzLnB1c2goZm91bmRbal0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IERvbTcoZm91bmRFbGVtZW50cyk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihzZWxlY3Rvcikge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzW2ldLmNoaWxkTm9kZXM7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEpIGNoaWxkcmVuLnB1c2goY2hpbGROb2Rlc1tqXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEgJiYgJChjaGlsZE5vZGVzW2pdKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KHVuaXF1ZShjaGlsZHJlbikpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlKSB0aGlzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZXRhY2goKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gYWRkKC4uLmFyZ3MpIHtcbiAgY29uc3QgZG9tID0gdGhpcztcbiAgbGV0IGk7XG4gIGxldCBqO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHRvQWRkID0gJChhcmdzW2ldKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdG9BZGQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIGRvbVtkb20ubGVuZ3RoXSA9IHRvQWRkW2pdO1xuICAgICAgZG9tLmxlbmd0aCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGVsID0gdGhpc1tpXTtcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZWwuY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBpZiAoZWwuY2hpbGROb2Rlc1tqXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZWwuY2hpbGROb2Rlc1tqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsLmNoaWxkTm9kZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbC50ZXh0Q29udGVudCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG8oLi4uYXJncykge1xuICBsZXQgW2xlZnQsIHRvcCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2tdID0gYXJncztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBlYXNpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICBbbGVmdCwgdG9wLCBkdXJhdGlvbiwgY2FsbGJhY2ssIGVhc2luZ10gPSBhcmdzO1xuICB9XG4gIGlmICh0eXBlb2YgZWFzaW5nID09PSAndW5kZWZpbmVkJykgZWFzaW5nID0gJ3N3aW5nJztcblxuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzO1xuICAgIGxldCBjdXJyZW50VG9wO1xuICAgIGxldCBjdXJyZW50TGVmdDtcbiAgICBsZXQgbWF4VG9wO1xuICAgIGxldCBtYXhMZWZ0O1xuICAgIGxldCBuZXdUb3A7XG4gICAgbGV0IG5ld0xlZnQ7XG4gICAgbGV0IHNjcm9sbFRvcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGxldCBzY3JvbGxMZWZ0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgbGV0IGFuaW1hdGVUb3AgPSB0b3AgPiAwIHx8IHRvcCA9PT0gMDtcbiAgICBsZXQgYW5pbWF0ZUxlZnQgPSBsZWZ0ID4gMCB8fCBsZWZ0ID09PSAwO1xuICAgIGlmICh0eXBlb2YgZWFzaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZWFzaW5nID0gJ3N3aW5nJztcbiAgICB9XG4gICAgaWYgKGFuaW1hdGVUb3ApIHtcbiAgICAgIGN1cnJlbnRUb3AgPSBlbC5zY3JvbGxUb3A7XG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuaW1hdGVMZWZ0KSB7XG4gICAgICBjdXJyZW50TGVmdCA9IGVsLnNjcm9sbExlZnQ7XG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWR1cmF0aW9uKSByZXR1cm47XG4gICAgaWYgKGFuaW1hdGVUb3ApIHtcbiAgICAgIG1heFRvcCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLm9mZnNldEhlaWdodDtcbiAgICAgIG5ld1RvcCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgbWF4VG9wKSwgMCk7XG4gICAgfVxuICAgIGlmIChhbmltYXRlTGVmdCkge1xuICAgICAgbWF4TGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICBuZXdMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4obGVmdCwgbWF4TGVmdCksIDApO1xuICAgIH1cbiAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPT09IGN1cnJlbnRUb3ApIGFuaW1hdGVUb3AgPSBmYWxzZTtcbiAgICBpZiAoYW5pbWF0ZUxlZnQgJiYgbmV3TGVmdCA9PT0gY3VycmVudExlZnQpIGFuaW1hdGVMZWZ0ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcmVuZGVyKHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSkge1xuICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgICBzdGFydFRpbWUgPSB0aW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbiwgMSksIDApO1xuICAgICAgY29uc3QgZWFzZVByb2dyZXNzID0gZWFzaW5nID09PSAnbGluZWFyJyA/IHByb2dyZXNzIDogKDAuNSAtIChNYXRoLmNvcyhwcm9ncmVzcyAqIE1hdGguUEkpIC8gMikpO1xuICAgICAgbGV0IGRvbmU7XG4gICAgICBpZiAoYW5pbWF0ZVRvcCkgc2Nyb2xsVG9wID0gY3VycmVudFRvcCArIChlYXNlUHJvZ3Jlc3MgKiAobmV3VG9wIC0gY3VycmVudFRvcCkpO1xuICAgICAgaWYgKGFuaW1hdGVMZWZ0KSBzY3JvbGxMZWZ0ID0gY3VycmVudExlZnQgKyAoZWFzZVByb2dyZXNzICogKG5ld0xlZnQgLSBjdXJyZW50TGVmdCkpO1xuICAgICAgaWYgKGFuaW1hdGVUb3AgJiYgbmV3VG9wID4gY3VycmVudFRvcCAmJiBzY3JvbGxUb3AgPj0gbmV3VG9wKSB7XG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IG5ld1RvcDtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPCBjdXJyZW50VG9wICYmIHNjcm9sbFRvcCA8PSBuZXdUb3ApIHtcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0gbmV3VG9wO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmltYXRlTGVmdCAmJiBuZXdMZWZ0ID4gY3VycmVudExlZnQgJiYgc2Nyb2xsTGVmdCA+PSBuZXdMZWZ0KSB7XG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBuZXdMZWZ0O1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmltYXRlTGVmdCAmJiBuZXdMZWZ0IDwgY3VycmVudExlZnQgJiYgc2Nyb2xsTGVmdCA8PSBuZXdMZWZ0KSB7XG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBuZXdMZWZ0O1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0ZVRvcCkgZWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgaWYgKGFuaW1hdGVMZWZ0KSBlbC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgfSk7XG59XG4vLyBzY3JvbGxUb3AodG9wLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjaykge1xuZnVuY3Rpb24gc2Nyb2xsVG9wKC4uLmFyZ3MpIHtcbiAgbGV0IFt0b3AsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgZWFzaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgW3RvcCwgZHVyYXRpb24sIGNhbGxiYWNrLCBlYXNpbmddID0gYXJncztcbiAgfVxuICBjb25zdCBkb20gPSB0aGlzO1xuICBpZiAodHlwZW9mIHRvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA+IDApIHJldHVybiBkb21bMF0uc2Nyb2xsVG9wO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBkb20uc2Nyb2xsVG8odW5kZWZpbmVkLCB0b3AsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHNjcm9sbExlZnQoLi4uYXJncykge1xuICBsZXQgW2xlZnQsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgZWFzaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgW2xlZnQsIGR1cmF0aW9uLCBjYWxsYmFjaywgZWFzaW5nXSA9IGFyZ3M7XG4gIH1cbiAgY29uc3QgZG9tID0gdGhpcztcbiAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChkb20ubGVuZ3RoID4gMCkgcmV0dXJuIGRvbVswXS5zY3JvbGxMZWZ0O1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBkb20uc2Nyb2xsVG8obGVmdCwgdW5kZWZpbmVkLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGUoaW5pdGlhbFByb3BzLCBpbml0aWFsUGFyYW1zKSB7XG4gIGNvbnN0IGVscyA9IHRoaXM7XG4gIGNvbnN0IGEgPSB7XG4gICAgcHJvcHM6IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxQcm9wcyksXG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICBlYXNpbmc6ICdzd2luZycsIC8vIG9yICdsaW5lYXInXG4gICAgICAvKiBDYWxsYmFja3NcbiAgICAgIGJlZ2luKGVsZW1lbnRzKVxuICAgICAgY29tcGxldGUoZWxlbWVudHMpXG4gICAgICBwcm9ncmVzcyhlbGVtZW50cywgY29tcGxldGUsIHJlbWFpbmluZywgc3RhcnQsIHR3ZWVuVmFsdWUpXG4gICAgICAqL1xuICAgIH0sIGluaXRpYWxQYXJhbXMpLFxuXG4gICAgZWxlbWVudHM6IGVscyxcbiAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgIHF1ZTogW10sXG5cbiAgICBlYXNpbmdQcm9ncmVzcyhlYXNpbmcsIHByb2dyZXNzKSB7XG4gICAgICBpZiAoZWFzaW5nID09PSAnc3dpbmcnKSB7XG4gICAgICAgIHJldHVybiAwLjUgLSAoTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgfSxcbiAgICBzdG9wKCkge1xuICAgICAgaWYgKGEuZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhLmZyYW1lSWQpO1xuICAgICAgfVxuICAgICAgYS5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIGEuZWxlbWVudHMuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbDtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuZG9tN0FuaW1hdGVJbnN0YW5jZTtcbiAgICAgIH0pO1xuICAgICAgYS5xdWUgPSBbXTtcbiAgICB9LFxuICAgIGRvbmUoY29tcGxldGUpIHtcbiAgICAgIGEuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBhLmVsZW1lbnRzLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWw7XG4gICAgICAgIGRlbGV0ZSBlbGVtZW50LmRvbTdBbmltYXRlSW5zdGFuY2U7XG4gICAgICB9KTtcbiAgICAgIGlmIChjb21wbGV0ZSkgY29tcGxldGUoZWxzKTtcbiAgICAgIGlmIChhLnF1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHF1ZSA9IGEucXVlLnNoaWZ0KCk7XG4gICAgICAgIGEuYW5pbWF0ZShxdWVbMF0sIHF1ZVsxXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRlKHByb3BzLCBwYXJhbXMpIHtcbiAgICAgIGlmIChhLmFuaW1hdGluZykge1xuICAgICAgICBhLnF1ZS5wdXNoKFtwcm9wcywgcGFyYW1zXSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgLy8gRGVmaW5lICYgQ2FjaGUgSW5pdGlhbHMgJiBVbml0c1xuICAgICAgYS5lbGVtZW50cy5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgbGV0IGluaXRpYWxGdWxsVmFsdWU7XG4gICAgICAgIGxldCBpbml0aWFsVmFsdWU7XG4gICAgICAgIGxldCB1bml0O1xuICAgICAgICBsZXQgZmluYWxWYWx1ZTtcbiAgICAgICAgbGV0IGZpbmFsRnVsbFZhbHVlO1xuXG4gICAgICAgIGlmICghZWwuZG9tN0FuaW1hdGVJbnN0YW5jZSkgYS5lbGVtZW50c1tpbmRleF0uZG9tN0FuaW1hdGVJbnN0YW5jZSA9IGE7XG5cbiAgICAgICAgZWxlbWVudHNbaW5kZXhdID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogZWwsXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgaW5pdGlhbEZ1bGxWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHBhcnNlRmxvYXQoaW5pdGlhbEZ1bGxWYWx1ZSk7XG4gICAgICAgICAgdW5pdCA9IGluaXRpYWxGdWxsVmFsdWUucmVwbGFjZShpbml0aWFsVmFsdWUsICcnKTtcbiAgICAgICAgICBmaW5hbFZhbHVlID0gcGFyc2VGbG9hdChwcm9wc1twcm9wXSk7XG4gICAgICAgICAgZmluYWxGdWxsVmFsdWUgPSBwcm9wc1twcm9wXSArIHVuaXQ7XG4gICAgICAgICAgZWxlbWVudHNbaW5kZXhdW3Byb3BdID0ge1xuICAgICAgICAgICAgaW5pdGlhbEZ1bGxWYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBmaW5hbFZhbHVlLFxuICAgICAgICAgICAgZmluYWxGdWxsVmFsdWUsXG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgIGxldCB0aW1lO1xuICAgICAgbGV0IGVsZW1lbnRzRG9uZSA9IDA7XG4gICAgICBsZXQgcHJvcHNEb25lID0gMDtcbiAgICAgIGxldCBkb25lO1xuICAgICAgbGV0IGJlZ2FuID0gZmFsc2U7XG5cbiAgICAgIGEuYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBwcm9ncmVzcztcbiAgICAgICAgbGV0IGVhc2VQcm9ncmVzcztcbiAgICAgICAgLy8gbGV0IGVsO1xuICAgICAgICBpZiAoIWJlZ2FuKSB7XG4gICAgICAgICAgYmVnYW4gPSB0cnVlO1xuICAgICAgICAgIGlmIChwYXJhbXMuYmVnaW4pIHBhcmFtcy5iZWdpbihlbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBwYXJhbXMucHJvZ3Jlc3MoZWxzLCBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBwYXJhbXMuZHVyYXRpb24sIDEpLCAwKSwgKChzdGFydFRpbWUgKyBwYXJhbXMuZHVyYXRpb24pIC0gdGltZSA8IDAgPyAwIDogKHN0YXJ0VGltZSArIHBhcmFtcy5kdXJhdGlvbikgLSB0aW1lKSwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBlbCA9IGVsZW1lbnQ7XG4gICAgICAgICAgaWYgKGRvbmUgfHwgZWwuZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSB8fCBlbC5kb25lKSByZXR1cm47XG4gICAgICAgICAgICBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCh0aW1lIC0gc3RhcnRUaW1lKSAvIHBhcmFtcy5kdXJhdGlvbiwgMSksIDApO1xuICAgICAgICAgICAgZWFzZVByb2dyZXNzID0gYS5lYXNpbmdQcm9ncmVzcyhwYXJhbXMuZWFzaW5nLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICBjb25zdCB7IGluaXRpYWxWYWx1ZSwgZmluYWxWYWx1ZSwgdW5pdCB9ID0gZWxbcHJvcF07XG4gICAgICAgICAgICBlbFtwcm9wXS5jdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWUgKyAoZWFzZVByb2dyZXNzICogKGZpbmFsVmFsdWUgLSBpbml0aWFsVmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGVsW3Byb3BdLmN1cnJlbnRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoZmluYWxWYWx1ZSA+IGluaXRpYWxWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPj0gZmluYWxWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgKGZpbmFsVmFsdWUgPCBpbml0aWFsVmFsdWUgJiYgY3VycmVudFZhbHVlIDw9IGZpbmFsVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGVsLmNvbnRhaW5lci5zdHlsZVtwcm9wXSA9IGZpbmFsVmFsdWUgKyB1bml0O1xuICAgICAgICAgICAgICBwcm9wc0RvbmUgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHByb3BzRG9uZSA9PT0gT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVsLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzRG9uZSArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50c0RvbmUgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBhLmRvbmUocGFyYW1zLmNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuY29udGFpbmVyLnN0eWxlW3Byb3BdID0gY3VycmVudFZhbHVlICsgdW5pdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIC8vIFRoZW4gY2FsbFxuICAgICAgICBhLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICAgIH1cbiAgICAgIGEuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSxcbiAgfTtcblxuICBpZiAoYS5lbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZWxzO1xuICB9XG5cbiAgbGV0IGFuaW1hdGVJbnN0YW5jZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGEuZWxlbWVudHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZSkge1xuICAgICAgYW5pbWF0ZUluc3RhbmNlID0gYS5lbGVtZW50c1tpXS5kb203QW5pbWF0ZUluc3RhbmNlO1xuICAgIH0gZWxzZSBhLmVsZW1lbnRzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2UgPSBhO1xuICB9XG4gIGlmICghYW5pbWF0ZUluc3RhbmNlKSB7XG4gICAgYW5pbWF0ZUluc3RhbmNlID0gYTtcbiAgfVxuXG4gIGlmIChpbml0aWFsUHJvcHMgPT09ICdzdG9wJykge1xuICAgIGFuaW1hdGVJbnN0YW5jZS5zdG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgYW5pbWF0ZUluc3RhbmNlLmFuaW1hdGUoYS5wcm9wcywgYS5wYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIGVscztcbn1cblxuZnVuY3Rpb24gc3RvcCgpIHtcbiAgY29uc3QgZWxzID0gdGhpcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoZWxzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2UpIHtcbiAgICAgIGVsc1tpXS5kb203QW5pbWF0ZUluc3RhbmNlLnN0b3AoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgbm9UcmlnZ2VyID0gKCdyZXNpemUgc2Nyb2xsJykuc3BsaXQoJyAnKTtcbmZ1bmN0aW9uIGV2ZW50U2hvcnRjdXQobmFtZSwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAobm9UcmlnZ2VyLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHRoaXNbaV0pIHRoaXNbaV1bbmFtZV0oKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgJCh0aGlzW2ldKS50cmlnZ2VyKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiB0aGlzLm9uKG5hbWUsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjbGljayguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2NsaWNrJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBibHVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnYmx1cicsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gZm9jdXMoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdmb2N1cycsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gZm9jdXNpbiguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2ZvY3VzaW4nLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGZvY3Vzb3V0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnZm9jdXNvdXQnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGtleXVwKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgna2V5dXAnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGtleWRvd24oLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdrZXlkb3duJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBrZXlwcmVzcyguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2tleXByZXNzJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzdWJtaXQoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdzdWJtaXQnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGNoYW5nZSguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2NoYW5nZScsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbW91c2Vkb3duKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2Vkb3duJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBtb3VzZW1vdmUoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdtb3VzZW1vdmUnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIG1vdXNldXAoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdtb3VzZXVwJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBtb3VzZWVudGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2VlbnRlcicsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbW91c2VsZWF2ZSguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlbGVhdmUnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIG1vdXNlb3V0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2VvdXQnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIG1vdXNlb3ZlciguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlb3ZlcicsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gdG91Y2hzdGFydCguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ3RvdWNoc3RhcnQnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHRvdWNoZW5kKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgndG91Y2hlbmQnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHRvdWNobW92ZSguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ3RvdWNobW92ZScsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gcmVzaXplKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgncmVzaXplJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzY3JvbGwoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdzY3JvbGwnLCAuLi5hcmdzKTtcbn1cblxuZXhwb3J0IHsgJCwgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBoYXNDbGFzcywgdG9nZ2xlQ2xhc3MsIGF0dHIsIHJlbW92ZUF0dHIsIHByb3AsIGRhdGEsIHJlbW92ZURhdGEsIGRhdGFzZXQsIHZhbCwgdHJhbnNmb3JtLCB0cmFuc2l0aW9uLCBvbiwgb2ZmLCBvbmNlLCB0cmlnZ2VyLCB0cmFuc2l0aW9uRW5kLCBhbmltYXRpb25FbmQsIHdpZHRoLCBvdXRlcldpZHRoLCBoZWlnaHQsIG91dGVySGVpZ2h0LCBvZmZzZXQsIGhpZGUsIHNob3csIHN0eWxlcywgY3NzLCB0b0FycmF5LCBlYWNoLCBmb3JFYWNoLCBmaWx0ZXIsIG1hcCwgaHRtbCwgdGV4dCwgaXMsIGluZGV4T2YsIGluZGV4LCBlcSwgYXBwZW5kLCBhcHBlbmRUbywgcHJlcGVuZCwgcHJlcGVuZFRvLCBpbnNlcnRCZWZvcmUsIGluc2VydEFmdGVyLCBuZXh0LCBuZXh0QWxsLCBwcmV2LCBwcmV2QWxsLCBzaWJsaW5ncywgcGFyZW50LCBwYXJlbnRzLCBjbG9zZXN0LCBmaW5kLCBjaGlsZHJlbiwgcmVtb3ZlLCBkZXRhY2gsIGFkZCwgZW1wdHksIHNjcm9sbFRvLCBzY3JvbGxUb3AsIHNjcm9sbExlZnQsIGFuaW1hdGUsIHN0b3AsIGNsaWNrLCBibHVyLCBmb2N1cywgZm9jdXNpbiwgZm9jdXNvdXQsIGtleXVwLCBrZXlkb3duLCBrZXlwcmVzcywgc3VibWl0LCBjaGFuZ2UsIG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwLCBtb3VzZWVudGVyLCBtb3VzZWxlYXZlLCBtb3VzZW91dCwgbW91c2VvdmVyLCB0b3VjaHN0YXJ0LCB0b3VjaGVuZCwgdG91Y2htb3ZlLCByZXNpemUsIHNjcm9sbCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/dom7/dist/dom7.modular.js\n");

/***/ }),

/***/ "./node_modules/materialize-css/dist/js/materialize.js":
/*!*************************************************************!*\
  !*** ./node_modules/materialize-css/dist/js/materialize.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * Materialize v1.0.0-rc.2 (http://materializecss.com)\r\n * Copyright 2014-2017 Materialize\r\n * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)\r\n */\r\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*! cash-dom 1.3.5, https://github.com/kenwheeler/cash @license MIT */\n(function (factory) {\n  window.cash = factory();\n})(function () {\n  var doc = document,\n      win = window,\n      ArrayProto = Array.prototype,\n      slice = ArrayProto.slice,\n      filter = ArrayProto.filter,\n      push = ArrayProto.push;\n\n  var noop = function () {},\n      isFunction = function (item) {\n    // @see https://crbug.com/568448\n    return typeof item === typeof noop && item.call;\n  },\n      isString = function (item) {\n    return typeof item === typeof \"\";\n  };\n\n  var idMatch = /^#[\\w-]*$/,\n      classMatch = /^\\.[\\w-]*$/,\n      htmlMatch = /<.+>/,\n      singlet = /^\\w+$/;\n\n  function find(selector, context) {\n    context = context || doc;\n    var elems = classMatch.test(selector) ? context.getElementsByClassName(selector.slice(1)) : singlet.test(selector) ? context.getElementsByTagName(selector) : context.querySelectorAll(selector);\n    return elems;\n  }\n\n  var frag;\n  function parseHTML(str) {\n    if (!frag) {\n      frag = doc.implementation.createHTMLDocument(null);\n      var base = frag.createElement(\"base\");\n      base.href = doc.location.href;\n      frag.head.appendChild(base);\n    }\n\n    frag.body.innerHTML = str;\n\n    return frag.body.childNodes;\n  }\n\n  function onReady(fn) {\n    if (doc.readyState !== \"loading\") {\n      fn();\n    } else {\n      doc.addEventListener(\"DOMContentLoaded\", fn);\n    }\n  }\n\n  function Init(selector, context) {\n    if (!selector) {\n      return this;\n    }\n\n    // If already a cash collection, don't do any further processing\n    if (selector.cash && selector !== win) {\n      return selector;\n    }\n\n    var elems = selector,\n        i = 0,\n        length;\n\n    if (isString(selector)) {\n      elems = idMatch.test(selector) ?\n      // If an ID use the faster getElementById check\n      doc.getElementById(selector.slice(1)) : htmlMatch.test(selector) ?\n      // If HTML, parse it into real elements\n      parseHTML(selector) :\n      // else use `find`\n      find(selector, context);\n\n      // If function, use as shortcut for DOM ready\n    } else if (isFunction(selector)) {\n      onReady(selector);return this;\n    }\n\n    if (!elems) {\n      return this;\n    }\n\n    // If a single DOM element is passed in or received via ID, return the single element\n    if (elems.nodeType || elems === win) {\n      this[0] = elems;\n      this.length = 1;\n    } else {\n      // Treat like an array and loop through each item.\n      length = this.length = elems.length;\n      for (; i < length; i++) {\n        this[i] = elems[i];\n      }\n    }\n\n    return this;\n  }\n\n  function cash(selector, context) {\n    return new Init(selector, context);\n  }\n\n  var fn = cash.fn = cash.prototype = Init.prototype = { // jshint ignore:line\n    cash: true,\n    length: 0,\n    push: push,\n    splice: ArrayProto.splice,\n    map: ArrayProto.map,\n    init: Init\n  };\n\n  Object.defineProperty(fn, \"constructor\", { value: cash });\n\n  cash.parseHTML = parseHTML;\n  cash.noop = noop;\n  cash.isFunction = isFunction;\n  cash.isString = isString;\n\n  cash.extend = fn.extend = function (target) {\n    target = target || {};\n\n    var args = slice.call(arguments),\n        length = args.length,\n        i = 1;\n\n    if (args.length === 1) {\n      target = this;\n      i = 0;\n    }\n\n    for (; i < length; i++) {\n      if (!args[i]) {\n        continue;\n      }\n      for (var key in args[i]) {\n        if (args[i].hasOwnProperty(key)) {\n          target[key] = args[i][key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function each(collection, callback) {\n    var l = collection.length,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (callback.call(collection[i], collection[i], i, collection) === false) {\n        break;\n      }\n    }\n  }\n\n  function matches(el, selector) {\n    var m = el && (el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector || el.oMatchesSelector);\n    return !!m && m.call(el, selector);\n  }\n\n  function getCompareFunction(selector) {\n    return (\n      /* Use browser's `matches` function if string */\n      isString(selector) ? matches :\n      /* Match a cash element */\n      selector.cash ? function (el) {\n        return selector.is(el);\n      } :\n      /* Direct comparison */\n      function (el, selector) {\n        return el === selector;\n      }\n    );\n  }\n\n  function unique(collection) {\n    return cash(slice.call(collection).filter(function (item, index, self) {\n      return self.indexOf(item) === index;\n    }));\n  }\n\n  cash.extend({\n    merge: function (first, second) {\n      var len = +second.length,\n          i = first.length,\n          j = 0;\n\n      for (; j < len; i++, j++) {\n        first[i] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n\n    each: each,\n    matches: matches,\n    unique: unique,\n    isArray: Array.isArray,\n    isNumeric: function (n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n  });\n\n  var uid = cash.uid = \"_cash\" + Date.now();\n\n  function getDataCache(node) {\n    return node[uid] = node[uid] || {};\n  }\n\n  function setData(node, key, value) {\n    return getDataCache(node)[key] = value;\n  }\n\n  function getData(node, key) {\n    var c = getDataCache(node);\n    if (c[key] === undefined) {\n      c[key] = node.dataset ? node.dataset[key] : cash(node).attr(\"data-\" + key);\n    }\n    return c[key];\n  }\n\n  function removeData(node, key) {\n    var c = getDataCache(node);\n    if (c) {\n      delete c[key];\n    } else if (node.dataset) {\n      delete node.dataset[key];\n    } else {\n      cash(node).removeAttr(\"data-\" + name);\n    }\n  }\n\n  fn.extend({\n    data: function (name, value) {\n      if (isString(name)) {\n        return value === undefined ? getData(this[0], name) : this.each(function (v) {\n          return setData(v, name, value);\n        });\n      }\n\n      for (var key in name) {\n        this.data(key, name[key]);\n      }\n\n      return this;\n    },\n\n    removeData: function (key) {\n      return this.each(function (v) {\n        return removeData(v, key);\n      });\n    }\n\n  });\n\n  var notWhiteMatch = /\\S+/g;\n\n  function getClasses(c) {\n    return isString(c) && c.match(notWhiteMatch);\n  }\n\n  function hasClass(v, c) {\n    return v.classList ? v.classList.contains(c) : new RegExp(\"(^| )\" + c + \"( |$)\", \"gi\").test(v.className);\n  }\n\n  function addClass(v, c, spacedName) {\n    if (v.classList) {\n      v.classList.add(c);\n    } else if (spacedName.indexOf(\" \" + c + \" \")) {\n      v.className += \" \" + c;\n    }\n  }\n\n  function removeClass(v, c) {\n    if (v.classList) {\n      v.classList.remove(c);\n    } else {\n      v.className = v.className.replace(c, \"\");\n    }\n  }\n\n  fn.extend({\n    addClass: function (c) {\n      var classes = getClasses(c);\n\n      return classes ? this.each(function (v) {\n        var spacedName = \" \" + v.className + \" \";\n        each(classes, function (c) {\n          addClass(v, c, spacedName);\n        });\n      }) : this;\n    },\n\n    attr: function (name, value) {\n      if (!name) {\n        return undefined;\n      }\n\n      if (isString(name)) {\n        if (value === undefined) {\n          return this[0] ? this[0].getAttribute ? this[0].getAttribute(name) : this[0][name] : undefined;\n        }\n\n        return this.each(function (v) {\n          if (v.setAttribute) {\n            v.setAttribute(name, value);\n          } else {\n            v[name] = value;\n          }\n        });\n      }\n\n      for (var key in name) {\n        this.attr(key, name[key]);\n      }\n\n      return this;\n    },\n\n    hasClass: function (c) {\n      var check = false,\n          classes = getClasses(c);\n      if (classes && classes.length) {\n        this.each(function (v) {\n          check = hasClass(v, classes[0]);\n          return !check;\n        });\n      }\n      return check;\n    },\n\n    prop: function (name, value) {\n      if (isString(name)) {\n        return value === undefined ? this[0][name] : this.each(function (v) {\n          v[name] = value;\n        });\n      }\n\n      for (var key in name) {\n        this.prop(key, name[key]);\n      }\n\n      return this;\n    },\n\n    removeAttr: function (name) {\n      return this.each(function (v) {\n        if (v.removeAttribute) {\n          v.removeAttribute(name);\n        } else {\n          delete v[name];\n        }\n      });\n    },\n\n    removeClass: function (c) {\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n      var classes = getClasses(c);\n      return classes ? this.each(function (v) {\n        each(classes, function (c) {\n          removeClass(v, c);\n        });\n      }) : this;\n    },\n\n    removeProp: function (name) {\n      return this.each(function (v) {\n        delete v[name];\n      });\n    },\n\n    toggleClass: function (c, state) {\n      if (state !== undefined) {\n        return this[state ? \"addClass\" : \"removeClass\"](c);\n      }\n      var classes = getClasses(c);\n      return classes ? this.each(function (v) {\n        var spacedName = \" \" + v.className + \" \";\n        each(classes, function (c) {\n          if (hasClass(v, c)) {\n            removeClass(v, c);\n          } else {\n            addClass(v, c, spacedName);\n          }\n        });\n      }) : this;\n    } });\n\n  fn.extend({\n    add: function (selector, context) {\n      return unique(cash.merge(this, cash(selector, context)));\n    },\n\n    each: function (callback) {\n      each(this, callback);\n      return this;\n    },\n\n    eq: function (index) {\n      return cash(this.get(index));\n    },\n\n    filter: function (selector) {\n      if (!selector) {\n        return this;\n      }\n\n      var comparator = isFunction(selector) ? selector : getCompareFunction(selector);\n\n      return cash(filter.call(this, function (e) {\n        return comparator(e, selector);\n      }));\n    },\n\n    first: function () {\n      return this.eq(0);\n    },\n\n    get: function (index) {\n      if (index === undefined) {\n        return slice.call(this);\n      }\n      return index < 0 ? this[index + this.length] : this[index];\n    },\n\n    index: function (elem) {\n      var child = elem ? cash(elem)[0] : this[0],\n          collection = elem ? this : cash(child).parent().children();\n      return slice.call(collection).indexOf(child);\n    },\n\n    last: function () {\n      return this.eq(-1);\n    }\n\n  });\n\n  var camelCase = function () {\n    var camelRegex = /(?:^\\w|[A-Z]|\\b\\w)/g,\n        whiteSpace = /[\\s-_]+/g;\n    return function (str) {\n      return str.replace(camelRegex, function (letter, index) {\n        return letter[index === 0 ? \"toLowerCase\" : \"toUpperCase\"]();\n      }).replace(whiteSpace, \"\");\n    };\n  }();\n\n  var getPrefixedProp = function () {\n    var cache = {},\n        doc = document,\n        div = doc.createElement(\"div\"),\n        style = div.style;\n\n    return function (prop) {\n      prop = camelCase(prop);\n      if (cache[prop]) {\n        return cache[prop];\n      }\n\n      var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n          prefixes = [\"webkit\", \"moz\", \"ms\", \"o\"],\n          props = (prop + \" \" + prefixes.join(ucProp + \" \") + ucProp).split(\" \");\n\n      each(props, function (p) {\n        if (p in style) {\n          cache[p] = prop = cache[prop] = p;\n          return false;\n        }\n      });\n\n      return cache[prop];\n    };\n  }();\n\n  cash.prefixedProp = getPrefixedProp;\n  cash.camelCase = camelCase;\n\n  fn.extend({\n    css: function (prop, value) {\n      if (isString(prop)) {\n        prop = getPrefixedProp(prop);\n        return arguments.length > 1 ? this.each(function (v) {\n          return v.style[prop] = value;\n        }) : win.getComputedStyle(this[0])[prop];\n      }\n\n      for (var key in prop) {\n        this.css(key, prop[key]);\n      }\n\n      return this;\n    }\n\n  });\n\n  function compute(el, prop) {\n    return parseInt(win.getComputedStyle(el[0], null)[prop], 10) || 0;\n  }\n\n  each([\"Width\", \"Height\"], function (v) {\n    var lower = v.toLowerCase();\n\n    fn[lower] = function () {\n      return this[0].getBoundingClientRect()[lower];\n    };\n\n    fn[\"inner\" + v] = function () {\n      return this[0][\"client\" + v];\n    };\n\n    fn[\"outer\" + v] = function (margins) {\n      return this[0][\"offset\" + v] + (margins ? compute(this, \"margin\" + (v === \"Width\" ? \"Left\" : \"Top\")) + compute(this, \"margin\" + (v === \"Width\" ? \"Right\" : \"Bottom\")) : 0);\n    };\n  });\n\n  function registerEvent(node, eventName, callback) {\n    var eventCache = getData(node, \"_cashEvents\") || setData(node, \"_cashEvents\", {});\n    eventCache[eventName] = eventCache[eventName] || [];\n    eventCache[eventName].push(callback);\n    node.addEventListener(eventName, callback);\n  }\n\n  function removeEvent(node, eventName, callback) {\n    var events = getData(node, \"_cashEvents\"),\n        eventCache = events && events[eventName],\n        index;\n\n    if (!eventCache) {\n      return;\n    }\n\n    if (callback) {\n      node.removeEventListener(eventName, callback);\n      index = eventCache.indexOf(callback);\n      if (index >= 0) {\n        eventCache.splice(index, 1);\n      }\n    } else {\n      each(eventCache, function (event) {\n        node.removeEventListener(eventName, event);\n      });\n      eventCache = [];\n    }\n  }\n\n  fn.extend({\n    off: function (eventName, callback) {\n      return this.each(function (v) {\n        return removeEvent(v, eventName, callback);\n      });\n    },\n\n    on: function (eventName, delegate, callback, runOnce) {\n      // jshint ignore:line\n      var originalCallback;\n      if (!isString(eventName)) {\n        for (var key in eventName) {\n          this.on(key, delegate, eventName[key]);\n        }\n        return this;\n      }\n\n      if (isFunction(delegate)) {\n        callback = delegate;\n        delegate = null;\n      }\n\n      if (eventName === \"ready\") {\n        onReady(callback);\n        return this;\n      }\n\n      if (delegate) {\n        originalCallback = callback;\n        callback = function (e) {\n          var t = e.target;\n          while (!matches(t, delegate)) {\n            if (t === this || t === null) {\n              return t = false;\n            }\n\n            t = t.parentNode;\n          }\n\n          if (t) {\n            originalCallback.call(t, e);\n          }\n        };\n      }\n\n      return this.each(function (v) {\n        var finalCallback = callback;\n        if (runOnce) {\n          finalCallback = function () {\n            callback.apply(this, arguments);\n            removeEvent(v, eventName, finalCallback);\n          };\n        }\n        registerEvent(v, eventName, finalCallback);\n      });\n    },\n\n    one: function (eventName, delegate, callback) {\n      return this.on(eventName, delegate, callback, true);\n    },\n\n    ready: onReady,\n\n    /**\n     * Modified\n     * Triggers browser event\n     * @param String eventName\n     * @param Object data - Add properties to event object\n     */\n    trigger: function (eventName, data) {\n      if (document.createEvent) {\n        var evt = document.createEvent('HTMLEvents');\n        evt.initEvent(eventName, true, false);\n        evt = this.extend(evt, data);\n        return this.each(function (v) {\n          return v.dispatchEvent(evt);\n        });\n      }\n    }\n\n  });\n\n  function encode(name, value) {\n    return \"&\" + encodeURIComponent(name) + \"=\" + encodeURIComponent(value).replace(/%20/g, \"+\");\n  }\n\n  function getSelectMultiple_(el) {\n    var values = [];\n    each(el.options, function (o) {\n      if (o.selected) {\n        values.push(o.value);\n      }\n    });\n    return values.length ? values : null;\n  }\n\n  function getSelectSingle_(el) {\n    var selectedIndex = el.selectedIndex;\n    return selectedIndex >= 0 ? el.options[selectedIndex].value : null;\n  }\n\n  function getValue(el) {\n    var type = el.type;\n    if (!type) {\n      return null;\n    }\n    switch (type.toLowerCase()) {\n      case \"select-one\":\n        return getSelectSingle_(el);\n      case \"select-multiple\":\n        return getSelectMultiple_(el);\n      case \"radio\":\n        return el.checked ? el.value : null;\n      case \"checkbox\":\n        return el.checked ? el.value : null;\n      default:\n        return el.value ? el.value : null;\n    }\n  }\n\n  fn.extend({\n    serialize: function () {\n      var query = \"\";\n\n      each(this[0].elements || this, function (el) {\n        if (el.disabled || el.tagName === \"FIELDSET\") {\n          return;\n        }\n        var name = el.name;\n        switch (el.type.toLowerCase()) {\n          case \"file\":\n          case \"reset\":\n          case \"submit\":\n          case \"button\":\n            break;\n          case \"select-multiple\":\n            var values = getValue(el);\n            if (values !== null) {\n              each(values, function (value) {\n                query += encode(name, value);\n              });\n            }\n            break;\n          default:\n            var value = getValue(el);\n            if (value !== null) {\n              query += encode(name, value);\n            }\n        }\n      });\n\n      return query.substr(1);\n    },\n\n    val: function (value) {\n      if (value === undefined) {\n        return getValue(this[0]);\n      }\n\n      return this.each(function (v) {\n        return v.value = value;\n      });\n    }\n\n  });\n\n  function insertElement(el, child, prepend) {\n    if (prepend) {\n      var first = el.childNodes[0];\n      el.insertBefore(child, first);\n    } else {\n      el.appendChild(child);\n    }\n  }\n\n  function insertContent(parent, child, prepend) {\n    var str = isString(child);\n\n    if (!str && child.length) {\n      each(child, function (v) {\n        return insertContent(parent, v, prepend);\n      });\n      return;\n    }\n\n    each(parent, str ? function (v) {\n      return v.insertAdjacentHTML(prepend ? \"afterbegin\" : \"beforeend\", child);\n    } : function (v, i) {\n      return insertElement(v, i === 0 ? child : child.cloneNode(true), prepend);\n    });\n  }\n\n  fn.extend({\n    after: function (selector) {\n      cash(selector).insertAfter(this);\n      return this;\n    },\n\n    append: function (content) {\n      insertContent(this, content);\n      return this;\n    },\n\n    appendTo: function (parent) {\n      insertContent(cash(parent), this);\n      return this;\n    },\n\n    before: function (selector) {\n      cash(selector).insertBefore(this);\n      return this;\n    },\n\n    clone: function () {\n      return cash(this.map(function (v) {\n        return v.cloneNode(true);\n      }));\n    },\n\n    empty: function () {\n      this.html(\"\");\n      return this;\n    },\n\n    html: function (content) {\n      if (content === undefined) {\n        return this[0].innerHTML;\n      }\n      var source = content.nodeType ? content[0].outerHTML : content;\n      return this.each(function (v) {\n        return v.innerHTML = source;\n      });\n    },\n\n    insertAfter: function (selector) {\n      var _this = this;\n\n      cash(selector).each(function (el, i) {\n        var parent = el.parentNode,\n            sibling = el.nextSibling;\n        _this.each(function (v) {\n          parent.insertBefore(i === 0 ? v : v.cloneNode(true), sibling);\n        });\n      });\n\n      return this;\n    },\n\n    insertBefore: function (selector) {\n      var _this2 = this;\n      cash(selector).each(function (el, i) {\n        var parent = el.parentNode;\n        _this2.each(function (v) {\n          parent.insertBefore(i === 0 ? v : v.cloneNode(true), el);\n        });\n      });\n      return this;\n    },\n\n    prepend: function (content) {\n      insertContent(this, content, true);\n      return this;\n    },\n\n    prependTo: function (parent) {\n      insertContent(cash(parent), this, true);\n      return this;\n    },\n\n    remove: function () {\n      return this.each(function (v) {\n        if (!!v.parentNode) {\n          return v.parentNode.removeChild(v);\n        }\n      });\n    },\n\n    text: function (content) {\n      if (content === undefined) {\n        return this[0].textContent;\n      }\n      return this.each(function (v) {\n        return v.textContent = content;\n      });\n    }\n\n  });\n\n  var docEl = doc.documentElement;\n\n  fn.extend({\n    position: function () {\n      var el = this[0];\n      return {\n        left: el.offsetLeft,\n        top: el.offsetTop\n      };\n    },\n\n    offset: function () {\n      var rect = this[0].getBoundingClientRect();\n      return {\n        top: rect.top + win.pageYOffset - docEl.clientTop,\n        left: rect.left + win.pageXOffset - docEl.clientLeft\n      };\n    },\n\n    offsetParent: function () {\n      return cash(this[0].offsetParent);\n    }\n\n  });\n\n  fn.extend({\n    children: function (selector) {\n      var elems = [];\n      this.each(function (el) {\n        push.apply(elems, el.children);\n      });\n      elems = unique(elems);\n\n      return !selector ? elems : elems.filter(function (v) {\n        return matches(v, selector);\n      });\n    },\n\n    closest: function (selector) {\n      if (!selector || this.length < 1) {\n        return cash();\n      }\n      if (this.is(selector)) {\n        return this.filter(selector);\n      }\n      return this.parent().closest(selector);\n    },\n\n    is: function (selector) {\n      if (!selector) {\n        return false;\n      }\n\n      var match = false,\n          comparator = getCompareFunction(selector);\n\n      this.each(function (el) {\n        match = comparator(el, selector);\n        return !match;\n      });\n\n      return match;\n    },\n\n    find: function (selector) {\n      if (!selector || selector.nodeType) {\n        return cash(selector && this.has(selector).length ? selector : null);\n      }\n\n      var elems = [];\n      this.each(function (el) {\n        push.apply(elems, find(selector, el));\n      });\n\n      return unique(elems);\n    },\n\n    has: function (selector) {\n      var comparator = isString(selector) ? function (el) {\n        return find(selector, el).length !== 0;\n      } : function (el) {\n        return el.contains(selector);\n      };\n\n      return this.filter(comparator);\n    },\n\n    next: function () {\n      return cash(this[0].nextElementSibling);\n    },\n\n    not: function (selector) {\n      if (!selector) {\n        return this;\n      }\n\n      var comparator = getCompareFunction(selector);\n\n      return this.filter(function (el) {\n        return !comparator(el, selector);\n      });\n    },\n\n    parent: function () {\n      var result = [];\n\n      this.each(function (item) {\n        if (item && item.parentNode) {\n          result.push(item.parentNode);\n        }\n      });\n\n      return unique(result);\n    },\n\n    parents: function (selector) {\n      var last,\n          result = [];\n\n      this.each(function (item) {\n        last = item;\n\n        while (last && last.parentNode && last !== doc.body.parentNode) {\n          last = last.parentNode;\n\n          if (!selector || selector && matches(last, selector)) {\n            result.push(last);\n          }\n        }\n      });\n\n      return unique(result);\n    },\n\n    prev: function () {\n      return cash(this[0].previousElementSibling);\n    },\n\n    siblings: function (selector) {\n      var collection = this.parent().children(selector),\n          el = this[0];\n\n      return collection.filter(function (i) {\n        return i !== el;\n      });\n    }\n\n  });\n\n  return cash;\n});\n;\nvar Component = function () {\n  /**\n   * Generic constructor for all components\n   * @constructor\n   * @param {Element} el\n   * @param {Object} options\n   */\n  function Component(classDef, el, options) {\n    _classCallCheck(this, Component);\n\n    // Display error if el is valid HTML Element\n    if (!(el instanceof Element)) {\n      console.error(Error(el + ' is not an HTML Element'));\n    }\n\n    // If exists, destroy and reinitialize in child\n    var ins = classDef.getInstance(el);\n    if (!!ins) {\n      ins.destroy();\n    }\n\n    this.el = el;\n    this.$el = cash(el);\n  }\n\n  /**\n   * Initializes components\n   * @param {class} classDef\n   * @param {Element | NodeList | jQuery} els\n   * @param {Object} options\n   */\n\n\n  _createClass(Component, null, [{\n    key: \"init\",\n    value: function init(classDef, els, options) {\n      var instances = null;\n      if (els instanceof Element) {\n        instances = new classDef(els, options);\n      } else if (!!els && (els.jquery || els.cash || els instanceof NodeList)) {\n        var instancesArr = [];\n        for (var i = 0; i < els.length; i++) {\n          instancesArr.push(new classDef(els[i], options));\n        }\n        instances = instancesArr;\n      }\n\n      return instances;\n    }\n  }]);\n\n  return Component;\n}();\n\n; // Required for Meteor package, the use of window prevents export by Meteor\n(function (window) {\n  if (window.Package) {\n    M = {};\n  } else {\n    window.M = {};\n  }\n\n  // Check for jQuery\n  M.jQueryLoaded = !!window.jQuery;\n})(window);\n\n// AMD\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return M;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n  // Common JS\n} else {}\n\nM.keys = {\n  TAB: 9,\n  ENTER: 13,\n  ESC: 27,\n  ARROW_UP: 38,\n  ARROW_DOWN: 40\n};\n\n/**\n * TabPress Keydown handler\n */\nM.tabPressed = false;\nM.keyDown = false;\nvar docHandleKeydown = function (e) {\n  M.keyDown = true;\n  if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {\n    M.tabPressed = true;\n  }\n};\nvar docHandleKeyup = function (e) {\n  M.keyDown = false;\n  if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {\n    M.tabPressed = false;\n  }\n};\nvar docHandleFocus = function (e) {\n  if (M.keyDown) {\n    document.body.classList.add('keyboard-focused');\n  }\n};\nvar docHandleBlur = function (e) {\n  document.body.classList.remove('keyboard-focused');\n};\ndocument.addEventListener('keydown', docHandleKeydown, true);\ndocument.addEventListener('keyup', docHandleKeyup, true);\ndocument.addEventListener('focus', docHandleFocus, true);\ndocument.addEventListener('blur', docHandleBlur, true);\n\n/**\n * Initialize jQuery wrapper for plugin\n * @param {Class} plugin  javascript class\n * @param {string} pluginName  jQuery plugin name\n * @param {string} classRef  Class reference name\n */\nM.initializeJqueryWrapper = function (plugin, pluginName, classRef) {\n  jQuery.fn[pluginName] = function (methodOrOptions) {\n    // Call plugin method if valid method name is passed in\n    if (plugin.prototype[methodOrOptions]) {\n      var params = Array.prototype.slice.call(arguments, 1);\n\n      // Getter methods\n      if (methodOrOptions.slice(0, 3) === 'get') {\n        var instance = this.first()[0][classRef];\n        return instance[methodOrOptions].apply(instance, params);\n      }\n\n      // Void methods\n      return this.each(function () {\n        var instance = this[classRef];\n        instance[methodOrOptions].apply(instance, params);\n      });\n\n      // Initialize plugin if options or no argument is passed in\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      plugin.init(this, arguments[0]);\n      return this;\n    }\n\n    // Return error if an unrecognized  method name is passed in\n    jQuery.error(\"Method \" + methodOrOptions + \" does not exist on jQuery.\" + pluginName);\n  };\n};\n\n/**\n * Automatically initialize components\n * @param {Element} context  DOM Element to search within for components\n */\nM.AutoInit = function (context) {\n  // Use document.body if no context is given\n  var root = !!context ? context : document.body;\n\n  var registry = {\n    Autocomplete: root.querySelectorAll('.autocomplete:not(.no-autoinit)'),\n    Carousel: root.querySelectorAll('.carousel:not(.no-autoinit)'),\n    Chips: root.querySelectorAll('.chips:not(.no-autoinit)'),\n    Collapsible: root.querySelectorAll('.collapsible:not(.no-autoinit)'),\n    Datepicker: root.querySelectorAll('.datepicker:not(.no-autoinit)'),\n    Dropdown: root.querySelectorAll('.dropdown-trigger:not(.no-autoinit)'),\n    Materialbox: root.querySelectorAll('.materialboxed:not(.no-autoinit)'),\n    Modal: root.querySelectorAll('.modal:not(.no-autoinit)'),\n    Parallax: root.querySelectorAll('.parallax:not(.no-autoinit)'),\n    Pushpin: root.querySelectorAll('.pushpin:not(.no-autoinit)'),\n    ScrollSpy: root.querySelectorAll('.scrollspy:not(.no-autoinit)'),\n    FormSelect: root.querySelectorAll('select:not(.no-autoinit)'),\n    Sidenav: root.querySelectorAll('.sidenav:not(.no-autoinit)'),\n    Tabs: root.querySelectorAll('.tabs:not(.no-autoinit)'),\n    TapTarget: root.querySelectorAll('.tap-target:not(.no-autoinit)'),\n    Timepicker: root.querySelectorAll('.timepicker:not(.no-autoinit)'),\n    Tooltip: root.querySelectorAll('.tooltipped:not(.no-autoinit)'),\n    FloatingActionButton: root.querySelectorAll('.fixed-action-btn:not(.no-autoinit)')\n  };\n\n  for (var pluginName in registry) {\n    var plugin = M[pluginName];\n    plugin.init(registry[pluginName]);\n  }\n};\n\n/**\n * Generate approximated selector string for a jQuery object\n * @param {jQuery} obj  jQuery object to be parsed\n * @returns {string}\n */\nM.objectSelectorString = function (obj) {\n  var tagStr = obj.prop('tagName') || '';\n  var idStr = obj.attr('id') || '';\n  var classStr = obj.attr('class') || '';\n  return (tagStr + idStr + classStr).replace(/\\s/g, '');\n};\n\n// Unique Random ID\nM.guid = function () {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return function () {\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  };\n}();\n\n/**\n * Escapes hash from special characters\n * @param {string} hash  String returned from this.hash\n * @returns {string}\n */\nM.escapeHash = function (hash) {\n  return hash.replace(/(:|\\.|\\[|\\]|,|=|\\/)/g, '\\\\$1');\n};\n\nM.elementOrParentIsFixed = function (element) {\n  var $element = $(element);\n  var $checkElements = $element.add($element.parents());\n  var isFixed = false;\n  $checkElements.each(function () {\n    if ($(this).css('position') === 'fixed') {\n      isFixed = true;\n      return false;\n    }\n  });\n  return isFixed;\n};\n\n/**\n * @typedef {Object} Edges\n * @property {Boolean} top  If the top edge was exceeded\n * @property {Boolean} right  If the right edge was exceeded\n * @property {Boolean} bottom  If the bottom edge was exceeded\n * @property {Boolean} left  If the left edge was exceeded\n */\n\n/**\n * @typedef {Object} Bounding\n * @property {Number} left  left offset coordinate\n * @property {Number} top  top offset coordinate\n * @property {Number} width\n * @property {Number} height\n */\n\n/**\n * Escapes hash from special characters\n * @param {Element} container  Container element that acts as the boundary\n * @param {Bounding} bounding  element bounding that is being checked\n * @param {Number} offset  offset from edge that counts as exceeding\n * @returns {Edges}\n */\nM.checkWithinContainer = function (container, bounding, offset) {\n  var edges = {\n    top: false,\n    right: false,\n    bottom: false,\n    left: false\n  };\n\n  var containerRect = container.getBoundingClientRect();\n  // If body element is smaller than viewport, use viewport height instead.\n  var containerBottom = container === document.body ? Math.max(containerRect.bottom, window.innerHeight) : containerRect.bottom;\n\n  var scrollLeft = container.scrollLeft;\n  var scrollTop = container.scrollTop;\n\n  var scrolledX = bounding.left - scrollLeft;\n  var scrolledY = bounding.top - scrollTop;\n\n  // Check for container and viewport for each edge\n  if (scrolledX < containerRect.left + offset || scrolledX < offset) {\n    edges.left = true;\n  }\n\n  if (scrolledX + bounding.width > containerRect.right - offset || scrolledX + bounding.width > window.innerWidth - offset) {\n    edges.right = true;\n  }\n\n  if (scrolledY < containerRect.top + offset || scrolledY < offset) {\n    edges.top = true;\n  }\n\n  if (scrolledY + bounding.height > containerBottom - offset || scrolledY + bounding.height > window.innerHeight - offset) {\n    edges.bottom = true;\n  }\n\n  return edges;\n};\n\nM.checkPossibleAlignments = function (el, container, bounding, offset) {\n  var canAlign = {\n    top: true,\n    right: true,\n    bottom: true,\n    left: true,\n    spaceOnTop: null,\n    spaceOnRight: null,\n    spaceOnBottom: null,\n    spaceOnLeft: null\n  };\n\n  var containerAllowsOverflow = getComputedStyle(container).overflow === 'visible';\n  var containerRect = container.getBoundingClientRect();\n  var containerHeight = Math.min(containerRect.height, window.innerHeight);\n  var containerWidth = Math.min(containerRect.width, window.innerWidth);\n  var elOffsetRect = el.getBoundingClientRect();\n\n  var scrollLeft = container.scrollLeft;\n  var scrollTop = container.scrollTop;\n\n  var scrolledX = bounding.left - scrollLeft;\n  var scrolledYTopEdge = bounding.top - scrollTop;\n  var scrolledYBottomEdge = bounding.top + elOffsetRect.height - scrollTop;\n\n  // Check for container and viewport for left\n  canAlign.spaceOnRight = !containerAllowsOverflow ? containerWidth - (scrolledX + bounding.width) : window.innerWidth - (elOffsetRect.left + bounding.width);\n  if (canAlign.spaceOnRight < 0) {\n    canAlign.left = false;\n  }\n\n  // Check for container and viewport for Right\n  canAlign.spaceOnLeft = !containerAllowsOverflow ? scrolledX - bounding.width + elOffsetRect.width : elOffsetRect.right - bounding.width;\n  if (canAlign.spaceOnLeft < 0) {\n    canAlign.right = false;\n  }\n\n  // Check for container and viewport for Top\n  canAlign.spaceOnBottom = !containerAllowsOverflow ? containerHeight - (scrolledYTopEdge + bounding.height + offset) : window.innerHeight - (elOffsetRect.top + bounding.height + offset);\n  if (canAlign.spaceOnBottom < 0) {\n    canAlign.top = false;\n  }\n\n  // Check for container and viewport for Bottom\n  canAlign.spaceOnTop = !containerAllowsOverflow ? scrolledYBottomEdge - (bounding.height - offset) : elOffsetRect.bottom - (bounding.height + offset);\n  if (canAlign.spaceOnTop < 0) {\n    canAlign.bottom = false;\n  }\n\n  return canAlign;\n};\n\nM.getOverflowParent = function (element) {\n  if (element == null) {\n    return null;\n  }\n\n  if (element === document.body || getComputedStyle(element).overflow !== 'visible') {\n    return element;\n  }\n\n  return M.getOverflowParent(element.parentElement);\n};\n\n/**\n * Gets id of component from a trigger\n * @param {Element} trigger  trigger\n * @returns {string}\n */\nM.getIdFromTrigger = function (trigger) {\n  var id = trigger.getAttribute('data-target');\n  if (!id) {\n    id = trigger.getAttribute('href');\n    if (id) {\n      id = id.slice(1);\n    } else {\n      id = '';\n    }\n  }\n  return id;\n};\n\n/**\n * Multi browser support for document scroll top\n * @returns {Number}\n */\nM.getDocumentScrollTop = function () {\n  return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n};\n\n/**\n * Multi browser support for document scroll left\n * @returns {Number}\n */\nM.getDocumentScrollLeft = function () {\n  return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n};\n\n/**\n * @typedef {Object} Edges\n * @property {Boolean} top  If the top edge was exceeded\n * @property {Boolean} right  If the right edge was exceeded\n * @property {Boolean} bottom  If the bottom edge was exceeded\n * @property {Boolean} left  If the left edge was exceeded\n */\n\n/**\n * @typedef {Object} Bounding\n * @property {Number} left  left offset coordinate\n * @property {Number} top  top offset coordinate\n * @property {Number} width\n * @property {Number} height\n */\n\n/**\n * Get time in ms\n * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\n * @type {function}\n * @return {number}\n */\nvar getTime = Date.now || function () {\n  return new Date().getTime();\n};\n\n/**\n * Returns a function, that, when invoked, will only be triggered at most once\n * during a given window of time. Normally, the throttled function will run\n * as much as it can, without ever going more than once per `wait` duration;\n * but if you'd like to disable the execution on the leading edge, pass\n * `{leading: false}`. To disable execution on the trailing edge, ditto.\n * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\n * @param {function} func\n * @param {number} wait\n * @param {Object=} options\n * @returns {Function}\n */\nM.throttle = function (func, wait, options) {\n  var context = void 0,\n      args = void 0,\n      result = void 0;\n  var timeout = null;\n  var previous = 0;\n  options || (options = {});\n  var later = function () {\n    previous = options.leading === false ? 0 : getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    context = args = null;\n  };\n  return function () {\n    var now = getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(context, args);\n      context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\n; /*\n  v2.2.0\n  2017 Julian Garnier\n  Released under the MIT license\n  */\nvar $jscomp = { scope: {} };$jscomp.defineProperty = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (e, r, p) {\n  if (p.get || p.set) throw new TypeError(\"ES3 does not support getters and setters.\");e != Array.prototype && e != Object.prototype && (e[r] = p.value);\n};$jscomp.getGlobal = function (e) {\n  return \"undefined\" != typeof window && window === e ? e : \"undefined\" != typeof global && null != global ? global : e;\n};$jscomp.global = $jscomp.getGlobal(this);$jscomp.SYMBOL_PREFIX = \"jscomp_symbol_\";\n$jscomp.initSymbol = function () {\n  $jscomp.initSymbol = function () {};$jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);\n};$jscomp.symbolCounter_ = 0;$jscomp.Symbol = function (e) {\n  return $jscomp.SYMBOL_PREFIX + (e || \"\") + $jscomp.symbolCounter_++;\n};\n$jscomp.initSymbolIterator = function () {\n  $jscomp.initSymbol();var e = $jscomp.global.Symbol.iterator;e || (e = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol(\"iterator\"));\"function\" != typeof Array.prototype[e] && $jscomp.defineProperty(Array.prototype, e, { configurable: !0, writable: !0, value: function () {\n      return $jscomp.arrayIterator(this);\n    } });$jscomp.initSymbolIterator = function () {};\n};$jscomp.arrayIterator = function (e) {\n  var r = 0;return $jscomp.iteratorPrototype(function () {\n    return r < e.length ? { done: !1, value: e[r++] } : { done: !0 };\n  });\n};\n$jscomp.iteratorPrototype = function (e) {\n  $jscomp.initSymbolIterator();e = { next: e };e[$jscomp.global.Symbol.iterator] = function () {\n    return this;\n  };return e;\n};$jscomp.array = $jscomp.array || {};$jscomp.iteratorFromArray = function (e, r) {\n  $jscomp.initSymbolIterator();e instanceof String && (e += \"\");var p = 0,\n      m = { next: function () {\n      if (p < e.length) {\n        var u = p++;return { value: r(u, e[u]), done: !1 };\n      }m.next = function () {\n        return { done: !0, value: void 0 };\n      };return m.next();\n    } };m[Symbol.iterator] = function () {\n    return m;\n  };return m;\n};\n$jscomp.polyfill = function (e, r, p, m) {\n  if (r) {\n    p = $jscomp.global;e = e.split(\".\");for (m = 0; m < e.length - 1; m++) {\n      var u = e[m];u in p || (p[u] = {});p = p[u];\n    }e = e[e.length - 1];m = p[e];r = r(m);r != m && null != r && $jscomp.defineProperty(p, e, { configurable: !0, writable: !0, value: r });\n  }\n};$jscomp.polyfill(\"Array.prototype.keys\", function (e) {\n  return e ? e : function () {\n    return $jscomp.iteratorFromArray(this, function (e) {\n      return e;\n    });\n  };\n}, \"es6-impl\", \"es3\");var $jscomp$this = this;\n(function (r) {\n  M.anime = r();\n})(function () {\n  function e(a) {\n    if (!h.col(a)) try {\n      return document.querySelectorAll(a);\n    } catch (c) {}\n  }function r(a, c) {\n    for (var d = a.length, b = 2 <= arguments.length ? arguments[1] : void 0, f = [], n = 0; n < d; n++) {\n      if (n in a) {\n        var k = a[n];c.call(b, k, n, a) && f.push(k);\n      }\n    }return f;\n  }function p(a) {\n    return a.reduce(function (a, d) {\n      return a.concat(h.arr(d) ? p(d) : d);\n    }, []);\n  }function m(a) {\n    if (h.arr(a)) return a;\n    h.str(a) && (a = e(a) || a);return a instanceof NodeList || a instanceof HTMLCollection ? [].slice.call(a) : [a];\n  }function u(a, c) {\n    return a.some(function (a) {\n      return a === c;\n    });\n  }function C(a) {\n    var c = {},\n        d;for (d in a) {\n      c[d] = a[d];\n    }return c;\n  }function D(a, c) {\n    var d = C(a),\n        b;for (b in a) {\n      d[b] = c.hasOwnProperty(b) ? c[b] : a[b];\n    }return d;\n  }function z(a, c) {\n    var d = C(a),\n        b;for (b in c) {\n      d[b] = h.und(a[b]) ? c[b] : a[b];\n    }return d;\n  }function T(a) {\n    a = a.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function (a, c, d, k) {\n      return c + c + d + d + k + k;\n    });var c = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(a);\n    a = parseInt(c[1], 16);var d = parseInt(c[2], 16),\n        c = parseInt(c[3], 16);return \"rgba(\" + a + \",\" + d + \",\" + c + \",1)\";\n  }function U(a) {\n    function c(a, c, b) {\n      0 > b && (b += 1);1 < b && --b;return b < 1 / 6 ? a + 6 * (c - a) * b : .5 > b ? c : b < 2 / 3 ? a + (c - a) * (2 / 3 - b) * 6 : a;\n    }var d = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(a) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(a);a = parseInt(d[1]) / 360;var b = parseInt(d[2]) / 100,\n        f = parseInt(d[3]) / 100,\n        d = d[4] || 1;if (0 == b) f = b = a = f;else {\n      var n = .5 > f ? f * (1 + b) : f + b - f * b,\n          k = 2 * f - n,\n          f = c(k, n, a + 1 / 3),\n          b = c(k, n, a);a = c(k, n, a - 1 / 3);\n    }return \"rgba(\" + 255 * f + \",\" + 255 * b + \",\" + 255 * a + \",\" + d + \")\";\n  }function y(a) {\n    if (a = /([\\+\\-]?[0-9#\\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a)) return a[2];\n  }function V(a) {\n    if (-1 < a.indexOf(\"translate\") || \"perspective\" === a) return \"px\";if (-1 < a.indexOf(\"rotate\") || -1 < a.indexOf(\"skew\")) return \"deg\";\n  }function I(a, c) {\n    return h.fnc(a) ? a(c.target, c.id, c.total) : a;\n  }function E(a, c) {\n    if (c in a.style) return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase()) || \"0\";\n  }function J(a, c) {\n    if (h.dom(a) && u(W, c)) return \"transform\";if (h.dom(a) && (a.getAttribute(c) || h.svg(a) && a[c])) return \"attribute\";if (h.dom(a) && \"transform\" !== c && E(a, c)) return \"css\";if (null != a[c]) return \"object\";\n  }function X(a, c) {\n    var d = V(c),\n        d = -1 < c.indexOf(\"scale\") ? 1 : 0 + d;a = a.style.transform;if (!a) return d;for (var b = [], f = [], n = [], k = /(\\w+)\\((.+?)\\)/g; b = k.exec(a);) {\n      f.push(b[1]), n.push(b[2]);\n    }a = r(n, function (a, b) {\n      return f[b] === c;\n    });return a.length ? a[0] : d;\n  }function K(a, c) {\n    switch (J(a, c)) {case \"transform\":\n        return X(a, c);case \"css\":\n        return E(a, c);case \"attribute\":\n        return a.getAttribute(c);}return a[c] || 0;\n  }function L(a, c) {\n    var d = /^(\\*=|\\+=|-=)/.exec(a);if (!d) return a;var b = y(a) || 0;c = parseFloat(c);a = parseFloat(a.replace(d[0], \"\"));switch (d[0][0]) {case \"+\":\n        return c + a + b;case \"-\":\n        return c - a + b;case \"*\":\n        return c * a + b;}\n  }function F(a, c) {\n    return Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));\n  }function M(a) {\n    a = a.points;for (var c = 0, d, b = 0; b < a.numberOfItems; b++) {\n      var f = a.getItem(b);0 < b && (c += F(d, f));d = f;\n    }return c;\n  }function N(a) {\n    if (a.getTotalLength) return a.getTotalLength();switch (a.tagName.toLowerCase()) {case \"circle\":\n        return 2 * Math.PI * a.getAttribute(\"r\");case \"rect\":\n        return 2 * a.getAttribute(\"width\") + 2 * a.getAttribute(\"height\");case \"line\":\n        return F({ x: a.getAttribute(\"x1\"), y: a.getAttribute(\"y1\") }, { x: a.getAttribute(\"x2\"), y: a.getAttribute(\"y2\") });case \"polyline\":\n        return M(a);case \"polygon\":\n        var c = a.points;return M(a) + F(c.getItem(c.numberOfItems - 1), c.getItem(0));}\n  }function Y(a, c) {\n    function d(b) {\n      b = void 0 === b ? 0 : b;return a.el.getPointAtLength(1 <= c + b ? c + b : 0);\n    }var b = d(),\n        f = d(-1),\n        n = d(1);switch (a.property) {case \"x\":\n        return b.x;case \"y\":\n        return b.y;\n      case \"angle\":\n        return 180 * Math.atan2(n.y - f.y, n.x - f.x) / Math.PI;}\n  }function O(a, c) {\n    var d = /-?\\d*\\.?\\d+/g,\n        b;b = h.pth(a) ? a.totalLength : a;if (h.col(b)) {\n      if (h.rgb(b)) {\n        var f = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(b);b = f ? \"rgba(\" + f[1] + \",1)\" : b;\n      } else b = h.hex(b) ? T(b) : h.hsl(b) ? U(b) : void 0;\n    } else f = (f = y(b)) ? b.substr(0, b.length - f.length) : b, b = c && !/\\s/g.test(b) ? f + c : f;b += \"\";return { original: b, numbers: b.match(d) ? b.match(d).map(Number) : [0], strings: h.str(a) || c ? b.split(d) : [] };\n  }function P(a) {\n    a = a ? p(h.arr(a) ? a.map(m) : m(a)) : [];return r(a, function (a, d, b) {\n      return b.indexOf(a) === d;\n    });\n  }function Z(a) {\n    var c = P(a);return c.map(function (a, b) {\n      return { target: a, id: b, total: c.length };\n    });\n  }function aa(a, c) {\n    var d = C(c);if (h.arr(a)) {\n      var b = a.length;2 !== b || h.obj(a[0]) ? h.fnc(c.duration) || (d.duration = c.duration / b) : a = { value: a };\n    }return m(a).map(function (a, b) {\n      b = b ? 0 : c.delay;a = h.obj(a) && !h.pth(a) ? a : { value: a };h.und(a.delay) && (a.delay = b);return a;\n    }).map(function (a) {\n      return z(a, d);\n    });\n  }function ba(a, c) {\n    var d = {},\n        b;for (b in a) {\n      var f = I(a[b], c);h.arr(f) && (f = f.map(function (a) {\n        return I(a, c);\n      }), 1 === f.length && (f = f[0]));d[b] = f;\n    }d.duration = parseFloat(d.duration);d.delay = parseFloat(d.delay);return d;\n  }function ca(a) {\n    return h.arr(a) ? A.apply(this, a) : Q[a];\n  }function da(a, c) {\n    var d;return a.tweens.map(function (b) {\n      b = ba(b, c);var f = b.value,\n          e = K(c.target, a.name),\n          k = d ? d.to.original : e,\n          k = h.arr(f) ? f[0] : k,\n          w = L(h.arr(f) ? f[1] : f, k),\n          e = y(w) || y(k) || y(e);b.from = O(k, e);b.to = O(w, e);b.start = d ? d.end : a.offset;b.end = b.start + b.delay + b.duration;b.easing = ca(b.easing);b.elasticity = (1E3 - Math.min(Math.max(b.elasticity, 1), 999)) / 1E3;b.isPath = h.pth(f);b.isColor = h.col(b.from.original);b.isColor && (b.round = 1);return d = b;\n    });\n  }function ea(a, c) {\n    return r(p(a.map(function (a) {\n      return c.map(function (b) {\n        var c = J(a.target, b.name);if (c) {\n          var d = da(b, a);b = { type: c, property: b.name, animatable: a, tweens: d, duration: d[d.length - 1].end, delay: d[0].delay };\n        } else b = void 0;return b;\n      });\n    })), function (a) {\n      return !h.und(a);\n    });\n  }function R(a, c, d, b) {\n    var f = \"delay\" === a;return c.length ? (f ? Math.min : Math.max).apply(Math, c.map(function (b) {\n      return b[a];\n    })) : f ? b.delay : d.offset + b.delay + b.duration;\n  }function fa(a) {\n    var c = D(ga, a),\n        d = D(S, a),\n        b = Z(a.targets),\n        f = [],\n        e = z(c, d),\n        k;for (k in a) {\n      e.hasOwnProperty(k) || \"targets\" === k || f.push({ name: k, offset: e.offset, tweens: aa(a[k], d) });\n    }a = ea(b, f);return z(c, { children: [], animatables: b, animations: a, duration: R(\"duration\", a, c, d), delay: R(\"delay\", a, c, d) });\n  }function q(a) {\n    function c() {\n      return window.Promise && new Promise(function (a) {\n        return p = a;\n      });\n    }function d(a) {\n      return g.reversed ? g.duration - a : a;\n    }function b(a) {\n      for (var b = 0, c = {}, d = g.animations, f = d.length; b < f;) {\n        var e = d[b],\n            k = e.animatable,\n            h = e.tweens,\n            n = h.length - 1,\n            l = h[n];n && (l = r(h, function (b) {\n          return a < b.end;\n        })[0] || l);for (var h = Math.min(Math.max(a - l.start - l.delay, 0), l.duration) / l.duration, w = isNaN(h) ? 1 : l.easing(h, l.elasticity), h = l.to.strings, p = l.round, n = [], m = void 0, m = l.to.numbers.length, t = 0; t < m; t++) {\n          var x = void 0,\n              x = l.to.numbers[t],\n              q = l.from.numbers[t],\n              x = l.isPath ? Y(l.value, w * x) : q + w * (x - q);p && (l.isColor && 2 < t || (x = Math.round(x * p) / p));n.push(x);\n        }if (l = h.length) for (m = h[0], w = 0; w < l; w++) {\n          p = h[w + 1], t = n[w], isNaN(t) || (m = p ? m + (t + p) : m + (t + \" \"));\n        } else m = n[0];ha[e.type](k.target, e.property, m, c, k.id);e.currentValue = m;b++;\n      }if (b = Object.keys(c).length) for (d = 0; d < b; d++) {\n        H || (H = E(document.body, \"transform\") ? \"transform\" : \"-webkit-transform\"), g.animatables[d].target.style[H] = c[d].join(\" \");\n      }g.currentTime = a;g.progress = a / g.duration * 100;\n    }function f(a) {\n      if (g[a]) g[a](g);\n    }function e() {\n      g.remaining && !0 !== g.remaining && g.remaining--;\n    }function k(a) {\n      var k = g.duration,\n          n = g.offset,\n          w = n + g.delay,\n          r = g.currentTime,\n          x = g.reversed,\n          q = d(a);if (g.children.length) {\n        var u = g.children,\n            v = u.length;\n        if (q >= g.currentTime) for (var G = 0; G < v; G++) {\n          u[G].seek(q);\n        } else for (; v--;) {\n          u[v].seek(q);\n        }\n      }if (q >= w || !k) g.began || (g.began = !0, f(\"begin\")), f(\"run\");if (q > n && q < k) b(q);else if (q <= n && 0 !== r && (b(0), x && e()), q >= k && r !== k || !k) b(k), x || e();f(\"update\");a >= k && (g.remaining ? (t = h, \"alternate\" === g.direction && (g.reversed = !g.reversed)) : (g.pause(), g.completed || (g.completed = !0, f(\"complete\"), \"Promise\" in window && (p(), m = c()))), l = 0);\n    }a = void 0 === a ? {} : a;var h,\n        t,\n        l = 0,\n        p = null,\n        m = c(),\n        g = fa(a);g.reset = function () {\n      var a = g.direction,\n          c = g.loop;g.currentTime = 0;g.progress = 0;g.paused = !0;g.began = !1;g.completed = !1;g.reversed = \"reverse\" === a;g.remaining = \"alternate\" === a && 1 === c ? 2 : c;b(0);for (a = g.children.length; a--;) {\n        g.children[a].reset();\n      }\n    };g.tick = function (a) {\n      h = a;t || (t = h);k((l + h - t) * q.speed);\n    };g.seek = function (a) {\n      k(d(a));\n    };g.pause = function () {\n      var a = v.indexOf(g);-1 < a && v.splice(a, 1);g.paused = !0;\n    };g.play = function () {\n      g.paused && (g.paused = !1, t = 0, l = d(g.currentTime), v.push(g), B || ia());\n    };g.reverse = function () {\n      g.reversed = !g.reversed;t = 0;l = d(g.currentTime);\n    };g.restart = function () {\n      g.pause();\n      g.reset();g.play();\n    };g.finished = m;g.reset();g.autoplay && g.play();return g;\n  }var ga = { update: void 0, begin: void 0, run: void 0, complete: void 0, loop: 1, direction: \"normal\", autoplay: !0, offset: 0 },\n      S = { duration: 1E3, delay: 0, easing: \"easeOutElastic\", elasticity: 500, round: 0 },\n      W = \"translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective\".split(\" \"),\n      H,\n      h = { arr: function (a) {\n      return Array.isArray(a);\n    }, obj: function (a) {\n      return -1 < Object.prototype.toString.call(a).indexOf(\"Object\");\n    },\n    pth: function (a) {\n      return h.obj(a) && a.hasOwnProperty(\"totalLength\");\n    }, svg: function (a) {\n      return a instanceof SVGElement;\n    }, dom: function (a) {\n      return a.nodeType || h.svg(a);\n    }, str: function (a) {\n      return \"string\" === typeof a;\n    }, fnc: function (a) {\n      return \"function\" === typeof a;\n    }, und: function (a) {\n      return \"undefined\" === typeof a;\n    }, hex: function (a) {\n      return (/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)\n      );\n    }, rgb: function (a) {\n      return (/^rgb/.test(a)\n      );\n    }, hsl: function (a) {\n      return (/^hsl/.test(a)\n      );\n    }, col: function (a) {\n      return h.hex(a) || h.rgb(a) || h.hsl(a);\n    } },\n      A = function () {\n    function a(a, d, b) {\n      return (((1 - 3 * b + 3 * d) * a + (3 * b - 6 * d)) * a + 3 * d) * a;\n    }return function (c, d, b, f) {\n      if (0 <= c && 1 >= c && 0 <= b && 1 >= b) {\n        var e = new Float32Array(11);if (c !== d || b !== f) for (var k = 0; 11 > k; ++k) {\n          e[k] = a(.1 * k, c, b);\n        }return function (k) {\n          if (c === d && b === f) return k;if (0 === k) return 0;if (1 === k) return 1;for (var h = 0, l = 1; 10 !== l && e[l] <= k; ++l) {\n            h += .1;\n          }--l;var l = h + (k - e[l]) / (e[l + 1] - e[l]) * .1,\n              n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;if (.001 <= n) {\n            for (h = 0; 4 > h; ++h) {\n              n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;if (0 === n) break;var m = a(l, c, b) - k,\n                  l = l - m / n;\n            }k = l;\n          } else if (0 === n) k = l;else {\n            var l = h,\n                h = h + .1,\n                g = 0;do {\n              m = l + (h - l) / 2, n = a(m, c, b) - k, 0 < n ? h = m : l = m;\n            } while (1e-7 < Math.abs(n) && 10 > ++g);k = m;\n          }return a(k, d, f);\n        };\n      }\n    };\n  }(),\n      Q = function () {\n    function a(a, b) {\n      return 0 === a || 1 === a ? a : -Math.pow(2, 10 * (a - 1)) * Math.sin(2 * (a - 1 - b / (2 * Math.PI) * Math.asin(1)) * Math.PI / b);\n    }var c = \"Quad Cubic Quart Quint Sine Expo Circ Back Elastic\".split(\" \"),\n        d = { In: [[.55, .085, .68, .53], [.55, .055, .675, .19], [.895, .03, .685, .22], [.755, .05, .855, .06], [.47, 0, .745, .715], [.95, .05, .795, .035], [.6, .04, .98, .335], [.6, -.28, .735, .045], a], Out: [[.25, .46, .45, .94], [.215, .61, .355, 1], [.165, .84, .44, 1], [.23, 1, .32, 1], [.39, .575, .565, 1], [.19, 1, .22, 1], [.075, .82, .165, 1], [.175, .885, .32, 1.275], function (b, c) {\n        return 1 - a(1 - b, c);\n      }], InOut: [[.455, .03, .515, .955], [.645, .045, .355, 1], [.77, 0, .175, 1], [.86, 0, .07, 1], [.445, .05, .55, .95], [1, 0, 0, 1], [.785, .135, .15, .86], [.68, -.55, .265, 1.55], function (b, c) {\n        return .5 > b ? a(2 * b, c) / 2 : 1 - a(-2 * b + 2, c) / 2;\n      }] },\n        b = { linear: A(.25, .25, .75, .75) },\n        f = {},\n        e;for (e in d) {\n      f.type = e, d[f.type].forEach(function (a) {\n        return function (d, f) {\n          b[\"ease\" + a.type + c[f]] = h.fnc(d) ? d : A.apply($jscomp$this, d);\n        };\n      }(f)), f = { type: f.type };\n    }return b;\n  }(),\n      ha = { css: function (a, c, d) {\n      return a.style[c] = d;\n    }, attribute: function (a, c, d) {\n      return a.setAttribute(c, d);\n    }, object: function (a, c, d) {\n      return a[c] = d;\n    }, transform: function (a, c, d, b, f) {\n      b[f] || (b[f] = []);b[f].push(c + \"(\" + d + \")\");\n    } },\n      v = [],\n      B = 0,\n      ia = function () {\n    function a() {\n      B = requestAnimationFrame(c);\n    }function c(c) {\n      var b = v.length;if (b) {\n        for (var d = 0; d < b;) {\n          v[d] && v[d].tick(c), d++;\n        }a();\n      } else cancelAnimationFrame(B), B = 0;\n    }return a;\n  }();q.version = \"2.2.0\";q.speed = 1;q.running = v;q.remove = function (a) {\n    a = P(a);for (var c = v.length; c--;) {\n      for (var d = v[c], b = d.animations, f = b.length; f--;) {\n        u(a, b[f].animatable.target) && (b.splice(f, 1), b.length || d.pause());\n      }\n    }\n  };q.getValue = K;q.path = function (a, c) {\n    var d = h.str(a) ? e(a)[0] : a,\n        b = c || 100;return function (a) {\n      return { el: d, property: a, totalLength: N(d) * (b / 100) };\n    };\n  };q.setDashoffset = function (a) {\n    var c = N(a);a.setAttribute(\"stroke-dasharray\", c);return c;\n  };q.bezier = A;q.easings = Q;q.timeline = function (a) {\n    var c = q(a);c.pause();c.duration = 0;c.add = function (d) {\n      c.children.forEach(function (a) {\n        a.began = !0;a.completed = !0;\n      });m(d).forEach(function (b) {\n        var d = z(b, D(S, a || {}));d.targets = d.targets || a.targets;b = c.duration;var e = d.offset;d.autoplay = !1;d.direction = c.direction;d.offset = h.und(e) ? b : L(e, b);c.began = !0;c.completed = !0;c.seek(d.offset);d = q(d);d.began = !0;d.completed = !0;d.duration > b && (c.duration = d.duration);c.children.push(d);\n      });c.seek(0);c.reset();c.autoplay && c.restart();return c;\n    };return c;\n  };q.random = function (a, c) {\n    return Math.floor(Math.random() * (c - a + 1)) + a;\n  };return q;\n});\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    accordion: true,\n    onOpenStart: undefined,\n    onOpenEnd: undefined,\n    onCloseStart: undefined,\n    onCloseEnd: undefined,\n    inDuration: 300,\n    outDuration: 300\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Collapsible = function (_Component) {\n    _inherits(Collapsible, _Component);\n\n    /**\n     * Construct Collapsible instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Collapsible(el, options) {\n      _classCallCheck(this, Collapsible);\n\n      var _this3 = _possibleConstructorReturn(this, (Collapsible.__proto__ || Object.getPrototypeOf(Collapsible)).call(this, Collapsible, el, options));\n\n      _this3.el.M_Collapsible = _this3;\n\n      /**\n       * Options for the collapsible\n       * @member Collapsible#options\n       * @prop {Boolean} [accordion=false] - Type of the collapsible\n       * @prop {Function} onOpenStart - Callback function called before collapsible is opened\n       * @prop {Function} onOpenEnd - Callback function called after collapsible is opened\n       * @prop {Function} onCloseStart - Callback function called before collapsible is closed\n       * @prop {Function} onCloseEnd - Callback function called after collapsible is closed\n       * @prop {Number} inDuration - Transition in duration in milliseconds.\n       * @prop {Number} outDuration - Transition duration in milliseconds.\n       */\n      _this3.options = $.extend({}, Collapsible.defaults, options);\n\n      // Setup tab indices\n      _this3.$headers = _this3.$el.children('li').children('.collapsible-header');\n      _this3.$headers.attr('tabindex', 0);\n\n      _this3._setupEventHandlers();\n\n      // Open first active\n      var $activeBodies = _this3.$el.children('li.active').children('.collapsible-body');\n      if (_this3.options.accordion) {\n        // Handle Accordion\n        $activeBodies.first().css('display', 'block');\n      } else {\n        // Handle Expandables\n        $activeBodies.css('display', 'block');\n      }\n      return _this3;\n    }\n\n    _createClass(Collapsible, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.el.M_Collapsible = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        var _this4 = this;\n\n        this._handleCollapsibleClickBound = this._handleCollapsibleClick.bind(this);\n        this._handleCollapsibleKeydownBound = this._handleCollapsibleKeydown.bind(this);\n        this.el.addEventListener('click', this._handleCollapsibleClickBound);\n        this.$headers.each(function (header) {\n          header.addEventListener('keydown', _this4._handleCollapsibleKeydownBound);\n        });\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        var _this5 = this;\n\n        this.el.removeEventListener('click', this._handleCollapsibleClickBound);\n        this.$headers.each(function (header) {\n          header.removeEventListener('keydown', _this5._handleCollapsibleKeydownBound);\n        });\n      }\n\n      /**\n       * Handle Collapsible Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCollapsibleClick\",\n      value: function _handleCollapsibleClick(e) {\n        var $header = $(e.target).closest('.collapsible-header');\n        if (e.target && $header.length) {\n          var $collapsible = $header.closest('.collapsible');\n          if ($collapsible[0] === this.el) {\n            var $collapsibleLi = $header.closest('li');\n            var $collapsibleLis = $collapsible.children('li');\n            var isActive = $collapsibleLi[0].classList.contains('active');\n            var index = $collapsibleLis.index($collapsibleLi);\n\n            if (isActive) {\n              this.close(index);\n            } else {\n              this.open(index);\n            }\n          }\n        }\n      }\n\n      /**\n       * Handle Collapsible Keydown\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCollapsibleKeydown\",\n      value: function _handleCollapsibleKeydown(e) {\n        if (e.keyCode === 13) {\n          this._handleCollapsibleClickBound(e);\n        }\n      }\n\n      /**\n       * Animate in collapsible slide\n       * @param {Number} index - 0th index of slide\n       */\n\n    }, {\n      key: \"_animateIn\",\n      value: function _animateIn(index) {\n        var _this6 = this;\n\n        var $collapsibleLi = this.$el.children('li').eq(index);\n        if ($collapsibleLi.length) {\n          var $body = $collapsibleLi.children('.collapsible-body');\n\n          anim.remove($body[0]);\n          $body.css({\n            display: 'block',\n            overflow: 'hidden',\n            height: 0,\n            paddingTop: '',\n            paddingBottom: ''\n          });\n\n          var pTop = $body.css('padding-top');\n          var pBottom = $body.css('padding-bottom');\n          var finalHeight = $body[0].scrollHeight;\n          $body.css({\n            paddingTop: 0,\n            paddingBottom: 0\n          });\n\n          anim({\n            targets: $body[0],\n            height: finalHeight,\n            paddingTop: pTop,\n            paddingBottom: pBottom,\n            duration: this.options.inDuration,\n            easing: 'easeInOutCubic',\n            complete: function (anim) {\n              $body.css({\n                overflow: '',\n                paddingTop: '',\n                paddingBottom: '',\n                height: ''\n              });\n\n              // onOpenEnd callback\n              if (typeof _this6.options.onOpenEnd === 'function') {\n                _this6.options.onOpenEnd.call(_this6, $collapsibleLi[0]);\n              }\n            }\n          });\n        }\n      }\n\n      /**\n       * Animate out collapsible slide\n       * @param {Number} index - 0th index of slide to open\n       */\n\n    }, {\n      key: \"_animateOut\",\n      value: function _animateOut(index) {\n        var _this7 = this;\n\n        var $collapsibleLi = this.$el.children('li').eq(index);\n        if ($collapsibleLi.length) {\n          var $body = $collapsibleLi.children('.collapsible-body');\n          anim.remove($body[0]);\n          $body.css('overflow', 'hidden');\n          anim({\n            targets: $body[0],\n            height: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            duration: this.options.outDuration,\n            easing: 'easeInOutCubic',\n            complete: function () {\n              $body.css({\n                height: '',\n                overflow: '',\n                padding: '',\n                display: ''\n              });\n\n              // onCloseEnd callback\n              if (typeof _this7.options.onCloseEnd === 'function') {\n                _this7.options.onCloseEnd.call(_this7, $collapsibleLi[0]);\n              }\n            }\n          });\n        }\n      }\n\n      /**\n       * Open Collapsible\n       * @param {Number} index - 0th index of slide\n       */\n\n    }, {\n      key: \"open\",\n      value: function open(index) {\n        var _this8 = this;\n\n        var $collapsibleLi = this.$el.children('li').eq(index);\n        if ($collapsibleLi.length && !$collapsibleLi[0].classList.contains('active')) {\n          // onOpenStart callback\n          if (typeof this.options.onOpenStart === 'function') {\n            this.options.onOpenStart.call(this, $collapsibleLi[0]);\n          }\n\n          // Handle accordion behavior\n          if (this.options.accordion) {\n            var $collapsibleLis = this.$el.children('li');\n            var $activeLis = this.$el.children('li.active');\n            $activeLis.each(function (el) {\n              var index = $collapsibleLis.index($(el));\n              _this8.close(index);\n            });\n          }\n\n          // Animate in\n          $collapsibleLi[0].classList.add('active');\n          this._animateIn(index);\n        }\n      }\n\n      /**\n       * Close Collapsible\n       * @param {Number} index - 0th index of slide\n       */\n\n    }, {\n      key: \"close\",\n      value: function close(index) {\n        var $collapsibleLi = this.$el.children('li').eq(index);\n        if ($collapsibleLi.length && $collapsibleLi[0].classList.contains('active')) {\n          // onCloseStart callback\n          if (typeof this.options.onCloseStart === 'function') {\n            this.options.onCloseStart.call(this, $collapsibleLi[0]);\n          }\n\n          // Animate out\n          $collapsibleLi[0].classList.remove('active');\n          this._animateOut(index);\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Collapsible.__proto__ || Object.getPrototypeOf(Collapsible), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Collapsible;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Collapsible;\n  }(Component);\n\n  M.Collapsible = Collapsible;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Collapsible, 'collapsible', 'M_Collapsible');\n  }\n})(cash, M.anime);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    alignment: 'left',\n    autoFocus: true,\n    constrainWidth: true,\n    container: null,\n    coverTrigger: true,\n    closeOnClick: true,\n    hover: false,\n    inDuration: 150,\n    outDuration: 250,\n    onOpenStart: null,\n    onOpenEnd: null,\n    onCloseStart: null,\n    onCloseEnd: null,\n    onItemClick: null\n  };\n\n  /**\n   * @class\n   */\n\n  var Dropdown = function (_Component2) {\n    _inherits(Dropdown, _Component2);\n\n    function Dropdown(el, options) {\n      _classCallCheck(this, Dropdown);\n\n      var _this9 = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, Dropdown, el, options));\n\n      _this9.el.M_Dropdown = _this9;\n      Dropdown._dropdowns.push(_this9);\n\n      _this9.id = M.getIdFromTrigger(el);\n      _this9.dropdownEl = document.getElementById(_this9.id);\n      _this9.$dropdownEl = $(_this9.dropdownEl);\n\n      /**\n       * Options for the dropdown\n       * @member Dropdown#options\n       * @prop {String} [alignment='left'] - Edge which the dropdown is aligned to\n       * @prop {Boolean} [autoFocus=true] - Automatically focus dropdown el for keyboard\n       * @prop {Boolean} [constrainWidth=true] - Constrain width to width of the button\n       * @prop {Element} container - Container element to attach dropdown to (optional)\n       * @prop {Boolean} [coverTrigger=true] - Place dropdown over trigger\n       * @prop {Boolean} [closeOnClick=true] - Close on click of dropdown item\n       * @prop {Boolean} [hover=false] - Open dropdown on hover\n       * @prop {Number} [inDuration=150] - Duration of open animation in ms\n       * @prop {Number} [outDuration=250] - Duration of close animation in ms\n       * @prop {Function} onOpenStart - Function called when dropdown starts opening\n       * @prop {Function} onOpenEnd - Function called when dropdown finishes opening\n       * @prop {Function} onCloseStart - Function called when dropdown starts closing\n       * @prop {Function} onCloseEnd - Function called when dropdown finishes closing\n       */\n      _this9.options = $.extend({}, Dropdown.defaults, options);\n\n      /**\n       * Describes open/close state of dropdown\n       * @type {Boolean}\n       */\n      _this9.isOpen = false;\n\n      /**\n       * Describes if dropdown content is scrollable\n       * @type {Boolean}\n       */\n      _this9.isScrollable = false;\n\n      /**\n       * Describes if touch moving on dropdown content\n       * @type {Boolean}\n       */\n      _this9.isTouchMoving = false;\n\n      _this9.focusedIndex = -1;\n      _this9.filterQuery = [];\n\n      // Move dropdown-content after dropdown-trigger\n      if (!!_this9.options.container) {\n        $(_this9.options.container).append(_this9.dropdownEl);\n      } else {\n        _this9.$el.after(_this9.dropdownEl);\n      }\n\n      _this9._makeDropdownFocusable();\n      _this9._resetFilterQueryBound = _this9._resetFilterQuery.bind(_this9);\n      _this9._handleDocumentClickBound = _this9._handleDocumentClick.bind(_this9);\n      _this9._handleDocumentTouchmoveBound = _this9._handleDocumentTouchmove.bind(_this9);\n      _this9._handleDropdownClickBound = _this9._handleDropdownClick.bind(_this9);\n      _this9._handleDropdownKeydownBound = _this9._handleDropdownKeydown.bind(_this9);\n      _this9._handleTriggerKeydownBound = _this9._handleTriggerKeydown.bind(_this9);\n      _this9._setupEventHandlers();\n      return _this9;\n    }\n\n    _createClass(Dropdown, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._resetDropdownStyles();\n        this._removeEventHandlers();\n        Dropdown._dropdowns.splice(Dropdown._dropdowns.indexOf(this), 1);\n        this.el.M_Dropdown = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        // Trigger keydown handler\n        this.el.addEventListener('keydown', this._handleTriggerKeydownBound);\n\n        // Item click handler\n        this.dropdownEl.addEventListener('click', this._handleDropdownClickBound);\n\n        // Hover event handlers\n        if (this.options.hover) {\n          this._handleMouseEnterBound = this._handleMouseEnter.bind(this);\n          this.el.addEventListener('mouseenter', this._handleMouseEnterBound);\n          this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);\n          this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);\n          this.dropdownEl.addEventListener('mouseleave', this._handleMouseLeaveBound);\n\n          // Click event handlers\n        } else {\n          this._handleClickBound = this._handleClick.bind(this);\n          this.el.addEventListener('click', this._handleClickBound);\n        }\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('keydown', this._handleTriggerKeydownBound);\n        this.dropdownEl.removeEventListener('click', this._handleDropdownClickBound);\n\n        if (this.options.hover) {\n          this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);\n          this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);\n          this.dropdownEl.removeEventListener('mouseleave', this._handleMouseLeaveBound);\n        } else {\n          this.el.removeEventListener('click', this._handleClickBound);\n        }\n      }\n    }, {\n      key: \"_setupTemporaryEventHandlers\",\n      value: function _setupTemporaryEventHandlers() {\n        // Use capture phase event handler to prevent click\n        document.body.addEventListener('click', this._handleDocumentClickBound, true);\n        document.body.addEventListener('touchend', this._handleDocumentClickBound);\n        document.body.addEventListener('touchmove', this._handleDocumentTouchmoveBound);\n        this.dropdownEl.addEventListener('keydown', this._handleDropdownKeydownBound);\n      }\n    }, {\n      key: \"_removeTemporaryEventHandlers\",\n      value: function _removeTemporaryEventHandlers() {\n        // Use capture phase event handler to prevent click\n        document.body.removeEventListener('click', this._handleDocumentClickBound, true);\n        document.body.removeEventListener('touchend', this._handleDocumentClickBound);\n        document.body.removeEventListener('touchmove', this._handleDocumentTouchmoveBound);\n        this.dropdownEl.removeEventListener('keydown', this._handleDropdownKeydownBound);\n      }\n    }, {\n      key: \"_handleClick\",\n      value: function _handleClick(e) {\n        e.preventDefault();\n        this.open();\n      }\n    }, {\n      key: \"_handleMouseEnter\",\n      value: function _handleMouseEnter() {\n        this.open();\n      }\n    }, {\n      key: \"_handleMouseLeave\",\n      value: function _handleMouseLeave(e) {\n        var toEl = e.toElement || e.relatedTarget;\n        var leaveToDropdownContent = !!$(toEl).closest('.dropdown-content').length;\n        var leaveToActiveDropdownTrigger = false;\n\n        var $closestTrigger = $(toEl).closest('.dropdown-trigger');\n        if ($closestTrigger.length && !!$closestTrigger[0].M_Dropdown && $closestTrigger[0].M_Dropdown.isOpen) {\n          leaveToActiveDropdownTrigger = true;\n        }\n\n        // Close hover dropdown if mouse did not leave to either active dropdown-trigger or dropdown-content\n        if (!leaveToActiveDropdownTrigger && !leaveToDropdownContent) {\n          this.close();\n        }\n      }\n    }, {\n      key: \"_handleDocumentClick\",\n      value: function _handleDocumentClick(e) {\n        var _this10 = this;\n\n        var $target = $(e.target);\n        if (this.options.closeOnClick && $target.closest('.dropdown-content').length && !this.isTouchMoving) {\n          // isTouchMoving to check if scrolling on mobile.\n          setTimeout(function () {\n            _this10.close();\n          }, 0);\n        } else if ($target.closest('.dropdown-trigger').length || !$target.closest('.dropdown-content').length) {\n          setTimeout(function () {\n            _this10.close();\n          }, 0);\n        }\n        this.isTouchMoving = false;\n      }\n    }, {\n      key: \"_handleTriggerKeydown\",\n      value: function _handleTriggerKeydown(e) {\n        // ARROW DOWN OR ENTER WHEN SELECT IS CLOSED - open Dropdown\n        if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ENTER) && !this.isOpen) {\n          e.preventDefault();\n          this.open();\n        }\n      }\n\n      /**\n       * Handle Document Touchmove\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleDocumentTouchmove\",\n      value: function _handleDocumentTouchmove(e) {\n        var $target = $(e.target);\n        if ($target.closest('.dropdown-content').length) {\n          this.isTouchMoving = true;\n        }\n      }\n\n      /**\n       * Handle Dropdown Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleDropdownClick\",\n      value: function _handleDropdownClick(e) {\n        // onItemClick callback\n        if (typeof this.options.onItemClick === 'function') {\n          var itemEl = $(e.target).closest('li')[0];\n          this.options.onItemClick.call(this, itemEl);\n        }\n      }\n\n      /**\n       * Handle Dropdown Keydown\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleDropdownKeydown\",\n      value: function _handleDropdownKeydown(e) {\n        if (e.which === M.keys.TAB) {\n          e.preventDefault();\n          this.close();\n\n          // Navigate down dropdown list\n        } else if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) && this.isOpen) {\n          e.preventDefault();\n          var direction = e.which === M.keys.ARROW_DOWN ? 1 : -1;\n          var newFocusedIndex = this.focusedIndex;\n          var foundNewIndex = false;\n          do {\n            newFocusedIndex = newFocusedIndex + direction;\n\n            if (!!this.dropdownEl.children[newFocusedIndex] && this.dropdownEl.children[newFocusedIndex].tabIndex !== -1) {\n              foundNewIndex = true;\n              break;\n            }\n          } while (newFocusedIndex < this.dropdownEl.children.length && newFocusedIndex >= 0);\n\n          if (foundNewIndex) {\n            this.focusedIndex = newFocusedIndex;\n            this._focusFocusedItem();\n          }\n\n          // ENTER selects choice on focused item\n        } else if (e.which === M.keys.ENTER && this.isOpen) {\n          // Search for <a> and <button>\n          var focusedElement = this.dropdownEl.children[this.focusedIndex];\n          var $activatableElement = $(focusedElement).find('a, button').first();\n\n          // Click a or button tag if exists, otherwise click li tag\n          !!$activatableElement.length ? $activatableElement[0].click() : focusedElement.click();\n\n          // Close dropdown on ESC\n        } else if (e.which === M.keys.ESC && this.isOpen) {\n          e.preventDefault();\n          this.close();\n        }\n\n        // CASE WHEN USER TYPE LETTERS\n        var letter = String.fromCharCode(e.which).toLowerCase(),\n            nonLetters = [9, 13, 27, 38, 40];\n        if (letter && nonLetters.indexOf(e.which) === -1) {\n          this.filterQuery.push(letter);\n\n          var string = this.filterQuery.join(''),\n              newOptionEl = $(this.dropdownEl).find('li').filter(function (el) {\n            return $(el).text().toLowerCase().indexOf(string) === 0;\n          })[0];\n\n          if (newOptionEl) {\n            this.focusedIndex = $(newOptionEl).index();\n            this._focusFocusedItem();\n          }\n        }\n\n        this.filterTimeout = setTimeout(this._resetFilterQueryBound, 1000);\n      }\n\n      /**\n       * Setup dropdown\n       */\n\n    }, {\n      key: \"_resetFilterQuery\",\n      value: function _resetFilterQuery() {\n        this.filterQuery = [];\n      }\n    }, {\n      key: \"_resetDropdownStyles\",\n      value: function _resetDropdownStyles() {\n        this.$dropdownEl.css({\n          display: '',\n          width: '',\n          height: '',\n          left: '',\n          top: '',\n          'transform-origin': '',\n          transform: '',\n          opacity: ''\n        });\n      }\n    }, {\n      key: \"_makeDropdownFocusable\",\n      value: function _makeDropdownFocusable() {\n        // Needed for arrow key navigation\n        this.dropdownEl.tabIndex = 0;\n\n        // Only set tabindex if it hasn't been set by user\n        $(this.dropdownEl).children().each(function (el) {\n          if (!el.getAttribute('tabindex')) {\n            el.setAttribute('tabindex', 0);\n          }\n        });\n      }\n    }, {\n      key: \"_focusFocusedItem\",\n      value: function _focusFocusedItem() {\n        if (this.focusedIndex >= 0 && this.focusedIndex < this.dropdownEl.children.length && this.options.autoFocus) {\n          this.dropdownEl.children[this.focusedIndex].focus();\n        }\n      }\n    }, {\n      key: \"_getDropdownPosition\",\n      value: function _getDropdownPosition() {\n        var offsetParentBRect = this.el.offsetParent.getBoundingClientRect();\n        var triggerBRect = this.el.getBoundingClientRect();\n        var dropdownBRect = this.dropdownEl.getBoundingClientRect();\n\n        var idealHeight = dropdownBRect.height;\n        var idealWidth = dropdownBRect.width;\n        var idealXPos = triggerBRect.left - dropdownBRect.left;\n        var idealYPos = triggerBRect.top - dropdownBRect.top;\n\n        var dropdownBounds = {\n          left: idealXPos,\n          top: idealYPos,\n          height: idealHeight,\n          width: idealWidth\n        };\n\n        // Countainer here will be closest ancestor with overflow: hidden\n        var closestOverflowParent = !!this.dropdownEl.offsetParent ? this.dropdownEl.offsetParent : this.dropdownEl.parentNode;\n\n        var alignments = M.checkPossibleAlignments(this.el, closestOverflowParent, dropdownBounds, this.options.coverTrigger ? 0 : triggerBRect.height);\n\n        var verticalAlignment = 'top';\n        var horizontalAlignment = this.options.alignment;\n        idealYPos += this.options.coverTrigger ? 0 : triggerBRect.height;\n\n        // Reset isScrollable\n        this.isScrollable = false;\n\n        if (!alignments.top) {\n          if (alignments.bottom) {\n            verticalAlignment = 'bottom';\n          } else {\n            this.isScrollable = true;\n\n            // Determine which side has most space and cutoff at correct height\n            if (alignments.spaceOnTop > alignments.spaceOnBottom) {\n              verticalAlignment = 'bottom';\n              idealHeight += alignments.spaceOnTop;\n              idealYPos -= alignments.spaceOnTop;\n            } else {\n              idealHeight += alignments.spaceOnBottom;\n            }\n          }\n        }\n\n        // If preferred horizontal alignment is possible\n        if (!alignments[horizontalAlignment]) {\n          var oppositeAlignment = horizontalAlignment === 'left' ? 'right' : 'left';\n          if (alignments[oppositeAlignment]) {\n            horizontalAlignment = oppositeAlignment;\n          } else {\n            // Determine which side has most space and cutoff at correct height\n            if (alignments.spaceOnLeft > alignments.spaceOnRight) {\n              horizontalAlignment = 'right';\n              idealWidth += alignments.spaceOnLeft;\n              idealXPos -= alignments.spaceOnLeft;\n            } else {\n              horizontalAlignment = 'left';\n              idealWidth += alignments.spaceOnRight;\n            }\n          }\n        }\n\n        if (verticalAlignment === 'bottom') {\n          idealYPos = idealYPos - dropdownBRect.height + (this.options.coverTrigger ? triggerBRect.height : 0);\n        }\n        if (horizontalAlignment === 'right') {\n          idealXPos = idealXPos - dropdownBRect.width + triggerBRect.width;\n        }\n        return {\n          x: idealXPos,\n          y: idealYPos,\n          verticalAlignment: verticalAlignment,\n          horizontalAlignment: horizontalAlignment,\n          height: idealHeight,\n          width: idealWidth\n        };\n      }\n\n      /**\n       * Animate in dropdown\n       */\n\n    }, {\n      key: \"_animateIn\",\n      value: function _animateIn() {\n        var _this11 = this;\n\n        anim.remove(this.dropdownEl);\n        anim({\n          targets: this.dropdownEl,\n          opacity: {\n            value: [0, 1],\n            easing: 'easeOutQuad'\n          },\n          scaleX: [0.3, 1],\n          scaleY: [0.3, 1],\n          duration: this.options.inDuration,\n          easing: 'easeOutQuint',\n          complete: function (anim) {\n            if (_this11.options.autoFocus) {\n              _this11.dropdownEl.focus();\n            }\n\n            // onOpenEnd callback\n            if (typeof _this11.options.onOpenEnd === 'function') {\n              var elem = anim.animatables[0].target;\n              _this11.options.onOpenEnd.call(elem, _this11.el);\n            }\n          }\n        });\n      }\n\n      /**\n       * Animate out dropdown\n       */\n\n    }, {\n      key: \"_animateOut\",\n      value: function _animateOut() {\n        var _this12 = this;\n\n        anim.remove(this.dropdownEl);\n        anim({\n          targets: this.dropdownEl,\n          opacity: {\n            value: 0,\n            easing: 'easeOutQuint'\n          },\n          scaleX: 0.3,\n          scaleY: 0.3,\n          duration: this.options.outDuration,\n          easing: 'easeOutQuint',\n          complete: function (anim) {\n            _this12._resetDropdownStyles();\n\n            // onCloseEnd callback\n            if (typeof _this12.options.onCloseEnd === 'function') {\n              var elem = anim.animatables[0].target;\n              _this12.options.onCloseEnd.call(_this12, _this12.el);\n            }\n          }\n        });\n      }\n\n      /**\n       * Place dropdown\n       */\n\n    }, {\n      key: \"_placeDropdown\",\n      value: function _placeDropdown() {\n        // Set width before calculating positionInfo\n        var idealWidth = this.options.constrainWidth ? this.el.getBoundingClientRect().width : this.dropdownEl.getBoundingClientRect().width;\n        this.dropdownEl.style.width = idealWidth + 'px';\n\n        var positionInfo = this._getDropdownPosition();\n        this.dropdownEl.style.left = positionInfo.x + 'px';\n        this.dropdownEl.style.top = positionInfo.y + 'px';\n        this.dropdownEl.style.height = positionInfo.height + 'px';\n        this.dropdownEl.style.width = positionInfo.width + 'px';\n        this.dropdownEl.style.transformOrigin = (positionInfo.horizontalAlignment === 'left' ? '0' : '100%') + \" \" + (positionInfo.verticalAlignment === 'top' ? '0' : '100%');\n      }\n\n      /**\n       * Open Dropdown\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this.isOpen) {\n          return;\n        }\n        this.isOpen = true;\n\n        // onOpenStart callback\n        if (typeof this.options.onOpenStart === 'function') {\n          this.options.onOpenStart.call(this, this.el);\n        }\n\n        // Reset styles\n        this._resetDropdownStyles();\n        this.dropdownEl.style.display = 'block';\n\n        this._placeDropdown();\n        this._animateIn();\n        this._setupTemporaryEventHandlers();\n      }\n\n      /**\n       * Close Dropdown\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n        this.isOpen = false;\n        this.focusedIndex = -1;\n\n        // onCloseStart callback\n        if (typeof this.options.onCloseStart === 'function') {\n          this.options.onCloseStart.call(this, this.el);\n        }\n\n        this._animateOut();\n        this._removeTemporaryEventHandlers();\n\n        if (this.options.autoFocus) {\n          this.el.focus();\n        }\n      }\n\n      /**\n       * Recalculate dimensions\n       */\n\n    }, {\n      key: \"recalculateDimensions\",\n      value: function recalculateDimensions() {\n        if (this.isOpen) {\n          this.$dropdownEl.css({\n            width: '',\n            height: '',\n            left: '',\n            top: '',\n            'transform-origin': ''\n          });\n          this._placeDropdown();\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Dropdown.__proto__ || Object.getPrototypeOf(Dropdown), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Dropdown;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Dropdown;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Dropdown\n   */\n\n\n  Dropdown._dropdowns = [];\n\n  window.M.Dropdown = Dropdown;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Dropdown, 'dropdown', 'M_Dropdown');\n  }\n})(cash, M.anime);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    opacity: 0.5,\n    inDuration: 250,\n    outDuration: 250,\n    onOpenStart: null,\n    onOpenEnd: null,\n    onCloseStart: null,\n    onCloseEnd: null,\n    preventScrolling: true,\n    dismissible: true,\n    startingTop: '4%',\n    endingTop: '10%'\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Modal = function (_Component3) {\n    _inherits(Modal, _Component3);\n\n    /**\n     * Construct Modal instance and set up overlay\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Modal(el, options) {\n      _classCallCheck(this, Modal);\n\n      var _this13 = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, Modal, el, options));\n\n      _this13.el.M_Modal = _this13;\n\n      /**\n       * Options for the modal\n       * @member Modal#options\n       * @prop {Number} [opacity=0.5] - Opacity of the modal overlay\n       * @prop {Number} [inDuration=250] - Length in ms of enter transition\n       * @prop {Number} [outDuration=250] - Length in ms of exit transition\n       * @prop {Function} onOpenStart - Callback function called before modal is opened\n       * @prop {Function} onOpenEnd - Callback function called after modal is opened\n       * @prop {Function} onCloseStart - Callback function called before modal is closed\n       * @prop {Function} onCloseEnd - Callback function called after modal is closed\n       * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click\n       * @prop {String} [startingTop='4%'] - startingTop\n       * @prop {String} [endingTop='10%'] - endingTop\n       */\n      _this13.options = $.extend({}, Modal.defaults, options);\n\n      /**\n       * Describes open/close state of modal\n       * @type {Boolean}\n       */\n      _this13.isOpen = false;\n\n      _this13.id = _this13.$el.attr('id');\n      _this13._openingTrigger = undefined;\n      _this13.$overlay = $('<div class=\"modal-overlay\"></div>');\n      _this13.el.tabIndex = 0;\n      _this13._nthModalOpened = 0;\n\n      Modal._count++;\n      _this13._setupEventHandlers();\n      return _this13;\n    }\n\n    _createClass(Modal, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        Modal._count--;\n        this._removeEventHandlers();\n        this.el.removeAttribute('style');\n        this.$overlay.remove();\n        this.el.M_Modal = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleOverlayClickBound = this._handleOverlayClick.bind(this);\n        this._handleModalCloseClickBound = this._handleModalCloseClick.bind(this);\n\n        if (Modal._count === 1) {\n          document.body.addEventListener('click', this._handleTriggerClick);\n        }\n        this.$overlay[0].addEventListener('click', this._handleOverlayClickBound);\n        this.el.addEventListener('click', this._handleModalCloseClickBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        if (Modal._count === 0) {\n          document.body.removeEventListener('click', this._handleTriggerClick);\n        }\n        this.$overlay[0].removeEventListener('click', this._handleOverlayClickBound);\n        this.el.removeEventListener('click', this._handleModalCloseClickBound);\n      }\n\n      /**\n       * Handle Trigger Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleTriggerClick\",\n      value: function _handleTriggerClick(e) {\n        var $trigger = $(e.target).closest('.modal-trigger');\n        if ($trigger.length) {\n          var modalId = M.getIdFromTrigger($trigger[0]);\n          var modalInstance = document.getElementById(modalId).M_Modal;\n          if (modalInstance) {\n            modalInstance.open($trigger);\n          }\n          e.preventDefault();\n        }\n      }\n\n      /**\n       * Handle Overlay Click\n       */\n\n    }, {\n      key: \"_handleOverlayClick\",\n      value: function _handleOverlayClick() {\n        if (this.options.dismissible) {\n          this.close();\n        }\n      }\n\n      /**\n       * Handle Modal Close Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleModalCloseClick\",\n      value: function _handleModalCloseClick(e) {\n        var $closeTrigger = $(e.target).closest('.modal-close');\n        if ($closeTrigger.length) {\n          this.close();\n        }\n      }\n\n      /**\n       * Handle Keydown\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleKeydown\",\n      value: function _handleKeydown(e) {\n        // ESC key\n        if (e.keyCode === 27 && this.options.dismissible) {\n          this.close();\n        }\n      }\n\n      /**\n       * Handle Focus\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleFocus\",\n      value: function _handleFocus(e) {\n        // Only trap focus if this modal is the last model opened (prevents loops in nested modals).\n        if (!this.el.contains(e.target) && this._nthModalOpened === Modal._modalsOpen) {\n          this.el.focus();\n        }\n      }\n\n      /**\n       * Animate in modal\n       */\n\n    }, {\n      key: \"_animateIn\",\n      value: function _animateIn() {\n        var _this14 = this;\n\n        // Set initial styles\n        $.extend(this.el.style, {\n          display: 'block',\n          opacity: 0\n        });\n        $.extend(this.$overlay[0].style, {\n          display: 'block',\n          opacity: 0\n        });\n\n        // Animate overlay\n        anim({\n          targets: this.$overlay[0],\n          opacity: this.options.opacity,\n          duration: this.options.inDuration,\n          easing: 'easeOutQuad'\n        });\n\n        // Define modal animation options\n        var enterAnimOptions = {\n          targets: this.el,\n          duration: this.options.inDuration,\n          easing: 'easeOutCubic',\n          // Handle modal onOpenEnd callback\n          complete: function () {\n            if (typeof _this14.options.onOpenEnd === 'function') {\n              _this14.options.onOpenEnd.call(_this14, _this14.el, _this14._openingTrigger);\n            }\n          }\n        };\n\n        // Bottom sheet animation\n        if (this.el.classList.contains('bottom-sheet')) {\n          $.extend(enterAnimOptions, {\n            bottom: 0,\n            opacity: 1\n          });\n          anim(enterAnimOptions);\n\n          // Normal modal animation\n        } else {\n          $.extend(enterAnimOptions, {\n            top: [this.options.startingTop, this.options.endingTop],\n            opacity: 1,\n            scaleX: [0.8, 1],\n            scaleY: [0.8, 1]\n          });\n          anim(enterAnimOptions);\n        }\n      }\n\n      /**\n       * Animate out modal\n       */\n\n    }, {\n      key: \"_animateOut\",\n      value: function _animateOut() {\n        var _this15 = this;\n\n        // Animate overlay\n        anim({\n          targets: this.$overlay[0],\n          opacity: 0,\n          duration: this.options.outDuration,\n          easing: 'easeOutQuart'\n        });\n\n        // Define modal animation options\n        var exitAnimOptions = {\n          targets: this.el,\n          duration: this.options.outDuration,\n          easing: 'easeOutCubic',\n          // Handle modal ready callback\n          complete: function () {\n            _this15.el.style.display = 'none';\n            _this15.$overlay.remove();\n\n            // Call onCloseEnd callback\n            if (typeof _this15.options.onCloseEnd === 'function') {\n              _this15.options.onCloseEnd.call(_this15, _this15.el);\n            }\n          }\n        };\n\n        // Bottom sheet animation\n        if (this.el.classList.contains('bottom-sheet')) {\n          $.extend(exitAnimOptions, {\n            bottom: '-100%',\n            opacity: 0\n          });\n          anim(exitAnimOptions);\n\n          // Normal modal animation\n        } else {\n          $.extend(exitAnimOptions, {\n            top: [this.options.endingTop, this.options.startingTop],\n            opacity: 0,\n            scaleX: 0.8,\n            scaleY: 0.8\n          });\n          anim(exitAnimOptions);\n        }\n      }\n\n      /**\n       * Open Modal\n       * @param {cash} [$trigger]\n       */\n\n    }, {\n      key: \"open\",\n      value: function open($trigger) {\n        if (this.isOpen) {\n          return;\n        }\n\n        this.isOpen = true;\n        Modal._modalsOpen++;\n        this._nthModalOpened = Modal._modalsOpen;\n\n        // Set Z-Index based on number of currently open modals\n        this.$overlay[0].style.zIndex = 1000 + Modal._modalsOpen * 2;\n        this.el.style.zIndex = 1000 + Modal._modalsOpen * 2 + 1;\n\n        // Set opening trigger, undefined indicates modal was opened by javascript\n        this._openingTrigger = !!$trigger ? $trigger[0] : undefined;\n\n        // onOpenStart callback\n        if (typeof this.options.onOpenStart === 'function') {\n          this.options.onOpenStart.call(this, this.el, this._openingTrigger);\n        }\n\n        if (this.options.preventScrolling) {\n          document.body.style.overflow = 'hidden';\n        }\n\n        this.el.classList.add('open');\n        this.el.insertAdjacentElement('afterend', this.$overlay[0]);\n\n        if (this.options.dismissible) {\n          this._handleKeydownBound = this._handleKeydown.bind(this);\n          this._handleFocusBound = this._handleFocus.bind(this);\n          document.addEventListener('keydown', this._handleKeydownBound);\n          document.addEventListener('focus', this._handleFocusBound, true);\n        }\n\n        anim.remove(this.el);\n        anim.remove(this.$overlay[0]);\n        this._animateIn();\n\n        // Focus modal\n        this.el.focus();\n\n        return this;\n      }\n\n      /**\n       * Close Modal\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        this.isOpen = false;\n        Modal._modalsOpen--;\n        this._nthModalOpened = 0;\n\n        // Call onCloseStart callback\n        if (typeof this.options.onCloseStart === 'function') {\n          this.options.onCloseStart.call(this, this.el);\n        }\n\n        this.el.classList.remove('open');\n\n        // Enable body scrolling only if there are no more modals open.\n        if (Modal._modalsOpen === 0) {\n          document.body.style.overflow = '';\n        }\n\n        if (this.options.dismissible) {\n          document.removeEventListener('keydown', this._handleKeydownBound);\n          document.removeEventListener('focus', this._handleFocusBound, true);\n        }\n\n        anim.remove(this.el);\n        anim.remove(this.$overlay[0]);\n        this._animateOut();\n        return this;\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Modal.__proto__ || Object.getPrototypeOf(Modal), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Modal;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Modal;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Modal\n   */\n\n\n  Modal._modalsOpen = 0;\n\n  /**\n   * @static\n   * @memberof Modal\n   */\n  Modal._count = 0;\n\n  M.Modal = Modal;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Modal, 'modal', 'M_Modal');\n  }\n})(cash, M.anime);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    inDuration: 275,\n    outDuration: 200,\n    onOpenStart: null,\n    onOpenEnd: null,\n    onCloseStart: null,\n    onCloseEnd: null\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Materialbox = function (_Component4) {\n    _inherits(Materialbox, _Component4);\n\n    /**\n     * Construct Materialbox instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Materialbox(el, options) {\n      _classCallCheck(this, Materialbox);\n\n      var _this16 = _possibleConstructorReturn(this, (Materialbox.__proto__ || Object.getPrototypeOf(Materialbox)).call(this, Materialbox, el, options));\n\n      _this16.el.M_Materialbox = _this16;\n\n      /**\n       * Options for the modal\n       * @member Materialbox#options\n       * @prop {Number} [inDuration=275] - Length in ms of enter transition\n       * @prop {Number} [outDuration=200] - Length in ms of exit transition\n       * @prop {Function} onOpenStart - Callback function called before materialbox is opened\n       * @prop {Function} onOpenEnd - Callback function called after materialbox is opened\n       * @prop {Function} onCloseStart - Callback function called before materialbox is closed\n       * @prop {Function} onCloseEnd - Callback function called after materialbox is closed\n       */\n      _this16.options = $.extend({}, Materialbox.defaults, options);\n\n      _this16.overlayActive = false;\n      _this16.doneAnimating = true;\n      _this16.placeholder = $('<div></div>').addClass('material-placeholder');\n      _this16.originalWidth = 0;\n      _this16.originalHeight = 0;\n      _this16.originInlineStyles = _this16.$el.attr('style');\n      _this16.caption = _this16.el.getAttribute('data-caption') || '';\n\n      // Wrap\n      _this16.$el.before(_this16.placeholder);\n      _this16.placeholder.append(_this16.$el);\n\n      _this16._setupEventHandlers();\n      return _this16;\n    }\n\n    _createClass(Materialbox, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.el.M_Materialbox = undefined;\n\n        // Unwrap image\n        $(this.placeholder).after(this.el).remove();\n\n        this.$el.removeAttr('style');\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleMaterialboxClickBound = this._handleMaterialboxClick.bind(this);\n        this.el.addEventListener('click', this._handleMaterialboxClickBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('click', this._handleMaterialboxClickBound);\n      }\n\n      /**\n       * Handle Materialbox Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleMaterialboxClick\",\n      value: function _handleMaterialboxClick(e) {\n        // If already modal, return to original\n        if (this.doneAnimating === false || this.overlayActive && this.doneAnimating) {\n          this.close();\n        } else {\n          this.open();\n        }\n      }\n\n      /**\n       * Handle Window Scroll\n       */\n\n    }, {\n      key: \"_handleWindowScroll\",\n      value: function _handleWindowScroll() {\n        if (this.overlayActive) {\n          this.close();\n        }\n      }\n\n      /**\n       * Handle Window Resize\n       */\n\n    }, {\n      key: \"_handleWindowResize\",\n      value: function _handleWindowResize() {\n        if (this.overlayActive) {\n          this.close();\n        }\n      }\n\n      /**\n       * Handle Window Resize\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleWindowEscape\",\n      value: function _handleWindowEscape(e) {\n        // ESC key\n        if (e.keyCode === 27 && this.doneAnimating && this.overlayActive) {\n          this.close();\n        }\n      }\n\n      /**\n       * Find ancestors with overflow: hidden; and make visible\n       */\n\n    }, {\n      key: \"_makeAncestorsOverflowVisible\",\n      value: function _makeAncestorsOverflowVisible() {\n        this.ancestorsChanged = $();\n        var ancestor = this.placeholder[0].parentNode;\n        while (ancestor !== null && !$(ancestor).is(document)) {\n          var curr = $(ancestor);\n          if (curr.css('overflow') !== 'visible') {\n            curr.css('overflow', 'visible');\n            if (this.ancestorsChanged === undefined) {\n              this.ancestorsChanged = curr;\n            } else {\n              this.ancestorsChanged = this.ancestorsChanged.add(curr);\n            }\n          }\n          ancestor = ancestor.parentNode;\n        }\n      }\n\n      /**\n       * Animate image in\n       */\n\n    }, {\n      key: \"_animateImageIn\",\n      value: function _animateImageIn() {\n        var _this17 = this;\n\n        var animOptions = {\n          targets: this.el,\n          height: [this.originalHeight, this.newHeight],\n          width: [this.originalWidth, this.newWidth],\n          left: M.getDocumentScrollLeft() + this.windowWidth / 2 - this.placeholder.offset().left - this.newWidth / 2,\n          top: M.getDocumentScrollTop() + this.windowHeight / 2 - this.placeholder.offset().top - this.newHeight / 2,\n          duration: this.options.inDuration,\n          easing: 'easeOutQuad',\n          complete: function () {\n            _this17.doneAnimating = true;\n\n            // onOpenEnd callback\n            if (typeof _this17.options.onOpenEnd === 'function') {\n              _this17.options.onOpenEnd.call(_this17, _this17.el);\n            }\n          }\n        };\n\n        // Override max-width or max-height if needed\n        this.maxWidth = this.$el.css('max-width');\n        this.maxHeight = this.$el.css('max-height');\n        if (this.maxWidth !== 'none') {\n          animOptions.maxWidth = this.newWidth;\n        }\n        if (this.maxHeight !== 'none') {\n          animOptions.maxHeight = this.newHeight;\n        }\n\n        anim(animOptions);\n      }\n\n      /**\n       * Animate image out\n       */\n\n    }, {\n      key: \"_animateImageOut\",\n      value: function _animateImageOut() {\n        var _this18 = this;\n\n        var animOptions = {\n          targets: this.el,\n          width: this.originalWidth,\n          height: this.originalHeight,\n          left: 0,\n          top: 0,\n          duration: this.options.outDuration,\n          easing: 'easeOutQuad',\n          complete: function () {\n            _this18.placeholder.css({\n              height: '',\n              width: '',\n              position: '',\n              top: '',\n              left: ''\n            });\n\n            // Revert to width or height attribute\n            if (_this18.attrWidth) {\n              _this18.$el.attr('width', _this18.attrWidth);\n            }\n            if (_this18.attrHeight) {\n              _this18.$el.attr('height', _this18.attrHeight);\n            }\n\n            _this18.$el.removeAttr('style');\n            _this18.originInlineStyles && _this18.$el.attr('style', _this18.originInlineStyles);\n\n            // Remove class\n            _this18.$el.removeClass('active');\n            _this18.doneAnimating = true;\n\n            // Remove overflow overrides on ancestors\n            if (_this18.ancestorsChanged.length) {\n              _this18.ancestorsChanged.css('overflow', '');\n            }\n\n            // onCloseEnd callback\n            if (typeof _this18.options.onCloseEnd === 'function') {\n              _this18.options.onCloseEnd.call(_this18, _this18.el);\n            }\n          }\n        };\n\n        anim(animOptions);\n      }\n\n      /**\n       * Update open and close vars\n       */\n\n    }, {\n      key: \"_updateVars\",\n      value: function _updateVars() {\n        this.windowWidth = window.innerWidth;\n        this.windowHeight = window.innerHeight;\n        this.caption = this.el.getAttribute('data-caption') || '';\n      }\n\n      /**\n       * Open Materialbox\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        var _this19 = this;\n\n        this._updateVars();\n        this.originalWidth = this.el.getBoundingClientRect().width;\n        this.originalHeight = this.el.getBoundingClientRect().height;\n\n        // Set states\n        this.doneAnimating = false;\n        this.$el.addClass('active');\n        this.overlayActive = true;\n\n        // onOpenStart callback\n        if (typeof this.options.onOpenStart === 'function') {\n          this.options.onOpenStart.call(this, this.el);\n        }\n\n        // Set positioning for placeholder\n        this.placeholder.css({\n          width: this.placeholder[0].getBoundingClientRect().width + 'px',\n          height: this.placeholder[0].getBoundingClientRect().height + 'px',\n          position: 'relative',\n          top: 0,\n          left: 0\n        });\n\n        this._makeAncestorsOverflowVisible();\n\n        // Set css on origin\n        this.$el.css({\n          position: 'absolute',\n          'z-index': 1000,\n          'will-change': 'left, top, width, height'\n        });\n\n        // Change from width or height attribute to css\n        this.attrWidth = this.$el.attr('width');\n        this.attrHeight = this.$el.attr('height');\n        if (this.attrWidth) {\n          this.$el.css('width', this.attrWidth + 'px');\n          this.$el.removeAttr('width');\n        }\n        if (this.attrHeight) {\n          this.$el.css('width', this.attrHeight + 'px');\n          this.$el.removeAttr('height');\n        }\n\n        // Add overlay\n        this.$overlay = $('<div id=\"materialbox-overlay\"></div>').css({\n          opacity: 0\n        }).one('click', function () {\n          if (_this19.doneAnimating) {\n            _this19.close();\n          }\n        });\n\n        // Put before in origin image to preserve z-index layering.\n        this.$el.before(this.$overlay);\n\n        // Set dimensions if needed\n        var overlayOffset = this.$overlay[0].getBoundingClientRect();\n        this.$overlay.css({\n          width: this.windowWidth + 'px',\n          height: this.windowHeight + 'px',\n          left: -1 * overlayOffset.left + 'px',\n          top: -1 * overlayOffset.top + 'px'\n        });\n\n        anim.remove(this.el);\n        anim.remove(this.$overlay[0]);\n\n        // Animate Overlay\n        anim({\n          targets: this.$overlay[0],\n          opacity: 1,\n          duration: this.options.inDuration,\n          easing: 'easeOutQuad'\n        });\n\n        // Add and animate caption if it exists\n        if (this.caption !== '') {\n          if (this.$photocaption) {\n            anim.remove(this.$photoCaption[0]);\n          }\n          this.$photoCaption = $('<div class=\"materialbox-caption\"></div>');\n          this.$photoCaption.text(this.caption);\n          $('body').append(this.$photoCaption);\n          this.$photoCaption.css({ display: 'inline' });\n\n          anim({\n            targets: this.$photoCaption[0],\n            opacity: 1,\n            duration: this.options.inDuration,\n            easing: 'easeOutQuad'\n          });\n        }\n\n        // Resize Image\n        var ratio = 0;\n        var widthPercent = this.originalWidth / this.windowWidth;\n        var heightPercent = this.originalHeight / this.windowHeight;\n        this.newWidth = 0;\n        this.newHeight = 0;\n\n        if (widthPercent > heightPercent) {\n          ratio = this.originalHeight / this.originalWidth;\n          this.newWidth = this.windowWidth * 0.9;\n          this.newHeight = this.windowWidth * 0.9 * ratio;\n        } else {\n          ratio = this.originalWidth / this.originalHeight;\n          this.newWidth = this.windowHeight * 0.9 * ratio;\n          this.newHeight = this.windowHeight * 0.9;\n        }\n\n        this._animateImageIn();\n\n        // Handle Exit triggers\n        this._handleWindowScrollBound = this._handleWindowScroll.bind(this);\n        this._handleWindowResizeBound = this._handleWindowResize.bind(this);\n        this._handleWindowEscapeBound = this._handleWindowEscape.bind(this);\n\n        window.addEventListener('scroll', this._handleWindowScrollBound);\n        window.addEventListener('resize', this._handleWindowResizeBound);\n        window.addEventListener('keyup', this._handleWindowEscapeBound);\n      }\n\n      /**\n       * Close Materialbox\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        var _this20 = this;\n\n        this._updateVars();\n        this.doneAnimating = false;\n\n        // onCloseStart callback\n        if (typeof this.options.onCloseStart === 'function') {\n          this.options.onCloseStart.call(this, this.el);\n        }\n\n        anim.remove(this.el);\n        anim.remove(this.$overlay[0]);\n\n        if (this.caption !== '') {\n          anim.remove(this.$photoCaption[0]);\n        }\n\n        // disable exit handlers\n        window.removeEventListener('scroll', this._handleWindowScrollBound);\n        window.removeEventListener('resize', this._handleWindowResizeBound);\n        window.removeEventListener('keyup', this._handleWindowEscapeBound);\n\n        anim({\n          targets: this.$overlay[0],\n          opacity: 0,\n          duration: this.options.outDuration,\n          easing: 'easeOutQuad',\n          complete: function () {\n            _this20.overlayActive = false;\n            _this20.$overlay.remove();\n          }\n        });\n\n        this._animateImageOut();\n\n        // Remove Caption + reset css settings on image\n        if (this.caption !== '') {\n          anim({\n            targets: this.$photoCaption[0],\n            opacity: 0,\n            duration: this.options.outDuration,\n            easing: 'easeOutQuad',\n            complete: function () {\n              _this20.$photoCaption.remove();\n            }\n          });\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Materialbox.__proto__ || Object.getPrototypeOf(Materialbox), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Materialbox;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Materialbox;\n  }(Component);\n\n  M.Materialbox = Materialbox;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Materialbox, 'materialbox', 'M_Materialbox');\n  }\n})(cash, M.anime);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    responsiveThreshold: 0 // breakpoint for swipeable\n  };\n\n  var Parallax = function (_Component5) {\n    _inherits(Parallax, _Component5);\n\n    function Parallax(el, options) {\n      _classCallCheck(this, Parallax);\n\n      var _this21 = _possibleConstructorReturn(this, (Parallax.__proto__ || Object.getPrototypeOf(Parallax)).call(this, Parallax, el, options));\n\n      _this21.el.M_Parallax = _this21;\n\n      /**\n       * Options for the Parallax\n       * @member Parallax#options\n       * @prop {Number} responsiveThreshold\n       */\n      _this21.options = $.extend({}, Parallax.defaults, options);\n      _this21._enabled = window.innerWidth > _this21.options.responsiveThreshold;\n\n      _this21.$img = _this21.$el.find('img').first();\n      _this21.$img.each(function () {\n        var el = this;\n        if (el.complete) $(el).trigger('load');\n      });\n\n      _this21._updateParallax();\n      _this21._setupEventHandlers();\n      _this21._setupStyles();\n\n      Parallax._parallaxes.push(_this21);\n      return _this21;\n    }\n\n    _createClass(Parallax, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        Parallax._parallaxes.splice(Parallax._parallaxes.indexOf(this), 1);\n        this.$img[0].style.transform = '';\n        this._removeEventHandlers();\n\n        this.$el[0].M_Parallax = undefined;\n      }\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleImageLoadBound = this._handleImageLoad.bind(this);\n        this.$img[0].addEventListener('load', this._handleImageLoadBound);\n\n        if (Parallax._parallaxes.length === 0) {\n          Parallax._handleScrollThrottled = M.throttle(Parallax._handleScroll, 5);\n          window.addEventListener('scroll', Parallax._handleScrollThrottled);\n\n          Parallax._handleWindowResizeThrottled = M.throttle(Parallax._handleWindowResize, 5);\n          window.addEventListener('resize', Parallax._handleWindowResizeThrottled);\n        }\n      }\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.$img[0].removeEventListener('load', this._handleImageLoadBound);\n\n        if (Parallax._parallaxes.length === 0) {\n          window.removeEventListener('scroll', Parallax._handleScrollThrottled);\n          window.removeEventListener('resize', Parallax._handleWindowResizeThrottled);\n        }\n      }\n    }, {\n      key: \"_setupStyles\",\n      value: function _setupStyles() {\n        this.$img[0].style.opacity = 1;\n      }\n    }, {\n      key: \"_handleImageLoad\",\n      value: function _handleImageLoad() {\n        this._updateParallax();\n      }\n    }, {\n      key: \"_updateParallax\",\n      value: function _updateParallax() {\n        var containerHeight = this.$el.height() > 0 ? this.el.parentNode.offsetHeight : 500;\n        var imgHeight = this.$img[0].offsetHeight;\n        var parallaxDist = imgHeight - containerHeight;\n        var bottom = this.$el.offset().top + containerHeight;\n        var top = this.$el.offset().top;\n        var scrollTop = M.getDocumentScrollTop();\n        var windowHeight = window.innerHeight;\n        var windowBottom = scrollTop + windowHeight;\n        var percentScrolled = (windowBottom - top) / (containerHeight + windowHeight);\n        var parallax = parallaxDist * percentScrolled;\n\n        if (!this._enabled) {\n          this.$img[0].style.transform = '';\n        } else if (bottom > scrollTop && top < scrollTop + windowHeight) {\n          this.$img[0].style.transform = \"translate3D(-50%, \" + parallax + \"px, 0)\";\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Parallax.__proto__ || Object.getPrototypeOf(Parallax), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Parallax;\n      }\n    }, {\n      key: \"_handleScroll\",\n      value: function _handleScroll() {\n        for (var i = 0; i < Parallax._parallaxes.length; i++) {\n          var parallaxInstance = Parallax._parallaxes[i];\n          parallaxInstance._updateParallax.call(parallaxInstance);\n        }\n      }\n    }, {\n      key: \"_handleWindowResize\",\n      value: function _handleWindowResize() {\n        for (var i = 0; i < Parallax._parallaxes.length; i++) {\n          var parallaxInstance = Parallax._parallaxes[i];\n          parallaxInstance._enabled = window.innerWidth > parallaxInstance.options.responsiveThreshold;\n        }\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Parallax;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Parallax\n   */\n\n\n  Parallax._parallaxes = [];\n\n  M.Parallax = Parallax;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Parallax, 'parallax', 'M_Parallax');\n  }\n})(cash);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    duration: 300,\n    onShow: null,\n    swipeable: false,\n    responsiveThreshold: Infinity // breakpoint for swipeable\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Tabs = function (_Component6) {\n    _inherits(Tabs, _Component6);\n\n    /**\n     * Construct Tabs instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Tabs(el, options) {\n      _classCallCheck(this, Tabs);\n\n      var _this22 = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, Tabs, el, options));\n\n      _this22.el.M_Tabs = _this22;\n\n      /**\n       * Options for the Tabs\n       * @member Tabs#options\n       * @prop {Number} duration\n       * @prop {Function} onShow\n       * @prop {Boolean} swipeable\n       * @prop {Number} responsiveThreshold\n       */\n      _this22.options = $.extend({}, Tabs.defaults, options);\n\n      // Setup\n      _this22.$tabLinks = _this22.$el.children('li.tab').children('a');\n      _this22.index = 0;\n      _this22._setupActiveTabLink();\n\n      // Setup tabs content\n      if (_this22.options.swipeable) {\n        _this22._setupSwipeableTabs();\n      } else {\n        _this22._setupNormalTabs();\n      }\n\n      // Setup tabs indicator after content to ensure accurate widths\n      _this22._setTabsAndTabWidth();\n      _this22._createIndicator();\n\n      _this22._setupEventHandlers();\n      return _this22;\n    }\n\n    _createClass(Tabs, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this._indicator.parentNode.removeChild(this._indicator);\n\n        if (this.options.swipeable) {\n          this._teardownSwipeableTabs();\n        } else {\n          this._teardownNormalTabs();\n        }\n\n        this.$el[0].M_Tabs = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleWindowResizeBound = this._handleWindowResize.bind(this);\n        window.addEventListener('resize', this._handleWindowResizeBound);\n\n        this._handleTabClickBound = this._handleTabClick.bind(this);\n        this.el.addEventListener('click', this._handleTabClickBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        window.removeEventListener('resize', this._handleWindowResizeBound);\n        this.el.removeEventListener('click', this._handleTabClickBound);\n      }\n\n      /**\n       * Handle window Resize\n       */\n\n    }, {\n      key: \"_handleWindowResize\",\n      value: function _handleWindowResize() {\n        this._setTabsAndTabWidth();\n\n        if (this.tabWidth !== 0 && this.tabsWidth !== 0) {\n          this._indicator.style.left = this._calcLeftPos(this.$activeTabLink) + 'px';\n          this._indicator.style.right = this._calcRightPos(this.$activeTabLink) + 'px';\n        }\n      }\n\n      /**\n       * Handle tab click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleTabClick\",\n      value: function _handleTabClick(e) {\n        var _this23 = this;\n\n        var tab = $(e.target).closest('li.tab');\n        var tabLink = $(e.target).closest('a');\n\n        // Handle click on tab link only\n        if (!tabLink.length || !tabLink.parent().hasClass('tab')) {\n          return;\n        }\n\n        if (tab.hasClass('disabled')) {\n          e.preventDefault();\n          return;\n        }\n\n        // Act as regular link if target attribute is specified.\n        if (!!tabLink.attr('target')) {\n          return;\n        }\n\n        // Make the old tab inactive.\n        this.$activeTabLink.removeClass('active');\n        var $oldContent = this.$content;\n\n        // Update the variables with the new link and content\n        this.$activeTabLink = tabLink;\n        this.$content = $(M.escapeHash(tabLink[0].hash));\n        this.$tabLinks = this.$el.children('li.tab').children('a');\n\n        // Make the tab active.\n        this.$activeTabLink.addClass('active');\n        var prevIndex = this.index;\n        this.index = Math.max(this.$tabLinks.index(tabLink), 0);\n\n        // Swap content\n        if (this.options.swipeable) {\n          if (this._tabsCarousel) {\n            this._tabsCarousel.set(this.index, function () {\n              if (typeof _this23.options.onShow === 'function') {\n                _this23.options.onShow.call(_this23, _this23.$content[0]);\n              }\n            });\n          }\n        } else {\n          if (this.$content.length) {\n            this.$content[0].style.display = 'block';\n            this.$content.addClass('active');\n            if (typeof this.options.onShow === 'function') {\n              this.options.onShow.call(this, this.$content[0]);\n            }\n\n            if ($oldContent.length && !$oldContent.is(this.$content)) {\n              $oldContent[0].style.display = 'none';\n              $oldContent.removeClass('active');\n            }\n          }\n        }\n\n        // Update widths after content is swapped (scrollbar bugfix)\n        this._setTabsAndTabWidth();\n\n        // Update indicator\n        this._animateIndicator(prevIndex);\n\n        // Prevent the anchor's default click action\n        e.preventDefault();\n      }\n\n      /**\n       * Generate elements for tab indicator.\n       */\n\n    }, {\n      key: \"_createIndicator\",\n      value: function _createIndicator() {\n        var _this24 = this;\n\n        var indicator = document.createElement('li');\n        indicator.classList.add('indicator');\n\n        this.el.appendChild(indicator);\n        this._indicator = indicator;\n\n        setTimeout(function () {\n          _this24._indicator.style.left = _this24._calcLeftPos(_this24.$activeTabLink) + 'px';\n          _this24._indicator.style.right = _this24._calcRightPos(_this24.$activeTabLink) + 'px';\n        }, 0);\n      }\n\n      /**\n       * Setup first active tab link.\n       */\n\n    }, {\n      key: \"_setupActiveTabLink\",\n      value: function _setupActiveTabLink() {\n        // If the location.hash matches one of the links, use that as the active tab.\n        this.$activeTabLink = $(this.$tabLinks.filter('[href=\"' + location.hash + '\"]'));\n\n        // If no match is found, use the first link or any with class 'active' as the initial active tab.\n        if (this.$activeTabLink.length === 0) {\n          this.$activeTabLink = this.$el.children('li.tab').children('a.active').first();\n        }\n        if (this.$activeTabLink.length === 0) {\n          this.$activeTabLink = this.$el.children('li.tab').children('a').first();\n        }\n\n        this.$tabLinks.removeClass('active');\n        this.$activeTabLink[0].classList.add('active');\n\n        this.index = Math.max(this.$tabLinks.index(this.$activeTabLink), 0);\n\n        if (this.$activeTabLink.length) {\n          this.$content = $(M.escapeHash(this.$activeTabLink[0].hash));\n          this.$content.addClass('active');\n        }\n      }\n\n      /**\n       * Setup swipeable tabs\n       */\n\n    }, {\n      key: \"_setupSwipeableTabs\",\n      value: function _setupSwipeableTabs() {\n        var _this25 = this;\n\n        // Change swipeable according to responsive threshold\n        if (window.innerWidth > this.options.responsiveThreshold) {\n          this.options.swipeable = false;\n        }\n\n        var $tabsContent = $();\n        this.$tabLinks.each(function (link) {\n          var $currContent = $(M.escapeHash(link.hash));\n          $currContent.addClass('carousel-item');\n          $tabsContent = $tabsContent.add($currContent);\n        });\n\n        var $tabsWrapper = $('<div class=\"tabs-content carousel carousel-slider\"></div>');\n        $tabsContent.first().before($tabsWrapper);\n        $tabsWrapper.append($tabsContent);\n        $tabsContent[0].style.display = '';\n\n        // Keep active tab index to set initial carousel slide\n        var activeTabIndex = this.$activeTabLink.closest('.tab').index();\n\n        this._tabsCarousel = M.Carousel.init($tabsWrapper[0], {\n          fullWidth: true,\n          noWrap: true,\n          onCycleTo: function (item) {\n            var prevIndex = _this25.index;\n            _this25.index = $(item).index();\n            _this25.$activeTabLink.removeClass('active');\n            _this25.$activeTabLink = _this25.$tabLinks.eq(_this25.index);\n            _this25.$activeTabLink.addClass('active');\n            _this25._animateIndicator(prevIndex);\n            if (typeof _this25.options.onShow === 'function') {\n              _this25.options.onShow.call(_this25, _this25.$content[0]);\n            }\n          }\n        });\n\n        // Set initial carousel slide to active tab\n        this._tabsCarousel.set(activeTabIndex);\n      }\n\n      /**\n       * Teardown normal tabs.\n       */\n\n    }, {\n      key: \"_teardownSwipeableTabs\",\n      value: function _teardownSwipeableTabs() {\n        var $tabsWrapper = this._tabsCarousel.$el;\n        this._tabsCarousel.destroy();\n\n        // Unwrap\n        $tabsWrapper.after($tabsWrapper.children());\n        $tabsWrapper.remove();\n      }\n\n      /**\n       * Setup normal tabs.\n       */\n\n    }, {\n      key: \"_setupNormalTabs\",\n      value: function _setupNormalTabs() {\n        // Hide Tabs Content\n        this.$tabLinks.not(this.$activeTabLink).each(function (link) {\n          if (!!link.hash) {\n            var $currContent = $(M.escapeHash(link.hash));\n            if ($currContent.length) {\n              $currContent[0].style.display = 'none';\n            }\n          }\n        });\n      }\n\n      /**\n       * Teardown normal tabs.\n       */\n\n    }, {\n      key: \"_teardownNormalTabs\",\n      value: function _teardownNormalTabs() {\n        // show Tabs Content\n        this.$tabLinks.each(function (link) {\n          if (!!link.hash) {\n            var $currContent = $(M.escapeHash(link.hash));\n            if ($currContent.length) {\n              $currContent[0].style.display = '';\n            }\n          }\n        });\n      }\n\n      /**\n       * set tabs and tab width\n       */\n\n    }, {\n      key: \"_setTabsAndTabWidth\",\n      value: function _setTabsAndTabWidth() {\n        this.tabsWidth = this.$el.width();\n        this.tabWidth = Math.max(this.tabsWidth, this.el.scrollWidth) / this.$tabLinks.length;\n      }\n\n      /**\n       * Finds right attribute for indicator based on active tab.\n       * @param {cash} el\n       */\n\n    }, {\n      key: \"_calcRightPos\",\n      value: function _calcRightPos(el) {\n        return Math.ceil(this.tabsWidth - el.position().left - el[0].getBoundingClientRect().width);\n      }\n\n      /**\n       * Finds left attribute for indicator based on active tab.\n       * @param {cash} el\n       */\n\n    }, {\n      key: \"_calcLeftPos\",\n      value: function _calcLeftPos(el) {\n        return Math.floor(el.position().left);\n      }\n    }, {\n      key: \"updateTabIndicator\",\n      value: function updateTabIndicator() {\n        this._setTabsAndTabWidth();\n        this._animateIndicator(this.index);\n      }\n\n      /**\n       * Animates Indicator to active tab.\n       * @param {Number} prevIndex\n       */\n\n    }, {\n      key: \"_animateIndicator\",\n      value: function _animateIndicator(prevIndex) {\n        var leftDelay = 0,\n            rightDelay = 0;\n\n        if (this.index - prevIndex >= 0) {\n          leftDelay = 90;\n        } else {\n          rightDelay = 90;\n        }\n\n        // Animate\n        var animOptions = {\n          targets: this._indicator,\n          left: {\n            value: this._calcLeftPos(this.$activeTabLink),\n            delay: leftDelay\n          },\n          right: {\n            value: this._calcRightPos(this.$activeTabLink),\n            delay: rightDelay\n          },\n          duration: this.options.duration,\n          easing: 'easeOutQuad'\n        };\n        anim.remove(this._indicator);\n        anim(animOptions);\n      }\n\n      /**\n       * Select tab.\n       * @param {String} tabId\n       */\n\n    }, {\n      key: \"select\",\n      value: function select(tabId) {\n        var tab = this.$tabLinks.filter('[href=\"#' + tabId + '\"]');\n        if (tab.length) {\n          tab.trigger('click');\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Tabs.__proto__ || Object.getPrototypeOf(Tabs), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Tabs;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Tabs;\n  }(Component);\n\n  window.M.Tabs = Tabs;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Tabs, 'tabs', 'M_Tabs');\n  }\n})(cash, M.anime);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    exitDelay: 200,\n    enterDelay: 0,\n    html: null,\n    margin: 5,\n    inDuration: 250,\n    outDuration: 200,\n    position: 'bottom',\n    transitionMovement: 10\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Tooltip = function (_Component7) {\n    _inherits(Tooltip, _Component7);\n\n    /**\n     * Construct Tooltip instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Tooltip(el, options) {\n      _classCallCheck(this, Tooltip);\n\n      var _this26 = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, Tooltip, el, options));\n\n      _this26.el.M_Tooltip = _this26;\n      _this26.options = $.extend({}, Tooltip.defaults, options);\n\n      _this26.isOpen = false;\n      _this26.isHovered = false;\n      _this26.isFocused = false;\n      _this26._appendTooltipEl();\n      _this26._setupEventHandlers();\n      return _this26;\n    }\n\n    _createClass(Tooltip, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        $(this.tooltipEl).remove();\n        this._removeEventHandlers();\n        this.el.M_Tooltip = undefined;\n      }\n    }, {\n      key: \"_appendTooltipEl\",\n      value: function _appendTooltipEl() {\n        var tooltipEl = document.createElement('div');\n        tooltipEl.classList.add('material-tooltip');\n        this.tooltipEl = tooltipEl;\n\n        var tooltipContentEl = document.createElement('div');\n        tooltipContentEl.classList.add('tooltip-content');\n        tooltipContentEl.innerHTML = this.options.html;\n        tooltipEl.appendChild(tooltipContentEl);\n        document.body.appendChild(tooltipEl);\n      }\n    }, {\n      key: \"_updateTooltipContent\",\n      value: function _updateTooltipContent() {\n        this.tooltipEl.querySelector('.tooltip-content').innerHTML = this.options.html;\n      }\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleMouseEnterBound = this._handleMouseEnter.bind(this);\n        this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);\n        this._handleFocusBound = this._handleFocus.bind(this);\n        this._handleBlurBound = this._handleBlur.bind(this);\n        this.el.addEventListener('mouseenter', this._handleMouseEnterBound);\n        this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);\n        this.el.addEventListener('focus', this._handleFocusBound, true);\n        this.el.addEventListener('blur', this._handleBlurBound, true);\n      }\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);\n        this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);\n        this.el.removeEventListener('focus', this._handleFocusBound, true);\n        this.el.removeEventListener('blur', this._handleBlurBound, true);\n      }\n    }, {\n      key: \"open\",\n      value: function open(isManual) {\n        if (this.isOpen) {\n          return;\n        }\n        isManual = isManual === undefined ? true : undefined; // Default value true\n        this.isOpen = true;\n        // Update tooltip content with HTML attribute options\n        this.options = $.extend({}, this.options, this._getAttributeOptions());\n        this._updateTooltipContent();\n        this._setEnterDelayTimeout(isManual);\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        this.isHovered = false;\n        this.isFocused = false;\n        this.isOpen = false;\n        this._setExitDelayTimeout();\n      }\n\n      /**\n       * Create timeout which delays when the tooltip closes\n       */\n\n    }, {\n      key: \"_setExitDelayTimeout\",\n      value: function _setExitDelayTimeout() {\n        var _this27 = this;\n\n        clearTimeout(this._exitDelayTimeout);\n\n        this._exitDelayTimeout = setTimeout(function () {\n          if (_this27.isHovered || _this27.isFocused) {\n            return;\n          }\n\n          _this27._animateOut();\n        }, this.options.exitDelay);\n      }\n\n      /**\n       * Create timeout which delays when the toast closes\n       */\n\n    }, {\n      key: \"_setEnterDelayTimeout\",\n      value: function _setEnterDelayTimeout(isManual) {\n        var _this28 = this;\n\n        clearTimeout(this._enterDelayTimeout);\n\n        this._enterDelayTimeout = setTimeout(function () {\n          if (!_this28.isHovered && !_this28.isFocused && !isManual) {\n            return;\n          }\n\n          _this28._animateIn();\n        }, this.options.enterDelay);\n      }\n    }, {\n      key: \"_positionTooltip\",\n      value: function _positionTooltip() {\n        var origin = this.el,\n            tooltip = this.tooltipEl,\n            originHeight = origin.offsetHeight,\n            originWidth = origin.offsetWidth,\n            tooltipHeight = tooltip.offsetHeight,\n            tooltipWidth = tooltip.offsetWidth,\n            newCoordinates = void 0,\n            margin = this.options.margin,\n            targetTop = void 0,\n            targetLeft = void 0;\n\n        this.xMovement = 0, this.yMovement = 0;\n\n        targetTop = origin.getBoundingClientRect().top + M.getDocumentScrollTop();\n        targetLeft = origin.getBoundingClientRect().left + M.getDocumentScrollLeft();\n\n        if (this.options.position === 'top') {\n          targetTop += -tooltipHeight - margin;\n          targetLeft += originWidth / 2 - tooltipWidth / 2;\n          this.yMovement = -this.options.transitionMovement;\n        } else if (this.options.position === 'right') {\n          targetTop += originHeight / 2 - tooltipHeight / 2;\n          targetLeft += originWidth + margin;\n          this.xMovement = this.options.transitionMovement;\n        } else if (this.options.position === 'left') {\n          targetTop += originHeight / 2 - tooltipHeight / 2;\n          targetLeft += -tooltipWidth - margin;\n          this.xMovement = -this.options.transitionMovement;\n        } else {\n          targetTop += originHeight + margin;\n          targetLeft += originWidth / 2 - tooltipWidth / 2;\n          this.yMovement = this.options.transitionMovement;\n        }\n\n        newCoordinates = this._repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n        $(tooltip).css({\n          top: newCoordinates.y + 'px',\n          left: newCoordinates.x + 'px'\n        });\n      }\n    }, {\n      key: \"_repositionWithinScreen\",\n      value: function _repositionWithinScreen(x, y, width, height) {\n        var scrollLeft = M.getDocumentScrollLeft();\n        var scrollTop = M.getDocumentScrollTop();\n        var newX = x - scrollLeft;\n        var newY = y - scrollTop;\n\n        var bounding = {\n          left: newX,\n          top: newY,\n          width: width,\n          height: height\n        };\n\n        var offset = this.options.margin + this.options.transitionMovement;\n        var edges = M.checkWithinContainer(document.body, bounding, offset);\n\n        if (edges.left) {\n          newX = offset;\n        } else if (edges.right) {\n          newX -= newX + width - window.innerWidth;\n        }\n\n        if (edges.top) {\n          newY = offset;\n        } else if (edges.bottom) {\n          newY -= newY + height - window.innerHeight;\n        }\n\n        return {\n          x: newX + scrollLeft,\n          y: newY + scrollTop\n        };\n      }\n    }, {\n      key: \"_animateIn\",\n      value: function _animateIn() {\n        this._positionTooltip();\n        this.tooltipEl.style.visibility = 'visible';\n        anim.remove(this.tooltipEl);\n        anim({\n          targets: this.tooltipEl,\n          opacity: 1,\n          translateX: this.xMovement,\n          translateY: this.yMovement,\n          duration: this.options.inDuration,\n          easing: 'easeOutCubic'\n        });\n      }\n    }, {\n      key: \"_animateOut\",\n      value: function _animateOut() {\n        anim.remove(this.tooltipEl);\n        anim({\n          targets: this.tooltipEl,\n          opacity: 0,\n          translateX: 0,\n          translateY: 0,\n          duration: this.options.outDuration,\n          easing: 'easeOutCubic'\n        });\n      }\n    }, {\n      key: \"_handleMouseEnter\",\n      value: function _handleMouseEnter() {\n        this.isHovered = true;\n        this.isFocused = false; // Allows close of tooltip when opened by focus.\n        this.open(false);\n      }\n    }, {\n      key: \"_handleMouseLeave\",\n      value: function _handleMouseLeave() {\n        this.isHovered = false;\n        this.isFocused = false; // Allows close of tooltip when opened by focus.\n        this.close();\n      }\n    }, {\n      key: \"_handleFocus\",\n      value: function _handleFocus() {\n        if (M.tabPressed) {\n          this.isFocused = true;\n          this.open(false);\n        }\n      }\n    }, {\n      key: \"_handleBlur\",\n      value: function _handleBlur() {\n        this.isFocused = false;\n        this.close();\n      }\n    }, {\n      key: \"_getAttributeOptions\",\n      value: function _getAttributeOptions() {\n        var attributeOptions = {};\n        var tooltipTextOption = this.el.getAttribute('data-tooltip');\n        var positionOption = this.el.getAttribute('data-position');\n\n        if (tooltipTextOption) {\n          attributeOptions.html = tooltipTextOption;\n        }\n\n        if (positionOption) {\n          attributeOptions.position = positionOption;\n        }\n        return attributeOptions;\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Tooltip.__proto__ || Object.getPrototypeOf(Tooltip), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Tooltip;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Tooltip;\n  }(Component);\n\n  M.Tooltip = Tooltip;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Tooltip, 'tooltip', 'M_Tooltip');\n  }\n})(cash, M.anime);\n; /*!\r\n  * Waves v0.6.4\r\n  * http://fian.my.id/Waves\r\n  *\r\n  * Copyright 2014 Alfiana E. Sibuea and other contributors\r\n  * Released under the MIT license\r\n  * https://github.com/fians/Waves/blob/master/LICENSE\r\n  */\n\n;(function (window) {\n  'use strict';\n\n  var Waves = Waves || {};\n  var $$ = document.querySelectorAll.bind(document);\n\n  // Find exact position of element\n  function isWindow(obj) {\n    return obj !== null && obj === obj.window;\n  }\n\n  function getWindow(elem) {\n    return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\n  }\n\n  function offset(elem) {\n    var docElem,\n        win,\n        box = { top: 0, left: 0 },\n        doc = elem && elem.ownerDocument;\n\n    docElem = doc.documentElement;\n\n    if (typeof elem.getBoundingClientRect !== typeof undefined) {\n      box = elem.getBoundingClientRect();\n    }\n    win = getWindow(doc);\n    return {\n      top: box.top + win.pageYOffset - docElem.clientTop,\n      left: box.left + win.pageXOffset - docElem.clientLeft\n    };\n  }\n\n  function convertStyle(obj) {\n    var style = '';\n\n    for (var a in obj) {\n      if (obj.hasOwnProperty(a)) {\n        style += a + ':' + obj[a] + ';';\n      }\n    }\n\n    return style;\n  }\n\n  var Effect = {\n\n    // Effect delay\n    duration: 750,\n\n    show: function (e, element) {\n\n      // Disable right click\n      if (e.button === 2) {\n        return false;\n      }\n\n      var el = element || this;\n\n      // Create ripple\n      var ripple = document.createElement('div');\n      ripple.className = 'waves-ripple';\n      el.appendChild(ripple);\n\n      // Get click coordinate and element witdh\n      var pos = offset(el);\n      var relativeY = e.pageY - pos.top;\n      var relativeX = e.pageX - pos.left;\n      var scale = 'scale(' + el.clientWidth / 100 * 10 + ')';\n\n      // Support for touch devices\n      if ('touches' in e) {\n        relativeY = e.touches[0].pageY - pos.top;\n        relativeX = e.touches[0].pageX - pos.left;\n      }\n\n      // Attach data to element\n      ripple.setAttribute('data-hold', Date.now());\n      ripple.setAttribute('data-scale', scale);\n      ripple.setAttribute('data-x', relativeX);\n      ripple.setAttribute('data-y', relativeY);\n\n      // Set ripple position\n      var rippleStyle = {\n        'top': relativeY + 'px',\n        'left': relativeX + 'px'\n      };\n\n      ripple.className = ripple.className + ' waves-notransition';\n      ripple.setAttribute('style', convertStyle(rippleStyle));\n      ripple.className = ripple.className.replace('waves-notransition', '');\n\n      // Scale the ripple\n      rippleStyle['-webkit-transform'] = scale;\n      rippleStyle['-moz-transform'] = scale;\n      rippleStyle['-ms-transform'] = scale;\n      rippleStyle['-o-transform'] = scale;\n      rippleStyle.transform = scale;\n      rippleStyle.opacity = '1';\n\n      rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['transition-duration'] = Effect.duration + 'ms';\n\n      rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n\n      ripple.setAttribute('style', convertStyle(rippleStyle));\n    },\n\n    hide: function (e) {\n      TouchHandler.touchup(e);\n\n      var el = this;\n      var width = el.clientWidth * 1.4;\n\n      // Get first ripple\n      var ripple = null;\n      var ripples = el.getElementsByClassName('waves-ripple');\n      if (ripples.length > 0) {\n        ripple = ripples[ripples.length - 1];\n      } else {\n        return false;\n      }\n\n      var relativeX = ripple.getAttribute('data-x');\n      var relativeY = ripple.getAttribute('data-y');\n      var scale = ripple.getAttribute('data-scale');\n\n      // Get delay beetween mousedown and mouse leave\n      var diff = Date.now() - Number(ripple.getAttribute('data-hold'));\n      var delay = 350 - diff;\n\n      if (delay < 0) {\n        delay = 0;\n      }\n\n      // Fade out ripple after delay\n      setTimeout(function () {\n        var style = {\n          'top': relativeY + 'px',\n          'left': relativeX + 'px',\n          'opacity': '0',\n\n          // Duration\n          '-webkit-transition-duration': Effect.duration + 'ms',\n          '-moz-transition-duration': Effect.duration + 'ms',\n          '-o-transition-duration': Effect.duration + 'ms',\n          'transition-duration': Effect.duration + 'ms',\n          '-webkit-transform': scale,\n          '-moz-transform': scale,\n          '-ms-transform': scale,\n          '-o-transform': scale,\n          'transform': scale\n        };\n\n        ripple.setAttribute('style', convertStyle(style));\n\n        setTimeout(function () {\n          try {\n            el.removeChild(ripple);\n          } catch (e) {\n            return false;\n          }\n        }, Effect.duration);\n      }, delay);\n    },\n\n    // Little hack to make <input> can perform waves effect\n    wrapInput: function (elements) {\n      for (var a = 0; a < elements.length; a++) {\n        var el = elements[a];\n\n        if (el.tagName.toLowerCase() === 'input') {\n          var parent = el.parentNode;\n\n          // If input already have parent just pass through\n          if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {\n            continue;\n          }\n\n          // Put element class and style to the specified parent\n          var wrapper = document.createElement('i');\n          wrapper.className = el.className + ' waves-input-wrapper';\n\n          var elementStyle = el.getAttribute('style');\n\n          if (!elementStyle) {\n            elementStyle = '';\n          }\n\n          wrapper.setAttribute('style', elementStyle);\n\n          el.className = 'waves-button-input';\n          el.removeAttribute('style');\n\n          // Put element as child\n          parent.replaceChild(wrapper, el);\n          wrapper.appendChild(el);\n        }\n      }\n    }\n  };\n\n  /**\r\n   * Disable mousedown event for 500ms during and after touch\r\n   */\n  var TouchHandler = {\n    /* uses an integer rather than bool so there's no issues with\r\n     * needing to clear timeouts if another touch event occurred\r\n     * within the 500ms. Cannot mouseup between touchstart and\r\n     * touchend, nor in the 500ms after touchend. */\n    touches: 0,\n    allowEvent: function (e) {\n      var allow = true;\n\n      if (e.type === 'touchstart') {\n        TouchHandler.touches += 1; //push\n      } else if (e.type === 'touchend' || e.type === 'touchcancel') {\n        setTimeout(function () {\n          if (TouchHandler.touches > 0) {\n            TouchHandler.touches -= 1; //pop after 500ms\n          }\n        }, 500);\n      } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {\n        allow = false;\n      }\n\n      return allow;\n    },\n    touchup: function (e) {\n      TouchHandler.allowEvent(e);\n    }\n  };\n\n  /**\r\n   * Delegated click handler for .waves-effect element.\r\n   * returns null when .waves-effect element not in \"click tree\"\r\n   */\n  function getWavesEffectElement(e) {\n    if (TouchHandler.allowEvent(e) === false) {\n      return null;\n    }\n\n    var element = null;\n    var target = e.target || e.srcElement;\n\n    while (target.parentNode !== null) {\n      if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {\n        element = target;\n        break;\n      }\n      target = target.parentNode;\n    }\n    return element;\n  }\n\n  /**\r\n   * Bubble the click and show effect if .waves-effect elem was found\r\n   */\n  function showEffect(e) {\n    var element = getWavesEffectElement(e);\n\n    if (element !== null) {\n      Effect.show(e, element);\n\n      if ('ontouchstart' in window) {\n        element.addEventListener('touchend', Effect.hide, false);\n        element.addEventListener('touchcancel', Effect.hide, false);\n      }\n\n      element.addEventListener('mouseup', Effect.hide, false);\n      element.addEventListener('mouseleave', Effect.hide, false);\n      element.addEventListener('dragend', Effect.hide, false);\n    }\n  }\n\n  Waves.displayEffect = function (options) {\n    options = options || {};\n\n    if ('duration' in options) {\n      Effect.duration = options.duration;\n    }\n\n    //Wrap input inside <i> tag\n    Effect.wrapInput($$('.waves-effect'));\n\n    if ('ontouchstart' in window) {\n      document.body.addEventListener('touchstart', showEffect, false);\n    }\n\n    document.body.addEventListener('mousedown', showEffect, false);\n  };\n\n  /**\r\n   * Attach Waves to an input element (or any element which doesn't\r\n   * bubble mouseup/mousedown events).\r\n   *   Intended to be used with dynamically loaded forms/inputs, or\r\n   * where the user doesn't want a delegated click handler.\r\n   */\n  Waves.attach = function (element) {\n    //FUTURE: automatically add waves classes and allow users\n    // to specify them with an options param? Eg. light/classic/button\n    if (element.tagName.toLowerCase() === 'input') {\n      Effect.wrapInput([element]);\n      element = element.parentNode;\n    }\n\n    if ('ontouchstart' in window) {\n      element.addEventListener('touchstart', showEffect, false);\n    }\n\n    element.addEventListener('mousedown', showEffect, false);\n  };\n\n  window.Waves = Waves;\n\n  document.addEventListener('DOMContentLoaded', function () {\n    Waves.displayEffect();\n  }, false);\n})(window);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    html: '',\n    displayLength: 4000,\n    inDuration: 300,\n    outDuration: 375,\n    classes: '',\n    completeCallback: null,\n    activationPercent: 0.8\n  };\n\n  var Toast = function () {\n    function Toast(options) {\n      _classCallCheck(this, Toast);\n\n      /**\n       * Options for the toast\n       * @member Toast#options\n       */\n      this.options = $.extend({}, Toast.defaults, options);\n      this.message = this.options.html;\n\n      /**\n       * Describes current pan state toast\n       * @type {Boolean}\n       */\n      this.panning = false;\n\n      /**\n       * Time remaining until toast is removed\n       */\n      this.timeRemaining = this.options.displayLength;\n\n      if (Toast._toasts.length === 0) {\n        Toast._createContainer();\n      }\n\n      // Create new toast\n      Toast._toasts.push(this);\n      var toastElement = this._createToast();\n      toastElement.M_Toast = this;\n      this.el = toastElement;\n      this.$el = $(toastElement);\n      this._animateIn();\n      this._setTimer();\n    }\n\n    _createClass(Toast, [{\n      key: \"_createToast\",\n\n\n      /**\n       * Create toast and append it to toast container\n       */\n      value: function _createToast() {\n        var toast = document.createElement('div');\n        toast.classList.add('toast');\n\n        // Add custom classes onto toast\n        if (!!this.options.classes.length) {\n          $(toast).addClass(this.options.classes);\n        }\n\n        // Set content\n        if (typeof HTMLElement === 'object' ? this.message instanceof HTMLElement : this.message && typeof this.message === 'object' && this.message !== null && this.message.nodeType === 1 && typeof this.message.nodeName === 'string') {\n          toast.appendChild(this.message);\n\n          // Check if it is jQuery object\n        } else if (!!this.message.jquery) {\n          $(toast).append(this.message[0]);\n\n          // Insert as html;\n        } else {\n          toast.innerHTML = this.message;\n        }\n\n        // Append toasft\n        Toast._container.appendChild(toast);\n        return toast;\n      }\n\n      /**\n       * Animate in toast\n       */\n\n    }, {\n      key: \"_animateIn\",\n      value: function _animateIn() {\n        // Animate toast in\n        anim({\n          targets: this.el,\n          top: 0,\n          opacity: 1,\n          duration: this.options.inDuration,\n          easing: 'easeOutCubic'\n        });\n      }\n\n      /**\n       * Create setInterval which automatically removes toast when timeRemaining >= 0\n       * has been reached\n       */\n\n    }, {\n      key: \"_setTimer\",\n      value: function _setTimer() {\n        var _this29 = this;\n\n        if (this.timeRemaining !== Infinity) {\n          this.counterInterval = setInterval(function () {\n            // If toast is not being dragged, decrease its time remaining\n            if (!_this29.panning) {\n              _this29.timeRemaining -= 20;\n            }\n\n            // Animate toast out\n            if (_this29.timeRemaining <= 0) {\n              _this29.dismiss();\n            }\n          }, 20);\n        }\n      }\n\n      /**\n       * Dismiss toast with animation\n       */\n\n    }, {\n      key: \"dismiss\",\n      value: function dismiss() {\n        var _this30 = this;\n\n        window.clearInterval(this.counterInterval);\n        var activationDistance = this.el.offsetWidth * this.options.activationPercent;\n\n        if (this.wasSwiped) {\n          this.el.style.transition = 'transform .05s, opacity .05s';\n          this.el.style.transform = \"translateX(\" + activationDistance + \"px)\";\n          this.el.style.opacity = 0;\n        }\n\n        anim({\n          targets: this.el,\n          opacity: 0,\n          marginTop: -40,\n          duration: this.options.outDuration,\n          easing: 'easeOutExpo',\n          complete: function () {\n            // Call the optional callback\n            if (typeof _this30.options.completeCallback === 'function') {\n              _this30.options.completeCallback();\n            }\n            // Remove toast from DOM\n            _this30.$el.remove();\n            Toast._toasts.splice(Toast._toasts.indexOf(_this30), 1);\n            if (Toast._toasts.length === 0) {\n              Toast._removeContainer();\n            }\n          }\n        });\n      }\n    }], [{\n      key: \"getInstance\",\n\n\n      /**\n       * Get Instance\n       */\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Toast;\n      }\n\n      /**\n       * Append toast container and add event handlers\n       */\n\n    }, {\n      key: \"_createContainer\",\n      value: function _createContainer() {\n        var container = document.createElement('div');\n        container.setAttribute('id', 'toast-container');\n\n        // Add event handler\n        container.addEventListener('touchstart', Toast._onDragStart);\n        container.addEventListener('touchmove', Toast._onDragMove);\n        container.addEventListener('touchend', Toast._onDragEnd);\n\n        container.addEventListener('mousedown', Toast._onDragStart);\n        document.addEventListener('mousemove', Toast._onDragMove);\n        document.addEventListener('mouseup', Toast._onDragEnd);\n\n        document.body.appendChild(container);\n        Toast._container = container;\n      }\n\n      /**\n       * Remove toast container and event handlers\n       */\n\n    }, {\n      key: \"_removeContainer\",\n      value: function _removeContainer() {\n        // Add event handler\n        document.removeEventListener('mousemove', Toast._onDragMove);\n        document.removeEventListener('mouseup', Toast._onDragEnd);\n\n        $(Toast._container).remove();\n        Toast._container = null;\n      }\n\n      /**\n       * Begin drag handler\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_onDragStart\",\n      value: function _onDragStart(e) {\n        if (e.target && $(e.target).closest('.toast').length) {\n          var $toast = $(e.target).closest('.toast');\n          var toast = $toast[0].M_Toast;\n          toast.panning = true;\n          Toast._draggedToast = toast;\n          toast.el.classList.add('panning');\n          toast.el.style.transition = '';\n          toast.startingXPos = Toast._xPos(e);\n          toast.time = Date.now();\n          toast.xPos = Toast._xPos(e);\n        }\n      }\n\n      /**\n       * Drag move handler\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_onDragMove\",\n      value: function _onDragMove(e) {\n        if (!!Toast._draggedToast) {\n          e.preventDefault();\n          var toast = Toast._draggedToast;\n          toast.deltaX = Math.abs(toast.xPos - Toast._xPos(e));\n          toast.xPos = Toast._xPos(e);\n          toast.velocityX = toast.deltaX / (Date.now() - toast.time);\n          toast.time = Date.now();\n\n          var totalDeltaX = toast.xPos - toast.startingXPos;\n          var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;\n          toast.el.style.transform = \"translateX(\" + totalDeltaX + \"px)\";\n          toast.el.style.opacity = 1 - Math.abs(totalDeltaX / activationDistance);\n        }\n      }\n\n      /**\n       * End drag handler\n       */\n\n    }, {\n      key: \"_onDragEnd\",\n      value: function _onDragEnd() {\n        if (!!Toast._draggedToast) {\n          var toast = Toast._draggedToast;\n          toast.panning = false;\n          toast.el.classList.remove('panning');\n\n          var totalDeltaX = toast.xPos - toast.startingXPos;\n          var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;\n          var shouldBeDismissed = Math.abs(totalDeltaX) > activationDistance || toast.velocityX > 1;\n\n          // Remove toast\n          if (shouldBeDismissed) {\n            toast.wasSwiped = true;\n            toast.dismiss();\n\n            // Animate toast back to original position\n          } else {\n            toast.el.style.transition = 'transform .2s, opacity .2s';\n            toast.el.style.transform = '';\n            toast.el.style.opacity = '';\n          }\n          Toast._draggedToast = null;\n        }\n      }\n\n      /**\n       * Get x position of mouse or touch event\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_xPos\",\n      value: function _xPos(e) {\n        if (e.targetTouches && e.targetTouches.length >= 1) {\n          return e.targetTouches[0].clientX;\n        }\n        // mouse event\n        return e.clientX;\n      }\n\n      /**\n       * Remove all toasts\n       */\n\n    }, {\n      key: \"dismissAll\",\n      value: function dismissAll() {\n        for (var toastIndex in Toast._toasts) {\n          Toast._toasts[toastIndex].dismiss();\n        }\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Toast;\n  }();\n\n  /**\n   * @static\n   * @memberof Toast\n   * @type {Array.<Toast>}\n   */\n\n\n  Toast._toasts = [];\n\n  /**\n   * @static\n   * @memberof Toast\n   */\n  Toast._container = null;\n\n  /**\n   * @static\n   * @memberof Toast\n   * @type {Toast}\n   */\n  Toast._draggedToast = null;\n\n  M.Toast = Toast;\n  M.toast = function (options) {\n    return new Toast(options);\n  };\n})(cash, M.anime);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    edge: 'left',\n    draggable: true,\n    inDuration: 250,\n    outDuration: 200,\n    onOpenStart: null,\n    onOpenEnd: null,\n    onCloseStart: null,\n    onCloseEnd: null,\n    preventScrolling: true\n  };\n\n  /**\n   * @class\n   */\n\n  var Sidenav = function (_Component8) {\n    _inherits(Sidenav, _Component8);\n\n    /**\n     * Construct Sidenav instance and set up overlay\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Sidenav(el, options) {\n      _classCallCheck(this, Sidenav);\n\n      var _this31 = _possibleConstructorReturn(this, (Sidenav.__proto__ || Object.getPrototypeOf(Sidenav)).call(this, Sidenav, el, options));\n\n      _this31.el.M_Sidenav = _this31;\n      _this31.id = _this31.$el.attr('id');\n\n      /**\n       * Options for the Sidenav\n       * @member Sidenav#options\n       * @prop {String} [edge='left'] - Side of screen on which Sidenav appears\n       * @prop {Boolean} [draggable=true] - Allow swipe gestures to open/close Sidenav\n       * @prop {Number} [inDuration=250] - Length in ms of enter transition\n       * @prop {Number} [outDuration=200] - Length in ms of exit transition\n       * @prop {Function} onOpenStart - Function called when sidenav starts entering\n       * @prop {Function} onOpenEnd - Function called when sidenav finishes entering\n       * @prop {Function} onCloseStart - Function called when sidenav starts exiting\n       * @prop {Function} onCloseEnd - Function called when sidenav finishes exiting\n       */\n      _this31.options = $.extend({}, Sidenav.defaults, options);\n\n      /**\n       * Describes open/close state of Sidenav\n       * @type {Boolean}\n       */\n      _this31.isOpen = false;\n\n      /**\n       * Describes if Sidenav is fixed\n       * @type {Boolean}\n       */\n      _this31.isFixed = _this31.el.classList.contains('sidenav-fixed');\n\n      /**\n       * Describes if Sidenav is being draggeed\n       * @type {Boolean}\n       */\n      _this31.isDragged = false;\n\n      // Window size variables for window resize checks\n      _this31.lastWindowWidth = window.innerWidth;\n      _this31.lastWindowHeight = window.innerHeight;\n\n      _this31._createOverlay();\n      _this31._createDragTarget();\n      _this31._setupEventHandlers();\n      _this31._setupClasses();\n      _this31._setupFixed();\n\n      Sidenav._sidenavs.push(_this31);\n      return _this31;\n    }\n\n    _createClass(Sidenav, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this._enableBodyScrolling();\n        this._overlay.parentNode.removeChild(this._overlay);\n        this.dragTarget.parentNode.removeChild(this.dragTarget);\n        this.el.M_Sidenav = undefined;\n        this.el.style.transform = '';\n\n        var index = Sidenav._sidenavs.indexOf(this);\n        if (index >= 0) {\n          Sidenav._sidenavs.splice(index, 1);\n        }\n      }\n    }, {\n      key: \"_createOverlay\",\n      value: function _createOverlay() {\n        var overlay = document.createElement('div');\n        this._closeBound = this.close.bind(this);\n        overlay.classList.add('sidenav-overlay');\n\n        overlay.addEventListener('click', this._closeBound);\n\n        document.body.appendChild(overlay);\n        this._overlay = overlay;\n      }\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        if (Sidenav._sidenavs.length === 0) {\n          document.body.addEventListener('click', this._handleTriggerClick);\n        }\n\n        this._handleDragTargetDragBound = this._handleDragTargetDrag.bind(this);\n        this._handleDragTargetReleaseBound = this._handleDragTargetRelease.bind(this);\n        this._handleCloseDragBound = this._handleCloseDrag.bind(this);\n        this._handleCloseReleaseBound = this._handleCloseRelease.bind(this);\n        this._handleCloseTriggerClickBound = this._handleCloseTriggerClick.bind(this);\n\n        this.dragTarget.addEventListener('touchmove', this._handleDragTargetDragBound);\n        this.dragTarget.addEventListener('touchend', this._handleDragTargetReleaseBound);\n        this._overlay.addEventListener('touchmove', this._handleCloseDragBound);\n        this._overlay.addEventListener('touchend', this._handleCloseReleaseBound);\n        this.el.addEventListener('touchmove', this._handleCloseDragBound);\n        this.el.addEventListener('touchend', this._handleCloseReleaseBound);\n        this.el.addEventListener('click', this._handleCloseTriggerClickBound);\n\n        // Add resize for side nav fixed\n        if (this.isFixed) {\n          this._handleWindowResizeBound = this._handleWindowResize.bind(this);\n          window.addEventListener('resize', this._handleWindowResizeBound);\n        }\n      }\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        if (Sidenav._sidenavs.length === 1) {\n          document.body.removeEventListener('click', this._handleTriggerClick);\n        }\n\n        this.dragTarget.removeEventListener('touchmove', this._handleDragTargetDragBound);\n        this.dragTarget.removeEventListener('touchend', this._handleDragTargetReleaseBound);\n        this._overlay.removeEventListener('touchmove', this._handleCloseDragBound);\n        this._overlay.removeEventListener('touchend', this._handleCloseReleaseBound);\n        this.el.removeEventListener('touchmove', this._handleCloseDragBound);\n        this.el.removeEventListener('touchend', this._handleCloseReleaseBound);\n        this.el.removeEventListener('click', this._handleCloseTriggerClickBound);\n\n        // Remove resize for side nav fixed\n        if (this.isFixed) {\n          window.removeEventListener('resize', this._handleWindowResizeBound);\n        }\n      }\n\n      /**\n       * Handle Trigger Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleTriggerClick\",\n      value: function _handleTriggerClick(e) {\n        var $trigger = $(e.target).closest('.sidenav-trigger');\n        if (e.target && $trigger.length) {\n          var sidenavId = M.getIdFromTrigger($trigger[0]);\n\n          var sidenavInstance = document.getElementById(sidenavId).M_Sidenav;\n          if (sidenavInstance) {\n            sidenavInstance.open($trigger);\n          }\n          e.preventDefault();\n        }\n      }\n\n      /**\n       * Set variables needed at the beggining of drag\n       * and stop any current transition.\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_startDrag\",\n      value: function _startDrag(e) {\n        var clientX = e.targetTouches[0].clientX;\n        this.isDragged = true;\n        this._startingXpos = clientX;\n        this._xPos = this._startingXpos;\n        this._time = Date.now();\n        this._width = this.el.getBoundingClientRect().width;\n        this._overlay.style.display = 'block';\n        this._initialScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();\n        this._verticallyScrolling = false;\n        anim.remove(this.el);\n        anim.remove(this._overlay);\n      }\n\n      /**\n       * Set variables needed at each drag move update tick\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_dragMoveUpdate\",\n      value: function _dragMoveUpdate(e) {\n        var clientX = e.targetTouches[0].clientX;\n        var currentScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();\n        this.deltaX = Math.abs(this._xPos - clientX);\n        this._xPos = clientX;\n        this.velocityX = this.deltaX / (Date.now() - this._time);\n        this._time = Date.now();\n        if (this._initialScrollTop !== currentScrollTop) {\n          this._verticallyScrolling = true;\n        }\n      }\n\n      /**\n       * Handles Dragging of Sidenav\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleDragTargetDrag\",\n      value: function _handleDragTargetDrag(e) {\n        // Check if draggable\n        if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) {\n          return;\n        }\n\n        // If not being dragged, set initial drag start variables\n        if (!this.isDragged) {\n          this._startDrag(e);\n        }\n\n        // Run touchmove updates\n        this._dragMoveUpdate(e);\n\n        // Calculate raw deltaX\n        var totalDeltaX = this._xPos - this._startingXpos;\n\n        // dragDirection is the attempted user drag direction\n        var dragDirection = totalDeltaX > 0 ? 'right' : 'left';\n\n        // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction\n        totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));\n        if (this.options.edge === dragDirection) {\n          totalDeltaX = 0;\n        }\n\n        /**\n         * transformX is the drag displacement\n         * transformPrefix is the initial transform placement\n         * Invert values if Sidenav is right edge\n         */\n        var transformX = totalDeltaX;\n        var transformPrefix = 'translateX(-100%)';\n        if (this.options.edge === 'right') {\n          transformPrefix = 'translateX(100%)';\n          transformX = -transformX;\n        }\n\n        // Calculate open/close percentage of sidenav, with open = 1 and close = 0\n        this.percentOpen = Math.min(1, totalDeltaX / this._width);\n\n        // Set transform and opacity styles\n        this.el.style.transform = transformPrefix + \" translateX(\" + transformX + \"px)\";\n        this._overlay.style.opacity = this.percentOpen;\n      }\n\n      /**\n       * Handle Drag Target Release\n       */\n\n    }, {\n      key: \"_handleDragTargetRelease\",\n      value: function _handleDragTargetRelease() {\n        if (this.isDragged) {\n          if (this.percentOpen > 0.2) {\n            this.open();\n          } else {\n            this._animateOut();\n          }\n\n          this.isDragged = false;\n          this._verticallyScrolling = false;\n        }\n      }\n\n      /**\n       * Handle Close Drag\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCloseDrag\",\n      value: function _handleCloseDrag(e) {\n        if (this.isOpen) {\n          // Check if draggable\n          if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) {\n            return;\n          }\n\n          // If not being dragged, set initial drag start variables\n          if (!this.isDragged) {\n            this._startDrag(e);\n          }\n\n          // Run touchmove updates\n          this._dragMoveUpdate(e);\n\n          // Calculate raw deltaX\n          var totalDeltaX = this._xPos - this._startingXpos;\n\n          // dragDirection is the attempted user drag direction\n          var dragDirection = totalDeltaX > 0 ? 'right' : 'left';\n\n          // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction\n          totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));\n          if (this.options.edge !== dragDirection) {\n            totalDeltaX = 0;\n          }\n\n          var transformX = -totalDeltaX;\n          if (this.options.edge === 'right') {\n            transformX = -transformX;\n          }\n\n          // Calculate open/close percentage of sidenav, with open = 1 and close = 0\n          this.percentOpen = Math.min(1, 1 - totalDeltaX / this._width);\n\n          // Set transform and opacity styles\n          this.el.style.transform = \"translateX(\" + transformX + \"px)\";\n          this._overlay.style.opacity = this.percentOpen;\n        }\n      }\n\n      /**\n       * Handle Close Release\n       */\n\n    }, {\n      key: \"_handleCloseRelease\",\n      value: function _handleCloseRelease() {\n        if (this.isOpen && this.isDragged) {\n          if (this.percentOpen > 0.8) {\n            this._animateIn();\n          } else {\n            this.close();\n          }\n\n          this.isDragged = false;\n          this._verticallyScrolling = false;\n        }\n      }\n\n      /**\n       * Handles closing of Sidenav when element with class .sidenav-close\n       */\n\n    }, {\n      key: \"_handleCloseTriggerClick\",\n      value: function _handleCloseTriggerClick(e) {\n        var $closeTrigger = $(e.target).closest('.sidenav-close');\n        if ($closeTrigger.length && !this._isCurrentlyFixed()) {\n          this.close();\n        }\n      }\n\n      /**\n       * Handle Window Resize\n       */\n\n    }, {\n      key: \"_handleWindowResize\",\n      value: function _handleWindowResize() {\n        // Only handle horizontal resizes\n        if (this.lastWindowWidth !== window.innerWidth) {\n          if (window.innerWidth > 992) {\n            this.open();\n          } else {\n            this.close();\n          }\n        }\n\n        this.lastWindowWidth = window.innerWidth;\n        this.lastWindowHeight = window.innerHeight;\n      }\n    }, {\n      key: \"_setupClasses\",\n      value: function _setupClasses() {\n        if (this.options.edge === 'right') {\n          this.el.classList.add('right-aligned');\n          this.dragTarget.classList.add('right-aligned');\n        }\n      }\n    }, {\n      key: \"_removeClasses\",\n      value: function _removeClasses() {\n        this.el.classList.remove('right-aligned');\n        this.dragTarget.classList.remove('right-aligned');\n      }\n    }, {\n      key: \"_setupFixed\",\n      value: function _setupFixed() {\n        if (this._isCurrentlyFixed()) {\n          this.open();\n        }\n      }\n    }, {\n      key: \"_isCurrentlyFixed\",\n      value: function _isCurrentlyFixed() {\n        return this.isFixed && window.innerWidth > 992;\n      }\n    }, {\n      key: \"_createDragTarget\",\n      value: function _createDragTarget() {\n        var dragTarget = document.createElement('div');\n        dragTarget.classList.add('drag-target');\n        document.body.appendChild(dragTarget);\n        this.dragTarget = dragTarget;\n      }\n    }, {\n      key: \"_preventBodyScrolling\",\n      value: function _preventBodyScrolling() {\n        var body = document.body;\n        body.style.overflow = 'hidden';\n      }\n    }, {\n      key: \"_enableBodyScrolling\",\n      value: function _enableBodyScrolling() {\n        var body = document.body;\n        body.style.overflow = '';\n      }\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this.isOpen === true) {\n          return;\n        }\n\n        this.isOpen = true;\n\n        // Run onOpenStart callback\n        if (typeof this.options.onOpenStart === 'function') {\n          this.options.onOpenStart.call(this, this.el);\n        }\n\n        // Handle fixed Sidenav\n        if (this._isCurrentlyFixed()) {\n          anim.remove(this.el);\n          anim({\n            targets: this.el,\n            translateX: 0,\n            duration: 0,\n            easing: 'easeOutQuad'\n          });\n          this._enableBodyScrolling();\n          this._overlay.style.display = 'none';\n\n          // Handle non-fixed Sidenav\n        } else {\n          if (this.options.preventScrolling) {\n            this._preventBodyScrolling();\n          }\n\n          if (!this.isDragged || this.percentOpen != 1) {\n            this._animateIn();\n          }\n        }\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (this.isOpen === false) {\n          return;\n        }\n\n        this.isOpen = false;\n\n        // Run onCloseStart callback\n        if (typeof this.options.onCloseStart === 'function') {\n          this.options.onCloseStart.call(this, this.el);\n        }\n\n        // Handle fixed Sidenav\n        if (this._isCurrentlyFixed()) {\n          var transformX = this.options.edge === 'left' ? '-105%' : '105%';\n          this.el.style.transform = \"translateX(\" + transformX + \")\";\n\n          // Handle non-fixed Sidenav\n        } else {\n          this._enableBodyScrolling();\n\n          if (!this.isDragged || this.percentOpen != 0) {\n            this._animateOut();\n          } else {\n            this._overlay.style.display = 'none';\n          }\n        }\n      }\n    }, {\n      key: \"_animateIn\",\n      value: function _animateIn() {\n        this._animateSidenavIn();\n        this._animateOverlayIn();\n      }\n    }, {\n      key: \"_animateSidenavIn\",\n      value: function _animateSidenavIn() {\n        var _this32 = this;\n\n        var slideOutPercent = this.options.edge === 'left' ? -1 : 1;\n        if (this.isDragged) {\n          slideOutPercent = this.options.edge === 'left' ? slideOutPercent + this.percentOpen : slideOutPercent - this.percentOpen;\n        }\n\n        anim.remove(this.el);\n        anim({\n          targets: this.el,\n          translateX: [slideOutPercent * 100 + \"%\", 0],\n          duration: this.options.inDuration,\n          easing: 'easeOutQuad',\n          complete: function () {\n            // Run onOpenEnd callback\n            if (typeof _this32.options.onOpenEnd === 'function') {\n              _this32.options.onOpenEnd.call(_this32, _this32.el);\n            }\n          }\n        });\n      }\n    }, {\n      key: \"_animateOverlayIn\",\n      value: function _animateOverlayIn() {\n        var start = 0;\n        if (this.isDragged) {\n          start = this.percentOpen;\n        } else {\n          $(this._overlay).css({\n            display: 'block'\n          });\n        }\n\n        anim.remove(this._overlay);\n        anim({\n          targets: this._overlay,\n          opacity: [start, 1],\n          duration: this.options.inDuration,\n          easing: 'easeOutQuad'\n        });\n      }\n    }, {\n      key: \"_animateOut\",\n      value: function _animateOut() {\n        this._animateSidenavOut();\n        this._animateOverlayOut();\n      }\n    }, {\n      key: \"_animateSidenavOut\",\n      value: function _animateSidenavOut() {\n        var _this33 = this;\n\n        var endPercent = this.options.edge === 'left' ? -1 : 1;\n        var slideOutPercent = 0;\n        if (this.isDragged) {\n          slideOutPercent = this.options.edge === 'left' ? endPercent + this.percentOpen : endPercent - this.percentOpen;\n        }\n\n        anim.remove(this.el);\n        anim({\n          targets: this.el,\n          translateX: [slideOutPercent * 100 + \"%\", endPercent * 105 + \"%\"],\n          duration: this.options.outDuration,\n          easing: 'easeOutQuad',\n          complete: function () {\n            // Run onOpenEnd callback\n            if (typeof _this33.options.onCloseEnd === 'function') {\n              _this33.options.onCloseEnd.call(_this33, _this33.el);\n            }\n          }\n        });\n      }\n    }, {\n      key: \"_animateOverlayOut\",\n      value: function _animateOverlayOut() {\n        var _this34 = this;\n\n        anim.remove(this._overlay);\n        anim({\n          targets: this._overlay,\n          opacity: 0,\n          duration: this.options.outDuration,\n          easing: 'easeOutQuad',\n          complete: function () {\n            $(_this34._overlay).css('display', 'none');\n          }\n        });\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Sidenav.__proto__ || Object.getPrototypeOf(Sidenav), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Sidenav;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Sidenav;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Sidenav\n   * @type {Array.<Sidenav>}\n   */\n\n\n  Sidenav._sidenavs = [];\n\n  window.M.Sidenav = Sidenav;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Sidenav, 'sidenav', 'M_Sidenav');\n  }\n})(cash, M.anime);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    throttle: 100,\n    scrollOffset: 200, // offset - 200 allows elements near bottom of page to scroll\n    activeClass: 'active',\n    getActiveElement: function (id) {\n      return 'a[href=\"#' + id + '\"]';\n    }\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var ScrollSpy = function (_Component9) {\n    _inherits(ScrollSpy, _Component9);\n\n    /**\n     * Construct ScrollSpy instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function ScrollSpy(el, options) {\n      _classCallCheck(this, ScrollSpy);\n\n      var _this35 = _possibleConstructorReturn(this, (ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy)).call(this, ScrollSpy, el, options));\n\n      _this35.el.M_ScrollSpy = _this35;\n\n      /**\n       * Options for the modal\n       * @member Modal#options\n       * @prop {Number} [throttle=100] - Throttle of scroll handler\n       * @prop {Number} [scrollOffset=200] - Offset for centering element when scrolled to\n       * @prop {String} [activeClass='active'] - Class applied to active elements\n       * @prop {Function} [getActiveElement] - Used to find active element\n       */\n      _this35.options = $.extend({}, ScrollSpy.defaults, options);\n\n      // setup\n      ScrollSpy._elements.push(_this35);\n      ScrollSpy._count++;\n      ScrollSpy._increment++;\n      _this35.tickId = -1;\n      _this35.id = ScrollSpy._increment;\n      _this35._setupEventHandlers();\n      _this35._handleWindowScroll();\n      return _this35;\n    }\n\n    _createClass(ScrollSpy, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        ScrollSpy._elements.splice(ScrollSpy._elements.indexOf(this), 1);\n        ScrollSpy._elementsInView.splice(ScrollSpy._elementsInView.indexOf(this), 1);\n        ScrollSpy._visibleElements.splice(ScrollSpy._visibleElements.indexOf(this.$el), 1);\n        ScrollSpy._count--;\n        this._removeEventHandlers();\n        $(this.options.getActiveElement(this.$el.attr('id'))).removeClass(this.options.activeClass);\n        this.el.M_ScrollSpy = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        var throttledResize = M.throttle(this._handleWindowScroll, 200);\n        this._handleThrottledResizeBound = throttledResize.bind(this);\n        this._handleWindowScrollBound = this._handleWindowScroll.bind(this);\n        if (ScrollSpy._count === 1) {\n          window.addEventListener('scroll', this._handleWindowScrollBound);\n          window.addEventListener('resize', this._handleThrottledResizeBound);\n          document.body.addEventListener('click', this._handleTriggerClick);\n        }\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        if (ScrollSpy._count === 0) {\n          window.removeEventListener('scroll', this._handleWindowScrollBound);\n          window.removeEventListener('resize', this._handleThrottledResizeBound);\n          document.body.removeEventListener('click', this._handleTriggerClick);\n        }\n      }\n\n      /**\n       * Handle Trigger Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleTriggerClick\",\n      value: function _handleTriggerClick(e) {\n        var $trigger = $(e.target);\n        for (var i = ScrollSpy._elements.length - 1; i >= 0; i--) {\n          var scrollspy = ScrollSpy._elements[i];\n          if ($trigger.is('a[href=\"#' + scrollspy.$el.attr('id') + '\"]')) {\n            e.preventDefault();\n            var offset = scrollspy.$el.offset().top + 1;\n\n            anim({\n              targets: [document.documentElement, document.body],\n              scrollTop: offset - scrollspy.options.scrollOffset,\n              duration: 400,\n              easing: 'easeOutCubic'\n            });\n            break;\n          }\n        }\n      }\n\n      /**\n       * Handle Window Scroll\n       */\n\n    }, {\n      key: \"_handleWindowScroll\",\n      value: function _handleWindowScroll() {\n        // unique tick id\n        ScrollSpy._ticks++;\n\n        // viewport rectangle\n        var top = M.getDocumentScrollTop(),\n            left = M.getDocumentScrollLeft(),\n            right = left + window.innerWidth,\n            bottom = top + window.innerHeight;\n\n        // determine which elements are in view\n        var intersections = ScrollSpy._findElements(top, right, bottom, left);\n        for (var i = 0; i < intersections.length; i++) {\n          var scrollspy = intersections[i];\n          var lastTick = scrollspy.tickId;\n          if (lastTick < 0) {\n            // entered into view\n            scrollspy._enter();\n          }\n\n          // update tick id\n          scrollspy.tickId = ScrollSpy._ticks;\n        }\n\n        for (var _i = 0; _i < ScrollSpy._elementsInView.length; _i++) {\n          var _scrollspy = ScrollSpy._elementsInView[_i];\n          var _lastTick = _scrollspy.tickId;\n          if (_lastTick >= 0 && _lastTick !== ScrollSpy._ticks) {\n            // exited from view\n            _scrollspy._exit();\n            _scrollspy.tickId = -1;\n          }\n        }\n\n        // remember elements in view for next tick\n        ScrollSpy._elementsInView = intersections;\n      }\n\n      /**\n       * Find elements that are within the boundary\n       * @param {number} top\n       * @param {number} right\n       * @param {number} bottom\n       * @param {number} left\n       * @return {Array.<ScrollSpy>}   A collection of elements\n       */\n\n    }, {\n      key: \"_enter\",\n      value: function _enter() {\n        ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (value) {\n          return value.height() != 0;\n        });\n\n        if (ScrollSpy._visibleElements[0]) {\n          $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);\n          if (ScrollSpy._visibleElements[0][0].M_ScrollSpy && this.id < ScrollSpy._visibleElements[0][0].M_ScrollSpy.id) {\n            ScrollSpy._visibleElements.unshift(this.$el);\n          } else {\n            ScrollSpy._visibleElements.push(this.$el);\n          }\n        } else {\n          ScrollSpy._visibleElements.push(this.$el);\n        }\n\n        $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);\n      }\n    }, {\n      key: \"_exit\",\n      value: function _exit() {\n        var _this36 = this;\n\n        ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (value) {\n          return value.height() != 0;\n        });\n\n        if (ScrollSpy._visibleElements[0]) {\n          $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);\n\n          ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (el) {\n            return el.attr('id') != _this36.$el.attr('id');\n          });\n          if (ScrollSpy._visibleElements[0]) {\n            // Check if empty\n            $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);\n          }\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_ScrollSpy;\n      }\n    }, {\n      key: \"_findElements\",\n      value: function _findElements(top, right, bottom, left) {\n        var hits = [];\n        for (var i = 0; i < ScrollSpy._elements.length; i++) {\n          var scrollspy = ScrollSpy._elements[i];\n          var currTop = top + scrollspy.options.scrollOffset || 200;\n\n          if (scrollspy.$el.height() > 0) {\n            var elTop = scrollspy.$el.offset().top,\n                elLeft = scrollspy.$el.offset().left,\n                elRight = elLeft + scrollspy.$el.width(),\n                elBottom = elTop + scrollspy.$el.height();\n\n            var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < currTop);\n\n            if (isIntersect) {\n              hits.push(scrollspy);\n            }\n          }\n        }\n        return hits;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return ScrollSpy;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof ScrollSpy\n   * @type {Array.<ScrollSpy>}\n   */\n\n\n  ScrollSpy._elements = [];\n\n  /**\n   * @static\n   * @memberof ScrollSpy\n   * @type {Array.<ScrollSpy>}\n   */\n  ScrollSpy._elementsInView = [];\n\n  /**\n   * @static\n   * @memberof ScrollSpy\n   * @type {Array.<cash>}\n   */\n  ScrollSpy._visibleElements = [];\n\n  /**\n   * @static\n   * @memberof ScrollSpy\n   */\n  ScrollSpy._count = 0;\n\n  /**\n   * @static\n   * @memberof ScrollSpy\n   */\n  ScrollSpy._increment = 0;\n\n  /**\n   * @static\n   * @memberof ScrollSpy\n   */\n  ScrollSpy._ticks = 0;\n\n  M.ScrollSpy = ScrollSpy;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(ScrollSpy, 'scrollSpy', 'M_ScrollSpy');\n  }\n})(cash, M.anime);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    data: {}, // Autocomplete data set\n    limit: Infinity, // Limit of results the autocomplete shows\n    onAutocomplete: null, // Callback for when autocompleted\n    minLength: 1, // Min characters before autocomplete starts\n    sortFunction: function (a, b, inputString) {\n      // Sort function for sorting autocomplete results\n      return a.indexOf(inputString) - b.indexOf(inputString);\n    }\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Autocomplete = function (_Component10) {\n    _inherits(Autocomplete, _Component10);\n\n    /**\n     * Construct Autocomplete instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Autocomplete(el, options) {\n      _classCallCheck(this, Autocomplete);\n\n      var _this37 = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, Autocomplete, el, options));\n\n      _this37.el.M_Autocomplete = _this37;\n\n      /**\n       * Options for the autocomplete\n       * @member Autocomplete#options\n       * @prop {Number} duration\n       * @prop {Number} dist\n       * @prop {number} shift\n       * @prop {number} padding\n       * @prop {Boolean} fullWidth\n       * @prop {Boolean} indicators\n       * @prop {Boolean} noWrap\n       * @prop {Function} onCycleTo\n       */\n      _this37.options = $.extend({}, Autocomplete.defaults, options);\n\n      // Setup\n      _this37.isOpen = false;\n      _this37.count = 0;\n      _this37.activeIndex = -1;\n      _this37.oldVal;\n      _this37.$inputField = _this37.$el.closest('.input-field');\n      _this37.$active = $();\n      _this37._mousedown = false;\n      _this37._setupDropdown();\n\n      _this37._setupEventHandlers();\n      return _this37;\n    }\n\n    _createClass(Autocomplete, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this._removeDropdown();\n        this.el.M_Autocomplete = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleInputBlurBound = this._handleInputBlur.bind(this);\n        this._handleInputKeyupAndFocusBound = this._handleInputKeyupAndFocus.bind(this);\n        this._handleInputKeydownBound = this._handleInputKeydown.bind(this);\n        this._handleInputClickBound = this._handleInputClick.bind(this);\n        this._handleContainerMousedownAndTouchstartBound = this._handleContainerMousedownAndTouchstart.bind(this);\n        this._handleContainerMouseupAndTouchendBound = this._handleContainerMouseupAndTouchend.bind(this);\n\n        this.el.addEventListener('blur', this._handleInputBlurBound);\n        this.el.addEventListener('keyup', this._handleInputKeyupAndFocusBound);\n        this.el.addEventListener('focus', this._handleInputKeyupAndFocusBound);\n        this.el.addEventListener('keydown', this._handleInputKeydownBound);\n        this.el.addEventListener('click', this._handleInputClickBound);\n        this.container.addEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);\n        this.container.addEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);\n\n        if (typeof window.ontouchstart !== 'undefined') {\n          this.container.addEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);\n          this.container.addEventListener('touchend', this._handleContainerMouseupAndTouchendBound);\n        }\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('blur', this._handleInputBlurBound);\n        this.el.removeEventListener('keyup', this._handleInputKeyupAndFocusBound);\n        this.el.removeEventListener('focus', this._handleInputKeyupAndFocusBound);\n        this.el.removeEventListener('keydown', this._handleInputKeydownBound);\n        this.el.removeEventListener('click', this._handleInputClickBound);\n        this.container.removeEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);\n        this.container.removeEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);\n\n        if (typeof window.ontouchstart !== 'undefined') {\n          this.container.removeEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);\n          this.container.removeEventListener('touchend', this._handleContainerMouseupAndTouchendBound);\n        }\n      }\n\n      /**\n       * Setup dropdown\n       */\n\n    }, {\n      key: \"_setupDropdown\",\n      value: function _setupDropdown() {\n        var _this38 = this;\n\n        this.container = document.createElement('ul');\n        this.container.id = \"autocomplete-options-\" + M.guid();\n        $(this.container).addClass('autocomplete-content dropdown-content');\n        this.$inputField.append(this.container);\n        this.el.setAttribute('data-target', this.container.id);\n\n        this.dropdown = M.Dropdown.init(this.el, {\n          autoFocus: false,\n          closeOnClick: false,\n          coverTrigger: false,\n          onItemClick: function (itemEl) {\n            _this38.selectOption($(itemEl));\n          }\n        });\n\n        // Sketchy removal of dropdown click handler\n        this.el.removeEventListener('click', this.dropdown._handleClickBound);\n      }\n\n      /**\n       * Remove dropdown\n       */\n\n    }, {\n      key: \"_removeDropdown\",\n      value: function _removeDropdown() {\n        this.container.parentNode.removeChild(this.container);\n      }\n\n      /**\n       * Handle Input Blur\n       */\n\n    }, {\n      key: \"_handleInputBlur\",\n      value: function _handleInputBlur() {\n        if (!this._mousedown) {\n          this.close();\n          this._resetAutocomplete();\n        }\n      }\n\n      /**\n       * Handle Input Keyup and Focus\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleInputKeyupAndFocus\",\n      value: function _handleInputKeyupAndFocus(e) {\n        if (e.type === 'keyup') {\n          Autocomplete._keydown = false;\n        }\n\n        this.count = 0;\n        var val = this.el.value.toLowerCase();\n\n        // Don't capture enter or arrow key usage.\n        if (e.keyCode === 13 || e.keyCode === 38 || e.keyCode === 40) {\n          return;\n        }\n\n        // Check if the input isn't empty\n        // Check if focus triggered by tab\n        if (this.oldVal !== val && (M.tabPressed || e.type !== 'focus')) {\n          this.open();\n        }\n\n        // Update oldVal\n        this.oldVal = val;\n      }\n\n      /**\n       * Handle Input Keydown\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleInputKeydown\",\n      value: function _handleInputKeydown(e) {\n        Autocomplete._keydown = true;\n\n        // Arrow keys and enter key usage\n        var keyCode = e.keyCode,\n            liElement = void 0,\n            numItems = $(this.container).children('li').length;\n\n        // select element on Enter\n        if (keyCode === M.keys.ENTER && this.activeIndex >= 0) {\n          liElement = $(this.container).children('li').eq(this.activeIndex);\n          if (liElement.length) {\n            this.selectOption(liElement);\n            e.preventDefault();\n          }\n          return;\n        }\n\n        // Capture up and down key\n        if (keyCode === M.keys.ARROW_UP || keyCode === M.keys.ARROW_DOWN) {\n          e.preventDefault();\n\n          if (keyCode === M.keys.ARROW_UP && this.activeIndex > 0) {\n            this.activeIndex--;\n          }\n\n          if (keyCode === M.keys.ARROW_DOWN && this.activeIndex < numItems - 1) {\n            this.activeIndex++;\n          }\n\n          this.$active.removeClass('active');\n          if (this.activeIndex >= 0) {\n            this.$active = $(this.container).children('li').eq(this.activeIndex);\n            this.$active.addClass('active');\n          }\n        }\n      }\n\n      /**\n       * Handle Input Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleInputClick\",\n      value: function _handleInputClick(e) {\n        this.open();\n      }\n\n      /**\n       * Handle Container Mousedown and Touchstart\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleContainerMousedownAndTouchstart\",\n      value: function _handleContainerMousedownAndTouchstart(e) {\n        this._mousedown = true;\n      }\n\n      /**\n       * Handle Container Mouseup and Touchend\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleContainerMouseupAndTouchend\",\n      value: function _handleContainerMouseupAndTouchend(e) {\n        this._mousedown = false;\n      }\n\n      /**\n       * Highlight partial match\n       */\n\n    }, {\n      key: \"_highlight\",\n      value: function _highlight(string, $el) {\n        var img = $el.find('img');\n        var matchStart = $el.text().toLowerCase().indexOf('' + string.toLowerCase() + ''),\n            matchEnd = matchStart + string.length - 1,\n            beforeMatch = $el.text().slice(0, matchStart),\n            matchText = $el.text().slice(matchStart, matchEnd + 1),\n            afterMatch = $el.text().slice(matchEnd + 1);\n        $el.html(\"<span>\" + beforeMatch + \"<span class='highlight'>\" + matchText + \"</span>\" + afterMatch + \"</span>\");\n        if (img.length) {\n          $el.prepend(img);\n        }\n      }\n\n      /**\n       * Reset current element position\n       */\n\n    }, {\n      key: \"_resetCurrentElement\",\n      value: function _resetCurrentElement() {\n        this.activeIndex = -1;\n        this.$active.removeClass('active');\n      }\n\n      /**\n       * Reset autocomplete elements\n       */\n\n    }, {\n      key: \"_resetAutocomplete\",\n      value: function _resetAutocomplete() {\n        $(this.container).empty();\n        this._resetCurrentElement();\n        this.oldVal = null;\n        this.isOpen = false;\n        this._mousedown = false;\n      }\n\n      /**\n       * Select autocomplete option\n       * @param {Element} el  Autocomplete option list item element\n       */\n\n    }, {\n      key: \"selectOption\",\n      value: function selectOption(el) {\n        var text = el.text().trim();\n        this.el.value = text;\n        this.$el.trigger('change');\n        this._resetAutocomplete();\n        this.close();\n\n        // Handle onAutocomplete callback.\n        if (typeof this.options.onAutocomplete === 'function') {\n          this.options.onAutocomplete.call(this, text);\n        }\n      }\n\n      /**\n       * Render dropdown content\n       * @param {Object} data  data set\n       * @param {String} val  current input value\n       */\n\n    }, {\n      key: \"_renderDropdown\",\n      value: function _renderDropdown(data, val) {\n        var _this39 = this;\n\n        this._resetAutocomplete();\n\n        var matchingData = [];\n\n        // Gather all matching data\n        for (var key in data) {\n          if (data.hasOwnProperty(key) && key.toLowerCase().indexOf(val) !== -1) {\n            // Break if past limit\n            if (this.count >= this.options.limit) {\n              break;\n            }\n\n            var entry = {\n              data: data[key],\n              key: key\n            };\n            matchingData.push(entry);\n\n            this.count++;\n          }\n        }\n\n        // Sort\n        if (this.options.sortFunction) {\n          var sortFunctionBound = function (a, b) {\n            return _this39.options.sortFunction(a.key.toLowerCase(), b.key.toLowerCase(), val.toLowerCase());\n          };\n          matchingData.sort(sortFunctionBound);\n        }\n\n        // Render\n        for (var i = 0; i < matchingData.length; i++) {\n          var _entry = matchingData[i];\n          var $autocompleteOption = $('<li></li>');\n          if (!!_entry.data) {\n            $autocompleteOption.append(\"<img src=\\\"\" + _entry.data + \"\\\" class=\\\"right circle\\\"><span>\" + _entry.key + \"</span>\");\n          } else {\n            $autocompleteOption.append('<span>' + _entry.key + '</span>');\n          }\n\n          $(this.container).append($autocompleteOption);\n          this._highlight(val, $autocompleteOption);\n        }\n      }\n\n      /**\n       * Open Autocomplete Dropdown\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        var val = this.el.value.toLowerCase();\n\n        this._resetAutocomplete();\n\n        if (val.length >= this.options.minLength) {\n          this.isOpen = true;\n          this._renderDropdown(this.options.data, val);\n        }\n\n        // Open dropdown\n        if (!this.dropdown.isOpen) {\n          this.dropdown.open();\n        } else {\n          // Recalculate dropdown when its already open\n          this.dropdown.recalculateDimensions();\n        }\n      }\n\n      /**\n       * Close Autocomplete Dropdown\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        this.dropdown.close();\n      }\n\n      /**\n       * Update Data\n       * @param {Object} data\n       */\n\n    }, {\n      key: \"updateData\",\n      value: function updateData(data) {\n        var val = this.el.value.toLowerCase();\n        this.options.data = data;\n\n        if (this.isOpen) {\n          this._renderDropdown(data, val);\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Autocomplete;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Autocomplete;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Autocomplete\n   */\n\n\n  Autocomplete._keydown = false;\n\n  M.Autocomplete = Autocomplete;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Autocomplete, 'autocomplete', 'M_Autocomplete');\n  }\n})(cash);\n;(function ($) {\n  // Function to update labels of text fields\n  M.updateTextFields = function () {\n    var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';\n    $(input_selector).each(function (element, index) {\n      var $this = $(this);\n      if (element.value.length > 0 || $(element).is(':focus') || element.autofocus || $this.attr('placeholder') !== null) {\n        $this.siblings('label').addClass('active');\n      } else if (element.validity) {\n        $this.siblings('label').toggleClass('active', element.validity.badInput === true);\n      } else {\n        $this.siblings('label').removeClass('active');\n      }\n    });\n  };\n\n  M.validate_field = function (object) {\n    var hasLength = object.attr('data-length') !== null;\n    var lenAttr = parseInt(object.attr('data-length'));\n    var len = object[0].value.length;\n\n    if (len === 0 && object[0].validity.badInput === false && !object.is(':required')) {\n      if (object.hasClass('validate')) {\n        object.removeClass('valid');\n        object.removeClass('invalid');\n      }\n    } else {\n      if (object.hasClass('validate')) {\n        // Check for character counter attributes\n        if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {\n          object.removeClass('invalid');\n          object.addClass('valid');\n        } else {\n          object.removeClass('valid');\n          object.addClass('invalid');\n        }\n      }\n    }\n  };\n\n  M.textareaAutoResize = function ($textarea) {\n    // Wrap if native element\n    if ($textarea instanceof Element) {\n      $textarea = $($textarea);\n    }\n\n    if (!$textarea.length) {\n      console.error('No textarea element found');\n      return;\n    }\n\n    // Textarea Auto Resize\n    var hiddenDiv = $('.hiddendiv').first();\n    if (!hiddenDiv.length) {\n      hiddenDiv = $('<div class=\"hiddendiv common\"></div>');\n      $('body').append(hiddenDiv);\n    }\n\n    // Set font properties of hiddenDiv\n    var fontFamily = $textarea.css('font-family');\n    var fontSize = $textarea.css('font-size');\n    var lineHeight = $textarea.css('line-height');\n\n    // Firefox can't handle padding shorthand.\n    var paddingTop = $textarea.css('padding-top');\n    var paddingRight = $textarea.css('padding-right');\n    var paddingBottom = $textarea.css('padding-bottom');\n    var paddingLeft = $textarea.css('padding-left');\n\n    if (fontSize) {\n      hiddenDiv.css('font-size', fontSize);\n    }\n    if (fontFamily) {\n      hiddenDiv.css('font-family', fontFamily);\n    }\n    if (lineHeight) {\n      hiddenDiv.css('line-height', lineHeight);\n    }\n    if (paddingTop) {\n      hiddenDiv.css('padding-top', paddingTop);\n    }\n    if (paddingRight) {\n      hiddenDiv.css('padding-right', paddingRight);\n    }\n    if (paddingBottom) {\n      hiddenDiv.css('padding-bottom', paddingBottom);\n    }\n    if (paddingLeft) {\n      hiddenDiv.css('padding-left', paddingLeft);\n    }\n\n    // Set original-height, if none\n    if (!$textarea.data('original-height')) {\n      $textarea.data('original-height', $textarea.height());\n    }\n\n    if ($textarea.attr('wrap') === 'off') {\n      hiddenDiv.css('overflow-wrap', 'normal').css('white-space', 'pre');\n    }\n\n    hiddenDiv.text($textarea[0].value + '\\n');\n    var content = hiddenDiv.html().replace(/\\n/g, '<br>');\n    hiddenDiv.html(content);\n\n    // When textarea is hidden, width goes crazy.\n    // Approximate with half of window size\n\n    if ($textarea[0].offsetWidth > 0 && $textarea[0].offsetHeight > 0) {\n      hiddenDiv.css('width', $textarea.width() + 'px');\n    } else {\n      hiddenDiv.css('width', window.innerWidth / 2 + 'px');\n    }\n\n    /**\n     * Resize if the new height is greater than the\n     * original height of the textarea\n     */\n    if ($textarea.data('original-height') <= hiddenDiv.innerHeight()) {\n      $textarea.css('height', hiddenDiv.innerHeight() + 'px');\n    } else if ($textarea[0].value.length < $textarea.data('previous-length')) {\n      /**\n       * In case the new height is less than original height, it\n       * means the textarea has less text than before\n       * So we set the height to the original one\n       */\n      $textarea.css('height', $textarea.data('original-height') + 'px');\n    }\n    $textarea.data('previous-length', $textarea[0].value.length);\n  };\n\n  $(document).ready(function () {\n    // Text based inputs\n    var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';\n\n    // Add active if form auto complete\n    $(document).on('change', input_selector, function () {\n      if (this.value.length !== 0 || $(this).attr('placeholder') !== null) {\n        $(this).siblings('label').addClass('active');\n      }\n      M.validate_field($(this));\n    });\n\n    // Add active if input element has been pre-populated on document ready\n    $(document).ready(function () {\n      M.updateTextFields();\n    });\n\n    // HTML DOM FORM RESET handling\n    $(document).on('reset', function (e) {\n      var formReset = $(e.target);\n      if (formReset.is('form')) {\n        formReset.find(input_selector).removeClass('valid').removeClass('invalid');\n        formReset.find(input_selector).each(function (e) {\n          if (this.value.length) {\n            $(this).siblings('label').removeClass('active');\n          }\n        });\n\n        // Reset select (after native reset)\n        setTimeout(function () {\n          formReset.find('select').each(function () {\n            // check if initialized\n            if (this.M_FormSelect) {\n              $(this).trigger('change');\n            }\n          });\n        }, 0);\n      }\n    });\n\n    /**\n     * Add active when element has focus\n     * @param {Event} e\n     */\n    document.addEventListener('focus', function (e) {\n      if ($(e.target).is(input_selector)) {\n        $(e.target).siblings('label, .prefix').addClass('active');\n      }\n    }, true);\n\n    /**\n     * Remove active when element is blurred\n     * @param {Event} e\n     */\n    document.addEventListener('blur', function (e) {\n      var $inputElement = $(e.target);\n      if ($inputElement.is(input_selector)) {\n        var selector = '.prefix';\n\n        if ($inputElement[0].value.length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === null) {\n          selector += ', label';\n        }\n        $inputElement.siblings(selector).removeClass('active');\n        M.validate_field($inputElement);\n      }\n    }, true);\n\n    // Radio and Checkbox focus class\n    var radio_checkbox = 'input[type=radio], input[type=checkbox]';\n    $(document).on('keyup', radio_checkbox, function (e) {\n      // TAB, check if tabbing to radio or checkbox.\n      if (e.which === M.keys.TAB) {\n        $(this).addClass('tabbed');\n        var $this = $(this);\n        $this.one('blur', function (e) {\n          $(this).removeClass('tabbed');\n        });\n        return;\n      }\n    });\n\n    var text_area_selector = '.materialize-textarea';\n    $(text_area_selector).each(function () {\n      var $textarea = $(this);\n      /**\n       * Resize textarea on document load after storing\n       * the original height and the original length\n       */\n      $textarea.data('original-height', $textarea.height());\n      $textarea.data('previous-length', this.value.length);\n      M.textareaAutoResize($textarea);\n    });\n\n    $(document).on('keyup', text_area_selector, function () {\n      M.textareaAutoResize($(this));\n    });\n    $(document).on('keydown', text_area_selector, function () {\n      M.textareaAutoResize($(this));\n    });\n\n    // File Input Path\n    $(document).on('change', '.file-field input[type=\"file\"]', function () {\n      var file_field = $(this).closest('.file-field');\n      var path_input = file_field.find('input.file-path');\n      var files = $(this)[0].files;\n      var file_names = [];\n      for (var i = 0; i < files.length; i++) {\n        file_names.push(files[i].name);\n      }\n      path_input[0].value = file_names.join(', ');\n      path_input.trigger('change');\n    });\n  }); // End of $(document).ready\n})(cash);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    indicators: true,\n    height: 400,\n    duration: 500,\n    interval: 6000\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Slider = function (_Component11) {\n    _inherits(Slider, _Component11);\n\n    /**\n     * Construct Slider instance and set up overlay\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Slider(el, options) {\n      _classCallCheck(this, Slider);\n\n      var _this40 = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, Slider, el, options));\n\n      _this40.el.M_Slider = _this40;\n\n      /**\n       * Options for the modal\n       * @member Slider#options\n       * @prop {Boolean} [indicators=true] - Show indicators\n       * @prop {Number} [height=400] - height of slider\n       * @prop {Number} [duration=500] - Length in ms of slide transition\n       * @prop {Number} [interval=6000] - Length in ms of slide interval\n       */\n      _this40.options = $.extend({}, Slider.defaults, options);\n\n      // setup\n      _this40.$slider = _this40.$el.find('.slides');\n      _this40.$slides = _this40.$slider.children('li');\n      _this40.activeIndex = _this40.$slides.filter(function (item) {\n        return $(item).hasClass('active');\n      }).first().index();\n      if (_this40.activeIndex != -1) {\n        _this40.$active = _this40.$slides.eq(_this40.activeIndex);\n      }\n\n      _this40._setSliderHeight();\n\n      // Set initial positions of captions\n      _this40.$slides.find('.caption').each(function (el) {\n        _this40._animateCaptionIn(el, 0);\n      });\n\n      // Move img src into background-image\n      _this40.$slides.find('img').each(function (el) {\n        var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n        if ($(el).attr('src') !== placeholderBase64) {\n          $(el).css('background-image', 'url(\"' + $(el).attr('src') + '\")');\n          $(el).attr('src', placeholderBase64);\n        }\n      });\n\n      _this40._setupIndicators();\n\n      // Show active slide\n      if (_this40.$active) {\n        _this40.$active.css('display', 'block');\n      } else {\n        _this40.$slides.first().addClass('active');\n        anim({\n          targets: _this40.$slides.first()[0],\n          opacity: 1,\n          duration: _this40.options.duration,\n          easing: 'easeOutQuad'\n        });\n\n        _this40.activeIndex = 0;\n        _this40.$active = _this40.$slides.eq(_this40.activeIndex);\n\n        // Update indicators\n        if (_this40.options.indicators) {\n          _this40.$indicators.eq(_this40.activeIndex).addClass('active');\n        }\n      }\n\n      // Adjust height to current slide\n      _this40.$active.find('img').each(function (el) {\n        anim({\n          targets: _this40.$active.find('.caption')[0],\n          opacity: 1,\n          translateX: 0,\n          translateY: 0,\n          duration: _this40.options.duration,\n          easing: 'easeOutQuad'\n        });\n      });\n\n      _this40._setupEventHandlers();\n\n      // auto scroll\n      _this40.start();\n      return _this40;\n    }\n\n    _createClass(Slider, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this.pause();\n        this._removeIndicators();\n        this._removeEventHandlers();\n        this.el.M_Slider = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        var _this41 = this;\n\n        this._handleIntervalBound = this._handleInterval.bind(this);\n        this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);\n\n        if (this.options.indicators) {\n          this.$indicators.each(function (el) {\n            el.addEventListener('click', _this41._handleIndicatorClickBound);\n          });\n        }\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        var _this42 = this;\n\n        if (this.options.indicators) {\n          this.$indicators.each(function (el) {\n            el.removeEventListener('click', _this42._handleIndicatorClickBound);\n          });\n        }\n      }\n\n      /**\n       * Handle indicator click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleIndicatorClick\",\n      value: function _handleIndicatorClick(e) {\n        var currIndex = $(e.target).index();\n        this.set(currIndex);\n      }\n\n      /**\n       * Handle Interval\n       */\n\n    }, {\n      key: \"_handleInterval\",\n      value: function _handleInterval() {\n        var newActiveIndex = this.$slider.find('.active').index();\n        if (this.$slides.length === newActiveIndex + 1) newActiveIndex = 0;\n        // loop to start\n        else newActiveIndex += 1;\n\n        this.set(newActiveIndex);\n      }\n\n      /**\n       * Animate in caption\n       * @param {Element} caption\n       * @param {Number} duration\n       */\n\n    }, {\n      key: \"_animateCaptionIn\",\n      value: function _animateCaptionIn(caption, duration) {\n        var animOptions = {\n          targets: caption,\n          opacity: 0,\n          duration: duration,\n          easing: 'easeOutQuad'\n        };\n\n        if ($(caption).hasClass('center-align')) {\n          animOptions.translateY = -100;\n        } else if ($(caption).hasClass('right-align')) {\n          animOptions.translateX = 100;\n        } else if ($(caption).hasClass('left-align')) {\n          animOptions.translateX = -100;\n        }\n\n        anim(animOptions);\n      }\n\n      /**\n       * Set height of slider\n       */\n\n    }, {\n      key: \"_setSliderHeight\",\n      value: function _setSliderHeight() {\n        // If fullscreen, do nothing\n        if (!this.$el.hasClass('fullscreen')) {\n          if (this.options.indicators) {\n            // Add height if indicators are present\n            this.$el.css('height', this.options.height + 40 + 'px');\n          } else {\n            this.$el.css('height', this.options.height + 'px');\n          }\n          this.$slider.css('height', this.options.height + 'px');\n        }\n      }\n\n      /**\n       * Setup indicators\n       */\n\n    }, {\n      key: \"_setupIndicators\",\n      value: function _setupIndicators() {\n        var _this43 = this;\n\n        if (this.options.indicators) {\n          this.$indicators = $('<ul class=\"indicators\"></ul>');\n          this.$slides.each(function (el, index) {\n            var $indicator = $('<li class=\"indicator-item\"></li>');\n            _this43.$indicators.append($indicator[0]);\n          });\n          this.$el.append(this.$indicators[0]);\n          this.$indicators = this.$indicators.children('li.indicator-item');\n        }\n      }\n\n      /**\n       * Remove indicators\n       */\n\n    }, {\n      key: \"_removeIndicators\",\n      value: function _removeIndicators() {\n        this.$el.find('ul.indicators').remove();\n      }\n\n      /**\n       * Cycle to nth item\n       * @param {Number} index\n       */\n\n    }, {\n      key: \"set\",\n      value: function set(index) {\n        var _this44 = this;\n\n        // Wrap around indices.\n        if (index >= this.$slides.length) index = 0;else if (index < 0) index = this.$slides.length - 1;\n\n        // Only do if index changes\n        if (this.activeIndex != index) {\n          this.$active = this.$slides.eq(this.activeIndex);\n          var $caption = this.$active.find('.caption');\n          this.$active.removeClass('active');\n\n          anim({\n            targets: this.$active[0],\n            opacity: 0,\n            duration: this.options.duration,\n            easing: 'easeOutQuad',\n            complete: function () {\n              _this44.$slides.not('.active').each(function (el) {\n                anim({\n                  targets: el,\n                  opacity: 0,\n                  translateX: 0,\n                  translateY: 0,\n                  duration: 0,\n                  easing: 'easeOutQuad'\n                });\n              });\n            }\n          });\n\n          this._animateCaptionIn($caption[0], this.options.duration);\n\n          // Update indicators\n          if (this.options.indicators) {\n            this.$indicators.eq(this.activeIndex).removeClass('active');\n            this.$indicators.eq(index).addClass('active');\n          }\n\n          anim({\n            targets: this.$slides.eq(index)[0],\n            opacity: 1,\n            duration: this.options.duration,\n            easing: 'easeOutQuad'\n          });\n\n          anim({\n            targets: this.$slides.eq(index).find('.caption')[0],\n            opacity: 1,\n            translateX: 0,\n            translateY: 0,\n            duration: this.options.duration,\n            delay: this.options.duration,\n            easing: 'easeOutQuad'\n          });\n\n          this.$slides.eq(index).addClass('active');\n          this.activeIndex = index;\n\n          // Reset interval\n          this.start();\n        }\n      }\n\n      /**\n       * Pause slider interval\n       */\n\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        clearInterval(this.interval);\n      }\n\n      /**\n       * Start slider interval\n       */\n\n    }, {\n      key: \"start\",\n      value: function start() {\n        clearInterval(this.interval);\n        this.interval = setInterval(this._handleIntervalBound, this.options.duration + this.options.interval);\n      }\n\n      /**\n       * Move to next slide\n       */\n\n    }, {\n      key: \"next\",\n      value: function next() {\n        var newIndex = this.activeIndex + 1;\n\n        // Wrap around indices.\n        if (newIndex >= this.$slides.length) newIndex = 0;else if (newIndex < 0) newIndex = this.$slides.length - 1;\n\n        this.set(newIndex);\n      }\n\n      /**\n       * Move to previous slide\n       */\n\n    }, {\n      key: \"prev\",\n      value: function prev() {\n        var newIndex = this.activeIndex - 1;\n\n        // Wrap around indices.\n        if (newIndex >= this.$slides.length) newIndex = 0;else if (newIndex < 0) newIndex = this.$slides.length - 1;\n\n        this.set(newIndex);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Slider.__proto__ || Object.getPrototypeOf(Slider), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Slider;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Slider;\n  }(Component);\n\n  M.Slider = Slider;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Slider, 'slider', 'M_Slider');\n  }\n})(cash, M.anime);\n;(function ($, anim) {\n  $(document).on('click', '.card', function (e) {\n    if ($(this).children('.card-reveal').length) {\n      var $card = $(e.target).closest('.card');\n      if ($card.data('initialOverflow') === undefined) {\n        $card.data('initialOverflow', $card.css('overflow') === undefined ? '' : $card.css('overflow'));\n      }\n      var $cardReveal = $(this).find('.card-reveal');\n      if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {\n        // Make Reveal animate down and display none\n        anim({\n          targets: $cardReveal[0],\n          translateY: 0,\n          duration: 225,\n          easing: 'easeInOutQuad',\n          complete: function (anim) {\n            var el = anim.animatables[0].target;\n            $(el).css({ display: 'none' });\n            $card.css('overflow', $card.data('initialOverflow'));\n          }\n        });\n      } else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {\n        $card.css('overflow', 'hidden');\n        $cardReveal.css({ display: 'block' });\n        anim({\n          targets: $cardReveal[0],\n          translateY: '-100%',\n          duration: 300,\n          easing: 'easeInOutQuad'\n        });\n      }\n    }\n  });\n})(cash, M.anime);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    data: [],\n    placeholder: '',\n    secondaryPlaceholder: '',\n    autocompleteOptions: {},\n    limit: Infinity,\n    onChipAdd: null,\n    onChipSelect: null,\n    onChipDelete: null\n  };\n\n  /**\n   * @typedef {Object} chip\n   * @property {String} tag  chip tag string\n   * @property {String} [image]  chip avatar image string\n   */\n\n  /**\n   * @class\n   *\n   */\n\n  var Chips = function (_Component12) {\n    _inherits(Chips, _Component12);\n\n    /**\n     * Construct Chips instance and set up overlay\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Chips(el, options) {\n      _classCallCheck(this, Chips);\n\n      var _this45 = _possibleConstructorReturn(this, (Chips.__proto__ || Object.getPrototypeOf(Chips)).call(this, Chips, el, options));\n\n      _this45.el.M_Chips = _this45;\n\n      /**\n       * Options for the modal\n       * @member Chips#options\n       * @prop {Array} data\n       * @prop {String} placeholder\n       * @prop {String} secondaryPlaceholder\n       * @prop {Object} autocompleteOptions\n       */\n      _this45.options = $.extend({}, Chips.defaults, options);\n\n      _this45.$el.addClass('chips input-field');\n      _this45.chipsData = [];\n      _this45.$chips = $();\n      _this45._setupInput();\n      _this45.hasAutocomplete = Object.keys(_this45.options.autocompleteOptions).length > 0;\n\n      // Set input id\n      if (!_this45.$input.attr('id')) {\n        _this45.$input.attr('id', M.guid());\n      }\n\n      // Render initial chips\n      if (_this45.options.data.length) {\n        _this45.chipsData = _this45.options.data;\n        _this45._renderChips(_this45.chipsData);\n      }\n\n      // Setup autocomplete if needed\n      if (_this45.hasAutocomplete) {\n        _this45._setupAutocomplete();\n      }\n\n      _this45._setPlaceholder();\n      _this45._setupLabel();\n      _this45._setupEventHandlers();\n      return _this45;\n    }\n\n    _createClass(Chips, [{\n      key: \"getData\",\n\n\n      /**\n       * Get Chips Data\n       */\n      value: function getData() {\n        return this.chipsData;\n      }\n\n      /**\n       * Teardown component\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.$chips.remove();\n        this.el.M_Chips = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleChipClickBound = this._handleChipClick.bind(this);\n        this._handleInputKeydownBound = this._handleInputKeydown.bind(this);\n        this._handleInputFocusBound = this._handleInputFocus.bind(this);\n        this._handleInputBlurBound = this._handleInputBlur.bind(this);\n\n        this.el.addEventListener('click', this._handleChipClickBound);\n        document.addEventListener('keydown', Chips._handleChipsKeydown);\n        document.addEventListener('keyup', Chips._handleChipsKeyup);\n        this.el.addEventListener('blur', Chips._handleChipsBlur, true);\n        this.$input[0].addEventListener('focus', this._handleInputFocusBound);\n        this.$input[0].addEventListener('blur', this._handleInputBlurBound);\n        this.$input[0].addEventListener('keydown', this._handleInputKeydownBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('click', this._handleChipClickBound);\n        document.removeEventListener('keydown', Chips._handleChipsKeydown);\n        document.removeEventListener('keyup', Chips._handleChipsKeyup);\n        this.el.removeEventListener('blur', Chips._handleChipsBlur, true);\n        this.$input[0].removeEventListener('focus', this._handleInputFocusBound);\n        this.$input[0].removeEventListener('blur', this._handleInputBlurBound);\n        this.$input[0].removeEventListener('keydown', this._handleInputKeydownBound);\n      }\n\n      /**\n       * Handle Chip Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleChipClick\",\n      value: function _handleChipClick(e) {\n        var $chip = $(e.target).closest('.chip');\n        var clickedClose = $(e.target).is('.close');\n        if ($chip.length) {\n          var index = $chip.index();\n          if (clickedClose) {\n            // delete chip\n            this.deleteChip(index);\n            this.$input[0].focus();\n          } else {\n            // select chip\n            this.selectChip(index);\n          }\n\n          // Default handle click to focus on input\n        } else {\n          this.$input[0].focus();\n        }\n      }\n\n      /**\n       * Handle Chips Keydown\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleInputFocus\",\n\n\n      /**\n       * Handle Input Focus\n       */\n      value: function _handleInputFocus() {\n        this.$el.addClass('focus');\n      }\n\n      /**\n       * Handle Input Blur\n       */\n\n    }, {\n      key: \"_handleInputBlur\",\n      value: function _handleInputBlur() {\n        this.$el.removeClass('focus');\n      }\n\n      /**\n       * Handle Input Keydown\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleInputKeydown\",\n      value: function _handleInputKeydown(e) {\n        Chips._keydown = true;\n\n        // enter\n        if (e.keyCode === 13) {\n          // Override enter if autocompleting.\n          if (this.hasAutocomplete && this.autocomplete && this.autocomplete.isOpen) {\n            return;\n          }\n\n          e.preventDefault();\n          this.addChip({\n            tag: this.$input[0].value\n          });\n          this.$input[0].value = '';\n\n          // delete or left\n        } else if ((e.keyCode === 8 || e.keyCode === 37) && this.$input[0].value === '' && this.chipsData.length) {\n          e.preventDefault();\n          this.selectChip(this.chipsData.length - 1);\n        }\n      }\n\n      /**\n       * Render Chip\n       * @param {chip} chip\n       * @return {Element}\n       */\n\n    }, {\n      key: \"_renderChip\",\n      value: function _renderChip(chip) {\n        if (!chip.tag) {\n          return;\n        }\n\n        var renderedChip = document.createElement('div');\n        var closeIcon = document.createElement('i');\n        renderedChip.classList.add('chip');\n        renderedChip.textContent = chip.tag;\n        renderedChip.setAttribute('tabindex', 0);\n        $(closeIcon).addClass('material-icons close');\n        closeIcon.textContent = 'close';\n\n        // attach image if needed\n        if (chip.image) {\n          var img = document.createElement('img');\n          img.setAttribute('src', chip.image);\n          renderedChip.insertBefore(img, renderedChip.firstChild);\n        }\n\n        renderedChip.appendChild(closeIcon);\n        return renderedChip;\n      }\n\n      /**\n       * Render Chips\n       */\n\n    }, {\n      key: \"_renderChips\",\n      value: function _renderChips() {\n        this.$chips.remove();\n        for (var i = 0; i < this.chipsData.length; i++) {\n          var chipEl = this._renderChip(this.chipsData[i]);\n          this.$el.append(chipEl);\n          this.$chips.add(chipEl);\n        }\n\n        // move input to end\n        this.$el.append(this.$input[0]);\n      }\n\n      /**\n       * Setup Autocomplete\n       */\n\n    }, {\n      key: \"_setupAutocomplete\",\n      value: function _setupAutocomplete() {\n        var _this46 = this;\n\n        this.options.autocompleteOptions.onAutocomplete = function (val) {\n          _this46.addChip({\n            tag: val\n          });\n          _this46.$input[0].value = '';\n          _this46.$input[0].focus();\n        };\n\n        this.autocomplete = M.Autocomplete.init(this.$input[0], this.options.autocompleteOptions);\n      }\n\n      /**\n       * Setup Input\n       */\n\n    }, {\n      key: \"_setupInput\",\n      value: function _setupInput() {\n        this.$input = this.$el.find('input');\n        if (!this.$input.length) {\n          this.$input = $('<input></input>');\n          this.$el.append(this.$input);\n        }\n\n        this.$input.addClass('input');\n      }\n\n      /**\n       * Setup Label\n       */\n\n    }, {\n      key: \"_setupLabel\",\n      value: function _setupLabel() {\n        this.$label = this.$el.find('label');\n        if (this.$label.length) {\n          this.$label.setAttribute('for', this.$input.attr('id'));\n        }\n      }\n\n      /**\n       * Set placeholder\n       */\n\n    }, {\n      key: \"_setPlaceholder\",\n      value: function _setPlaceholder() {\n        if (this.chipsData !== undefined && !this.chipsData.length && this.options.placeholder) {\n          $(this.$input).prop('placeholder', this.options.placeholder);\n        } else if ((this.chipsData === undefined || !!this.chipsData.length) && this.options.secondaryPlaceholder) {\n          $(this.$input).prop('placeholder', this.options.secondaryPlaceholder);\n        }\n      }\n\n      /**\n       * Check if chip is valid\n       * @param {chip} chip\n       */\n\n    }, {\n      key: \"_isValid\",\n      value: function _isValid(chip) {\n        if (chip.hasOwnProperty('tag') && chip.tag !== '') {\n          var exists = false;\n          for (var i = 0; i < this.chipsData.length; i++) {\n            if (this.chipsData[i].tag === chip.tag) {\n              exists = true;\n              break;\n            }\n          }\n          return !exists;\n        }\n\n        return false;\n      }\n\n      /**\n       * Add chip\n       * @param {chip} chip\n       */\n\n    }, {\n      key: \"addChip\",\n      value: function addChip(chip) {\n        if (!this._isValid(chip) || this.chipsData.length >= this.options.limit) {\n          return;\n        }\n\n        var renderedChip = this._renderChip(chip);\n        this.$chips.add(renderedChip);\n        this.chipsData.push(chip);\n        $(this.$input).before(renderedChip);\n        this._setPlaceholder();\n\n        // fire chipAdd callback\n        if (typeof this.options.onChipAdd === 'function') {\n          this.options.onChipAdd.call(this, this.$el, renderedChip);\n        }\n      }\n\n      /**\n       * Delete chip\n       * @param {Number} chip\n       */\n\n    }, {\n      key: \"deleteChip\",\n      value: function deleteChip(chipIndex) {\n        var $chip = this.$chips.eq(chipIndex);\n        this.$chips.eq(chipIndex).remove();\n        this.$chips = this.$chips.filter(function (el) {\n          return $(el).index() >= 0;\n        });\n        this.chipsData.splice(chipIndex, 1);\n        this._setPlaceholder();\n\n        // fire chipDelete callback\n        if (typeof this.options.onChipDelete === 'function') {\n          this.options.onChipDelete.call(this, this.$el, $chip[0]);\n        }\n      }\n\n      /**\n       * Select chip\n       * @param {Number} chip\n       */\n\n    }, {\n      key: \"selectChip\",\n      value: function selectChip(chipIndex) {\n        var $chip = this.$chips.eq(chipIndex);\n        this._selectedChip = $chip;\n        $chip[0].focus();\n\n        // fire chipSelect callback\n        if (typeof this.options.onChipSelect === 'function') {\n          this.options.onChipSelect.call(this, this.$el, $chip[0]);\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Chips.__proto__ || Object.getPrototypeOf(Chips), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Chips;\n      }\n    }, {\n      key: \"_handleChipsKeydown\",\n      value: function _handleChipsKeydown(e) {\n        Chips._keydown = true;\n\n        var $chips = $(e.target).closest('.chips');\n        var chipsKeydown = e.target && $chips.length;\n\n        // Don't handle keydown inputs on input and textarea\n        if ($(e.target).is('input, textarea') || !chipsKeydown) {\n          return;\n        }\n\n        var currChips = $chips[0].M_Chips;\n\n        // backspace and delete\n        if (e.keyCode === 8 || e.keyCode === 46) {\n          e.preventDefault();\n\n          var selectIndex = currChips.chipsData.length;\n          if (currChips._selectedChip) {\n            var index = currChips._selectedChip.index();\n            currChips.deleteChip(index);\n            currChips._selectedChip = null;\n\n            // Make sure selectIndex doesn't go negative\n            selectIndex = Math.max(index - 1, 0);\n          }\n\n          if (currChips.chipsData.length) {\n            currChips.selectChip(selectIndex);\n          }\n\n          // left arrow key\n        } else if (e.keyCode === 37) {\n          if (currChips._selectedChip) {\n            var _selectIndex = currChips._selectedChip.index() - 1;\n            if (_selectIndex < 0) {\n              return;\n            }\n            currChips.selectChip(_selectIndex);\n          }\n\n          // right arrow key\n        } else if (e.keyCode === 39) {\n          if (currChips._selectedChip) {\n            var _selectIndex2 = currChips._selectedChip.index() + 1;\n\n            if (_selectIndex2 >= currChips.chipsData.length) {\n              currChips.$input[0].focus();\n            } else {\n              currChips.selectChip(_selectIndex2);\n            }\n          }\n        }\n      }\n\n      /**\n       * Handle Chips Keyup\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleChipsKeyup\",\n      value: function _handleChipsKeyup(e) {\n        Chips._keydown = false;\n      }\n\n      /**\n       * Handle Chips Blur\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleChipsBlur\",\n      value: function _handleChipsBlur(e) {\n        if (!Chips._keydown) {\n          var $chips = $(e.target).closest('.chips');\n          var currChips = $chips[0].M_Chips;\n\n          currChips._selectedChip = null;\n        }\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Chips;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Chips\n   */\n\n\n  Chips._keydown = false;\n\n  M.Chips = Chips;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Chips, 'chips', 'M_Chips');\n  }\n\n  $(document).ready(function () {\n    // Handle removal of static chips.\n    $(document.body).on('click', '.chip .close', function () {\n      var $chips = $(this).closest('.chips');\n      if ($chips.length && $chips[0].M_Chips) {\n        return;\n      }\n      $(this).closest('.chip').remove();\n    });\n  });\n})(cash);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    top: 0,\n    bottom: Infinity,\n    offset: 0,\n    onPositionChange: null\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Pushpin = function (_Component13) {\n    _inherits(Pushpin, _Component13);\n\n    /**\n     * Construct Pushpin instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Pushpin(el, options) {\n      _classCallCheck(this, Pushpin);\n\n      var _this47 = _possibleConstructorReturn(this, (Pushpin.__proto__ || Object.getPrototypeOf(Pushpin)).call(this, Pushpin, el, options));\n\n      _this47.el.M_Pushpin = _this47;\n\n      /**\n       * Options for the modal\n       * @member Pushpin#options\n       */\n      _this47.options = $.extend({}, Pushpin.defaults, options);\n\n      _this47.originalOffset = _this47.el.offsetTop;\n      Pushpin._pushpins.push(_this47);\n      _this47._setupEventHandlers();\n      _this47._updatePosition();\n      return _this47;\n    }\n\n    _createClass(Pushpin, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this.el.style.top = null;\n        this._removePinClasses();\n        this._removeEventHandlers();\n\n        // Remove pushpin Inst\n        var index = Pushpin._pushpins.indexOf(this);\n        Pushpin._pushpins.splice(index, 1);\n      }\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        document.addEventListener('scroll', Pushpin._updateElements);\n      }\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        document.removeEventListener('scroll', Pushpin._updateElements);\n      }\n    }, {\n      key: \"_updatePosition\",\n      value: function _updatePosition() {\n        var scrolled = M.getDocumentScrollTop() + this.options.offset;\n\n        if (this.options.top <= scrolled && this.options.bottom >= scrolled && !this.el.classList.contains('pinned')) {\n          this._removePinClasses();\n          this.el.style.top = this.options.offset + \"px\";\n          this.el.classList.add('pinned');\n\n          // onPositionChange callback\n          if (typeof this.options.onPositionChange === 'function') {\n            this.options.onPositionChange.call(this, 'pinned');\n          }\n        }\n\n        // Add pin-top (when scrolled position is above top)\n        if (scrolled < this.options.top && !this.el.classList.contains('pin-top')) {\n          this._removePinClasses();\n          this.el.style.top = 0;\n          this.el.classList.add('pin-top');\n\n          // onPositionChange callback\n          if (typeof this.options.onPositionChange === 'function') {\n            this.options.onPositionChange.call(this, 'pin-top');\n          }\n        }\n\n        // Add pin-bottom (when scrolled position is below bottom)\n        if (scrolled > this.options.bottom && !this.el.classList.contains('pin-bottom')) {\n          this._removePinClasses();\n          this.el.classList.add('pin-bottom');\n          this.el.style.top = this.options.bottom - this.originalOffset + \"px\";\n\n          // onPositionChange callback\n          if (typeof this.options.onPositionChange === 'function') {\n            this.options.onPositionChange.call(this, 'pin-bottom');\n          }\n        }\n      }\n    }, {\n      key: \"_removePinClasses\",\n      value: function _removePinClasses() {\n        // IE 11 bug (can't remove multiple classes in one line)\n        this.el.classList.remove('pin-top');\n        this.el.classList.remove('pinned');\n        this.el.classList.remove('pin-bottom');\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Pushpin.__proto__ || Object.getPrototypeOf(Pushpin), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Pushpin;\n      }\n    }, {\n      key: \"_updateElements\",\n      value: function _updateElements() {\n        for (var elIndex in Pushpin._pushpins) {\n          var pInstance = Pushpin._pushpins[elIndex];\n          pInstance._updatePosition();\n        }\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Pushpin;\n  }(Component);\n\n  /**\n   * @static\n   * @memberof Pushpin\n   */\n\n\n  Pushpin._pushpins = [];\n\n  M.Pushpin = Pushpin;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Pushpin, 'pushpin', 'M_Pushpin');\n  }\n})(cash);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {\n    direction: 'top',\n    hoverEnabled: true,\n    toolbarEnabled: false\n  };\n\n  $.fn.reverse = [].reverse;\n\n  /**\n   * @class\n   *\n   */\n\n  var FloatingActionButton = function (_Component14) {\n    _inherits(FloatingActionButton, _Component14);\n\n    /**\n     * Construct FloatingActionButton instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function FloatingActionButton(el, options) {\n      _classCallCheck(this, FloatingActionButton);\n\n      var _this48 = _possibleConstructorReturn(this, (FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton)).call(this, FloatingActionButton, el, options));\n\n      _this48.el.M_FloatingActionButton = _this48;\n\n      /**\n       * Options for the fab\n       * @member FloatingActionButton#options\n       * @prop {Boolean} [direction] - Direction fab menu opens\n       * @prop {Boolean} [hoverEnabled=true] - Enable hover vs click\n       * @prop {Boolean} [toolbarEnabled=false] - Enable toolbar transition\n       */\n      _this48.options = $.extend({}, FloatingActionButton.defaults, options);\n\n      _this48.isOpen = false;\n      _this48.$anchor = _this48.$el.children('a').first();\n      _this48.$menu = _this48.$el.children('ul').first();\n      _this48.$floatingBtns = _this48.$el.find('ul .btn-floating');\n      _this48.$floatingBtnsReverse = _this48.$el.find('ul .btn-floating').reverse();\n      _this48.offsetY = 0;\n      _this48.offsetX = 0;\n\n      _this48.$el.addClass(\"direction-\" + _this48.options.direction);\n      if (_this48.options.direction === 'top') {\n        _this48.offsetY = 40;\n      } else if (_this48.options.direction === 'right') {\n        _this48.offsetX = -40;\n      } else if (_this48.options.direction === 'bottom') {\n        _this48.offsetY = -40;\n      } else {\n        _this48.offsetX = 40;\n      }\n      _this48._setupEventHandlers();\n      return _this48;\n    }\n\n    _createClass(FloatingActionButton, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.el.M_FloatingActionButton = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleFABClickBound = this._handleFABClick.bind(this);\n        this._handleOpenBound = this.open.bind(this);\n        this._handleCloseBound = this.close.bind(this);\n\n        if (this.options.hoverEnabled && !this.options.toolbarEnabled) {\n          this.el.addEventListener('mouseenter', this._handleOpenBound);\n          this.el.addEventListener('mouseleave', this._handleCloseBound);\n        } else {\n          this.el.addEventListener('click', this._handleFABClickBound);\n        }\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        if (this.options.hoverEnabled && !this.options.toolbarEnabled) {\n          this.el.removeEventListener('mouseenter', this._handleOpenBound);\n          this.el.removeEventListener('mouseleave', this._handleCloseBound);\n        } else {\n          this.el.removeEventListener('click', this._handleFABClickBound);\n        }\n      }\n\n      /**\n       * Handle FAB Click\n       */\n\n    }, {\n      key: \"_handleFABClick\",\n      value: function _handleFABClick() {\n        if (this.isOpen) {\n          this.close();\n        } else {\n          this.open();\n        }\n      }\n\n      /**\n       * Handle Document Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleDocumentClick\",\n      value: function _handleDocumentClick(e) {\n        if (!$(e.target).closest(this.$menu).length) {\n          this.close();\n        }\n      }\n\n      /**\n       * Open FAB\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this.isOpen) {\n          return;\n        }\n\n        if (this.options.toolbarEnabled) {\n          this._animateInToolbar();\n        } else {\n          this._animateInFAB();\n        }\n        this.isOpen = true;\n      }\n\n      /**\n       * Close FAB\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        if (this.options.toolbarEnabled) {\n          window.removeEventListener('scroll', this._handleCloseBound, true);\n          document.body.removeEventListener('click', this._handleDocumentClickBound, true);\n          this._animateOutToolbar();\n        } else {\n          this._animateOutFAB();\n        }\n        this.isOpen = false;\n      }\n\n      /**\n       * Classic FAB Menu open\n       */\n\n    }, {\n      key: \"_animateInFAB\",\n      value: function _animateInFAB() {\n        var _this49 = this;\n\n        this.$el.addClass('active');\n\n        var time = 0;\n        this.$floatingBtnsReverse.each(function (el) {\n          anim({\n            targets: el,\n            opacity: 1,\n            scale: [0.4, 1],\n            translateY: [_this49.offsetY, 0],\n            translateX: [_this49.offsetX, 0],\n            duration: 275,\n            delay: time,\n            easing: 'easeInOutQuad'\n          });\n          time += 40;\n        });\n      }\n\n      /**\n       * Classic FAB Menu close\n       */\n\n    }, {\n      key: \"_animateOutFAB\",\n      value: function _animateOutFAB() {\n        var _this50 = this;\n\n        this.$floatingBtnsReverse.each(function (el) {\n          anim.remove(el);\n          anim({\n            targets: el,\n            opacity: 0,\n            scale: 0.4,\n            translateY: _this50.offsetY,\n            translateX: _this50.offsetX,\n            duration: 175,\n            easing: 'easeOutQuad',\n            complete: function () {\n              _this50.$el.removeClass('active');\n            }\n          });\n        });\n      }\n\n      /**\n       * Toolbar transition Menu open\n       */\n\n    }, {\n      key: \"_animateInToolbar\",\n      value: function _animateInToolbar() {\n        var _this51 = this;\n\n        var scaleFactor = void 0;\n        var windowWidth = window.innerWidth;\n        var windowHeight = window.innerHeight;\n        var btnRect = this.el.getBoundingClientRect();\n        var backdrop = $('<div class=\"fab-backdrop\"></div>');\n        var fabColor = this.$anchor.css('background-color');\n        this.$anchor.append(backdrop);\n\n        this.offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;\n        this.offsetY = windowHeight - btnRect.bottom;\n        scaleFactor = windowWidth / backdrop[0].clientWidth;\n        this.btnBottom = btnRect.bottom;\n        this.btnLeft = btnRect.left;\n        this.btnWidth = btnRect.width;\n\n        // Set initial state\n        this.$el.addClass('active');\n        this.$el.css({\n          'text-align': 'center',\n          width: '100%',\n          bottom: 0,\n          left: 0,\n          transform: 'translateX(' + this.offsetX + 'px)',\n          transition: 'none'\n        });\n        this.$anchor.css({\n          transform: 'translateY(' + -this.offsetY + 'px)',\n          transition: 'none'\n        });\n        backdrop.css({\n          'background-color': fabColor\n        });\n\n        setTimeout(function () {\n          _this51.$el.css({\n            transform: '',\n            transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'\n          });\n          _this51.$anchor.css({\n            overflow: 'visible',\n            transform: '',\n            transition: 'transform .2s'\n          });\n\n          setTimeout(function () {\n            _this51.$el.css({\n              overflow: 'hidden',\n              'background-color': fabColor\n            });\n            backdrop.css({\n              transform: 'scale(' + scaleFactor + ')',\n              transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n            });\n            _this51.$menu.children('li').children('a').css({\n              opacity: 1\n            });\n\n            // Scroll to close.\n            _this51._handleDocumentClickBound = _this51._handleDocumentClick.bind(_this51);\n            window.addEventListener('scroll', _this51._handleCloseBound, true);\n            document.body.addEventListener('click', _this51._handleDocumentClickBound, true);\n          }, 100);\n        }, 0);\n      }\n\n      /**\n       * Toolbar transition Menu close\n       */\n\n    }, {\n      key: \"_animateOutToolbar\",\n      value: function _animateOutToolbar() {\n        var _this52 = this;\n\n        var windowWidth = window.innerWidth;\n        var windowHeight = window.innerHeight;\n        var backdrop = this.$el.find('.fab-backdrop');\n        var fabColor = this.$anchor.css('background-color');\n\n        this.offsetX = this.btnLeft - windowWidth / 2 + this.btnWidth / 2;\n        this.offsetY = windowHeight - this.btnBottom;\n\n        // Hide backdrop\n        this.$el.removeClass('active');\n        this.$el.css({\n          'background-color': 'transparent',\n          transition: 'none'\n        });\n        this.$anchor.css({\n          transition: 'none'\n        });\n        backdrop.css({\n          transform: 'scale(0)',\n          'background-color': fabColor\n        });\n        this.$menu.children('li').children('a').css({\n          opacity: ''\n        });\n\n        setTimeout(function () {\n          backdrop.remove();\n\n          // Set initial state.\n          _this52.$el.css({\n            'text-align': '',\n            width: '',\n            bottom: '',\n            left: '',\n            overflow: '',\n            'background-color': '',\n            transform: 'translate3d(' + -_this52.offsetX + 'px,0,0)'\n          });\n          _this52.$anchor.css({\n            overflow: '',\n            transform: 'translate3d(0,' + _this52.offsetY + 'px,0)'\n          });\n\n          setTimeout(function () {\n            _this52.$el.css({\n              transform: 'translate3d(0,0,0)',\n              transition: 'transform .2s'\n            });\n            _this52.$anchor.css({\n              transform: 'translate3d(0,0,0)',\n              transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n            });\n          }, 20);\n        }, 200);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_FloatingActionButton;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return FloatingActionButton;\n  }(Component);\n\n  M.FloatingActionButton = FloatingActionButton;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(FloatingActionButton, 'floatingActionButton', 'M_FloatingActionButton');\n  }\n})(cash, M.anime);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    // Close when date is selected\n    autoClose: false,\n\n    // the default output format for the input field value\n    format: 'mmm dd, yyyy',\n\n    // Used to create date object from current input string\n    parse: null,\n\n    // The initial date to view when first opened\n    defaultDate: null,\n\n    // Make the `defaultDate` the initial selected value\n    setDefaultDate: false,\n\n    disableWeekends: false,\n\n    disableDayFn: null,\n\n    // First day of week (0: Sunday, 1: Monday etc)\n    firstDay: 0,\n\n    // The earliest date that can be selected\n    minDate: null,\n    // Thelatest date that can be selected\n    maxDate: null,\n\n    // Number of years either side, or array of upper/lower range\n    yearRange: 10,\n\n    // used internally (don't config outside)\n    minYear: 0,\n    maxYear: 9999,\n    minMonth: undefined,\n    maxMonth: undefined,\n\n    startRange: null,\n    endRange: null,\n\n    isRTL: false,\n\n    // Render the month after year in the calendar title\n    showMonthAfterYear: false,\n\n    // Render days of the calendar grid that fall in the next or previous month\n    showDaysInNextAndPreviousMonths: false,\n\n    // Specify a DOM element to render the calendar in\n    container: null,\n\n    // Show clear button\n    showClearBtn: false,\n\n    // internationalization\n    i18n: {\n      cancel: 'Cancel',\n      clear: 'Clear',\n      done: 'Ok',\n      previousMonth: '‹',\n      nextMonth: '›',\n      months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n      weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n      weekdaysAbbrev: ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n    },\n\n    // events array\n    events: [],\n\n    // callback function\n    onSelect: null,\n    onOpen: null,\n    onClose: null,\n    onDraw: null\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Datepicker = function (_Component15) {\n    _inherits(Datepicker, _Component15);\n\n    /**\n     * Construct Datepicker instance and set up overlay\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Datepicker(el, options) {\n      _classCallCheck(this, Datepicker);\n\n      var _this53 = _possibleConstructorReturn(this, (Datepicker.__proto__ || Object.getPrototypeOf(Datepicker)).call(this, Datepicker, el, options));\n\n      _this53.el.M_Datepicker = _this53;\n\n      _this53.options = $.extend({}, Datepicker.defaults, options);\n\n      // make sure i18n defaults are not lost when only few i18n option properties are passed\n      if (!!options && options.hasOwnProperty('i18n') && typeof options.i18n === 'object') {\n        _this53.options.i18n = $.extend({}, Datepicker.defaults.i18n, options.i18n);\n      }\n\n      // Remove time component from minDate and maxDate options\n      if (_this53.options.minDate) _this53.options.minDate.setHours(0, 0, 0, 0);\n      if (_this53.options.maxDate) _this53.options.maxDate.setHours(0, 0, 0, 0);\n\n      _this53.id = M.guid();\n\n      _this53._setupVariables();\n      _this53._insertHTMLIntoDOM();\n      _this53._setupModal();\n\n      _this53._setupEventHandlers();\n\n      if (!_this53.options.defaultDate) {\n        _this53.options.defaultDate = new Date(Date.parse(_this53.el.value));\n      }\n\n      var defDate = _this53.options.defaultDate;\n      if (Datepicker._isDate(defDate)) {\n        if (_this53.options.setDefaultDate) {\n          _this53.setDate(defDate, true);\n          _this53.setInputValue();\n        } else {\n          _this53.gotoDate(defDate);\n        }\n      } else {\n        _this53.gotoDate(new Date());\n      }\n\n      /**\n       * Describes open/close state of datepicker\n       * @type {Boolean}\n       */\n      _this53.isOpen = false;\n      return _this53;\n    }\n\n    _createClass(Datepicker, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.modal.destroy();\n        $(this.modalEl).remove();\n        this.destroySelects();\n        this.el.M_Datepicker = undefined;\n      }\n    }, {\n      key: \"destroySelects\",\n      value: function destroySelects() {\n        var oldYearSelect = this.calendarEl.querySelector('.orig-select-year');\n        if (oldYearSelect) {\n          M.FormSelect.getInstance(oldYearSelect).destroy();\n        }\n        var oldMonthSelect = this.calendarEl.querySelector('.orig-select-month');\n        if (oldMonthSelect) {\n          M.FormSelect.getInstance(oldMonthSelect).destroy();\n        }\n      }\n    }, {\n      key: \"_insertHTMLIntoDOM\",\n      value: function _insertHTMLIntoDOM() {\n        if (this.options.showClearBtn) {\n          $(this.clearBtn).css({ visibility: '' });\n          this.clearBtn.innerHTML = this.options.i18n.clear;\n        }\n\n        this.doneBtn.innerHTML = this.options.i18n.done;\n        this.cancelBtn.innerHTML = this.options.i18n.cancel;\n\n        if (this.options.container) {\n          this.$modalEl.appendTo(this.options.container);\n        } else {\n          this.$modalEl.insertBefore(this.el);\n        }\n      }\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        var _this54 = this;\n\n        this.modalEl.id = 'modal-' + this.id;\n        this.modal = M.Modal.init(this.modalEl, {\n          onCloseEnd: function () {\n            _this54.isOpen = false;\n          }\n        });\n      }\n    }, {\n      key: \"toString\",\n      value: function toString(format) {\n        var _this55 = this;\n\n        format = format || this.options.format;\n        if (!Datepicker._isDate(this.date)) {\n          return '';\n        }\n\n        var formatArray = format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);\n        var formattedDate = formatArray.map(function (label) {\n          if (_this55.formats[label]) {\n            return _this55.formats[label]();\n          }\n\n          return label;\n        }).join('');\n        return formattedDate;\n      }\n    }, {\n      key: \"setDate\",\n      value: function setDate(date, preventOnSelect) {\n        if (!date) {\n          this.date = null;\n          this._renderDateDisplay();\n          return this.draw();\n        }\n        if (typeof date === 'string') {\n          date = new Date(Date.parse(date));\n        }\n        if (!Datepicker._isDate(date)) {\n          return;\n        }\n\n        var min = this.options.minDate,\n            max = this.options.maxDate;\n\n        if (Datepicker._isDate(min) && date < min) {\n          date = min;\n        } else if (Datepicker._isDate(max) && date > max) {\n          date = max;\n        }\n\n        this.date = new Date(date.getTime());\n\n        this._renderDateDisplay();\n\n        Datepicker._setToStartOfDay(this.date);\n        this.gotoDate(this.date);\n\n        if (!preventOnSelect && typeof this.options.onSelect === 'function') {\n          this.options.onSelect.call(this, this.date);\n        }\n      }\n    }, {\n      key: \"setInputValue\",\n      value: function setInputValue() {\n        this.el.value = this.toString();\n        this.$el.trigger('change', { firedBy: this });\n      }\n    }, {\n      key: \"_renderDateDisplay\",\n      value: function _renderDateDisplay() {\n        var displayDate = Datepicker._isDate(this.date) ? this.date : new Date();\n        var i18n = this.options.i18n;\n        var day = i18n.weekdaysShort[displayDate.getDay()];\n        var month = i18n.monthsShort[displayDate.getMonth()];\n        var date = displayDate.getDate();\n        this.yearTextEl.innerHTML = displayDate.getFullYear();\n        this.dateTextEl.innerHTML = day + \", \" + month + \" \" + date;\n      }\n\n      /**\n       * change view to a specific date\n       */\n\n    }, {\n      key: \"gotoDate\",\n      value: function gotoDate(date) {\n        var newCalendar = true;\n\n        if (!Datepicker._isDate(date)) {\n          return;\n        }\n\n        if (this.calendars) {\n          var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),\n              lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),\n              visibleDate = date.getTime();\n          // get the end of the month\n          lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);\n          lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);\n          newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;\n        }\n\n        if (newCalendar) {\n          this.calendars = [{\n            month: date.getMonth(),\n            year: date.getFullYear()\n          }];\n        }\n\n        this.adjustCalendars();\n      }\n    }, {\n      key: \"adjustCalendars\",\n      value: function adjustCalendars() {\n        this.calendars[0] = this.adjustCalendar(this.calendars[0]);\n        this.draw();\n      }\n    }, {\n      key: \"adjustCalendar\",\n      value: function adjustCalendar(calendar) {\n        if (calendar.month < 0) {\n          calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);\n          calendar.month += 12;\n        }\n        if (calendar.month > 11) {\n          calendar.year += Math.floor(Math.abs(calendar.month) / 12);\n          calendar.month -= 12;\n        }\n        return calendar;\n      }\n    }, {\n      key: \"nextMonth\",\n      value: function nextMonth() {\n        this.calendars[0].month++;\n        this.adjustCalendars();\n      }\n    }, {\n      key: \"prevMonth\",\n      value: function prevMonth() {\n        this.calendars[0].month--;\n        this.adjustCalendars();\n      }\n    }, {\n      key: \"render\",\n      value: function render(year, month, randId) {\n        var opts = this.options,\n            now = new Date(),\n            days = Datepicker._getDaysInMonth(year, month),\n            before = new Date(year, month, 1).getDay(),\n            data = [],\n            row = [];\n        Datepicker._setToStartOfDay(now);\n        if (opts.firstDay > 0) {\n          before -= opts.firstDay;\n          if (before < 0) {\n            before += 7;\n          }\n        }\n        var previousMonth = month === 0 ? 11 : month - 1,\n            nextMonth = month === 11 ? 0 : month + 1,\n            yearOfPreviousMonth = month === 0 ? year - 1 : year,\n            yearOfNextMonth = month === 11 ? year + 1 : year,\n            daysInPreviousMonth = Datepicker._getDaysInMonth(yearOfPreviousMonth, previousMonth);\n        var cells = days + before,\n            after = cells;\n        while (after > 7) {\n          after -= 7;\n        }\n        cells += 7 - after;\n        var isWeekSelected = false;\n        for (var i = 0, r = 0; i < cells; i++) {\n          var day = new Date(year, month, 1 + (i - before)),\n              isSelected = Datepicker._isDate(this.date) ? Datepicker._compareDates(day, this.date) : false,\n              isToday = Datepicker._compareDates(day, now),\n              hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,\n              isEmpty = i < before || i >= days + before,\n              dayNumber = 1 + (i - before),\n              monthNumber = month,\n              yearNumber = year,\n              isStartRange = opts.startRange && Datepicker._compareDates(opts.startRange, day),\n              isEndRange = opts.endRange && Datepicker._compareDates(opts.endRange, day),\n              isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,\n              isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && Datepicker._isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);\n\n          if (isEmpty) {\n            if (i < before) {\n              dayNumber = daysInPreviousMonth + dayNumber;\n              monthNumber = previousMonth;\n              yearNumber = yearOfPreviousMonth;\n            } else {\n              dayNumber = dayNumber - days;\n              monthNumber = nextMonth;\n              yearNumber = yearOfNextMonth;\n            }\n          }\n\n          var dayConfig = {\n            day: dayNumber,\n            month: monthNumber,\n            year: yearNumber,\n            hasEvent: hasEvent,\n            isSelected: isSelected,\n            isToday: isToday,\n            isDisabled: isDisabled,\n            isEmpty: isEmpty,\n            isStartRange: isStartRange,\n            isEndRange: isEndRange,\n            isInRange: isInRange,\n            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths\n          };\n\n          row.push(this.renderDay(dayConfig));\n\n          if (++r === 7) {\n            data.push(this.renderRow(row, opts.isRTL, isWeekSelected));\n            row = [];\n            r = 0;\n            isWeekSelected = false;\n          }\n        }\n        return this.renderTable(opts, data, randId);\n      }\n    }, {\n      key: \"renderDay\",\n      value: function renderDay(opts) {\n        var arr = [];\n        var ariaSelected = 'false';\n        if (opts.isEmpty) {\n          if (opts.showDaysInNextAndPreviousMonths) {\n            arr.push('is-outside-current-month');\n            arr.push('is-selection-disabled');\n          } else {\n            return '<td class=\"is-empty\"></td>';\n          }\n        }\n        if (opts.isDisabled) {\n          arr.push('is-disabled');\n        }\n\n        if (opts.isToday) {\n          arr.push('is-today');\n        }\n        if (opts.isSelected) {\n          arr.push('is-selected');\n          ariaSelected = 'true';\n        }\n        if (opts.hasEvent) {\n          arr.push('has-event');\n        }\n        if (opts.isInRange) {\n          arr.push('is-inrange');\n        }\n        if (opts.isStartRange) {\n          arr.push('is-startrange');\n        }\n        if (opts.isEndRange) {\n          arr.push('is-endrange');\n        }\n        return \"<td data-day=\\\"\" + opts.day + \"\\\" class=\\\"\" + arr.join(' ') + \"\\\" aria-selected=\\\"\" + ariaSelected + \"\\\">\" + (\"<button class=\\\"datepicker-day-button\\\" type=\\\"button\\\" data-year=\\\"\" + opts.year + \"\\\" data-month=\\\"\" + opts.month + \"\\\" data-day=\\\"\" + opts.day + \"\\\">\" + opts.day + \"</button>\") + '</td>';\n      }\n    }, {\n      key: \"renderRow\",\n      value: function renderRow(days, isRTL, isRowSelected) {\n        return '<tr class=\"datepicker-row' + (isRowSelected ? ' is-selected' : '') + '\">' + (isRTL ? days.reverse() : days).join('') + '</tr>';\n      }\n    }, {\n      key: \"renderTable\",\n      value: function renderTable(opts, data, randId) {\n        return '<div class=\"datepicker-table-wrapper\"><table cellpadding=\"0\" cellspacing=\"0\" class=\"datepicker-table\" role=\"grid\" aria-labelledby=\"' + randId + '\">' + this.renderHead(opts) + this.renderBody(data) + '</table></div>';\n      }\n    }, {\n      key: \"renderHead\",\n      value: function renderHead(opts) {\n        var i = void 0,\n            arr = [];\n        for (i = 0; i < 7; i++) {\n          arr.push(\"<th scope=\\\"col\\\"><abbr title=\\\"\" + this.renderDayName(opts, i) + \"\\\">\" + this.renderDayName(opts, i, true) + \"</abbr></th>\");\n        }\n        return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';\n      }\n    }, {\n      key: \"renderBody\",\n      value: function renderBody(rows) {\n        return '<tbody>' + rows.join('') + '</tbody>';\n      }\n    }, {\n      key: \"renderTitle\",\n      value: function renderTitle(instance, c, year, month, refYear, randId) {\n        var i = void 0,\n            j = void 0,\n            arr = void 0,\n            opts = this.options,\n            isMinYear = year === opts.minYear,\n            isMaxYear = year === opts.maxYear,\n            html = '<div id=\"' + randId + '\" class=\"datepicker-controls\" role=\"heading\" aria-live=\"assertive\">',\n            monthHtml = void 0,\n            yearHtml = void 0,\n            prev = true,\n            next = true;\n\n        for (arr = [], i = 0; i < 12; i++) {\n          arr.push('<option value=\"' + (year === refYear ? i - c : 12 + i - c) + '\"' + (i === month ? ' selected=\"selected\"' : '') + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? 'disabled=\"disabled\"' : '') + '>' + opts.i18n.months[i] + '</option>');\n        }\n\n        monthHtml = '<select class=\"datepicker-select orig-select-month\" tabindex=\"-1\">' + arr.join('') + '</select>';\n\n        if ($.isArray(opts.yearRange)) {\n          i = opts.yearRange[0];\n          j = opts.yearRange[1] + 1;\n        } else {\n          i = year - opts.yearRange;\n          j = 1 + year + opts.yearRange;\n        }\n\n        for (arr = []; i < j && i <= opts.maxYear; i++) {\n          if (i >= opts.minYear) {\n            arr.push(\"<option value=\\\"\" + i + \"\\\" \" + (i === year ? 'selected=\"selected\"' : '') + \">\" + i + \"</option>\");\n          }\n        }\n\n        yearHtml = \"<select class=\\\"datepicker-select orig-select-year\\\" tabindex=\\\"-1\\\">\" + arr.join('') + \"</select>\";\n\n        var leftArrow = '<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\"/><path d=\"M0-.5h24v24H0z\" fill=\"none\"/></svg>';\n        html += \"<button class=\\\"month-prev\" + (prev ? '' : ' is-disabled') + \"\\\" type=\\\"button\\\">\" + leftArrow + \"</button>\";\n\n        html += '<div class=\"selects-container\">';\n        if (opts.showMonthAfterYear) {\n          html += yearHtml + monthHtml;\n        } else {\n          html += monthHtml + yearHtml;\n        }\n        html += '</div>';\n\n        if (isMinYear && (month === 0 || opts.minMonth >= month)) {\n          prev = false;\n        }\n\n        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {\n          next = false;\n        }\n\n        var rightArrow = '<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z\"/><path d=\"M0-.25h24v24H0z\" fill=\"none\"/></svg>';\n        html += \"<button class=\\\"month-next\" + (next ? '' : ' is-disabled') + \"\\\" type=\\\"button\\\">\" + rightArrow + \"</button>\";\n\n        return html += '</div>';\n      }\n\n      /**\n       * refresh the HTML\n       */\n\n    }, {\n      key: \"draw\",\n      value: function draw(force) {\n        if (!this.isOpen && !force) {\n          return;\n        }\n        var opts = this.options,\n            minYear = opts.minYear,\n            maxYear = opts.maxYear,\n            minMonth = opts.minMonth,\n            maxMonth = opts.maxMonth,\n            html = '',\n            randId = void 0;\n\n        if (this._y <= minYear) {\n          this._y = minYear;\n          if (!isNaN(minMonth) && this._m < minMonth) {\n            this._m = minMonth;\n          }\n        }\n        if (this._y >= maxYear) {\n          this._y = maxYear;\n          if (!isNaN(maxMonth) && this._m > maxMonth) {\n            this._m = maxMonth;\n          }\n        }\n\n        randId = 'datepicker-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);\n\n        for (var c = 0; c < 1; c++) {\n          this._renderDateDisplay();\n          html += this.renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId);\n        }\n\n        this.destroySelects();\n\n        this.calendarEl.innerHTML = html;\n\n        // Init Materialize Select\n        var yearSelect = this.calendarEl.querySelector('.orig-select-year');\n        var monthSelect = this.calendarEl.querySelector('.orig-select-month');\n        M.FormSelect.init(yearSelect, {\n          classes: 'select-year',\n          dropdownOptions: { container: document.body, constrainWidth: false }\n        });\n        M.FormSelect.init(monthSelect, {\n          classes: 'select-month',\n          dropdownOptions: { container: document.body, constrainWidth: false }\n        });\n\n        // Add change handlers for select\n        yearSelect.addEventListener('change', this._handleYearChange.bind(this));\n        monthSelect.addEventListener('change', this._handleMonthChange.bind(this));\n\n        if (typeof this.options.onDraw === 'function') {\n          this.options.onDraw(this);\n        }\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleInputKeydownBound = this._handleInputKeydown.bind(this);\n        this._handleInputClickBound = this._handleInputClick.bind(this);\n        this._handleInputChangeBound = this._handleInputChange.bind(this);\n        this._handleCalendarClickBound = this._handleCalendarClick.bind(this);\n        this._finishSelectionBound = this._finishSelection.bind(this);\n        this._handleMonthChange = this._handleMonthChange.bind(this);\n        this._closeBound = this.close.bind(this);\n\n        this.el.addEventListener('click', this._handleInputClickBound);\n        this.el.addEventListener('keydown', this._handleInputKeydownBound);\n        this.el.addEventListener('change', this._handleInputChangeBound);\n        this.calendarEl.addEventListener('click', this._handleCalendarClickBound);\n        this.doneBtn.addEventListener('click', this._finishSelectionBound);\n        this.cancelBtn.addEventListener('click', this._closeBound);\n\n        if (this.options.showClearBtn) {\n          this._handleClearClickBound = this._handleClearClick.bind(this);\n          this.clearBtn.addEventListener('click', this._handleClearClickBound);\n        }\n      }\n    }, {\n      key: \"_setupVariables\",\n      value: function _setupVariables() {\n        var _this56 = this;\n\n        this.$modalEl = $(Datepicker._template);\n        this.modalEl = this.$modalEl[0];\n\n        this.calendarEl = this.modalEl.querySelector('.datepicker-calendar');\n\n        this.yearTextEl = this.modalEl.querySelector('.year-text');\n        this.dateTextEl = this.modalEl.querySelector('.date-text');\n        if (this.options.showClearBtn) {\n          this.clearBtn = this.modalEl.querySelector('.datepicker-clear');\n        }\n        this.doneBtn = this.modalEl.querySelector('.datepicker-done');\n        this.cancelBtn = this.modalEl.querySelector('.datepicker-cancel');\n\n        this.formats = {\n          d: function () {\n            return _this56.date.getDate();\n          },\n          dd: function () {\n            var d = _this56.date.getDate();\n            return (d < 10 ? '0' : '') + d;\n          },\n          ddd: function () {\n            return _this56.options.i18n.weekdaysShort[_this56.date.getDay()];\n          },\n          dddd: function () {\n            return _this56.options.i18n.weekdays[_this56.date.getDay()];\n          },\n          m: function () {\n            return _this56.date.getMonth() + 1;\n          },\n          mm: function () {\n            var m = _this56.date.getMonth() + 1;\n            return (m < 10 ? '0' : '') + m;\n          },\n          mmm: function () {\n            return _this56.options.i18n.monthsShort[_this56.date.getMonth()];\n          },\n          mmmm: function () {\n            return _this56.options.i18n.months[_this56.date.getMonth()];\n          },\n          yy: function () {\n            return ('' + _this56.date.getFullYear()).slice(2);\n          },\n          yyyy: function () {\n            return _this56.date.getFullYear();\n          }\n        };\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('click', this._handleInputClickBound);\n        this.el.removeEventListener('keydown', this._handleInputKeydownBound);\n        this.el.removeEventListener('change', this._handleInputChangeBound);\n        this.calendarEl.removeEventListener('click', this._handleCalendarClickBound);\n      }\n    }, {\n      key: \"_handleInputClick\",\n      value: function _handleInputClick() {\n        this.open();\n      }\n    }, {\n      key: \"_handleInputKeydown\",\n      value: function _handleInputKeydown(e) {\n        if (e.which === M.keys.ENTER) {\n          e.preventDefault();\n          this.open();\n        }\n      }\n    }, {\n      key: \"_handleCalendarClick\",\n      value: function _handleCalendarClick(e) {\n        if (!this.isOpen) {\n          return;\n        }\n\n        var $target = $(e.target);\n        if (!$target.hasClass('is-disabled')) {\n          if ($target.hasClass('datepicker-day-button') && !$target.hasClass('is-empty') && !$target.parent().hasClass('is-disabled')) {\n            this.setDate(new Date(e.target.getAttribute('data-year'), e.target.getAttribute('data-month'), e.target.getAttribute('data-day')));\n            if (this.options.autoClose) {\n              this._finishSelection();\n            }\n          } else if ($target.closest('.month-prev').length) {\n            this.prevMonth();\n          } else if ($target.closest('.month-next').length) {\n            this.nextMonth();\n          }\n        }\n      }\n    }, {\n      key: \"_handleClearClick\",\n      value: function _handleClearClick() {\n        this.date = null;\n        this.setInputValue();\n        this.close();\n      }\n    }, {\n      key: \"_handleMonthChange\",\n      value: function _handleMonthChange(e) {\n        this.gotoMonth(e.target.value);\n      }\n    }, {\n      key: \"_handleYearChange\",\n      value: function _handleYearChange(e) {\n        this.gotoYear(e.target.value);\n      }\n\n      /**\n       * change view to a specific month (zero-index, e.g. 0: January)\n       */\n\n    }, {\n      key: \"gotoMonth\",\n      value: function gotoMonth(month) {\n        if (!isNaN(month)) {\n          this.calendars[0].month = parseInt(month, 10);\n          this.adjustCalendars();\n        }\n      }\n\n      /**\n       * change view to a specific full year (e.g. \"2012\")\n       */\n\n    }, {\n      key: \"gotoYear\",\n      value: function gotoYear(year) {\n        if (!isNaN(year)) {\n          this.calendars[0].year = parseInt(year, 10);\n          this.adjustCalendars();\n        }\n      }\n    }, {\n      key: \"_handleInputChange\",\n      value: function _handleInputChange(e) {\n        var date = void 0;\n\n        // Prevent change event from being fired when triggered by the plugin\n        if (e.firedBy === this) {\n          return;\n        }\n        if (this.options.parse) {\n          date = this.options.parse(this.el.value, this.options.format);\n        } else {\n          date = new Date(Date.parse(this.el.value));\n        }\n\n        if (Datepicker._isDate(date)) {\n          this.setDate(date);\n        }\n      }\n    }, {\n      key: \"renderDayName\",\n      value: function renderDayName(opts, day, abbr) {\n        day += opts.firstDay;\n        while (day >= 7) {\n          day -= 7;\n        }\n        return abbr ? opts.i18n.weekdaysAbbrev[day] : opts.i18n.weekdays[day];\n      }\n\n      /**\n       * Set input value to the selected date and close Datepicker\n       */\n\n    }, {\n      key: \"_finishSelection\",\n      value: function _finishSelection() {\n        this.setInputValue();\n        this.close();\n      }\n\n      /**\n       * Open Datepicker\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this.isOpen) {\n          return;\n        }\n\n        this.isOpen = true;\n        if (typeof this.options.onOpen === 'function') {\n          this.options.onOpen.call(this);\n        }\n        this.draw();\n        this.modal.open();\n        return this;\n      }\n\n      /**\n       * Close Datepicker\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        this.isOpen = false;\n        if (typeof this.options.onClose === 'function') {\n          this.options.onClose.call(this);\n        }\n        this.modal.close();\n        return this;\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Datepicker.__proto__ || Object.getPrototypeOf(Datepicker), \"init\", this).call(this, this, els, options);\n      }\n    }, {\n      key: \"_isDate\",\n      value: function _isDate(obj) {\n        return (/Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime())\n        );\n      }\n    }, {\n      key: \"_isWeekend\",\n      value: function _isWeekend(date) {\n        var day = date.getDay();\n        return day === 0 || day === 6;\n      }\n    }, {\n      key: \"_setToStartOfDay\",\n      value: function _setToStartOfDay(date) {\n        if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);\n      }\n    }, {\n      key: \"_getDaysInMonth\",\n      value: function _getDaysInMonth(year, month) {\n        return [31, Datepicker._isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n      }\n    }, {\n      key: \"_isLeapYear\",\n      value: function _isLeapYear(year) {\n        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n      }\n    }, {\n      key: \"_compareDates\",\n      value: function _compareDates(a, b) {\n        // weak date comparison (use setToStartOfDay(date) to ensure correct result)\n        return a.getTime() === b.getTime();\n      }\n    }, {\n      key: \"_setToStartOfDay\",\n      value: function _setToStartOfDay(date) {\n        if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Datepicker;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Datepicker;\n  }(Component);\n\n  Datepicker._template = ['<div class= \"modal datepicker-modal\">', '<div class=\"modal-content datepicker-container\">', '<div class=\"datepicker-date-display\">', '<span class=\"year-text\"></span>', '<span class=\"date-text\"></span>', '</div>', '<div class=\"datepicker-calendar-container\">', '<div class=\"datepicker-calendar\"></div>', '<div class=\"datepicker-footer\">', '<button class=\"btn-flat datepicker-clear waves-effect\" style=\"visibility: hidden;\" type=\"button\"></button>', '<div class=\"confirmation-btns\">', '<button class=\"btn-flat datepicker-cancel waves-effect\" type=\"button\"></button>', '<button class=\"btn-flat datepicker-done waves-effect\" type=\"button\"></button>', '</div>', '</div>', '</div>', '</div>', '</div>'].join('');\n\n  M.Datepicker = Datepicker;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Datepicker, 'datepicker', 'M_Datepicker');\n  }\n})(cash);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    dialRadius: 135,\n    outerRadius: 105,\n    innerRadius: 70,\n    tickRadius: 20,\n    duration: 350,\n    container: null,\n    defaultTime: 'now', // default time, 'now' or '13:14' e.g.\n    fromNow: 0, // Millisecond offset from the defaultTime\n    showClearBtn: false,\n\n    // internationalization\n    i18n: {\n      cancel: 'Cancel',\n      clear: 'Clear',\n      done: 'Ok'\n    },\n\n    autoClose: false, // auto close when minute is selected\n    twelveHour: true, // change to 12 hour AM/PM clock from 24 hour\n    vibrate: true, // vibrate the device when dragging clock hand\n\n    // Callbacks\n    onOpenStart: null,\n    onOpenEnd: null,\n    onCloseStart: null,\n    onCloseEnd: null,\n    onSelect: null\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Timepicker = function (_Component16) {\n    _inherits(Timepicker, _Component16);\n\n    function Timepicker(el, options) {\n      _classCallCheck(this, Timepicker);\n\n      var _this57 = _possibleConstructorReturn(this, (Timepicker.__proto__ || Object.getPrototypeOf(Timepicker)).call(this, Timepicker, el, options));\n\n      _this57.el.M_Timepicker = _this57;\n\n      _this57.options = $.extend({}, Timepicker.defaults, options);\n\n      _this57.id = M.guid();\n      _this57._insertHTMLIntoDOM();\n      _this57._setupModal();\n      _this57._setupVariables();\n      _this57._setupEventHandlers();\n\n      _this57._clockSetup();\n      _this57._pickerSetup();\n      return _this57;\n    }\n\n    _createClass(Timepicker, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.modal.destroy();\n        $(this.modalEl).remove();\n        this.el.M_Timepicker = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleInputKeydownBound = this._handleInputKeydown.bind(this);\n        this._handleInputClickBound = this._handleInputClick.bind(this);\n        this._handleClockClickStartBound = this._handleClockClickStart.bind(this);\n        this._handleDocumentClickMoveBound = this._handleDocumentClickMove.bind(this);\n        this._handleDocumentClickEndBound = this._handleDocumentClickEnd.bind(this);\n\n        this.el.addEventListener('click', this._handleInputClickBound);\n        this.el.addEventListener('keydown', this._handleInputKeydownBound);\n        this.plate.addEventListener('mousedown', this._handleClockClickStartBound);\n        this.plate.addEventListener('touchstart', this._handleClockClickStartBound);\n\n        $(this.spanHours).on('click', this.showView.bind(this, 'hours'));\n        $(this.spanMinutes).on('click', this.showView.bind(this, 'minutes'));\n      }\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('click', this._handleInputClickBound);\n        this.el.removeEventListener('keydown', this._handleInputKeydownBound);\n      }\n    }, {\n      key: \"_handleInputClick\",\n      value: function _handleInputClick() {\n        this.open();\n      }\n    }, {\n      key: \"_handleInputKeydown\",\n      value: function _handleInputKeydown(e) {\n        if (e.which === M.keys.ENTER) {\n          e.preventDefault();\n          this.open();\n        }\n      }\n    }, {\n      key: \"_handleClockClickStart\",\n      value: function _handleClockClickStart(e) {\n        e.preventDefault();\n        var clockPlateBR = this.plate.getBoundingClientRect();\n        var offset = { x: clockPlateBR.left, y: clockPlateBR.top };\n\n        this.x0 = offset.x + this.options.dialRadius;\n        this.y0 = offset.y + this.options.dialRadius;\n        this.moved = false;\n        var clickPos = Timepicker._Pos(e);\n        this.dx = clickPos.x - this.x0;\n        this.dy = clickPos.y - this.y0;\n\n        // Set clock hands\n        this.setHand(this.dx, this.dy, false);\n\n        // Mousemove on document\n        document.addEventListener('mousemove', this._handleDocumentClickMoveBound);\n        document.addEventListener('touchmove', this._handleDocumentClickMoveBound);\n\n        // Mouseup on document\n        document.addEventListener('mouseup', this._handleDocumentClickEndBound);\n        document.addEventListener('touchend', this._handleDocumentClickEndBound);\n      }\n    }, {\n      key: \"_handleDocumentClickMove\",\n      value: function _handleDocumentClickMove(e) {\n        e.preventDefault();\n        var clickPos = Timepicker._Pos(e);\n        var x = clickPos.x - this.x0;\n        var y = clickPos.y - this.y0;\n        this.moved = true;\n        this.setHand(x, y, false, true);\n      }\n    }, {\n      key: \"_handleDocumentClickEnd\",\n      value: function _handleDocumentClickEnd(e) {\n        var _this58 = this;\n\n        e.preventDefault();\n        document.removeEventListener('mouseup', this._handleDocumentClickEndBound);\n        document.removeEventListener('touchend', this._handleDocumentClickEndBound);\n        var clickPos = Timepicker._Pos(e);\n        var x = clickPos.x - this.x0;\n        var y = clickPos.y - this.y0;\n        if (this.moved && x === this.dx && y === this.dy) {\n          this.setHand(x, y);\n        }\n\n        if (this.currentView === 'hours') {\n          this.showView('minutes', this.options.duration / 2);\n        } else if (this.options.autoClose) {\n          $(this.minutesView).addClass('timepicker-dial-out');\n          setTimeout(function () {\n            _this58.done();\n          }, this.options.duration / 2);\n        }\n\n        if (typeof this.options.onSelect === 'function') {\n          this.options.onSelect.call(this, this.hours, this.minutes);\n        }\n\n        // Unbind mousemove event\n        document.removeEventListener('mousemove', this._handleDocumentClickMoveBound);\n        document.removeEventListener('touchmove', this._handleDocumentClickMoveBound);\n      }\n    }, {\n      key: \"_insertHTMLIntoDOM\",\n      value: function _insertHTMLIntoDOM() {\n        this.$modalEl = $(Timepicker._template);\n        this.modalEl = this.$modalEl[0];\n        this.modalEl.id = 'modal-' + this.id;\n\n        // Append popover to input by default\n        var containerEl = document.querySelector(this.options.container);\n        if (this.options.container && !!containerEl) {\n          this.$modalEl.appendTo(containerEl);\n        } else {\n          this.$modalEl.insertBefore(this.el);\n        }\n      }\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        var _this59 = this;\n\n        this.modal = M.Modal.init(this.modalEl, {\n          onOpenStart: this.options.onOpenStart,\n          onOpenEnd: this.options.onOpenEnd,\n          onCloseStart: this.options.onCloseStart,\n          onCloseEnd: function () {\n            if (typeof _this59.options.onCloseEnd === 'function') {\n              _this59.options.onCloseEnd.call(_this59);\n            }\n            _this59.isOpen = false;\n          }\n        });\n      }\n    }, {\n      key: \"_setupVariables\",\n      value: function _setupVariables() {\n        this.currentView = 'hours';\n        this.vibrate = navigator.vibrate ? 'vibrate' : navigator.webkitVibrate ? 'webkitVibrate' : null;\n\n        this._canvas = this.modalEl.querySelector('.timepicker-canvas');\n        this.plate = this.modalEl.querySelector('.timepicker-plate');\n\n        this.hoursView = this.modalEl.querySelector('.timepicker-hours');\n        this.minutesView = this.modalEl.querySelector('.timepicker-minutes');\n        this.spanHours = this.modalEl.querySelector('.timepicker-span-hours');\n        this.spanMinutes = this.modalEl.querySelector('.timepicker-span-minutes');\n        this.spanAmPm = this.modalEl.querySelector('.timepicker-span-am-pm');\n        this.footer = this.modalEl.querySelector('.timepicker-footer');\n        this.amOrPm = 'PM';\n      }\n    }, {\n      key: \"_pickerSetup\",\n      value: function _pickerSetup() {\n        var $clearBtn = $(\"<button class=\\\"btn-flat timepicker-clear waves-effect\\\" style=\\\"visibility: hidden;\\\" type=\\\"button\\\" tabindex=\\\"\" + (this.options.twelveHour ? '3' : '1') + \"\\\">\" + this.options.i18n.clear + \"</button>\").appendTo(this.footer).on('click', this.clear.bind(this));\n        if (this.options.showClearBtn) {\n          $clearBtn.css({ visibility: '' });\n        }\n\n        var confirmationBtnsContainer = $('<div class=\"confirmation-btns\"></div>');\n        $('<button class=\"btn-flat timepicker-close waves-effect\" type=\"button\" tabindex=\"' + (this.options.twelveHour ? '3' : '1') + '\">' + this.options.i18n.cancel + '</button>').appendTo(confirmationBtnsContainer).on('click', this.close.bind(this));\n        $('<button class=\"btn-flat timepicker-close waves-effect\" type=\"button\" tabindex=\"' + (this.options.twelveHour ? '3' : '1') + '\">' + this.options.i18n.done + '</button>').appendTo(confirmationBtnsContainer).on('click', this.done.bind(this));\n        confirmationBtnsContainer.appendTo(this.footer);\n      }\n    }, {\n      key: \"_clockSetup\",\n      value: function _clockSetup() {\n        if (this.options.twelveHour) {\n          this.$amBtn = $('<div class=\"am-btn\">AM</div>');\n          this.$pmBtn = $('<div class=\"pm-btn\">PM</div>');\n          this.$amBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);\n          this.$pmBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);\n        }\n\n        this._buildHoursView();\n        this._buildMinutesView();\n        this._buildSVGClock();\n      }\n    }, {\n      key: \"_buildSVGClock\",\n      value: function _buildSVGClock() {\n        // Draw clock hands and others\n        var dialRadius = this.options.dialRadius;\n        var tickRadius = this.options.tickRadius;\n        var diameter = dialRadius * 2;\n\n        var svg = Timepicker._createSVGEl('svg');\n        svg.setAttribute('class', 'timepicker-svg');\n        svg.setAttribute('width', diameter);\n        svg.setAttribute('height', diameter);\n        var g = Timepicker._createSVGEl('g');\n        g.setAttribute('transform', 'translate(' + dialRadius + ',' + dialRadius + ')');\n        var bearing = Timepicker._createSVGEl('circle');\n        bearing.setAttribute('class', 'timepicker-canvas-bearing');\n        bearing.setAttribute('cx', 0);\n        bearing.setAttribute('cy', 0);\n        bearing.setAttribute('r', 4);\n        var hand = Timepicker._createSVGEl('line');\n        hand.setAttribute('x1', 0);\n        hand.setAttribute('y1', 0);\n        var bg = Timepicker._createSVGEl('circle');\n        bg.setAttribute('class', 'timepicker-canvas-bg');\n        bg.setAttribute('r', tickRadius);\n        g.appendChild(hand);\n        g.appendChild(bg);\n        g.appendChild(bearing);\n        svg.appendChild(g);\n        this._canvas.appendChild(svg);\n\n        this.hand = hand;\n        this.bg = bg;\n        this.bearing = bearing;\n        this.g = g;\n      }\n    }, {\n      key: \"_buildHoursView\",\n      value: function _buildHoursView() {\n        var $tick = $('<div class=\"timepicker-tick\"></div>');\n        // Hours view\n        if (this.options.twelveHour) {\n          for (var i = 1; i < 13; i += 1) {\n            var tick = $tick.clone();\n            var radian = i / 6 * Math.PI;\n            var radius = this.options.outerRadius;\n            tick.css({\n              left: this.options.dialRadius + Math.sin(radian) * radius - this.options.tickRadius + 'px',\n              top: this.options.dialRadius - Math.cos(radian) * radius - this.options.tickRadius + 'px'\n            });\n            tick.html(i === 0 ? '00' : i);\n            this.hoursView.appendChild(tick[0]);\n            // tick.on(mousedownEvent, mousedown);\n          }\n        } else {\n          for (var _i2 = 0; _i2 < 24; _i2 += 1) {\n            var _tick = $tick.clone();\n            var _radian = _i2 / 6 * Math.PI;\n            var inner = _i2 > 0 && _i2 < 13;\n            var _radius = inner ? this.options.innerRadius : this.options.outerRadius;\n            _tick.css({\n              left: this.options.dialRadius + Math.sin(_radian) * _radius - this.options.tickRadius + 'px',\n              top: this.options.dialRadius - Math.cos(_radian) * _radius - this.options.tickRadius + 'px'\n            });\n            _tick.html(_i2 === 0 ? '00' : _i2);\n            this.hoursView.appendChild(_tick[0]);\n            // tick.on(mousedownEvent, mousedown);\n          }\n        }\n      }\n    }, {\n      key: \"_buildMinutesView\",\n      value: function _buildMinutesView() {\n        var $tick = $('<div class=\"timepicker-tick\"></div>');\n        // Minutes view\n        for (var i = 0; i < 60; i += 5) {\n          var tick = $tick.clone();\n          var radian = i / 30 * Math.PI;\n          tick.css({\n            left: this.options.dialRadius + Math.sin(radian) * this.options.outerRadius - this.options.tickRadius + 'px',\n            top: this.options.dialRadius - Math.cos(radian) * this.options.outerRadius - this.options.tickRadius + 'px'\n          });\n          tick.html(Timepicker._addLeadingZero(i));\n          this.minutesView.appendChild(tick[0]);\n        }\n      }\n    }, {\n      key: \"_handleAmPmClick\",\n      value: function _handleAmPmClick(e) {\n        var $btnClicked = $(e.target);\n        this.amOrPm = $btnClicked.hasClass('am-btn') ? 'AM' : 'PM';\n        this._updateAmPmView();\n      }\n    }, {\n      key: \"_updateAmPmView\",\n      value: function _updateAmPmView() {\n        if (this.options.twelveHour) {\n          this.$amBtn.toggleClass('text-primary', this.amOrPm === 'AM');\n          this.$pmBtn.toggleClass('text-primary', this.amOrPm === 'PM');\n        }\n      }\n    }, {\n      key: \"_updateTimeFromInput\",\n      value: function _updateTimeFromInput() {\n        // Get the time\n        var value = ((this.el.value || this.options.defaultTime || '') + '').split(':');\n        if (this.options.twelveHour && !(typeof value[1] === 'undefined')) {\n          if (value[1].toUpperCase().indexOf('AM') > 0) {\n            this.amOrPm = 'AM';\n          } else {\n            this.amOrPm = 'PM';\n          }\n          value[1] = value[1].replace('AM', '').replace('PM', '');\n        }\n        if (value[0] === 'now') {\n          var now = new Date(+new Date() + this.options.fromNow);\n          value = [now.getHours(), now.getMinutes()];\n          if (this.options.twelveHour) {\n            this.amOrPm = value[0] >= 12 && value[0] < 24 ? 'PM' : 'AM';\n          }\n        }\n        this.hours = +value[0] || 0;\n        this.minutes = +value[1] || 0;\n        this.spanHours.innerHTML = this.hours;\n        this.spanMinutes.innerHTML = Timepicker._addLeadingZero(this.minutes);\n\n        this._updateAmPmView();\n      }\n    }, {\n      key: \"showView\",\n      value: function showView(view, delay) {\n        if (view === 'minutes' && $(this.hoursView).css('visibility') === 'visible') {\n          // raiseCallback(this.options.beforeHourSelect);\n        }\n        var isHours = view === 'hours',\n            nextView = isHours ? this.hoursView : this.minutesView,\n            hideView = isHours ? this.minutesView : this.hoursView;\n        this.currentView = view;\n\n        $(this.spanHours).toggleClass('text-primary', isHours);\n        $(this.spanMinutes).toggleClass('text-primary', !isHours);\n\n        // Transition view\n        hideView.classList.add('timepicker-dial-out');\n        $(nextView).css('visibility', 'visible').removeClass('timepicker-dial-out');\n\n        // Reset clock hand\n        this.resetClock(delay);\n\n        // After transitions ended\n        clearTimeout(this.toggleViewTimer);\n        this.toggleViewTimer = setTimeout(function () {\n          $(hideView).css('visibility', 'hidden');\n        }, this.options.duration);\n      }\n    }, {\n      key: \"resetClock\",\n      value: function resetClock(delay) {\n        var view = this.currentView,\n            value = this[view],\n            isHours = view === 'hours',\n            unit = Math.PI / (isHours ? 6 : 30),\n            radian = value * unit,\n            radius = isHours && value > 0 && value < 13 ? this.options.innerRadius : this.options.outerRadius,\n            x = Math.sin(radian) * radius,\n            y = -Math.cos(radian) * radius,\n            self = this;\n\n        if (delay) {\n          $(this.canvas).addClass('timepicker-canvas-out');\n          setTimeout(function () {\n            $(self.canvas).removeClass('timepicker-canvas-out');\n            self.setHand(x, y);\n          }, delay);\n        } else {\n          this.setHand(x, y);\n        }\n      }\n    }, {\n      key: \"setHand\",\n      value: function setHand(x, y, roundBy5) {\n        var _this60 = this;\n\n        var radian = Math.atan2(x, -y),\n            isHours = this.currentView === 'hours',\n            unit = Math.PI / (isHours || roundBy5 ? 6 : 30),\n            z = Math.sqrt(x * x + y * y),\n            inner = isHours && z < (this.options.outerRadius + this.options.innerRadius) / 2,\n            radius = inner ? this.options.innerRadius : this.options.outerRadius;\n\n        if (this.options.twelveHour) {\n          radius = this.options.outerRadius;\n        }\n\n        // Radian should in range [0, 2PI]\n        if (radian < 0) {\n          radian = Math.PI * 2 + radian;\n        }\n\n        // Get the round value\n        var value = Math.round(radian / unit);\n\n        // Get the round radian\n        radian = value * unit;\n\n        // Correct the hours or minutes\n        if (this.options.twelveHour) {\n          if (isHours) {\n            if (value === 0) value = 12;\n          } else {\n            if (roundBy5) value *= 5;\n            if (value === 60) value = 0;\n          }\n        } else {\n          if (isHours) {\n            if (value === 12) {\n              value = 0;\n            }\n            value = inner ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;\n          } else {\n            if (roundBy5) {\n              value *= 5;\n            }\n            if (value === 60) {\n              value = 0;\n            }\n          }\n        }\n\n        // Once hours or minutes changed, vibrate the device\n        if (this[this.currentView] !== value) {\n          if (this.vibrate && this.options.vibrate) {\n            // Do not vibrate too frequently\n            if (!this.vibrateTimer) {\n              navigator[this.vibrate](10);\n              this.vibrateTimer = setTimeout(function () {\n                _this60.vibrateTimer = null;\n              }, 100);\n            }\n          }\n        }\n\n        this[this.currentView] = value;\n        if (isHours) {\n          this['spanHours'].innerHTML = value;\n        } else {\n          this['spanMinutes'].innerHTML = Timepicker._addLeadingZero(value);\n        }\n\n        // Set clock hand and others' position\n        var cx1 = Math.sin(radian) * (radius - this.options.tickRadius),\n            cy1 = -Math.cos(radian) * (radius - this.options.tickRadius),\n            cx2 = Math.sin(radian) * radius,\n            cy2 = -Math.cos(radian) * radius;\n        this.hand.setAttribute('x2', cx1);\n        this.hand.setAttribute('y2', cy1);\n        this.bg.setAttribute('cx', cx2);\n        this.bg.setAttribute('cy', cy2);\n      }\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this.isOpen) {\n          return;\n        }\n\n        this.isOpen = true;\n        this._updateTimeFromInput();\n        this.showView('hours');\n\n        this.modal.open();\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        this.isOpen = false;\n        this.modal.close();\n      }\n\n      /**\n       * Finish timepicker selection.\n       */\n\n    }, {\n      key: \"done\",\n      value: function done(e, clearValue) {\n        // Set input value\n        var last = this.el.value;\n        var value = clearValue ? '' : Timepicker._addLeadingZero(this.hours) + ':' + Timepicker._addLeadingZero(this.minutes);\n        this.time = value;\n        if (!clearValue && this.options.twelveHour) {\n          value = value + \" \" + this.amOrPm;\n        }\n        this.el.value = value;\n\n        // Trigger change event\n        if (value !== last) {\n          this.$el.trigger('change');\n        }\n\n        this.close();\n        this.el.focus();\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.done(null, true);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Timepicker.__proto__ || Object.getPrototypeOf(Timepicker), \"init\", this).call(this, this, els, options);\n      }\n    }, {\n      key: \"_addLeadingZero\",\n      value: function _addLeadingZero(num) {\n        return (num < 10 ? '0' : '') + num;\n      }\n    }, {\n      key: \"_createSVGEl\",\n      value: function _createSVGEl(name) {\n        var svgNS = 'http://www.w3.org/2000/svg';\n        return document.createElementNS(svgNS, name);\n      }\n\n      /**\n       * @typedef {Object} Point\n       * @property {number} x The X Coordinate\n       * @property {number} y The Y Coordinate\n       */\n\n      /**\n       * Get x position of mouse or touch event\n       * @param {Event} e\n       * @return {Point} x and y location\n       */\n\n    }, {\n      key: \"_Pos\",\n      value: function _Pos(e) {\n        if (e.targetTouches && e.targetTouches.length >= 1) {\n          return { x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY };\n        }\n        // mouse event\n        return { x: e.clientX, y: e.clientY };\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Timepicker;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Timepicker;\n  }(Component);\n\n  Timepicker._template = ['<div class= \"modal timepicker-modal\">', '<div class=\"modal-content timepicker-container\">', '<div class=\"timepicker-digital-display\">', '<div class=\"timepicker-text-container\">', '<div class=\"timepicker-display-column\">', '<span class=\"timepicker-span-hours text-primary\"></span>', ':', '<span class=\"timepicker-span-minutes\"></span>', '</div>', '<div class=\"timepicker-display-column timepicker-display-am-pm\">', '<div class=\"timepicker-span-am-pm\"></div>', '</div>', '</div>', '</div>', '<div class=\"timepicker-analog-display\">', '<div class=\"timepicker-plate\">', '<div class=\"timepicker-canvas\"></div>', '<div class=\"timepicker-dial timepicker-hours\"></div>', '<div class=\"timepicker-dial timepicker-minutes timepicker-dial-out\"></div>', '</div>', '<div class=\"timepicker-footer\"></div>', '</div>', '</div>', '</div>'].join('');\n\n  M.Timepicker = Timepicker;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Timepicker, 'timepicker', 'M_Timepicker');\n  }\n})(cash);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {};\n\n  /**\n   * @class\n   *\n   */\n\n  var CharacterCounter = function (_Component17) {\n    _inherits(CharacterCounter, _Component17);\n\n    /**\n     * Construct CharacterCounter instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function CharacterCounter(el, options) {\n      _classCallCheck(this, CharacterCounter);\n\n      var _this61 = _possibleConstructorReturn(this, (CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter)).call(this, CharacterCounter, el, options));\n\n      _this61.el.M_CharacterCounter = _this61;\n\n      /**\n       * Options for the character counter\n       */\n      _this61.options = $.extend({}, CharacterCounter.defaults, options);\n\n      _this61.isInvalid = false;\n      _this61.isValidLength = false;\n      _this61._setupCounter();\n      _this61._setupEventHandlers();\n      return _this61;\n    }\n\n    _createClass(CharacterCounter, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.el.CharacterCounter = undefined;\n        this._removeCounter();\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleUpdateCounterBound = this.updateCounter.bind(this);\n\n        this.el.addEventListener('focus', this._handleUpdateCounterBound, true);\n        this.el.addEventListener('input', this._handleUpdateCounterBound, true);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('focus', this._handleUpdateCounterBound, true);\n        this.el.removeEventListener('input', this._handleUpdateCounterBound, true);\n      }\n\n      /**\n       * Setup counter element\n       */\n\n    }, {\n      key: \"_setupCounter\",\n      value: function _setupCounter() {\n        this.counterEl = document.createElement('span');\n        $(this.counterEl).addClass('character-counter').css({\n          float: 'right',\n          'font-size': '12px',\n          height: 1\n        });\n\n        this.$el.parent().append(this.counterEl);\n      }\n\n      /**\n       * Remove counter element\n       */\n\n    }, {\n      key: \"_removeCounter\",\n      value: function _removeCounter() {\n        $(this.counterEl).remove();\n      }\n\n      /**\n       * Update counter\n       */\n\n    }, {\n      key: \"updateCounter\",\n      value: function updateCounter() {\n        var maxLength = +this.$el.attr('data-length'),\n            actualLength = this.el.value.length;\n        this.isValidLength = actualLength <= maxLength;\n        var counterString = actualLength;\n\n        if (maxLength) {\n          counterString += '/' + maxLength;\n          this._validateInput();\n        }\n\n        $(this.counterEl).html(counterString);\n      }\n\n      /**\n       * Add validation classes\n       */\n\n    }, {\n      key: \"_validateInput\",\n      value: function _validateInput() {\n        if (this.isValidLength && this.isInvalid) {\n          this.isInvalid = false;\n          this.$el.removeClass('invalid');\n        } else if (!this.isValidLength && !this.isInvalid) {\n          this.isInvalid = true;\n          this.$el.removeClass('valid');\n          this.$el.addClass('invalid');\n        }\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_CharacterCounter;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return CharacterCounter;\n  }(Component);\n\n  M.CharacterCounter = CharacterCounter;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(CharacterCounter, 'characterCounter', 'M_CharacterCounter');\n  }\n})(cash);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    duration: 200, // ms\n    dist: -100, // zoom scale TODO: make this more intuitive as an option\n    shift: 0, // spacing for center image\n    padding: 0, // Padding between non center items\n    numVisible: 5, // Number of visible items in carousel\n    fullWidth: false, // Change to full width styles\n    indicators: false, // Toggle indicators\n    noWrap: false, // Don't wrap around and cycle through items.\n    onCycleTo: null // Callback for when a new slide is cycled to.\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var Carousel = function (_Component18) {\n    _inherits(Carousel, _Component18);\n\n    /**\n     * Construct Carousel instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Carousel(el, options) {\n      _classCallCheck(this, Carousel);\n\n      var _this62 = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, Carousel, el, options));\n\n      _this62.el.M_Carousel = _this62;\n\n      /**\n       * Options for the carousel\n       * @member Carousel#options\n       * @prop {Number} duration\n       * @prop {Number} dist\n       * @prop {Number} shift\n       * @prop {Number} padding\n       * @prop {Number} numVisible\n       * @prop {Boolean} fullWidth\n       * @prop {Boolean} indicators\n       * @prop {Boolean} noWrap\n       * @prop {Function} onCycleTo\n       */\n      _this62.options = $.extend({}, Carousel.defaults, options);\n\n      // Setup\n      _this62.hasMultipleSlides = _this62.$el.find('.carousel-item').length > 1;\n      _this62.showIndicators = _this62.options.indicators && _this62.hasMultipleSlides;\n      _this62.noWrap = _this62.options.noWrap || !_this62.hasMultipleSlides;\n      _this62.pressed = false;\n      _this62.dragged = false;\n      _this62.offset = _this62.target = 0;\n      _this62.images = [];\n      _this62.itemWidth = _this62.$el.find('.carousel-item').first().innerWidth();\n      _this62.itemHeight = _this62.$el.find('.carousel-item').first().innerHeight();\n      _this62.dim = _this62.itemWidth * 2 + _this62.options.padding || 1; // Make sure dim is non zero for divisions.\n      _this62._autoScrollBound = _this62._autoScroll.bind(_this62);\n      _this62._trackBound = _this62._track.bind(_this62);\n\n      // Full Width carousel setup\n      if (_this62.options.fullWidth) {\n        _this62.options.dist = 0;\n        _this62._setCarouselHeight();\n\n        // Offset fixed items when indicators.\n        if (_this62.showIndicators) {\n          _this62.$el.find('.carousel-fixed-item').addClass('with-indicators');\n        }\n      }\n\n      // Iterate through slides\n      _this62.$indicators = $('<ul class=\"indicators\"></ul>');\n      _this62.$el.find('.carousel-item').each(function (el, i) {\n        _this62.images.push(el);\n        if (_this62.showIndicators) {\n          var $indicator = $('<li class=\"indicator-item\"></li>');\n\n          // Add active to first by default.\n          if (i === 0) {\n            $indicator[0].classList.add('active');\n          }\n\n          _this62.$indicators.append($indicator);\n        }\n      });\n      if (_this62.showIndicators) {\n        _this62.$el.append(_this62.$indicators);\n      }\n      _this62.count = _this62.images.length;\n\n      // Cap numVisible at count\n      _this62.options.numVisible = Math.min(_this62.count, _this62.options.numVisible);\n\n      // Setup cross browser string\n      _this62.xform = 'transform';\n      ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {\n        var e = prefix + 'Transform';\n        if (typeof document.body.style[e] !== 'undefined') {\n          _this62.xform = e;\n          return false;\n        }\n        return true;\n      });\n\n      _this62._setupEventHandlers();\n      _this62._scroll(_this62.offset);\n      return _this62;\n    }\n\n    _createClass(Carousel, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.el.M_Carousel = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        var _this63 = this;\n\n        this._handleCarouselTapBound = this._handleCarouselTap.bind(this);\n        this._handleCarouselDragBound = this._handleCarouselDrag.bind(this);\n        this._handleCarouselReleaseBound = this._handleCarouselRelease.bind(this);\n        this._handleCarouselClickBound = this._handleCarouselClick.bind(this);\n\n        if (typeof window.ontouchstart !== 'undefined') {\n          this.el.addEventListener('touchstart', this._handleCarouselTapBound);\n          this.el.addEventListener('touchmove', this._handleCarouselDragBound);\n          this.el.addEventListener('touchend', this._handleCarouselReleaseBound);\n        }\n\n        this.el.addEventListener('mousedown', this._handleCarouselTapBound);\n        this.el.addEventListener('mousemove', this._handleCarouselDragBound);\n        this.el.addEventListener('mouseup', this._handleCarouselReleaseBound);\n        this.el.addEventListener('mouseleave', this._handleCarouselReleaseBound);\n        this.el.addEventListener('click', this._handleCarouselClickBound);\n\n        if (this.showIndicators && this.$indicators) {\n          this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);\n          this.$indicators.find('.indicator-item').each(function (el, i) {\n            el.addEventListener('click', _this63._handleIndicatorClickBound);\n          });\n        }\n\n        // Resize\n        var throttledResize = M.throttle(this._handleResize, 200);\n        this._handleThrottledResizeBound = throttledResize.bind(this);\n\n        window.addEventListener('resize', this._handleThrottledResizeBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        var _this64 = this;\n\n        if (typeof window.ontouchstart !== 'undefined') {\n          this.el.removeEventListener('touchstart', this._handleCarouselTapBound);\n          this.el.removeEventListener('touchmove', this._handleCarouselDragBound);\n          this.el.removeEventListener('touchend', this._handleCarouselReleaseBound);\n        }\n        this.el.removeEventListener('mousedown', this._handleCarouselTapBound);\n        this.el.removeEventListener('mousemove', this._handleCarouselDragBound);\n        this.el.removeEventListener('mouseup', this._handleCarouselReleaseBound);\n        this.el.removeEventListener('mouseleave', this._handleCarouselReleaseBound);\n        this.el.removeEventListener('click', this._handleCarouselClickBound);\n\n        if (this.showIndicators && this.$indicators) {\n          this.$indicators.find('.indicator-item').each(function (el, i) {\n            el.removeEventListener('click', _this64._handleIndicatorClickBound);\n          });\n        }\n\n        window.removeEventListener('resize', this._handleThrottledResizeBound);\n      }\n\n      /**\n       * Handle Carousel Tap\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCarouselTap\",\n      value: function _handleCarouselTap(e) {\n        // Fixes firefox draggable image bug\n        if (e.type === 'mousedown' && $(e.target).is('img')) {\n          e.preventDefault();\n        }\n        this.pressed = true;\n        this.dragged = false;\n        this.verticalDragged = false;\n        this.reference = this._xpos(e);\n        this.referenceY = this._ypos(e);\n\n        this.velocity = this.amplitude = 0;\n        this.frame = this.offset;\n        this.timestamp = Date.now();\n        clearInterval(this.ticker);\n        this.ticker = setInterval(this._trackBound, 100);\n      }\n\n      /**\n       * Handle Carousel Drag\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCarouselDrag\",\n      value: function _handleCarouselDrag(e) {\n        var x = void 0,\n            y = void 0,\n            delta = void 0,\n            deltaY = void 0;\n        if (this.pressed) {\n          x = this._xpos(e);\n          y = this._ypos(e);\n          delta = this.reference - x;\n          deltaY = Math.abs(this.referenceY - y);\n          if (deltaY < 30 && !this.verticalDragged) {\n            // If vertical scrolling don't allow dragging.\n            if (delta > 2 || delta < -2) {\n              this.dragged = true;\n              this.reference = x;\n              this._scroll(this.offset + delta);\n            }\n          } else if (this.dragged) {\n            // If dragging don't allow vertical scroll.\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n          } else {\n            // Vertical scrolling.\n            this.verticalDragged = true;\n          }\n        }\n\n        if (this.dragged) {\n          // If dragging don't allow vertical scroll.\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      }\n\n      /**\n       * Handle Carousel Release\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCarouselRelease\",\n      value: function _handleCarouselRelease(e) {\n        if (this.pressed) {\n          this.pressed = false;\n        } else {\n          return;\n        }\n\n        clearInterval(this.ticker);\n        this.target = this.offset;\n        if (this.velocity > 10 || this.velocity < -10) {\n          this.amplitude = 0.9 * this.velocity;\n          this.target = this.offset + this.amplitude;\n        }\n        this.target = Math.round(this.target / this.dim) * this.dim;\n\n        // No wrap of items.\n        if (this.noWrap) {\n          if (this.target >= this.dim * (this.count - 1)) {\n            this.target = this.dim * (this.count - 1);\n          } else if (this.target < 0) {\n            this.target = 0;\n          }\n        }\n        this.amplitude = this.target - this.offset;\n        this.timestamp = Date.now();\n        requestAnimationFrame(this._autoScrollBound);\n\n        if (this.dragged) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        return false;\n      }\n\n      /**\n       * Handle Carousel CLick\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleCarouselClick\",\n      value: function _handleCarouselClick(e) {\n        // Disable clicks if carousel was dragged.\n        if (this.dragged) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        } else if (!this.options.fullWidth) {\n          var clickedIndex = $(e.target).closest('.carousel-item').index();\n          var diff = this._wrap(this.center) - clickedIndex;\n\n          // Disable clicks if carousel was shifted by click\n          if (diff !== 0) {\n            e.preventDefault();\n            e.stopPropagation();\n          }\n          this._cycleTo(clickedIndex);\n        }\n      }\n\n      /**\n       * Handle Indicator CLick\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleIndicatorClick\",\n      value: function _handleIndicatorClick(e) {\n        e.stopPropagation();\n\n        var indicator = $(e.target).closest('.indicator-item');\n        if (indicator.length) {\n          this._cycleTo(indicator.index());\n        }\n      }\n\n      /**\n       * Handle Throttle Resize\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleResize\",\n      value: function _handleResize(e) {\n        if (this.options.fullWidth) {\n          this.itemWidth = this.$el.find('.carousel-item').first().innerWidth();\n          this.imageHeight = this.$el.find('.carousel-item.active').height();\n          this.dim = this.itemWidth * 2 + this.options.padding;\n          this.offset = this.center * 2 * this.itemWidth;\n          this.target = this.offset;\n          this._setCarouselHeight(true);\n        } else {\n          this._scroll();\n        }\n      }\n\n      /**\n       * Set carousel height based on first slide\n       * @param {Booleam} imageOnly - true for image slides\n       */\n\n    }, {\n      key: \"_setCarouselHeight\",\n      value: function _setCarouselHeight(imageOnly) {\n        var _this65 = this;\n\n        var firstSlide = this.$el.find('.carousel-item.active').length ? this.$el.find('.carousel-item.active').first() : this.$el.find('.carousel-item').first();\n        var firstImage = firstSlide.find('img').first();\n        if (firstImage.length) {\n          if (firstImage[0].complete) {\n            // If image won't trigger the load event\n            var imageHeight = firstImage.height();\n            if (imageHeight > 0) {\n              this.$el.css('height', imageHeight + 'px');\n            } else {\n              // If image still has no height, use the natural dimensions to calculate\n              var naturalWidth = firstImage[0].naturalWidth;\n              var naturalHeight = firstImage[0].naturalHeight;\n              var adjustedHeight = this.$el.width() / naturalWidth * naturalHeight;\n              this.$el.css('height', adjustedHeight + 'px');\n            }\n          } else {\n            // Get height when image is loaded normally\n            firstImage.one('load', function (el, i) {\n              _this65.$el.css('height', el.offsetHeight + 'px');\n            });\n          }\n        } else if (!imageOnly) {\n          var slideHeight = firstSlide.height();\n          this.$el.css('height', slideHeight + 'px');\n        }\n      }\n\n      /**\n       * Get x position from event\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_xpos\",\n      value: function _xpos(e) {\n        // touch event\n        if (e.targetTouches && e.targetTouches.length >= 1) {\n          return e.targetTouches[0].clientX;\n        }\n\n        // mouse event\n        return e.clientX;\n      }\n\n      /**\n       * Get y position from event\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_ypos\",\n      value: function _ypos(e) {\n        // touch event\n        if (e.targetTouches && e.targetTouches.length >= 1) {\n          return e.targetTouches[0].clientY;\n        }\n\n        // mouse event\n        return e.clientY;\n      }\n\n      /**\n       * Wrap index\n       * @param {Number} x\n       */\n\n    }, {\n      key: \"_wrap\",\n      value: function _wrap(x) {\n        return x >= this.count ? x % this.count : x < 0 ? this._wrap(this.count + x % this.count) : x;\n      }\n\n      /**\n       * Tracks scrolling information\n       */\n\n    }, {\n      key: \"_track\",\n      value: function _track() {\n        var now = void 0,\n            elapsed = void 0,\n            delta = void 0,\n            v = void 0;\n\n        now = Date.now();\n        elapsed = now - this.timestamp;\n        this.timestamp = now;\n        delta = this.offset - this.frame;\n        this.frame = this.offset;\n\n        v = 1000 * delta / (1 + elapsed);\n        this.velocity = 0.8 * v + 0.2 * this.velocity;\n      }\n\n      /**\n       * Auto scrolls to nearest carousel item.\n       */\n\n    }, {\n      key: \"_autoScroll\",\n      value: function _autoScroll() {\n        var elapsed = void 0,\n            delta = void 0;\n\n        if (this.amplitude) {\n          elapsed = Date.now() - this.timestamp;\n          delta = this.amplitude * Math.exp(-elapsed / this.options.duration);\n          if (delta > 2 || delta < -2) {\n            this._scroll(this.target - delta);\n            requestAnimationFrame(this._autoScrollBound);\n          } else {\n            this._scroll(this.target);\n          }\n        }\n      }\n\n      /**\n       * Scroll to target\n       * @param {Number} x\n       */\n\n    }, {\n      key: \"_scroll\",\n      value: function _scroll(x) {\n        var _this66 = this;\n\n        // Track scrolling state\n        if (!this.$el.hasClass('scrolling')) {\n          this.el.classList.add('scrolling');\n        }\n        if (this.scrollingTimeout != null) {\n          window.clearTimeout(this.scrollingTimeout);\n        }\n        this.scrollingTimeout = window.setTimeout(function () {\n          _this66.$el.removeClass('scrolling');\n        }, this.options.duration);\n\n        // Start actual scroll\n        var i = void 0,\n            half = void 0,\n            delta = void 0,\n            dir = void 0,\n            tween = void 0,\n            el = void 0,\n            alignment = void 0,\n            zTranslation = void 0,\n            tweenedOpacity = void 0,\n            centerTweenedOpacity = void 0;\n        var lastCenter = this.center;\n        var numVisibleOffset = 1 / this.options.numVisible;\n\n        this.offset = typeof x === 'number' ? x : this.offset;\n        this.center = Math.floor((this.offset + this.dim / 2) / this.dim);\n        delta = this.offset - this.center * this.dim;\n        dir = delta < 0 ? 1 : -1;\n        tween = -dir * delta * 2 / this.dim;\n        half = this.count >> 1;\n\n        if (this.options.fullWidth) {\n          alignment = 'translateX(0)';\n          centerTweenedOpacity = 1;\n        } else {\n          alignment = 'translateX(' + (this.el.clientWidth - this.itemWidth) / 2 + 'px) ';\n          alignment += 'translateY(' + (this.el.clientHeight - this.itemHeight) / 2 + 'px)';\n          centerTweenedOpacity = 1 - numVisibleOffset * tween;\n        }\n\n        // Set indicator active\n        if (this.showIndicators) {\n          var diff = this.center % this.count;\n          var activeIndicator = this.$indicators.find('.indicator-item.active');\n          if (activeIndicator.index() !== diff) {\n            activeIndicator.removeClass('active');\n            this.$indicators.find('.indicator-item').eq(diff)[0].classList.add('active');\n          }\n        }\n\n        // center\n        // Don't show wrapped items.\n        if (!this.noWrap || this.center >= 0 && this.center < this.count) {\n          el = this.images[this._wrap(this.center)];\n\n          // Add active class to center item.\n          if (!$(el).hasClass('active')) {\n            this.$el.find('.carousel-item').removeClass('active');\n            el.classList.add('active');\n          }\n          var transformString = alignment + \" translateX(\" + -delta / 2 + \"px) translateX(\" + dir * this.options.shift * tween * i + \"px) translateZ(\" + this.options.dist * tween + \"px)\";\n          this._updateItemStyle(el, centerTweenedOpacity, 0, transformString);\n        }\n\n        for (i = 1; i <= half; ++i) {\n          // right side\n          if (this.options.fullWidth) {\n            zTranslation = this.options.dist;\n            tweenedOpacity = i === half && delta < 0 ? 1 - tween : 1;\n          } else {\n            zTranslation = this.options.dist * (i * 2 + tween * dir);\n            tweenedOpacity = 1 - numVisibleOffset * (i * 2 + tween * dir);\n          }\n          // Don't show wrapped items.\n          if (!this.noWrap || this.center + i < this.count) {\n            el = this.images[this._wrap(this.center + i)];\n            var _transformString = alignment + \" translateX(\" + (this.options.shift + (this.dim * i - delta) / 2) + \"px) translateZ(\" + zTranslation + \"px)\";\n            this._updateItemStyle(el, tweenedOpacity, -i, _transformString);\n          }\n\n          // left side\n          if (this.options.fullWidth) {\n            zTranslation = this.options.dist;\n            tweenedOpacity = i === half && delta > 0 ? 1 - tween : 1;\n          } else {\n            zTranslation = this.options.dist * (i * 2 - tween * dir);\n            tweenedOpacity = 1 - numVisibleOffset * (i * 2 - tween * dir);\n          }\n          // Don't show wrapped items.\n          if (!this.noWrap || this.center - i >= 0) {\n            el = this.images[this._wrap(this.center - i)];\n            var _transformString2 = alignment + \" translateX(\" + (-this.options.shift + (-this.dim * i - delta) / 2) + \"px) translateZ(\" + zTranslation + \"px)\";\n            this._updateItemStyle(el, tweenedOpacity, -i, _transformString2);\n          }\n        }\n\n        // center\n        // Don't show wrapped items.\n        if (!this.noWrap || this.center >= 0 && this.center < this.count) {\n          el = this.images[this._wrap(this.center)];\n          var _transformString3 = alignment + \" translateX(\" + -delta / 2 + \"px) translateX(\" + dir * this.options.shift * tween + \"px) translateZ(\" + this.options.dist * tween + \"px)\";\n          this._updateItemStyle(el, centerTweenedOpacity, 0, _transformString3);\n        }\n\n        // onCycleTo callback\n        var $currItem = this.$el.find('.carousel-item').eq(this._wrap(this.center));\n        if (lastCenter !== this.center && typeof this.options.onCycleTo === 'function') {\n          this.options.onCycleTo.call(this, $currItem[0], this.dragged);\n        }\n\n        // One time callback\n        if (typeof this.oneTimeCallback === 'function') {\n          this.oneTimeCallback.call(this, $currItem[0], this.dragged);\n          this.oneTimeCallback = null;\n        }\n      }\n\n      /**\n       * Cycle to target\n       * @param {Element} el\n       * @param {Number} opacity\n       * @param {Number} zIndex\n       * @param {String} transform\n       */\n\n    }, {\n      key: \"_updateItemStyle\",\n      value: function _updateItemStyle(el, opacity, zIndex, transform) {\n        el.style[this.xform] = transform;\n        el.style.zIndex = zIndex;\n        el.style.opacity = opacity;\n        el.style.visibility = 'visible';\n      }\n\n      /**\n       * Cycle to target\n       * @param {Number} n\n       * @param {Function} callback\n       */\n\n    }, {\n      key: \"_cycleTo\",\n      value: function _cycleTo(n, callback) {\n        var diff = this.center % this.count - n;\n\n        // Account for wraparound.\n        if (!this.noWrap) {\n          if (diff < 0) {\n            if (Math.abs(diff + this.count) < Math.abs(diff)) {\n              diff += this.count;\n            }\n          } else if (diff > 0) {\n            if (Math.abs(diff - this.count) < diff) {\n              diff -= this.count;\n            }\n          }\n        }\n\n        this.target = this.dim * Math.round(this.offset / this.dim);\n        // Next\n        if (diff < 0) {\n          this.target += this.dim * Math.abs(diff);\n\n          // Prev\n        } else if (diff > 0) {\n          this.target -= this.dim * diff;\n        }\n\n        // Set one time callback\n        if (typeof callback === 'function') {\n          this.oneTimeCallback = callback;\n        }\n\n        // Scroll\n        if (this.offset !== this.target) {\n          this.amplitude = this.target - this.offset;\n          this.timestamp = Date.now();\n          requestAnimationFrame(this._autoScrollBound);\n        }\n      }\n\n      /**\n       * Cycle to next item\n       * @param {Number} [n]\n       */\n\n    }, {\n      key: \"next\",\n      value: function next(n) {\n        if (n === undefined || isNaN(n)) {\n          n = 1;\n        }\n\n        var index = this.center + n;\n        if (index >= this.count || index < 0) {\n          if (this.noWrap) {\n            return;\n          }\n\n          index = this._wrap(index);\n        }\n        this._cycleTo(index);\n      }\n\n      /**\n       * Cycle to previous item\n       * @param {Number} [n]\n       */\n\n    }, {\n      key: \"prev\",\n      value: function prev(n) {\n        if (n === undefined || isNaN(n)) {\n          n = 1;\n        }\n\n        var index = this.center - n;\n        if (index >= this.count || index < 0) {\n          if (this.noWrap) {\n            return;\n          }\n\n          index = this._wrap(index);\n        }\n\n        this._cycleTo(index);\n      }\n\n      /**\n       * Cycle to nth item\n       * @param {Number} [n]\n       * @param {Function} callback\n       */\n\n    }, {\n      key: \"set\",\n      value: function set(n, callback) {\n        if (n === undefined || isNaN(n)) {\n          n = 0;\n        }\n\n        if (n > this.count || n < 0) {\n          if (this.noWrap) {\n            return;\n          }\n\n          n = this._wrap(n);\n        }\n\n        this._cycleTo(n, callback);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Carousel.__proto__ || Object.getPrototypeOf(Carousel), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Carousel;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Carousel;\n  }(Component);\n\n  M.Carousel = Carousel;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Carousel, 'carousel', 'M_Carousel');\n  }\n})(cash);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    onOpen: undefined,\n    onClose: undefined\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var TapTarget = function (_Component19) {\n    _inherits(TapTarget, _Component19);\n\n    /**\n     * Construct TapTarget instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function TapTarget(el, options) {\n      _classCallCheck(this, TapTarget);\n\n      var _this67 = _possibleConstructorReturn(this, (TapTarget.__proto__ || Object.getPrototypeOf(TapTarget)).call(this, TapTarget, el, options));\n\n      _this67.el.M_TapTarget = _this67;\n\n      /**\n       * Options for the select\n       * @member TapTarget#options\n       * @prop {Function} onOpen - Callback function called when feature discovery is opened\n       * @prop {Function} onClose - Callback function called when feature discovery is closed\n       */\n      _this67.options = $.extend({}, TapTarget.defaults, options);\n\n      _this67.isOpen = false;\n\n      // setup\n      _this67.$origin = $('#' + _this67.$el.attr('data-target'));\n      _this67._setup();\n\n      _this67._calculatePositioning();\n      _this67._setupEventHandlers();\n      return _this67;\n    }\n\n    _createClass(TapTarget, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this.el.TapTarget = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleDocumentClickBound = this._handleDocumentClick.bind(this);\n        this._handleTargetClickBound = this._handleTargetClick.bind(this);\n        this._handleOriginClickBound = this._handleOriginClick.bind(this);\n\n        this.el.addEventListener('click', this._handleTargetClickBound);\n        this.originEl.addEventListener('click', this._handleOriginClickBound);\n\n        // Resize\n        var throttledResize = M.throttle(this._handleResize, 200);\n        this._handleThrottledResizeBound = throttledResize.bind(this);\n\n        window.addEventListener('resize', this._handleThrottledResizeBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('click', this._handleTargetClickBound);\n        this.originEl.removeEventListener('click', this._handleOriginClickBound);\n        window.removeEventListener('resize', this._handleThrottledResizeBound);\n      }\n\n      /**\n       * Handle Target Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleTargetClick\",\n      value: function _handleTargetClick(e) {\n        this.open();\n      }\n\n      /**\n       * Handle Origin Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleOriginClick\",\n      value: function _handleOriginClick(e) {\n        this.close();\n      }\n\n      /**\n       * Handle Resize\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleResize\",\n      value: function _handleResize(e) {\n        this._calculatePositioning();\n      }\n\n      /**\n       * Handle Resize\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleDocumentClick\",\n      value: function _handleDocumentClick(e) {\n        if (!$(e.target).closest('.tap-target-wrapper').length) {\n          this.close();\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      }\n\n      /**\n       * Setup Tap Target\n       */\n\n    }, {\n      key: \"_setup\",\n      value: function _setup() {\n        // Creating tap target\n        this.wrapper = this.$el.parent()[0];\n        this.waveEl = $(this.wrapper).find('.tap-target-wave')[0];\n        this.originEl = $(this.wrapper).find('.tap-target-origin')[0];\n        this.contentEl = this.$el.find('.tap-target-content')[0];\n\n        // Creating wrapper\n        if (!$(this.wrapper).hasClass('.tap-target-wrapper')) {\n          this.wrapper = document.createElement('div');\n          this.wrapper.classList.add('tap-target-wrapper');\n          this.$el.before($(this.wrapper));\n          this.wrapper.append(this.el);\n        }\n\n        // Creating content\n        if (!this.contentEl) {\n          this.contentEl = document.createElement('div');\n          this.contentEl.classList.add('tap-target-content');\n          this.$el.append(this.contentEl);\n        }\n\n        // Creating foreground wave\n        if (!this.waveEl) {\n          this.waveEl = document.createElement('div');\n          this.waveEl.classList.add('tap-target-wave');\n\n          // Creating origin\n          if (!this.originEl) {\n            this.originEl = this.$origin.clone(true, true);\n            this.originEl.addClass('tap-target-origin');\n            this.originEl.removeAttr('id');\n            this.originEl.removeAttr('style');\n            this.originEl = this.originEl[0];\n            this.waveEl.append(this.originEl);\n          }\n\n          this.wrapper.append(this.waveEl);\n        }\n      }\n\n      /**\n       * Calculate positioning\n       */\n\n    }, {\n      key: \"_calculatePositioning\",\n      value: function _calculatePositioning() {\n        // Element or parent is fixed position?\n        var isFixed = this.$origin.css('position') === 'fixed';\n        if (!isFixed) {\n          var parents = this.$origin.parents();\n          for (var i = 0; i < parents.length; i++) {\n            isFixed = $(parents[i]).css('position') == 'fixed';\n            if (isFixed) {\n              break;\n            }\n          }\n        }\n\n        // Calculating origin\n        var originWidth = this.$origin.outerWidth();\n        var originHeight = this.$origin.outerHeight();\n        var originTop = isFixed ? this.$origin.offset().top - M.getDocumentScrollTop() : this.$origin.offset().top;\n        var originLeft = isFixed ? this.$origin.offset().left - M.getDocumentScrollLeft() : this.$origin.offset().left;\n\n        // Calculating screen\n        var windowWidth = window.innerWidth;\n        var windowHeight = window.innerHeight;\n        var centerX = windowWidth / 2;\n        var centerY = windowHeight / 2;\n        var isLeft = originLeft <= centerX;\n        var isRight = originLeft > centerX;\n        var isTop = originTop <= centerY;\n        var isBottom = originTop > centerY;\n        var isCenterX = originLeft >= windowWidth * 0.25 && originLeft <= windowWidth * 0.75;\n\n        // Calculating tap target\n        var tapTargetWidth = this.$el.outerWidth();\n        var tapTargetHeight = this.$el.outerHeight();\n        var tapTargetTop = originTop + originHeight / 2 - tapTargetHeight / 2;\n        var tapTargetLeft = originLeft + originWidth / 2 - tapTargetWidth / 2;\n        var tapTargetPosition = isFixed ? 'fixed' : 'absolute';\n\n        // Calculating content\n        var tapTargetTextWidth = isCenterX ? tapTargetWidth : tapTargetWidth / 2 + originWidth;\n        var tapTargetTextHeight = tapTargetHeight / 2;\n        var tapTargetTextTop = isTop ? tapTargetHeight / 2 : 0;\n        var tapTargetTextBottom = 0;\n        var tapTargetTextLeft = isLeft && !isCenterX ? tapTargetWidth / 2 - originWidth : 0;\n        var tapTargetTextRight = 0;\n        var tapTargetTextPadding = originWidth;\n        var tapTargetTextAlign = isBottom ? 'bottom' : 'top';\n\n        // Calculating wave\n        var tapTargetWaveWidth = originWidth > originHeight ? originWidth * 2 : originWidth * 2;\n        var tapTargetWaveHeight = tapTargetWaveWidth;\n        var tapTargetWaveTop = tapTargetHeight / 2 - tapTargetWaveHeight / 2;\n        var tapTargetWaveLeft = tapTargetWidth / 2 - tapTargetWaveWidth / 2;\n\n        // Setting tap target\n        var tapTargetWrapperCssObj = {};\n        tapTargetWrapperCssObj.top = isTop ? tapTargetTop + 'px' : '';\n        tapTargetWrapperCssObj.right = isRight ? windowWidth - tapTargetLeft - tapTargetWidth + 'px' : '';\n        tapTargetWrapperCssObj.bottom = isBottom ? windowHeight - tapTargetTop - tapTargetHeight + 'px' : '';\n        tapTargetWrapperCssObj.left = isLeft ? tapTargetLeft + 'px' : '';\n        tapTargetWrapperCssObj.position = tapTargetPosition;\n        $(this.wrapper).css(tapTargetWrapperCssObj);\n\n        // Setting content\n        $(this.contentEl).css({\n          width: tapTargetTextWidth + 'px',\n          height: tapTargetTextHeight + 'px',\n          top: tapTargetTextTop + 'px',\n          right: tapTargetTextRight + 'px',\n          bottom: tapTargetTextBottom + 'px',\n          left: tapTargetTextLeft + 'px',\n          padding: tapTargetTextPadding + 'px',\n          verticalAlign: tapTargetTextAlign\n        });\n\n        // Setting wave\n        $(this.waveEl).css({\n          top: tapTargetWaveTop + 'px',\n          left: tapTargetWaveLeft + 'px',\n          width: tapTargetWaveWidth + 'px',\n          height: tapTargetWaveHeight + 'px'\n        });\n      }\n\n      /**\n       * Open TapTarget\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this.isOpen) {\n          return;\n        }\n\n        // onOpen callback\n        if (typeof this.options.onOpen === 'function') {\n          this.options.onOpen.call(this, this.$origin[0]);\n        }\n\n        this.isOpen = true;\n        this.wrapper.classList.add('open');\n\n        document.body.addEventListener('click', this._handleDocumentClickBound, true);\n        document.body.addEventListener('touchend', this._handleDocumentClickBound);\n      }\n\n      /**\n       * Close Tap Target\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        // onClose callback\n        if (typeof this.options.onClose === 'function') {\n          this.options.onClose.call(this, this.$origin[0]);\n        }\n\n        this.isOpen = false;\n        this.wrapper.classList.remove('open');\n\n        document.body.removeEventListener('click', this._handleDocumentClickBound, true);\n        document.body.removeEventListener('touchend', this._handleDocumentClickBound);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(TapTarget.__proto__ || Object.getPrototypeOf(TapTarget), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_TapTarget;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return TapTarget;\n  }(Component);\n\n  M.TapTarget = TapTarget;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(TapTarget, 'tapTarget', 'M_TapTarget');\n  }\n})(cash);\n;(function ($) {\n  'use strict';\n\n  var _defaults = {\n    classes: '',\n    dropdownOptions: {}\n  };\n\n  /**\n   * @class\n   *\n   */\n\n  var FormSelect = function (_Component20) {\n    _inherits(FormSelect, _Component20);\n\n    /**\n     * Construct FormSelect instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function FormSelect(el, options) {\n      _classCallCheck(this, FormSelect);\n\n      // Don't init if browser default version\n      var _this68 = _possibleConstructorReturn(this, (FormSelect.__proto__ || Object.getPrototypeOf(FormSelect)).call(this, FormSelect, el, options));\n\n      if (_this68.$el.hasClass('browser-default')) {\n        return _possibleConstructorReturn(_this68);\n      }\n\n      _this68.el.M_FormSelect = _this68;\n\n      /**\n       * Options for the select\n       * @member FormSelect#options\n       */\n      _this68.options = $.extend({}, FormSelect.defaults, options);\n\n      _this68.isMultiple = _this68.$el.prop('multiple');\n\n      // Setup\n      _this68.el.tabIndex = -1;\n      _this68._keysSelected = {};\n      _this68._valueDict = {}; // Maps key to original and generated option element.\n      _this68._setupDropdown();\n\n      _this68._setupEventHandlers();\n      return _this68;\n    }\n\n    _createClass(FormSelect, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this._removeDropdown();\n        this.el.M_FormSelect = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        var _this69 = this;\n\n        this._handleSelectChangeBound = this._handleSelectChange.bind(this);\n        this._handleOptionClickBound = this._handleOptionClick.bind(this);\n        this._handleInputClickBound = this._handleInputClick.bind(this);\n\n        $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {\n          el.addEventListener('click', _this69._handleOptionClickBound);\n        });\n        this.el.addEventListener('change', this._handleSelectChangeBound);\n        this.input.addEventListener('click', this._handleInputClickBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        var _this70 = this;\n\n        $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {\n          el.removeEventListener('click', _this70._handleOptionClickBound);\n        });\n        this.el.removeEventListener('change', this._handleSelectChangeBound);\n        this.input.removeEventListener('click', this._handleInputClickBound);\n      }\n\n      /**\n       * Handle Select Change\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleSelectChange\",\n      value: function _handleSelectChange(e) {\n        this._setValueToInput();\n      }\n\n      /**\n       * Handle Option Click\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleOptionClick\",\n      value: function _handleOptionClick(e) {\n        e.preventDefault();\n        var option = $(e.target).closest('li')[0];\n        var key = option.id;\n        if (!$(option).hasClass('disabled') && !$(option).hasClass('optgroup') && key.length) {\n          var selected = true;\n\n          if (this.isMultiple) {\n            // Deselect placeholder option if still selected.\n            var placeholderOption = $(this.dropdownOptions).find('li.disabled.selected');\n            if (placeholderOption.length) {\n              placeholderOption.removeClass('selected');\n              placeholderOption.find('input[type=\"checkbox\"]').prop('checked', false);\n              this._toggleEntryFromArray(placeholderOption[0].id);\n            }\n            selected = this._toggleEntryFromArray(key);\n          } else {\n            $(this.dropdownOptions).find('li').removeClass('selected');\n            $(option).toggleClass('selected', selected);\n          }\n\n          // Set selected on original select option\n          // Only trigger if selected state changed\n          var prevSelected = $(this._valueDict[key].el).prop('selected');\n          if (prevSelected !== selected) {\n            $(this._valueDict[key].el).prop('selected', selected);\n            this.$el.trigger('change');\n          }\n        }\n\n        e.stopPropagation();\n      }\n\n      /**\n       * Handle Input Click\n       */\n\n    }, {\n      key: \"_handleInputClick\",\n      value: function _handleInputClick() {\n        if (this.dropdown && this.dropdown.isOpen) {\n          this._setValueToInput();\n          this._setSelectedStates();\n        }\n      }\n\n      /**\n       * Setup dropdown\n       */\n\n    }, {\n      key: \"_setupDropdown\",\n      value: function _setupDropdown() {\n        var _this71 = this;\n\n        this.wrapper = document.createElement('div');\n        $(this.wrapper).addClass('select-wrapper ' + this.options.classes);\n        this.$el.before($(this.wrapper));\n        this.wrapper.appendChild(this.el);\n\n        if (this.el.disabled) {\n          this.wrapper.classList.add('disabled');\n        }\n\n        // Create dropdown\n        this.$selectOptions = this.$el.children('option, optgroup');\n        this.dropdownOptions = document.createElement('ul');\n        this.dropdownOptions.id = \"select-options-\" + M.guid();\n        $(this.dropdownOptions).addClass('dropdown-content select-dropdown ' + (this.isMultiple ? 'multiple-select-dropdown' : ''));\n\n        // Create dropdown structure.\n        if (this.$selectOptions.length) {\n          this.$selectOptions.each(function (el) {\n            if ($(el).is('option')) {\n              // Direct descendant option.\n              var optionEl = void 0;\n              if (_this71.isMultiple) {\n                optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'multiple');\n              } else {\n                optionEl = _this71._appendOptionWithIcon(_this71.$el, el);\n              }\n\n              _this71._addOptionToValueDict(el, optionEl);\n            } else if ($(el).is('optgroup')) {\n              // Optgroup.\n              var selectOptions = $(el).children('option');\n              $(_this71.dropdownOptions).append($('<li class=\"optgroup\"><span>' + el.getAttribute('label') + '</span></li>')[0]);\n\n              selectOptions.each(function (el) {\n                var optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'optgroup-option');\n                _this71._addOptionToValueDict(el, optionEl);\n              });\n            }\n          });\n        }\n\n        this.$el.after(this.dropdownOptions);\n\n        // Add input dropdown\n        this.input = document.createElement('input');\n        $(this.input).addClass('select-dropdown dropdown-trigger');\n        this.input.setAttribute('type', 'text');\n        this.input.setAttribute('readonly', 'true');\n        this.input.setAttribute('data-target', this.dropdownOptions.id);\n        if (this.el.disabled) {\n          $(this.input).prop('disabled', 'true');\n        }\n\n        this.$el.before(this.input);\n        this._setValueToInput();\n\n        // Add caret\n        var dropdownIcon = $('<svg class=\"caret\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 10l5 5 5-5z\"/><path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>');\n        this.$el.before(dropdownIcon[0]);\n\n        // Initialize dropdown\n        if (!this.el.disabled) {\n          var dropdownOptions = $.extend({}, this.options.dropdownOptions);\n\n          // Add callback for centering selected option when dropdown content is scrollable\n          dropdownOptions.onOpenEnd = function (el) {\n            var selectedOption = $(_this71.dropdownOptions).find('.selected').first();\n            if (_this71.dropdown.isScrollable && selectedOption.length) {\n              var scrollOffset = selectedOption[0].getBoundingClientRect().top - _this71.dropdownOptions.getBoundingClientRect().top; // scroll to selected option\n              scrollOffset -= _this71.dropdownOptions.clientHeight / 2; // center in dropdown\n              _this71.dropdownOptions.scrollTop = scrollOffset;\n            }\n          };\n\n          if (this.isMultiple) {\n            dropdownOptions.closeOnClick = false;\n          }\n          this.dropdown = M.Dropdown.init(this.input, dropdownOptions);\n        }\n\n        // Add initial selections\n        this._setSelectedStates();\n      }\n\n      /**\n       * Add option to value dict\n       * @param {Element} el  original option element\n       * @param {Element} optionEl  generated option element\n       */\n\n    }, {\n      key: \"_addOptionToValueDict\",\n      value: function _addOptionToValueDict(el, optionEl) {\n        var index = Object.keys(this._valueDict).length;\n        var key = this.dropdownOptions.id + index;\n        var obj = {};\n        optionEl.id = key;\n\n        obj.el = el;\n        obj.optionEl = optionEl;\n        this._valueDict[key] = obj;\n      }\n\n      /**\n       * Remove dropdown\n       */\n\n    }, {\n      key: \"_removeDropdown\",\n      value: function _removeDropdown() {\n        $(this.wrapper).find('.caret').remove();\n        $(this.input).remove();\n        $(this.dropdownOptions).remove();\n        $(this.wrapper).before(this.$el);\n        $(this.wrapper).remove();\n      }\n\n      /**\n       * Setup dropdown\n       * @param {Element} select  select element\n       * @param {Element} option  option element from select\n       * @param {String} type\n       * @return {Element}  option element added\n       */\n\n    }, {\n      key: \"_appendOptionWithIcon\",\n      value: function _appendOptionWithIcon(select, option, type) {\n        // Add disabled attr if disabled\n        var disabledClass = option.disabled ? 'disabled ' : '';\n        var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';\n        var multipleCheckbox = this.isMultiple ? \"<label><input type=\\\"checkbox\\\"\" + disabledClass + \"\\\"/><span>\" + option.innerHTML + \"</span></label>\" : option.innerHTML;\n        var liEl = $('<li></li>');\n        var spanEl = $('<span></span>');\n        spanEl.html(multipleCheckbox);\n        liEl.addClass(disabledClass + \" \" + optgroupClass);\n        liEl.append(spanEl);\n\n        // add icons\n        var iconUrl = option.getAttribute('data-icon');\n        if (!!iconUrl) {\n          var imgEl = $(\"<img alt=\\\"\\\" src=\\\"\" + iconUrl + \"\\\">\");\n          liEl.prepend(imgEl);\n        }\n\n        // Check for multiple type.\n        $(this.dropdownOptions).append(liEl[0]);\n        return liEl[0];\n      }\n\n      /**\n       * Toggle entry from option\n       * @param {String} key  Option key\n       * @return {Boolean}  if entry was added or removed\n       */\n\n    }, {\n      key: \"_toggleEntryFromArray\",\n      value: function _toggleEntryFromArray(key) {\n        var notAdded = !this._keysSelected.hasOwnProperty(key);\n        var $optionLi = $(this._valueDict[key].optionEl);\n\n        if (notAdded) {\n          this._keysSelected[key] = true;\n        } else {\n          delete this._keysSelected[key];\n        }\n\n        $optionLi.toggleClass('selected', notAdded);\n\n        // Set checkbox checked value\n        $optionLi.find('input[type=\"checkbox\"]').prop('checked', notAdded);\n\n        // use notAdded instead of true (to detect if the option is selected or not)\n        $optionLi.prop('selected', notAdded);\n\n        return notAdded;\n      }\n\n      /**\n       * Set text value to input\n       */\n\n    }, {\n      key: \"_setValueToInput\",\n      value: function _setValueToInput() {\n        var values = [];\n        var options = this.$el.find('option');\n\n        options.each(function (el) {\n          if ($(el).prop('selected')) {\n            var text = $(el).text();\n            values.push(text);\n          }\n        });\n\n        if (!values.length) {\n          var firstDisabled = this.$el.find('option:disabled').eq(0);\n          if (firstDisabled.length && firstDisabled[0].value === '') {\n            values.push(firstDisabled.text());\n          }\n        }\n\n        this.input.value = values.join(', ');\n      }\n\n      /**\n       * Set selected state of dropdown to match actual select element\n       */\n\n    }, {\n      key: \"_setSelectedStates\",\n      value: function _setSelectedStates() {\n        this._keysSelected = {};\n\n        for (var key in this._valueDict) {\n          var option = this._valueDict[key];\n          var optionIsSelected = $(option.el).prop('selected');\n          $(option.optionEl).find('input[type=\"checkbox\"]').prop('checked', optionIsSelected);\n          if (optionIsSelected) {\n            this._activateOption($(this.dropdownOptions), $(option.optionEl));\n            this._keysSelected[key] = true;\n          } else {\n            $(option.optionEl).removeClass('selected');\n          }\n        }\n      }\n\n      /**\n       * Make option as selected and scroll to selected position\n       * @param {jQuery} collection  Select options jQuery element\n       * @param {Element} newOption  element of the new option\n       */\n\n    }, {\n      key: \"_activateOption\",\n      value: function _activateOption(collection, newOption) {\n        if (newOption) {\n          if (!this.isMultiple) {\n            collection.find('li.selected').removeClass('selected');\n          }\n          var option = $(newOption);\n          option.addClass('selected');\n        }\n      }\n\n      /**\n       * Get Selected Values\n       * @return {Array}  Array of selected values\n       */\n\n    }, {\n      key: \"getSelectedValues\",\n      value: function getSelectedValues() {\n        var selectedValues = [];\n        for (var key in this._keysSelected) {\n          selectedValues.push(this._valueDict[key].el.value);\n        }\n        return selectedValues;\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(FormSelect.__proto__ || Object.getPrototypeOf(FormSelect), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_FormSelect;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return FormSelect;\n  }(Component);\n\n  M.FormSelect = FormSelect;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(FormSelect, 'formSelect', 'M_FormSelect');\n  }\n})(cash);\n;(function ($, anim) {\n  'use strict';\n\n  var _defaults = {};\n\n  /**\n   * @class\n   *\n   */\n\n  var Range = function (_Component21) {\n    _inherits(Range, _Component21);\n\n    /**\n     * Construct Range instance\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Range(el, options) {\n      _classCallCheck(this, Range);\n\n      var _this72 = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, Range, el, options));\n\n      _this72.el.M_Range = _this72;\n\n      /**\n       * Options for the range\n       * @member Range#options\n       */\n      _this72.options = $.extend({}, Range.defaults, options);\n\n      _this72._mousedown = false;\n\n      // Setup\n      _this72._setupThumb();\n\n      _this72._setupEventHandlers();\n      return _this72;\n    }\n\n    _createClass(Range, [{\n      key: \"destroy\",\n\n\n      /**\n       * Teardown component\n       */\n      value: function destroy() {\n        this._removeEventHandlers();\n        this._removeThumb();\n        this.el.M_Range = undefined;\n      }\n\n      /**\n       * Setup Event Handlers\n       */\n\n    }, {\n      key: \"_setupEventHandlers\",\n      value: function _setupEventHandlers() {\n        this._handleRangeChangeBound = this._handleRangeChange.bind(this);\n        this._handleRangeMousedownTouchstartBound = this._handleRangeMousedownTouchstart.bind(this);\n        this._handleRangeInputMousemoveTouchmoveBound = this._handleRangeInputMousemoveTouchmove.bind(this);\n        this._handleRangeMouseupTouchendBound = this._handleRangeMouseupTouchend.bind(this);\n        this._handleRangeBlurMouseoutTouchleaveBound = this._handleRangeBlurMouseoutTouchleave.bind(this);\n\n        this.el.addEventListener('change', this._handleRangeChangeBound);\n\n        this.el.addEventListener('mousedown', this._handleRangeMousedownTouchstartBound);\n        this.el.addEventListener('touchstart', this._handleRangeMousedownTouchstartBound);\n\n        this.el.addEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);\n        this.el.addEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);\n        this.el.addEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);\n\n        this.el.addEventListener('mouseup', this._handleRangeMouseupTouchendBound);\n        this.el.addEventListener('touchend', this._handleRangeMouseupTouchendBound);\n\n        this.el.addEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);\n        this.el.addEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);\n        this.el.addEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);\n      }\n\n      /**\n       * Remove Event Handlers\n       */\n\n    }, {\n      key: \"_removeEventHandlers\",\n      value: function _removeEventHandlers() {\n        this.el.removeEventListener('change', this._handleRangeChangeBound);\n\n        this.el.removeEventListener('mousedown', this._handleRangeMousedownTouchstartBound);\n        this.el.removeEventListener('touchstart', this._handleRangeMousedownTouchstartBound);\n\n        this.el.removeEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);\n        this.el.removeEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);\n        this.el.removeEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);\n\n        this.el.removeEventListener('mouseup', this._handleRangeMouseupTouchendBound);\n        this.el.removeEventListener('touchend', this._handleRangeMouseupTouchendBound);\n\n        this.el.removeEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);\n        this.el.removeEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);\n        this.el.removeEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);\n      }\n\n      /**\n       * Handle Range Change\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleRangeChange\",\n      value: function _handleRangeChange() {\n        $(this.value).html(this.$el.val());\n\n        if (!$(this.thumb).hasClass('active')) {\n          this._showRangeBubble();\n        }\n\n        var offsetLeft = this._calcRangeOffset();\n        $(this.thumb).addClass('active').css('left', offsetLeft + 'px');\n      }\n\n      /**\n       * Handle Range Mousedown and Touchstart\n       * @param {Event} e\n       */\n\n    }, {\n      key: \"_handleRangeMousedownTouchstart\",\n      value: function _handleRangeMousedownTouchstart(e) {\n        // Set indicator value\n        $(this.value).html(this.$el.val());\n\n        this._mousedown = true;\n        this.$el.addClass('active');\n\n        if (!$(this.thumb).hasClass('active')) {\n          this._showRangeBubble();\n        }\n\n        if (e.type !== 'input') {\n          var offsetLeft = this._calcRangeOffset();\n          $(this.thumb).addClass('active').css('left', offsetLeft + 'px');\n        }\n      }\n\n      /**\n       * Handle Range Input, Mousemove and Touchmove\n       */\n\n    }, {\n      key: \"_handleRangeInputMousemoveTouchmove\",\n      value: function _handleRangeInputMousemoveTouchmove() {\n        if (this._mousedown) {\n          if (!$(this.thumb).hasClass('active')) {\n            this._showRangeBubble();\n          }\n\n          var offsetLeft = this._calcRangeOffset();\n          $(this.thumb).addClass('active').css('left', offsetLeft + 'px');\n          $(this.value).html(this.$el.val());\n        }\n      }\n\n      /**\n       * Handle Range Mouseup and Touchend\n       */\n\n    }, {\n      key: \"_handleRangeMouseupTouchend\",\n      value: function _handleRangeMouseupTouchend() {\n        this._mousedown = false;\n        this.$el.removeClass('active');\n      }\n\n      /**\n       * Handle Range Blur, Mouseout and Touchleave\n       */\n\n    }, {\n      key: \"_handleRangeBlurMouseoutTouchleave\",\n      value: function _handleRangeBlurMouseoutTouchleave() {\n        if (!this._mousedown) {\n          var paddingLeft = parseInt(this.$el.css('padding-left'));\n          var marginLeft = 7 + paddingLeft + 'px';\n\n          if ($(this.thumb).hasClass('active')) {\n            anim.remove(this.thumb);\n            anim({\n              targets: this.thumb,\n              height: 0,\n              width: 0,\n              top: 10,\n              easing: 'easeOutQuad',\n              marginLeft: marginLeft,\n              duration: 100\n            });\n          }\n          $(this.thumb).removeClass('active');\n        }\n      }\n\n      /**\n       * Setup dropdown\n       */\n\n    }, {\n      key: \"_setupThumb\",\n      value: function _setupThumb() {\n        this.thumb = document.createElement('span');\n        this.value = document.createElement('span');\n        $(this.thumb).addClass('thumb');\n        $(this.value).addClass('value');\n        $(this.thumb).append(this.value);\n        this.$el.after(this.thumb);\n      }\n\n      /**\n       * Remove dropdown\n       */\n\n    }, {\n      key: \"_removeThumb\",\n      value: function _removeThumb() {\n        $(this.thumb).remove();\n      }\n\n      /**\n       * morph thumb into bubble\n       */\n\n    }, {\n      key: \"_showRangeBubble\",\n      value: function _showRangeBubble() {\n        var paddingLeft = parseInt($(this.thumb).parent().css('padding-left'));\n        var marginLeft = -7 + paddingLeft + 'px'; // TODO: fix magic number?\n        anim.remove(this.thumb);\n        anim({\n          targets: this.thumb,\n          height: 30,\n          width: 30,\n          top: -30,\n          marginLeft: marginLeft,\n          duration: 300,\n          easing: 'easeOutQuint'\n        });\n      }\n\n      /**\n       * Calculate the offset of the thumb\n       * @return {Number}  offset in pixels\n       */\n\n    }, {\n      key: \"_calcRangeOffset\",\n      value: function _calcRangeOffset() {\n        var width = this.$el.width() - 15;\n        var max = parseFloat(this.$el.attr('max')) || 100; // Range default max\n        var min = parseFloat(this.$el.attr('min')) || 0; // Range default min\n        var percent = (parseFloat(this.$el.val()) - min) / (max - min);\n        return percent * width;\n      }\n    }], [{\n      key: \"init\",\n      value: function init(els, options) {\n        return _get(Range.__proto__ || Object.getPrototypeOf(Range), \"init\", this).call(this, this, els, options);\n      }\n\n      /**\n       * Get Instance\n       */\n\n    }, {\n      key: \"getInstance\",\n      value: function getInstance(el) {\n        var domElem = !!el.jquery ? el[0] : el;\n        return domElem.M_Range;\n      }\n    }, {\n      key: \"defaults\",\n      get: function () {\n        return _defaults;\n      }\n    }]);\n\n    return Range;\n  }(Component);\n\n  M.Range = Range;\n\n  if (M.jQueryLoaded) {\n    M.initializeJqueryWrapper(Range, 'range', 'M_Range');\n  }\n\n  Range.init($('input[type=range]'));\n})(cash, M.anime);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0ZXJpYWxpemUtY3NzL2Rpc3QvanMvbWF0ZXJpYWxpemUuanM/NGQ1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsa0JBQWtCLEVBQUUsT0FBTyx3Q0FBd0MsRUFBRSxFQUFFLDRCQUE0QixtQkFBbUIsRUFBRSxPQUFPLHVCQUF1Qiw0QkFBNEIsa0JBQWtCLEVBQUUsOEJBQThCLEVBQUU7O0FBRXhlLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsY0FBYzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q1Q7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9COztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEMsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEVBQUU7QUFDTCxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUgsK2JBQStiOztBQUUvYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJO0FBQ3JJLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QixrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tYXRlcmlhbGl6ZS1jc3MvZGlzdC9qcy9tYXRlcmlhbGl6ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBNYXRlcmlhbGl6ZSB2MS4wLjAtcmMuMiAoaHR0cDovL21hdGVyaWFsaXplY3NzLmNvbSlcclxuICogQ29weXJpZ2h0IDIwMTQtMjAxNyBNYXRlcmlhbGl6ZVxyXG4gKiBNSVQgTGljZW5zZSAoaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0RvZ2ZhbG8vbWF0ZXJpYWxpemUvbWFzdGVyL0xJQ0VOU0UpXHJcbiAqL1xyXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyohIGNhc2gtZG9tIDEuMy41LCBodHRwczovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9jYXNoIEBsaWNlbnNlIE1JVCAqL1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIHdpbmRvdy5jYXNoID0gZmFjdG9yeSgpO1xufSkoZnVuY3Rpb24gKCkge1xuICB2YXIgZG9jID0gZG9jdW1lbnQsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgZmlsdGVyID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgICBwdXNoID0gQXJyYXlQcm90by5wdXNoO1xuXG4gIHZhciBub29wID0gZnVuY3Rpb24gKCkge30sXG4gICAgICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAvLyBAc2VlIGh0dHBzOi8vY3JidWcuY29tLzU2ODQ0OFxuICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gdHlwZW9mIG5vb3AgJiYgaXRlbS5jYWxsO1xuICB9LFxuICAgICAgaXNTdHJpbmcgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gdHlwZW9mIFwiXCI7XG4gIH07XG5cbiAgdmFyIGlkTWF0Y2ggPSAvXiNbXFx3LV0qJC8sXG4gICAgICBjbGFzc01hdGNoID0gL15cXC5bXFx3LV0qJC8sXG4gICAgICBodG1sTWF0Y2ggPSAvPC4rPi8sXG4gICAgICBzaW5nbGV0ID0gL15cXHcrJC87XG5cbiAgZnVuY3Rpb24gZmluZChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvYztcbiAgICB2YXIgZWxlbXMgPSBjbGFzc01hdGNoLnRlc3Qoc2VsZWN0b3IpID8gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHNlbGVjdG9yLnNsaWNlKDEpKSA6IHNpbmdsZXQudGVzdChzZWxlY3RvcikgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSA6IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgcmV0dXJuIGVsZW1zO1xuICB9XG5cbiAgdmFyIGZyYWc7XG4gIGZ1bmN0aW9uIHBhcnNlSFRNTChzdHIpIHtcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGZyYWcgPSBkb2MuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KG51bGwpO1xuICAgICAgdmFyIGJhc2UgPSBmcmFnLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpO1xuICAgICAgYmFzZS5ocmVmID0gZG9jLmxvY2F0aW9uLmhyZWY7XG4gICAgICBmcmFnLmhlYWQuYXBwZW5kQ2hpbGQoYmFzZSk7XG4gICAgfVxuXG4gICAgZnJhZy5ib2R5LmlubmVySFRNTCA9IHN0cjtcblxuICAgIHJldHVybiBmcmFnLmJvZHkuY2hpbGROb2RlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVhZHkoZm4pIHtcbiAgICBpZiAoZG9jLnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSB7XG4gICAgICBmbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZm4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEluaXQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJZiBhbHJlYWR5IGEgY2FzaCBjb2xsZWN0aW9uLCBkb24ndCBkbyBhbnkgZnVydGhlciBwcm9jZXNzaW5nXG4gICAgaWYgKHNlbGVjdG9yLmNhc2ggJiYgc2VsZWN0b3IgIT09IHdpbikge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIHZhciBlbGVtcyA9IHNlbGVjdG9yLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuZ3RoO1xuXG4gICAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgZWxlbXMgPSBpZE1hdGNoLnRlc3Qoc2VsZWN0b3IpID9cbiAgICAgIC8vIElmIGFuIElEIHVzZSB0aGUgZmFzdGVyIGdldEVsZW1lbnRCeUlkIGNoZWNrXG4gICAgICBkb2MuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3Iuc2xpY2UoMSkpIDogaHRtbE1hdGNoLnRlc3Qoc2VsZWN0b3IpID9cbiAgICAgIC8vIElmIEhUTUwsIHBhcnNlIGl0IGludG8gcmVhbCBlbGVtZW50c1xuICAgICAgcGFyc2VIVE1MKHNlbGVjdG9yKSA6XG4gICAgICAvLyBlbHNlIHVzZSBgZmluZGBcbiAgICAgIGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpO1xuXG4gICAgICAvLyBJZiBmdW5jdGlvbiwgdXNlIGFzIHNob3J0Y3V0IGZvciBET00gcmVhZHlcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICBvblJlYWR5KHNlbGVjdG9yKTtyZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWVsZW1zKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJZiBhIHNpbmdsZSBET00gZWxlbWVudCBpcyBwYXNzZWQgaW4gb3IgcmVjZWl2ZWQgdmlhIElELCByZXR1cm4gdGhlIHNpbmdsZSBlbGVtZW50XG4gICAgaWYgKGVsZW1zLm5vZGVUeXBlIHx8IGVsZW1zID09PSB3aW4pIHtcbiAgICAgIHRoaXNbMF0gPSBlbGVtcztcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJlYXQgbGlrZSBhbiBhcnJheSBhbmQgbG9vcCB0aHJvdWdoIGVhY2ggaXRlbS5cbiAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldID0gZWxlbXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBjYXNoKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBJbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgfVxuXG4gIHZhciBmbiA9IGNhc2guZm4gPSBjYXNoLnByb3RvdHlwZSA9IEluaXQucHJvdG90eXBlID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBjYXNoOiB0cnVlLFxuICAgIGxlbmd0aDogMCxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHNwbGljZTogQXJyYXlQcm90by5zcGxpY2UsXG4gICAgbWFwOiBBcnJheVByb3RvLm1hcCxcbiAgICBpbml0OiBJbml0XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IGNhc2ggfSk7XG5cbiAgY2FzaC5wYXJzZUhUTUwgPSBwYXJzZUhUTUw7XG4gIGNhc2gubm9vcCA9IG5vb3A7XG4gIGNhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gIGNhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcblxuICBjYXNoLmV4dGVuZCA9IGZuLmV4dGVuZCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgIGkgPSAxO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgaSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFhcmdzW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3NbaV0pIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gYXJnc1tpXVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICBmdW5jdGlvbiBlYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoY29sbGVjdGlvbltpXSwgY29sbGVjdGlvbltpXSwgaSwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG0gPSBlbCAmJiAoZWwubWF0Y2hlcyB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm9NYXRjaGVzU2VsZWN0b3IpO1xuICAgIHJldHVybiAhIW0gJiYgbS5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21wYXJlRnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyogVXNlIGJyb3dzZXIncyBgbWF0Y2hlc2AgZnVuY3Rpb24gaWYgc3RyaW5nICovXG4gICAgICBpc1N0cmluZyhzZWxlY3RvcikgPyBtYXRjaGVzIDpcbiAgICAgIC8qIE1hdGNoIGEgY2FzaCBlbGVtZW50ICovXG4gICAgICBzZWxlY3Rvci5jYXNoID8gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5pcyhlbCk7XG4gICAgICB9IDpcbiAgICAgIC8qIERpcmVjdCBjb21wYXJpc29uICovXG4gICAgICBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gc2VsZWN0b3I7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaXF1ZShjb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNhc2goc2xpY2UuY2FsbChjb2xsZWN0aW9uKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4LCBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbiAgICB9KSk7XG4gIH1cblxuICBjYXNoLmV4dGVuZCh7XG4gICAgbWVyZ2U6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG4gICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aCxcbiAgICAgICAgICBqID0gMDtcblxuICAgICAgZm9yICg7IGogPCBsZW47IGkrKywgaisrKSB7XG4gICAgICAgIGZpcnN0W2ldID0gc2Vjb25kW2pdO1xuICAgICAgfVxuXG4gICAgICBmaXJzdC5sZW5ndGggPSBpO1xuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH0sXG5cbiAgICBlYWNoOiBlYWNoLFxuICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgICBpc051bWVyaWM6IGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICB9KTtcblxuICB2YXIgdWlkID0gY2FzaC51aWQgPSBcIl9jYXNoXCIgKyBEYXRlLm5vdygpO1xuXG4gIGZ1bmN0aW9uIGdldERhdGFDYWNoZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGVbdWlkXSA9IG5vZGVbdWlkXSB8fCB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERhdGEobm9kZSwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBnZXREYXRhQ2FjaGUobm9kZSlba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YShub2RlLCBrZXkpIHtcbiAgICB2YXIgYyA9IGdldERhdGFDYWNoZShub2RlKTtcbiAgICBpZiAoY1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNba2V5XSA9IG5vZGUuZGF0YXNldCA/IG5vZGUuZGF0YXNldFtrZXldIDogY2FzaChub2RlKS5hdHRyKFwiZGF0YS1cIiArIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBjW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEYXRhKG5vZGUsIGtleSkge1xuICAgIHZhciBjID0gZ2V0RGF0YUNhY2hlKG5vZGUpO1xuICAgIGlmIChjKSB7XG4gICAgICBkZWxldGUgY1trZXldO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kYXRhc2V0KSB7XG4gICAgICBkZWxldGUgbm9kZS5kYXRhc2V0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhc2gobm9kZSkucmVtb3ZlQXR0cihcImRhdGEtXCIgKyBuYW1lKTtcbiAgICB9XG4gIH1cblxuICBmbi5leHRlbmQoe1xuICAgIGRhdGE6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZ2V0RGF0YSh0aGlzWzBdLCBuYW1lKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBzZXREYXRhKHYsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIHRoaXMuZGF0YShrZXksIG5hbWVba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiByZW1vdmVEYXRhKHYsIGtleSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIG5vdFdoaXRlTWF0Y2ggPSAvXFxTKy9nO1xuXG4gIGZ1bmN0aW9uIGdldENsYXNzZXMoYykge1xuICAgIHJldHVybiBpc1N0cmluZyhjKSAmJiBjLm1hdGNoKG5vdFdoaXRlTWF0Y2gpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2xhc3ModiwgYykge1xuICAgIHJldHVybiB2LmNsYXNzTGlzdCA/IHYuY2xhc3NMaXN0LmNvbnRhaW5zKGMpIDogbmV3IFJlZ0V4cChcIihefCApXCIgKyBjICsgXCIoIHwkKVwiLCBcImdpXCIpLnRlc3Qodi5jbGFzc05hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3ModiwgYywgc3BhY2VkTmFtZSkge1xuICAgIGlmICh2LmNsYXNzTGlzdCkge1xuICAgICAgdi5jbGFzc0xpc3QuYWRkKGMpO1xuICAgIH0gZWxzZSBpZiAoc3BhY2VkTmFtZS5pbmRleE9mKFwiIFwiICsgYyArIFwiIFwiKSkge1xuICAgICAgdi5jbGFzc05hbWUgKz0gXCIgXCIgKyBjO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKHYsIGMpIHtcbiAgICBpZiAodi5jbGFzc0xpc3QpIHtcbiAgICAgIHYuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdi5jbGFzc05hbWUgPSB2LmNsYXNzTmFtZS5yZXBsYWNlKGMsIFwiXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZuLmV4dGVuZCh7XG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGdldENsYXNzZXMoYyk7XG5cbiAgICAgIHJldHVybiBjbGFzc2VzID8gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBzcGFjZWROYW1lID0gXCIgXCIgKyB2LmNsYXNzTmFtZSArIFwiIFwiO1xuICAgICAgICBlYWNoKGNsYXNzZXMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYWRkQ2xhc3ModiwgYywgc3BhY2VkTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkgOiB0aGlzO1xuICAgIH0sXG5cbiAgICBhdHRyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uZ2V0QXR0cmlidXRlID8gdGhpc1swXS5nZXRBdHRyaWJ1dGUobmFtZSkgOiB0aGlzWzBdW25hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmICh2LnNldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdi5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hdHRyKGtleSwgbmFtZVtrZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIGNoZWNrID0gZmFsc2UsXG4gICAgICAgICAgY2xhc3NlcyA9IGdldENsYXNzZXMoYyk7XG4gICAgICBpZiAoY2xhc3NlcyAmJiBjbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBjaGVjayA9IGhhc0NsYXNzKHYsIGNsYXNzZXNbMF0pO1xuICAgICAgICAgIHJldHVybiAhY2hlY2s7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0sXG5cbiAgICBwcm9wOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXNbMF1bbmFtZV0gOiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICB0aGlzLnByb3Aoa2V5LCBuYW1lW2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgICAgICAgdi5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgXCJcIik7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NlcyA9IGdldENsYXNzZXMoYyk7XG4gICAgICByZXR1cm4gY2xhc3NlcyA/IHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICBlYWNoKGNsYXNzZXMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModiwgYyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkgOiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICBkZWxldGUgdltuYW1lXTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24gKGMsIHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzdGF0ZSA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oYyk7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NlcyA9IGdldENsYXNzZXMoYyk7XG4gICAgICByZXR1cm4gY2xhc3NlcyA/IHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgc3BhY2VkTmFtZSA9IFwiIFwiICsgdi5jbGFzc05hbWUgKyBcIiBcIjtcbiAgICAgICAgZWFjaChjbGFzc2VzLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyh2LCBjKSkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModiwgYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZENsYXNzKHYsIGMsIHNwYWNlZE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSA6IHRoaXM7XG4gICAgfSB9KTtcblxuICBmbi5leHRlbmQoe1xuICAgIGFkZDogZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdW5pcXVlKGNhc2gubWVyZ2UodGhpcywgY2FzaChzZWxlY3RvciwgY29udGV4dCkpKTtcbiAgICB9LFxuXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBlYWNoKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlcTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FzaCh0aGlzLmdldChpbmRleCkpO1xuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogZ2V0Q29tcGFyZUZ1bmN0aW9uKHNlbGVjdG9yKTtcblxuICAgICAgcmV0dXJuIGNhc2goZmlsdGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoZSwgc2VsZWN0b3IpO1xuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB0aGlzW2luZGV4ICsgdGhpcy5sZW5ndGhdIDogdGhpc1tpbmRleF07XG4gICAgfSxcblxuICAgIGluZGV4OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyIGNoaWxkID0gZWxlbSA/IGNhc2goZWxlbSlbMF0gOiB0aGlzWzBdLFxuICAgICAgICAgIGNvbGxlY3Rpb24gPSBlbGVtID8gdGhpcyA6IGNhc2goY2hpbGQpLnBhcmVudCgpLmNoaWxkcmVuKCk7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbChjb2xsZWN0aW9uKS5pbmRleE9mKGNoaWxkKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xuICAgIH1cblxuICB9KTtcblxuICB2YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW1lbFJlZ2V4ID0gLyg/Ol5cXHd8W0EtWl18XFxiXFx3KS9nLFxuICAgICAgICB3aGl0ZVNwYWNlID0gL1tcXHMtX10rL2c7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbFJlZ2V4LCBmdW5jdGlvbiAobGV0dGVyLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGV0dGVyW2luZGV4ID09PSAwID8gXCJ0b0xvd2VyQ2FzZVwiIDogXCJ0b1VwcGVyQ2FzZVwiXSgpO1xuICAgICAgfSkucmVwbGFjZSh3aGl0ZVNwYWNlLCBcIlwiKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGdldFByZWZpeGVkUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FjaGUgPSB7fSxcbiAgICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICAgIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBzdHlsZSA9IGRpdi5zdHlsZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcHJvcCA9IGNhbWVsQ2FzZShwcm9wKTtcbiAgICAgIGlmIChjYWNoZVtwcm9wXSkge1xuICAgICAgICByZXR1cm4gY2FjaGVbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIHZhciB1Y1Byb3AgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKSxcbiAgICAgICAgICBwcmVmaXhlcyA9IFtcIndlYmtpdFwiLCBcIm1velwiLCBcIm1zXCIsIFwib1wiXSxcbiAgICAgICAgICBwcm9wcyA9IChwcm9wICsgXCIgXCIgKyBwcmVmaXhlcy5qb2luKHVjUHJvcCArIFwiIFwiKSArIHVjUHJvcCkuc3BsaXQoXCIgXCIpO1xuXG4gICAgICBlYWNoKHByb3BzLCBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAocCBpbiBzdHlsZSkge1xuICAgICAgICAgIGNhY2hlW3BdID0gcHJvcCA9IGNhY2hlW3Byb3BdID0gcDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY2FjaGVbcHJvcF07XG4gICAgfTtcbiAgfSgpO1xuXG4gIGNhc2gucHJlZml4ZWRQcm9wID0gZ2V0UHJlZml4ZWRQcm9wO1xuICBjYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcblxuICBmbi5leHRlbmQoe1xuICAgIGNzczogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNTdHJpbmcocHJvcCkpIHtcbiAgICAgICAgcHJvcCA9IGdldFByZWZpeGVkUHJvcChwcm9wKTtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIHYuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfSkgOiB3aW4uZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdKVtwcm9wXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3ApIHtcbiAgICAgICAgdGhpcy5jc3Moa2V5LCBwcm9wW2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY29tcHV0ZShlbCwgcHJvcCkge1xuICAgIHJldHVybiBwYXJzZUludCh3aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbFswXSwgbnVsbClbcHJvcF0sIDEwKSB8fCAwO1xuICB9XG5cbiAgZWFjaChbXCJXaWR0aFwiLCBcIkhlaWdodFwiXSwgZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgbG93ZXIgPSB2LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBmbltsb3dlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtsb3dlcl07XG4gICAgfTtcblxuICAgIGZuW1wiaW5uZXJcIiArIHZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbMF1bXCJjbGllbnRcIiArIHZdO1xuICAgIH07XG5cbiAgICBmbltcIm91dGVyXCIgKyB2XSA9IGZ1bmN0aW9uIChtYXJnaW5zKSB7XG4gICAgICByZXR1cm4gdGhpc1swXVtcIm9mZnNldFwiICsgdl0gKyAobWFyZ2lucyA/IGNvbXB1dGUodGhpcywgXCJtYXJnaW5cIiArICh2ID09PSBcIldpZHRoXCIgPyBcIkxlZnRcIiA6IFwiVG9wXCIpKSArIGNvbXB1dGUodGhpcywgXCJtYXJnaW5cIiArICh2ID09PSBcIldpZHRoXCIgPyBcIlJpZ2h0XCIgOiBcIkJvdHRvbVwiKSkgOiAwKTtcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50KG5vZGUsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZXZlbnRDYWNoZSA9IGdldERhdGEobm9kZSwgXCJfY2FzaEV2ZW50c1wiKSB8fCBzZXREYXRhKG5vZGUsIFwiX2Nhc2hFdmVudHNcIiwge30pO1xuICAgIGV2ZW50Q2FjaGVbZXZlbnROYW1lXSA9IGV2ZW50Q2FjaGVbZXZlbnROYW1lXSB8fCBbXTtcbiAgICBldmVudENhY2hlW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobm9kZSwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBldmVudHMgPSBnZXREYXRhKG5vZGUsIFwiX2Nhc2hFdmVudHNcIiksXG4gICAgICAgIGV2ZW50Q2FjaGUgPSBldmVudHMgJiYgZXZlbnRzW2V2ZW50TmFtZV0sXG4gICAgICAgIGluZGV4O1xuXG4gICAgaWYgKCFldmVudENhY2hlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICBpbmRleCA9IGV2ZW50Q2FjaGUuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBldmVudENhY2hlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVhY2goZXZlbnRDYWNoZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgZXZlbnRDYWNoZSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGZuLmV4dGVuZCh7XG4gICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRXZlbnQodiwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGRlbGVnYXRlLCBjYWxsYmFjaywgcnVuT25jZSkge1xuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjaztcbiAgICAgIGlmICghaXNTdHJpbmcoZXZlbnROYW1lKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgICAgdGhpcy5vbihrZXksIGRlbGVnYXRlLCBldmVudE5hbWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRlbGVnYXRlKSkge1xuICAgICAgICBjYWxsYmFjayA9IGRlbGVnYXRlO1xuICAgICAgICBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwicmVhZHlcIikge1xuICAgICAgICBvblJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IGUudGFyZ2V0O1xuICAgICAgICAgIHdoaWxlICghbWF0Y2hlcyh0LCBkZWxlZ2F0ZSkpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSB0aGlzIHx8IHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdCA9IHQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5jYWxsKHQsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgZmluYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAocnVuT25jZSkge1xuICAgICAgICAgIGZpbmFsQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQodiwgZXZlbnROYW1lLCBmaW5hbENhbGxiYWNrKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyRXZlbnQodiwgZXZlbnROYW1lLCBmaW5hbENhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvbmU6IGZ1bmN0aW9uIChldmVudE5hbWUsIGRlbGVnYXRlLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBkZWxlZ2F0ZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgIH0sXG5cbiAgICByZWFkeTogb25SZWFkeSxcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVkXG4gICAgICogVHJpZ2dlcnMgYnJvd3NlciBldmVudFxuICAgICAqIEBwYXJhbSBTdHJpbmcgZXZlbnROYW1lXG4gICAgICogQHBhcmFtIE9iamVjdCBkYXRhIC0gQWRkIHByb3BlcnRpZXMgdG8gZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBldnQgPSB0aGlzLmV4dGVuZChldnQsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIHYuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW5jb2RlKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiJlwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpLnJlcGxhY2UoLyUyMC9nLCBcIitcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZWxlY3RNdWx0aXBsZV8oZWwpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZWFjaChlbC5vcHRpb25zLCBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKG8uc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goby52YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyB2YWx1ZXMgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0U2luZ2xlXyhlbCkge1xuICAgIHZhciBzZWxlY3RlZEluZGV4ID0gZWwuc2VsZWN0ZWRJbmRleDtcbiAgICByZXR1cm4gc2VsZWN0ZWRJbmRleCA+PSAwID8gZWwub3B0aW9uc1tzZWxlY3RlZEluZGV4XS52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xuICAgIHZhciB0eXBlID0gZWwudHlwZTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcInNlbGVjdC1vbmVcIjpcbiAgICAgICAgcmV0dXJuIGdldFNlbGVjdFNpbmdsZV8oZWwpO1xuICAgICAgY2FzZSBcInNlbGVjdC1tdWx0aXBsZVwiOlxuICAgICAgICByZXR1cm4gZ2V0U2VsZWN0TXVsdGlwbGVfKGVsKTtcbiAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICByZXR1cm4gZWwuY2hlY2tlZCA/IGVsLnZhbHVlIDogbnVsbDtcbiAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICByZXR1cm4gZWwuY2hlY2tlZCA/IGVsLnZhbHVlIDogbnVsbDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlbC52YWx1ZSA/IGVsLnZhbHVlIDogbnVsbDtcbiAgICB9XG4gIH1cblxuICBmbi5leHRlbmQoe1xuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHF1ZXJ5ID0gXCJcIjtcblxuICAgICAgZWFjaCh0aGlzWzBdLmVsZW1lbnRzIHx8IHRoaXMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwuZGlzYWJsZWQgfHwgZWwudGFnTmFtZSA9PT0gXCJGSUVMRFNFVFwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gZWwubmFtZTtcbiAgICAgICAgc3dpdGNoIChlbC50eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgIGNhc2UgXCJyZXNldFwiOlxuICAgICAgICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2VsZWN0LW11bHRpcGxlXCI6XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlYWNoKHZhbHVlcywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgKz0gZW5jb2RlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHF1ZXJ5ICs9IGVuY29kZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcXVlcnkuc3Vic3RyKDEpO1xuICAgIH0sXG5cbiAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2LnZhbHVlID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaW5zZXJ0RWxlbWVudChlbCwgY2hpbGQsIHByZXBlbmQpIHtcbiAgICBpZiAocHJlcGVuZCkge1xuICAgICAgdmFyIGZpcnN0ID0gZWwuY2hpbGROb2Rlc1swXTtcbiAgICAgIGVsLmluc2VydEJlZm9yZShjaGlsZCwgZmlyc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Q29udGVudChwYXJlbnQsIGNoaWxkLCBwcmVwZW5kKSB7XG4gICAgdmFyIHN0ciA9IGlzU3RyaW5nKGNoaWxkKTtcblxuICAgIGlmICghc3RyICYmIGNoaWxkLmxlbmd0aCkge1xuICAgICAgZWFjaChjaGlsZCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydENvbnRlbnQocGFyZW50LCB2LCBwcmVwZW5kKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2gocGFyZW50LCBzdHIgPyBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYuaW5zZXJ0QWRqYWNlbnRIVE1MKHByZXBlbmQgPyBcImFmdGVyYmVnaW5cIiA6IFwiYmVmb3JlZW5kXCIsIGNoaWxkKTtcbiAgICB9IDogZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHJldHVybiBpbnNlcnRFbGVtZW50KHYsIGkgPT09IDAgPyBjaGlsZCA6IGNoaWxkLmNsb25lTm9kZSh0cnVlKSwgcHJlcGVuZCk7XG4gICAgfSk7XG4gIH1cblxuICBmbi5leHRlbmQoe1xuICAgIGFmdGVyOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGNhc2goc2VsZWN0b3IpLmluc2VydEFmdGVyKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFwcGVuZDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIGluc2VydENvbnRlbnQodGhpcywgY29udGVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYXBwZW5kVG86IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgIGluc2VydENvbnRlbnQoY2FzaChwYXJlbnQpLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgY2FzaChzZWxlY3RvcikuaW5zZXJ0QmVmb3JlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2FzaCh0aGlzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmh0bWwoXCJcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaHRtbDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0uaW5uZXJIVE1MO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZSA9IGNvbnRlbnQubm9kZVR5cGUgPyBjb250ZW50WzBdLm91dGVySFRNTCA6IGNvbnRlbnQ7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2LmlubmVySFRNTCA9IHNvdXJjZTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBjYXNoKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHNpYmxpbmcgPSBlbC5uZXh0U2libGluZztcbiAgICAgICAgX3RoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoaSA9PT0gMCA/IHYgOiB2LmNsb25lTm9kZSh0cnVlKSwgc2libGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBjYXNoKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgX3RoaXMyLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGkgPT09IDAgPyB2IDogdi5jbG9uZU5vZGUodHJ1ZSksIGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVwZW5kOiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgaW5zZXJ0Q29udGVudCh0aGlzLCBjb250ZW50LCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVwZW5kVG86IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgIGluc2VydENvbnRlbnQoY2FzaChwYXJlbnQpLCB0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCEhdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRleHQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdLnRleHRDb250ZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICBmbi5leHRlbmQoe1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzWzBdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZWwub2Zmc2V0TGVmdCxcbiAgICAgICAgdG9wOiBlbC5vZmZzZXRUb3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIG9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsLmNsaWVudFRvcCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWwuY2xpZW50TGVmdFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2FzaCh0aGlzWzBdLm9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGZuLmV4dGVuZCh7XG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZW1zID0gW107XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHB1c2guYXBwbHkoZWxlbXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgIH0pO1xuICAgICAgZWxlbXMgPSB1bmlxdWUoZWxlbXMpO1xuXG4gICAgICByZXR1cm4gIXNlbGVjdG9yID8gZWxlbXMgOiBlbGVtcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXModiwgc2VsZWN0b3IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKCFzZWxlY3RvciB8fCB0aGlzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGNhc2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIGlzOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICBjb21wYXJhdG9yID0gZ2V0Q29tcGFyZUZ1bmN0aW9uKHNlbGVjdG9yKTtcblxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBtYXRjaCA9IGNvbXBhcmF0b3IoZWwsIHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuICFtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3Rvci5ub2RlVHlwZSkge1xuICAgICAgICByZXR1cm4gY2FzaChzZWxlY3RvciAmJiB0aGlzLmhhcyhzZWxlY3RvcikubGVuZ3RoID8gc2VsZWN0b3IgOiBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1zID0gW107XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHB1c2guYXBwbHkoZWxlbXMsIGZpbmQoc2VsZWN0b3IsIGVsKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHVuaXF1ZShlbGVtcyk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGlzU3RyaW5nKHNlbGVjdG9yKSA/IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZmluZChzZWxlY3RvciwgZWwpLmxlbmd0aCAhPT0gMDtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNvbnRhaW5zKHNlbGVjdG9yKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihjb21wYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhc2godGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgIH0sXG5cbiAgICBub3Q6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBnZXRDb21wYXJlRnVuY3Rpb24oc2VsZWN0b3IpO1xuXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAhY29tcGFyYXRvcihlbCwgc2VsZWN0b3IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB1bmlxdWUocmVzdWx0KTtcbiAgICB9LFxuXG4gICAgcGFyZW50czogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgbGFzdCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGxhc3QgPSBpdGVtO1xuXG4gICAgICAgIHdoaWxlIChsYXN0ICYmIGxhc3QucGFyZW50Tm9kZSAmJiBsYXN0ICE9PSBkb2MuYm9keS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgbGFzdCA9IGxhc3QucGFyZW50Tm9kZTtcblxuICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgJiYgbWF0Y2hlcyhsYXN0LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB1bmlxdWUocmVzdWx0KTtcbiAgICB9LFxuXG4gICAgcHJldjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhc2godGhpc1swXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKTtcbiAgICB9LFxuXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKHNlbGVjdG9yKSxcbiAgICAgICAgICBlbCA9IHRoaXNbMF07XG5cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaSAhPT0gZWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgcmV0dXJuIGNhc2g7XG59KTtcbjtcbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBHZW5lcmljIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9uZW50c1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KGNsYXNzRGVmLCBlbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnQpO1xuXG4gICAgLy8gRGlzcGxheSBlcnJvciBpZiBlbCBpcyB2YWxpZCBIVE1MIEVsZW1lbnRcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKEVycm9yKGVsICsgJyBpcyBub3QgYW4gSFRNTCBFbGVtZW50JykpO1xuICAgIH1cblxuICAgIC8vIElmIGV4aXN0cywgZGVzdHJveSBhbmQgcmVpbml0aWFsaXplIGluIGNoaWxkXG4gICAgdmFyIGlucyA9IGNsYXNzRGVmLmdldEluc3RhbmNlKGVsKTtcbiAgICBpZiAoISFpbnMpIHtcbiAgICAgIGlucy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuJGVsID0gY2FzaChlbCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgY29tcG9uZW50c1xuICAgKiBAcGFyYW0ge2NsYXNzfSBjbGFzc0RlZlxuICAgKiBAcGFyYW0ge0VsZW1lbnQgfCBOb2RlTGlzdCB8IGpRdWVyeX0gZWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbXBvbmVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGNsYXNzRGVmLCBlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBudWxsO1xuICAgICAgaWYgKGVscyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgaW5zdGFuY2VzID0gbmV3IGNsYXNzRGVmKGVscywgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKCEhZWxzICYmIChlbHMuanF1ZXJ5IHx8IGVscy5jYXNoIHx8IGVscyBpbnN0YW5jZW9mIE5vZGVMaXN0KSkge1xuICAgICAgICB2YXIgaW5zdGFuY2VzQXJyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW5zdGFuY2VzQXJyLnB1c2gobmV3IGNsYXNzRGVmKGVsc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlcyA9IGluc3RhbmNlc0FycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG47IC8vIFJlcXVpcmVkIGZvciBNZXRlb3IgcGFja2FnZSwgdGhlIHVzZSBvZiB3aW5kb3cgcHJldmVudHMgZXhwb3J0IGJ5IE1ldGVvclxuKGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgaWYgKHdpbmRvdy5QYWNrYWdlKSB7XG4gICAgTSA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5NID0ge307XG4gIH1cblxuICAvLyBDaGVjayBmb3IgalF1ZXJ5XG4gIE0ualF1ZXJ5TG9hZGVkID0gISF3aW5kb3cualF1ZXJ5O1xufSkod2luZG93KTtcblxuLy8gQU1EXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZSgnTScsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE07XG4gIH0pO1xuXG4gIC8vIENvbW1vbiBKU1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgIWV4cG9ydHMubm9kZVR5cGUpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNO1xuICB9XG4gIGV4cG9ydHMuZGVmYXVsdCA9IE07XG59XG5cbk0ua2V5cyA9IHtcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIEVTQzogMjcsXG4gIEFSUk9XX1VQOiAzOCxcbiAgQVJST1dfRE9XTjogNDBcbn07XG5cbi8qKlxuICogVGFiUHJlc3MgS2V5ZG93biBoYW5kbGVyXG4gKi9cbk0udGFiUHJlc3NlZCA9IGZhbHNlO1xuTS5rZXlEb3duID0gZmFsc2U7XG52YXIgZG9jSGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gIE0ua2V5RG93biA9IHRydWU7XG4gIGlmIChlLndoaWNoID09PSBNLmtleXMuVEFCIHx8IGUud2hpY2ggPT09IE0ua2V5cy5BUlJPV19ET1dOIHx8IGUud2hpY2ggPT09IE0ua2V5cy5BUlJPV19VUCkge1xuICAgIE0udGFiUHJlc3NlZCA9IHRydWU7XG4gIH1cbn07XG52YXIgZG9jSGFuZGxlS2V5dXAgPSBmdW5jdGlvbiAoZSkge1xuICBNLmtleURvd24gPSBmYWxzZTtcbiAgaWYgKGUud2hpY2ggPT09IE0ua2V5cy5UQUIgfHwgZS53aGljaCA9PT0gTS5rZXlzLkFSUk9XX0RPV04gfHwgZS53aGljaCA9PT0gTS5rZXlzLkFSUk9XX1VQKSB7XG4gICAgTS50YWJQcmVzc2VkID0gZmFsc2U7XG4gIH1cbn07XG52YXIgZG9jSGFuZGxlRm9jdXMgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoTS5rZXlEb3duKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdrZXlib2FyZC1mb2N1c2VkJyk7XG4gIH1cbn07XG52YXIgZG9jSGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChlKSB7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgna2V5Ym9hcmQtZm9jdXNlZCcpO1xufTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb2NIYW5kbGVLZXlkb3duLCB0cnVlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZG9jSGFuZGxlS2V5dXAsIHRydWUpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBkb2NIYW5kbGVGb2N1cywgdHJ1ZSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZG9jSGFuZGxlQmx1ciwgdHJ1ZSk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBqUXVlcnkgd3JhcHBlciBmb3IgcGx1Z2luXG4gKiBAcGFyYW0ge0NsYXNzfSBwbHVnaW4gIGphdmFzY3JpcHQgY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5OYW1lICBqUXVlcnkgcGx1Z2luIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1JlZiAgQ2xhc3MgcmVmZXJlbmNlIG5hbWVcbiAqL1xuTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlciA9IGZ1bmN0aW9uIChwbHVnaW4sIHBsdWdpbk5hbWUsIGNsYXNzUmVmKSB7XG4gIGpRdWVyeS5mbltwbHVnaW5OYW1lXSA9IGZ1bmN0aW9uIChtZXRob2RPck9wdGlvbnMpIHtcbiAgICAvLyBDYWxsIHBsdWdpbiBtZXRob2QgaWYgdmFsaWQgbWV0aG9kIG5hbWUgaXMgcGFzc2VkIGluXG4gICAgaWYgKHBsdWdpbi5wcm90b3R5cGVbbWV0aG9kT3JPcHRpb25zXSkge1xuICAgICAgdmFyIHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIC8vIEdldHRlciBtZXRob2RzXG4gICAgICBpZiAobWV0aG9kT3JPcHRpb25zLnNsaWNlKDAsIDMpID09PSAnZ2V0Jykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmZpcnN0KClbMF1bY2xhc3NSZWZdO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kT3JPcHRpb25zXS5hcHBseShpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgLy8gVm9pZCBtZXRob2RzXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpc1tjbGFzc1JlZl07XG4gICAgICAgIGluc3RhbmNlW21ldGhvZE9yT3B0aW9uc10uYXBwbHkoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBwbHVnaW4gaWYgb3B0aW9ucyBvciBubyBhcmd1bWVudCBpcyBwYXNzZWQgaW5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtZXRob2RPck9wdGlvbnMgPT09ICdvYmplY3QnIHx8ICFtZXRob2RPck9wdGlvbnMpIHtcbiAgICAgIHBsdWdpbi5pbml0KHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gZXJyb3IgaWYgYW4gdW5yZWNvZ25pemVkICBtZXRob2QgbmFtZSBpcyBwYXNzZWQgaW5cbiAgICBqUXVlcnkuZXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2RPck9wdGlvbnMgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuXCIgKyBwbHVnaW5OYW1lKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBpbml0aWFsaXplIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dCAgRE9NIEVsZW1lbnQgdG8gc2VhcmNoIHdpdGhpbiBmb3IgY29tcG9uZW50c1xuICovXG5NLkF1dG9Jbml0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgLy8gVXNlIGRvY3VtZW50LmJvZHkgaWYgbm8gY29udGV4dCBpcyBnaXZlblxuICB2YXIgcm9vdCA9ICEhY29udGV4dCA/IGNvbnRleHQgOiBkb2N1bWVudC5ib2R5O1xuXG4gIHZhciByZWdpc3RyeSA9IHtcbiAgICBBdXRvY29tcGxldGU6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLmF1dG9jb21wbGV0ZTpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIENhcm91c2VsOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJvdXNlbDpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIENoaXBzOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGlwczpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIENvbGxhcHNpYmxlOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb2xsYXBzaWJsZTpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIERhdGVwaWNrZXI6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLmRhdGVwaWNrZXI6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBEcm9wZG93bjogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuZHJvcGRvd24tdHJpZ2dlcjpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIE1hdGVyaWFsYm94OiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tYXRlcmlhbGJveGVkOm5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgTW9kYWw6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLm1vZGFsOm5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgUGFyYWxsYXg6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLnBhcmFsbGF4Om5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgUHVzaHBpbjogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcucHVzaHBpbjpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIFNjcm9sbFNweTogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuc2Nyb2xsc3B5Om5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgRm9ybVNlbGVjdDogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3Q6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBTaWRlbmF2OiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaWRlbmF2Om5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgVGFiczogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcudGFiczpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIFRhcFRhcmdldDogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcudGFwLXRhcmdldDpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIFRpbWVwaWNrZXI6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLnRpbWVwaWNrZXI6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBUb29sdGlwOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy50b29sdGlwcGVkOm5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgRmxvYXRpbmdBY3Rpb25CdXR0b246IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLmZpeGVkLWFjdGlvbi1idG46bm90KC5uby1hdXRvaW5pdCknKVxuICB9O1xuXG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gcmVnaXN0cnkpIHtcbiAgICB2YXIgcGx1Z2luID0gTVtwbHVnaW5OYW1lXTtcbiAgICBwbHVnaW4uaW5pdChyZWdpc3RyeVtwbHVnaW5OYW1lXSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYXBwcm94aW1hdGVkIHNlbGVjdG9yIHN0cmluZyBmb3IgYSBqUXVlcnkgb2JqZWN0XG4gKiBAcGFyYW0ge2pRdWVyeX0gb2JqICBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTS5vYmplY3RTZWxlY3RvclN0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHRhZ1N0ciA9IG9iai5wcm9wKCd0YWdOYW1lJykgfHwgJyc7XG4gIHZhciBpZFN0ciA9IG9iai5hdHRyKCdpZCcpIHx8ICcnO1xuICB2YXIgY2xhc3NTdHIgPSBvYmouYXR0cignY2xhc3MnKSB8fCAnJztcbiAgcmV0dXJuICh0YWdTdHIgKyBpZFN0ciArIGNsYXNzU3RyKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufTtcblxuLy8gVW5pcXVlIFJhbmRvbSBJRFxuTS5ndWlkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzNCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBFc2NhcGVzIGhhc2ggZnJvbSBzcGVjaWFsIGNoYXJhY3RlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoICBTdHJpbmcgcmV0dXJuZWQgZnJvbSB0aGlzLmhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk0uZXNjYXBlSGFzaCA9IGZ1bmN0aW9uIChoYXNoKSB7XG4gIHJldHVybiBoYXNoLnJlcGxhY2UoLyg6fFxcLnxcXFt8XFxdfCx8PXxcXC8pL2csICdcXFxcJDEnKTtcbn07XG5cbk0uZWxlbWVudE9yUGFyZW50SXNGaXhlZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gIHZhciAkY2hlY2tFbGVtZW50cyA9ICRlbGVtZW50LmFkZCgkZWxlbWVudC5wYXJlbnRzKCkpO1xuICB2YXIgaXNGaXhlZCA9IGZhbHNlO1xuICAkY2hlY2tFbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICAgIGlzRml4ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpc0ZpeGVkO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFZGdlc1xuICogQHByb3BlcnR5IHtCb29sZWFufSB0b3AgIElmIHRoZSB0b3AgZWRnZSB3YXMgZXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcmlnaHQgIElmIHRoZSByaWdodCBlZGdlIHdhcyBleGNlZWRlZFxuICogQHByb3BlcnR5IHtCb29sZWFufSBib3R0b20gIElmIHRoZSBib3R0b20gZWRnZSB3YXMgZXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbGVmdCAgSWYgdGhlIGxlZnQgZWRnZSB3YXMgZXhjZWVkZWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJvdW5kaW5nXG4gKiBAcHJvcGVydHkge051bWJlcn0gbGVmdCAgbGVmdCBvZmZzZXQgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHRvcCAgdG9wIG9mZnNldCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge051bWJlcn0gd2lkdGhcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWlnaHRcbiAqL1xuXG4vKipcbiAqIEVzY2FwZXMgaGFzaCBmcm9tIHNwZWNpYWwgY2hhcmFjdGVyc1xuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgIENvbnRhaW5lciBlbGVtZW50IHRoYXQgYWN0cyBhcyB0aGUgYm91bmRhcnlcbiAqIEBwYXJhbSB7Qm91bmRpbmd9IGJvdW5kaW5nICBlbGVtZW50IGJvdW5kaW5nIHRoYXQgaXMgYmVpbmcgY2hlY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAgb2Zmc2V0IGZyb20gZWRnZSB0aGF0IGNvdW50cyBhcyBleGNlZWRpbmdcbiAqIEByZXR1cm5zIHtFZGdlc31cbiAqL1xuTS5jaGVja1dpdGhpbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGJvdW5kaW5nLCBvZmZzZXQpIHtcbiAgdmFyIGVkZ2VzID0ge1xuICAgIHRvcDogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIGJvdHRvbTogZmFsc2UsXG4gICAgbGVmdDogZmFsc2VcbiAgfTtcblxuICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgLy8gSWYgYm9keSBlbGVtZW50IGlzIHNtYWxsZXIgdGhhbiB2aWV3cG9ydCwgdXNlIHZpZXdwb3J0IGhlaWdodCBpbnN0ZWFkLlxuICB2YXIgY29udGFpbmVyQm90dG9tID0gY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5ID8gTWF0aC5tYXgoY29udGFpbmVyUmVjdC5ib3R0b20sIHdpbmRvdy5pbm5lckhlaWdodCkgOiBjb250YWluZXJSZWN0LmJvdHRvbTtcblxuICB2YXIgc2Nyb2xsTGVmdCA9IGNvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICB2YXIgc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbFRvcDtcblxuICB2YXIgc2Nyb2xsZWRYID0gYm91bmRpbmcubGVmdCAtIHNjcm9sbExlZnQ7XG4gIHZhciBzY3JvbGxlZFkgPSBib3VuZGluZy50b3AgLSBzY3JvbGxUb3A7XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbnRhaW5lciBhbmQgdmlld3BvcnQgZm9yIGVhY2ggZWRnZVxuICBpZiAoc2Nyb2xsZWRYIDwgY29udGFpbmVyUmVjdC5sZWZ0ICsgb2Zmc2V0IHx8IHNjcm9sbGVkWCA8IG9mZnNldCkge1xuICAgIGVkZ2VzLmxlZnQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHNjcm9sbGVkWCArIGJvdW5kaW5nLndpZHRoID4gY29udGFpbmVyUmVjdC5yaWdodCAtIG9mZnNldCB8fCBzY3JvbGxlZFggKyBib3VuZGluZy53aWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoIC0gb2Zmc2V0KSB7XG4gICAgZWRnZXMucmlnaHQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHNjcm9sbGVkWSA8IGNvbnRhaW5lclJlY3QudG9wICsgb2Zmc2V0IHx8IHNjcm9sbGVkWSA8IG9mZnNldCkge1xuICAgIGVkZ2VzLnRvcCA9IHRydWU7XG4gIH1cblxuICBpZiAoc2Nyb2xsZWRZICsgYm91bmRpbmcuaGVpZ2h0ID4gY29udGFpbmVyQm90dG9tIC0gb2Zmc2V0IHx8IHNjcm9sbGVkWSArIGJvdW5kaW5nLmhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCAtIG9mZnNldCkge1xuICAgIGVkZ2VzLmJvdHRvbSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZWRnZXM7XG59O1xuXG5NLmNoZWNrUG9zc2libGVBbGlnbm1lbnRzID0gZnVuY3Rpb24gKGVsLCBjb250YWluZXIsIGJvdW5kaW5nLCBvZmZzZXQpIHtcbiAgdmFyIGNhbkFsaWduID0ge1xuICAgIHRvcDogdHJ1ZSxcbiAgICByaWdodDogdHJ1ZSxcbiAgICBib3R0b206IHRydWUsXG4gICAgbGVmdDogdHJ1ZSxcbiAgICBzcGFjZU9uVG9wOiBudWxsLFxuICAgIHNwYWNlT25SaWdodDogbnVsbCxcbiAgICBzcGFjZU9uQm90dG9tOiBudWxsLFxuICAgIHNwYWNlT25MZWZ0OiBudWxsXG4gIH07XG5cbiAgdmFyIGNvbnRhaW5lckFsbG93c092ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLm92ZXJmbG93ID09PSAndmlzaWJsZSc7XG4gIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gTWF0aC5taW4oY29udGFpbmVyUmVjdC5oZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gIHZhciBjb250YWluZXJXaWR0aCA9IE1hdGgubWluKGNvbnRhaW5lclJlY3Qud2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgdmFyIGVsT2Zmc2V0UmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIHZhciBzY3JvbGxMZWZ0ID0gY29udGFpbmVyLnNjcm9sbExlZnQ7XG4gIHZhciBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xuXG4gIHZhciBzY3JvbGxlZFggPSBib3VuZGluZy5sZWZ0IC0gc2Nyb2xsTGVmdDtcbiAgdmFyIHNjcm9sbGVkWVRvcEVkZ2UgPSBib3VuZGluZy50b3AgLSBzY3JvbGxUb3A7XG4gIHZhciBzY3JvbGxlZFlCb3R0b21FZGdlID0gYm91bmRpbmcudG9wICsgZWxPZmZzZXRSZWN0LmhlaWdodCAtIHNjcm9sbFRvcDtcblxuICAvLyBDaGVjayBmb3IgY29udGFpbmVyIGFuZCB2aWV3cG9ydCBmb3IgbGVmdFxuICBjYW5BbGlnbi5zcGFjZU9uUmlnaHQgPSAhY29udGFpbmVyQWxsb3dzT3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCAtIChzY3JvbGxlZFggKyBib3VuZGluZy53aWR0aCkgOiB3aW5kb3cuaW5uZXJXaWR0aCAtIChlbE9mZnNldFJlY3QubGVmdCArIGJvdW5kaW5nLndpZHRoKTtcbiAgaWYgKGNhbkFsaWduLnNwYWNlT25SaWdodCA8IDApIHtcbiAgICBjYW5BbGlnbi5sZWZ0ID0gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgY29udGFpbmVyIGFuZCB2aWV3cG9ydCBmb3IgUmlnaHRcbiAgY2FuQWxpZ24uc3BhY2VPbkxlZnQgPSAhY29udGFpbmVyQWxsb3dzT3ZlcmZsb3cgPyBzY3JvbGxlZFggLSBib3VuZGluZy53aWR0aCArIGVsT2Zmc2V0UmVjdC53aWR0aCA6IGVsT2Zmc2V0UmVjdC5yaWdodCAtIGJvdW5kaW5nLndpZHRoO1xuICBpZiAoY2FuQWxpZ24uc3BhY2VPbkxlZnQgPCAwKSB7XG4gICAgY2FuQWxpZ24ucmlnaHQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBjb250YWluZXIgYW5kIHZpZXdwb3J0IGZvciBUb3BcbiAgY2FuQWxpZ24uc3BhY2VPbkJvdHRvbSA9ICFjb250YWluZXJBbGxvd3NPdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCAtIChzY3JvbGxlZFlUb3BFZGdlICsgYm91bmRpbmcuaGVpZ2h0ICsgb2Zmc2V0KSA6IHdpbmRvdy5pbm5lckhlaWdodCAtIChlbE9mZnNldFJlY3QudG9wICsgYm91bmRpbmcuaGVpZ2h0ICsgb2Zmc2V0KTtcbiAgaWYgKGNhbkFsaWduLnNwYWNlT25Cb3R0b20gPCAwKSB7XG4gICAgY2FuQWxpZ24udG9wID0gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgY29udGFpbmVyIGFuZCB2aWV3cG9ydCBmb3IgQm90dG9tXG4gIGNhbkFsaWduLnNwYWNlT25Ub3AgPSAhY29udGFpbmVyQWxsb3dzT3ZlcmZsb3cgPyBzY3JvbGxlZFlCb3R0b21FZGdlIC0gKGJvdW5kaW5nLmhlaWdodCAtIG9mZnNldCkgOiBlbE9mZnNldFJlY3QuYm90dG9tIC0gKGJvdW5kaW5nLmhlaWdodCArIG9mZnNldCk7XG4gIGlmIChjYW5BbGlnbi5zcGFjZU9uVG9wIDwgMCkge1xuICAgIGNhbkFsaWduLmJvdHRvbSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNhbkFsaWduO1xufTtcblxuTS5nZXRPdmVyZmxvd1BhcmVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5IHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkub3ZlcmZsb3cgIT09ICd2aXNpYmxlJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIE0uZ2V0T3ZlcmZsb3dQYXJlbnQoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbn07XG5cbi8qKlxuICogR2V0cyBpZCBvZiBjb21wb25lbnQgZnJvbSBhIHRyaWdnZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlciAgdHJpZ2dlclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTS5nZXRJZEZyb21UcmlnZ2VyID0gZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgdmFyIGlkID0gdHJpZ2dlci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0Jyk7XG4gIGlmICghaWQpIHtcbiAgICBpZCA9IHRyaWdnZXIuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIE11bHRpIGJyb3dzZXIgc3VwcG9ydCBmb3IgZG9jdW1lbnQgc2Nyb2xsIHRvcFxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuTS5nZXREb2N1bWVudFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG59O1xuXG4vKipcbiAqIE11bHRpIGJyb3dzZXIgc3VwcG9ydCBmb3IgZG9jdW1lbnQgc2Nyb2xsIGxlZnRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbk0uZ2V0RG9jdW1lbnRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFZGdlc1xuICogQHByb3BlcnR5IHtCb29sZWFufSB0b3AgIElmIHRoZSB0b3AgZWRnZSB3YXMgZXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcmlnaHQgIElmIHRoZSByaWdodCBlZGdlIHdhcyBleGNlZWRlZFxuICogQHByb3BlcnR5IHtCb29sZWFufSBib3R0b20gIElmIHRoZSBib3R0b20gZWRnZSB3YXMgZXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbGVmdCAgSWYgdGhlIGxlZnQgZWRnZSB3YXMgZXhjZWVkZWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJvdW5kaW5nXG4gKiBAcHJvcGVydHkge051bWJlcn0gbGVmdCAgbGVmdCBvZmZzZXQgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHRvcCAgdG9wIG9mZnNldCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge051bWJlcn0gd2lkdGhcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWlnaHRcbiAqL1xuXG4vKipcbiAqIEdldCB0aW1lIGluIG1zXG4gKiBAbGljZW5zZSBodHRwczovL3Jhdy5naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL21hc3Rlci9MSUNFTlNFXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbnZhciBnZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICogZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gKiBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gKiBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICogYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gKiBAbGljZW5zZSBodHRwczovL3Jhdy5naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL21hc3Rlci9MSUNFTlNFXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbk0udGhyb3R0bGUgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgIGFyZ3MgPSB2b2lkIDAsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG4gIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBnZXRUaW1lKCk7XG4gICAgdGltZW91dCA9IG51bGw7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IGdldFRpbWUoKTtcbiAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuOyAvKlxuICB2Mi4yLjBcbiAgMjAxNyBKdWxpYW4gR2FybmllclxuICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgKi9cbnZhciAkanNjb21wID0geyBzY29wZToge30gfTskanNjb21wLmRlZmluZVByb3BlcnR5ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIChlLCByLCBwKSB7XG4gIGlmIChwLmdldCB8fCBwLnNldCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVTMyBkb2VzIG5vdCBzdXBwb3J0IGdldHRlcnMgYW5kIHNldHRlcnMuXCIpO2UgIT0gQXJyYXkucHJvdG90eXBlICYmIGUgIT0gT2JqZWN0LnByb3RvdHlwZSAmJiAoZVtyXSA9IHAudmFsdWUpO1xufTskanNjb21wLmdldEdsb2JhbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgd2luZG93ID09PSBlID8gZSA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbCAmJiBudWxsICE9IGdsb2JhbCA/IGdsb2JhbCA6IGU7XG59OyRqc2NvbXAuZ2xvYmFsID0gJGpzY29tcC5nZXRHbG9iYWwodGhpcyk7JGpzY29tcC5TWU1CT0xfUFJFRklYID0gXCJqc2NvbXBfc3ltYm9sX1wiO1xuJGpzY29tcC5pbml0U3ltYm9sID0gZnVuY3Rpb24gKCkge1xuICAkanNjb21wLmluaXRTeW1ib2wgPSBmdW5jdGlvbiAoKSB7fTskanNjb21wLmdsb2JhbC5TeW1ib2wgfHwgKCRqc2NvbXAuZ2xvYmFsLlN5bWJvbCA9ICRqc2NvbXAuU3ltYm9sKTtcbn07JGpzY29tcC5zeW1ib2xDb3VudGVyXyA9IDA7JGpzY29tcC5TeW1ib2wgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gJGpzY29tcC5TWU1CT0xfUFJFRklYICsgKGUgfHwgXCJcIikgKyAkanNjb21wLnN5bWJvbENvdW50ZXJfKys7XG59O1xuJGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICRqc2NvbXAuaW5pdFN5bWJvbCgpO3ZhciBlID0gJGpzY29tcC5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yO2UgfHwgKGUgPSAkanNjb21wLmdsb2JhbC5TeW1ib2wuaXRlcmF0b3IgPSAkanNjb21wLmdsb2JhbC5TeW1ib2woXCJpdGVyYXRvclwiKSk7XCJmdW5jdGlvblwiICE9IHR5cGVvZiBBcnJheS5wcm90b3R5cGVbZV0gJiYgJGpzY29tcC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsIGUsIHsgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRqc2NvbXAuYXJyYXlJdGVyYXRvcih0aGlzKTtcbiAgICB9IH0pOyRqc2NvbXAuaW5pdFN5bWJvbEl0ZXJhdG9yID0gZnVuY3Rpb24gKCkge307XG59OyRqc2NvbXAuYXJyYXlJdGVyYXRvciA9IGZ1bmN0aW9uIChlKSB7XG4gIHZhciByID0gMDtyZXR1cm4gJGpzY29tcC5pdGVyYXRvclByb3RvdHlwZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHIgPCBlLmxlbmd0aCA/IHsgZG9uZTogITEsIHZhbHVlOiBlW3IrK10gfSA6IHsgZG9uZTogITAgfTtcbiAgfSk7XG59O1xuJGpzY29tcC5pdGVyYXRvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChlKSB7XG4gICRqc2NvbXAuaW5pdFN5bWJvbEl0ZXJhdG9yKCk7ZSA9IHsgbmV4dDogZSB9O2VbJGpzY29tcC5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtyZXR1cm4gZTtcbn07JGpzY29tcC5hcnJheSA9ICRqc2NvbXAuYXJyYXkgfHwge307JGpzY29tcC5pdGVyYXRvckZyb21BcnJheSA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICRqc2NvbXAuaW5pdFN5bWJvbEl0ZXJhdG9yKCk7ZSBpbnN0YW5jZW9mIFN0cmluZyAmJiAoZSArPSBcIlwiKTt2YXIgcCA9IDAsXG4gICAgICBtID0geyBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocCA8IGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciB1ID0gcCsrO3JldHVybiB7IHZhbHVlOiByKHUsIGVbdV0pLCBkb25lOiAhMSB9O1xuICAgICAgfW0ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogITAsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgIH07cmV0dXJuIG0ubmV4dCgpO1xuICAgIH0gfTttW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG07XG4gIH07cmV0dXJuIG07XG59O1xuJGpzY29tcC5wb2x5ZmlsbCA9IGZ1bmN0aW9uIChlLCByLCBwLCBtKSB7XG4gIGlmIChyKSB7XG4gICAgcCA9ICRqc2NvbXAuZ2xvYmFsO2UgPSBlLnNwbGl0KFwiLlwiKTtmb3IgKG0gPSAwOyBtIDwgZS5sZW5ndGggLSAxOyBtKyspIHtcbiAgICAgIHZhciB1ID0gZVttXTt1IGluIHAgfHwgKHBbdV0gPSB7fSk7cCA9IHBbdV07XG4gICAgfWUgPSBlW2UubGVuZ3RoIC0gMV07bSA9IHBbZV07ciA9IHIobSk7ciAhPSBtICYmIG51bGwgIT0gciAmJiAkanNjb21wLmRlZmluZVByb3BlcnR5KHAsIGUsIHsgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogciB9KTtcbiAgfVxufTskanNjb21wLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLmtleXNcIiwgZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGUgPyBlIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkanNjb21wLml0ZXJhdG9yRnJvbUFycmF5KHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfTtcbn0sIFwiZXM2LWltcGxcIiwgXCJlczNcIik7dmFyICRqc2NvbXAkdGhpcyA9IHRoaXM7XG4oZnVuY3Rpb24gKHIpIHtcbiAgTS5hbmltZSA9IHIoKTtcbn0pKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZShhKSB7XG4gICAgaWYgKCFoLmNvbChhKSkgdHJ5IHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGEpO1xuICAgIH0gY2F0Y2ggKGMpIHt9XG4gIH1mdW5jdGlvbiByKGEsIGMpIHtcbiAgICBmb3IgKHZhciBkID0gYS5sZW5ndGgsIGIgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDAsIGYgPSBbXSwgbiA9IDA7IG4gPCBkOyBuKyspIHtcbiAgICAgIGlmIChuIGluIGEpIHtcbiAgICAgICAgdmFyIGsgPSBhW25dO2MuY2FsbChiLCBrLCBuLCBhKSAmJiBmLnB1c2goayk7XG4gICAgICB9XG4gICAgfXJldHVybiBmO1xuICB9ZnVuY3Rpb24gcChhKSB7XG4gICAgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICByZXR1cm4gYS5jb25jYXQoaC5hcnIoZCkgPyBwKGQpIDogZCk7XG4gICAgfSwgW10pO1xuICB9ZnVuY3Rpb24gbShhKSB7XG4gICAgaWYgKGguYXJyKGEpKSByZXR1cm4gYTtcbiAgICBoLnN0cihhKSAmJiAoYSA9IGUoYSkgfHwgYSk7cmV0dXJuIGEgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBhIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24gPyBbXS5zbGljZS5jYWxsKGEpIDogW2FdO1xuICB9ZnVuY3Rpb24gdShhLCBjKSB7XG4gICAgcmV0dXJuIGEuc29tZShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEgPT09IGM7XG4gICAgfSk7XG4gIH1mdW5jdGlvbiBDKGEpIHtcbiAgICB2YXIgYyA9IHt9LFxuICAgICAgICBkO2ZvciAoZCBpbiBhKSB7XG4gICAgICBjW2RdID0gYVtkXTtcbiAgICB9cmV0dXJuIGM7XG4gIH1mdW5jdGlvbiBEKGEsIGMpIHtcbiAgICB2YXIgZCA9IEMoYSksXG4gICAgICAgIGI7Zm9yIChiIGluIGEpIHtcbiAgICAgIGRbYl0gPSBjLmhhc093blByb3BlcnR5KGIpID8gY1tiXSA6IGFbYl07XG4gICAgfXJldHVybiBkO1xuICB9ZnVuY3Rpb24geihhLCBjKSB7XG4gICAgdmFyIGQgPSBDKGEpLFxuICAgICAgICBiO2ZvciAoYiBpbiBjKSB7XG4gICAgICBkW2JdID0gaC51bmQoYVtiXSkgPyBjW2JdIDogYVtiXTtcbiAgICB9cmV0dXJuIGQ7XG4gIH1mdW5jdGlvbiBUKGEpIHtcbiAgICBhID0gYS5yZXBsYWNlKC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2ksIGZ1bmN0aW9uIChhLCBjLCBkLCBrKSB7XG4gICAgICByZXR1cm4gYyArIGMgKyBkICsgZCArIGsgKyBrO1xuICAgIH0pO3ZhciBjID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGEpO1xuICAgIGEgPSBwYXJzZUludChjWzFdLCAxNik7dmFyIGQgPSBwYXJzZUludChjWzJdLCAxNiksXG4gICAgICAgIGMgPSBwYXJzZUludChjWzNdLCAxNik7cmV0dXJuIFwicmdiYShcIiArIGEgKyBcIixcIiArIGQgKyBcIixcIiArIGMgKyBcIiwxKVwiO1xuICB9ZnVuY3Rpb24gVShhKSB7XG4gICAgZnVuY3Rpb24gYyhhLCBjLCBiKSB7XG4gICAgICAwID4gYiAmJiAoYiArPSAxKTsxIDwgYiAmJiAtLWI7cmV0dXJuIGIgPCAxIC8gNiA/IGEgKyA2ICogKGMgLSBhKSAqIGIgOiAuNSA+IGIgPyBjIDogYiA8IDIgLyAzID8gYSArIChjIC0gYSkgKiAoMiAvIDMgLSBiKSAqIDYgOiBhO1xuICAgIH12YXIgZCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGEpIHx8IC9oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKylcXCkvZy5leGVjKGEpO2EgPSBwYXJzZUludChkWzFdKSAvIDM2MDt2YXIgYiA9IHBhcnNlSW50KGRbMl0pIC8gMTAwLFxuICAgICAgICBmID0gcGFyc2VJbnQoZFszXSkgLyAxMDAsXG4gICAgICAgIGQgPSBkWzRdIHx8IDE7aWYgKDAgPT0gYikgZiA9IGIgPSBhID0gZjtlbHNlIHtcbiAgICAgIHZhciBuID0gLjUgPiBmID8gZiAqICgxICsgYikgOiBmICsgYiAtIGYgKiBiLFxuICAgICAgICAgIGsgPSAyICogZiAtIG4sXG4gICAgICAgICAgZiA9IGMoaywgbiwgYSArIDEgLyAzKSxcbiAgICAgICAgICBiID0gYyhrLCBuLCBhKTthID0gYyhrLCBuLCBhIC0gMSAvIDMpO1xuICAgIH1yZXR1cm4gXCJyZ2JhKFwiICsgMjU1ICogZiArIFwiLFwiICsgMjU1ICogYiArIFwiLFwiICsgMjU1ICogYSArIFwiLFwiICsgZCArIFwiKVwiO1xuICB9ZnVuY3Rpb24geShhKSB7XG4gICAgaWYgKGEgPSAvKFtcXCtcXC1dP1swLTkjXFwuXSspKCV8cHh8cHR8ZW18cmVtfGlufGNtfG1tfGV4fGNofHBjfHZ3fHZofHZtaW58dm1heHxkZWd8cmFkfHR1cm4pPyQvLmV4ZWMoYSkpIHJldHVybiBhWzJdO1xuICB9ZnVuY3Rpb24gVihhKSB7XG4gICAgaWYgKC0xIDwgYS5pbmRleE9mKFwidHJhbnNsYXRlXCIpIHx8IFwicGVyc3BlY3RpdmVcIiA9PT0gYSkgcmV0dXJuIFwicHhcIjtpZiAoLTEgPCBhLmluZGV4T2YoXCJyb3RhdGVcIikgfHwgLTEgPCBhLmluZGV4T2YoXCJza2V3XCIpKSByZXR1cm4gXCJkZWdcIjtcbiAgfWZ1bmN0aW9uIEkoYSwgYykge1xuICAgIHJldHVybiBoLmZuYyhhKSA/IGEoYy50YXJnZXQsIGMuaWQsIGMudG90YWwpIDogYTtcbiAgfWZ1bmN0aW9uIEUoYSwgYykge1xuICAgIGlmIChjIGluIGEuc3R5bGUpIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCkpIHx8IFwiMFwiO1xuICB9ZnVuY3Rpb24gSihhLCBjKSB7XG4gICAgaWYgKGguZG9tKGEpICYmIHUoVywgYykpIHJldHVybiBcInRyYW5zZm9ybVwiO2lmIChoLmRvbShhKSAmJiAoYS5nZXRBdHRyaWJ1dGUoYykgfHwgaC5zdmcoYSkgJiYgYVtjXSkpIHJldHVybiBcImF0dHJpYnV0ZVwiO2lmIChoLmRvbShhKSAmJiBcInRyYW5zZm9ybVwiICE9PSBjICYmIEUoYSwgYykpIHJldHVybiBcImNzc1wiO2lmIChudWxsICE9IGFbY10pIHJldHVybiBcIm9iamVjdFwiO1xuICB9ZnVuY3Rpb24gWChhLCBjKSB7XG4gICAgdmFyIGQgPSBWKGMpLFxuICAgICAgICBkID0gLTEgPCBjLmluZGV4T2YoXCJzY2FsZVwiKSA/IDEgOiAwICsgZDthID0gYS5zdHlsZS50cmFuc2Zvcm07aWYgKCFhKSByZXR1cm4gZDtmb3IgKHZhciBiID0gW10sIGYgPSBbXSwgbiA9IFtdLCBrID0gLyhcXHcrKVxcKCguKz8pXFwpL2c7IGIgPSBrLmV4ZWMoYSk7KSB7XG4gICAgICBmLnB1c2goYlsxXSksIG4ucHVzaChiWzJdKTtcbiAgICB9YSA9IHIobiwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmW2JdID09PSBjO1xuICAgIH0pO3JldHVybiBhLmxlbmd0aCA/IGFbMF0gOiBkO1xuICB9ZnVuY3Rpb24gSyhhLCBjKSB7XG4gICAgc3dpdGNoIChKKGEsIGMpKSB7Y2FzZSBcInRyYW5zZm9ybVwiOlxuICAgICAgICByZXR1cm4gWChhLCBjKTtjYXNlIFwiY3NzXCI6XG4gICAgICAgIHJldHVybiBFKGEsIGMpO2Nhc2UgXCJhdHRyaWJ1dGVcIjpcbiAgICAgICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlKGMpO31yZXR1cm4gYVtjXSB8fCAwO1xuICB9ZnVuY3Rpb24gTChhLCBjKSB7XG4gICAgdmFyIGQgPSAvXihcXCo9fFxcKz18LT0pLy5leGVjKGEpO2lmICghZCkgcmV0dXJuIGE7dmFyIGIgPSB5KGEpIHx8IDA7YyA9IHBhcnNlRmxvYXQoYyk7YSA9IHBhcnNlRmxvYXQoYS5yZXBsYWNlKGRbMF0sIFwiXCIpKTtzd2l0Y2ggKGRbMF1bMF0pIHtjYXNlIFwiK1wiOlxuICAgICAgICByZXR1cm4gYyArIGEgKyBiO2Nhc2UgXCItXCI6XG4gICAgICAgIHJldHVybiBjIC0gYSArIGI7Y2FzZSBcIipcIjpcbiAgICAgICAgcmV0dXJuIGMgKiBhICsgYjt9XG4gIH1mdW5jdGlvbiBGKGEsIGMpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGMueCAtIGEueCwgMikgKyBNYXRoLnBvdyhjLnkgLSBhLnksIDIpKTtcbiAgfWZ1bmN0aW9uIE0oYSkge1xuICAgIGEgPSBhLnBvaW50cztmb3IgKHZhciBjID0gMCwgZCwgYiA9IDA7IGIgPCBhLm51bWJlck9mSXRlbXM7IGIrKykge1xuICAgICAgdmFyIGYgPSBhLmdldEl0ZW0oYik7MCA8IGIgJiYgKGMgKz0gRihkLCBmKSk7ZCA9IGY7XG4gICAgfXJldHVybiBjO1xuICB9ZnVuY3Rpb24gTihhKSB7XG4gICAgaWYgKGEuZ2V0VG90YWxMZW5ndGgpIHJldHVybiBhLmdldFRvdGFsTGVuZ3RoKCk7c3dpdGNoIChhLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge2Nhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgcmV0dXJuIDIgKiBNYXRoLlBJICogYS5nZXRBdHRyaWJ1dGUoXCJyXCIpO2Nhc2UgXCJyZWN0XCI6XG4gICAgICAgIHJldHVybiAyICogYS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSArIDIgKiBhLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtjYXNlIFwibGluZVwiOlxuICAgICAgICByZXR1cm4gRih7IHg6IGEuZ2V0QXR0cmlidXRlKFwieDFcIiksIHk6IGEuZ2V0QXR0cmlidXRlKFwieTFcIikgfSwgeyB4OiBhLmdldEF0dHJpYnV0ZShcIngyXCIpLCB5OiBhLmdldEF0dHJpYnV0ZShcInkyXCIpIH0pO2Nhc2UgXCJwb2x5bGluZVwiOlxuICAgICAgICByZXR1cm4gTShhKTtjYXNlIFwicG9seWdvblwiOlxuICAgICAgICB2YXIgYyA9IGEucG9pbnRzO3JldHVybiBNKGEpICsgRihjLmdldEl0ZW0oYy5udW1iZXJPZkl0ZW1zIC0gMSksIGMuZ2V0SXRlbSgwKSk7fVxuICB9ZnVuY3Rpb24gWShhLCBjKSB7XG4gICAgZnVuY3Rpb24gZChiKSB7XG4gICAgICBiID0gdm9pZCAwID09PSBiID8gMCA6IGI7cmV0dXJuIGEuZWwuZ2V0UG9pbnRBdExlbmd0aCgxIDw9IGMgKyBiID8gYyArIGIgOiAwKTtcbiAgICB9dmFyIGIgPSBkKCksXG4gICAgICAgIGYgPSBkKC0xKSxcbiAgICAgICAgbiA9IGQoMSk7c3dpdGNoIChhLnByb3BlcnR5KSB7Y2FzZSBcInhcIjpcbiAgICAgICAgcmV0dXJuIGIueDtjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gYi55O1xuICAgICAgY2FzZSBcImFuZ2xlXCI6XG4gICAgICAgIHJldHVybiAxODAgKiBNYXRoLmF0YW4yKG4ueSAtIGYueSwgbi54IC0gZi54KSAvIE1hdGguUEk7fVxuICB9ZnVuY3Rpb24gTyhhLCBjKSB7XG4gICAgdmFyIGQgPSAvLT9cXGQqXFwuP1xcZCsvZyxcbiAgICAgICAgYjtiID0gaC5wdGgoYSkgPyBhLnRvdGFsTGVuZ3RoIDogYTtpZiAoaC5jb2woYikpIHtcbiAgICAgIGlmIChoLnJnYihiKSkge1xuICAgICAgICB2YXIgZiA9IC9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhiKTtiID0gZiA/IFwicmdiYShcIiArIGZbMV0gKyBcIiwxKVwiIDogYjtcbiAgICAgIH0gZWxzZSBiID0gaC5oZXgoYikgPyBUKGIpIDogaC5oc2woYikgPyBVKGIpIDogdm9pZCAwO1xuICAgIH0gZWxzZSBmID0gKGYgPSB5KGIpKSA/IGIuc3Vic3RyKDAsIGIubGVuZ3RoIC0gZi5sZW5ndGgpIDogYiwgYiA9IGMgJiYgIS9cXHMvZy50ZXN0KGIpID8gZiArIGMgOiBmO2IgKz0gXCJcIjtyZXR1cm4geyBvcmlnaW5hbDogYiwgbnVtYmVyczogYi5tYXRjaChkKSA/IGIubWF0Y2goZCkubWFwKE51bWJlcikgOiBbMF0sIHN0cmluZ3M6IGguc3RyKGEpIHx8IGMgPyBiLnNwbGl0KGQpIDogW10gfTtcbiAgfWZ1bmN0aW9uIFAoYSkge1xuICAgIGEgPSBhID8gcChoLmFycihhKSA/IGEubWFwKG0pIDogbShhKSkgOiBbXTtyZXR1cm4gcihhLCBmdW5jdGlvbiAoYSwgZCwgYikge1xuICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA9PT0gZDtcbiAgICB9KTtcbiAgfWZ1bmN0aW9uIFooYSkge1xuICAgIHZhciBjID0gUChhKTtyZXR1cm4gYy5tYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB7IHRhcmdldDogYSwgaWQ6IGIsIHRvdGFsOiBjLmxlbmd0aCB9O1xuICAgIH0pO1xuICB9ZnVuY3Rpb24gYWEoYSwgYykge1xuICAgIHZhciBkID0gQyhjKTtpZiAoaC5hcnIoYSkpIHtcbiAgICAgIHZhciBiID0gYS5sZW5ndGg7MiAhPT0gYiB8fCBoLm9iaihhWzBdKSA/IGguZm5jKGMuZHVyYXRpb24pIHx8IChkLmR1cmF0aW9uID0gYy5kdXJhdGlvbiAvIGIpIDogYSA9IHsgdmFsdWU6IGEgfTtcbiAgICB9cmV0dXJuIG0oYSkubWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBiID0gYiA/IDAgOiBjLmRlbGF5O2EgPSBoLm9iaihhKSAmJiAhaC5wdGgoYSkgPyBhIDogeyB2YWx1ZTogYSB9O2gudW5kKGEuZGVsYXkpICYmIChhLmRlbGF5ID0gYik7cmV0dXJuIGE7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4geihhLCBkKTtcbiAgICB9KTtcbiAgfWZ1bmN0aW9uIGJhKGEsIGMpIHtcbiAgICB2YXIgZCA9IHt9LFxuICAgICAgICBiO2ZvciAoYiBpbiBhKSB7XG4gICAgICB2YXIgZiA9IEkoYVtiXSwgYyk7aC5hcnIoZikgJiYgKGYgPSBmLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSShhLCBjKTtcbiAgICAgIH0pLCAxID09PSBmLmxlbmd0aCAmJiAoZiA9IGZbMF0pKTtkW2JdID0gZjtcbiAgICB9ZC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZC5kdXJhdGlvbik7ZC5kZWxheSA9IHBhcnNlRmxvYXQoZC5kZWxheSk7cmV0dXJuIGQ7XG4gIH1mdW5jdGlvbiBjYShhKSB7XG4gICAgcmV0dXJuIGguYXJyKGEpID8gQS5hcHBseSh0aGlzLCBhKSA6IFFbYV07XG4gIH1mdW5jdGlvbiBkYShhLCBjKSB7XG4gICAgdmFyIGQ7cmV0dXJuIGEudHdlZW5zLm1hcChmdW5jdGlvbiAoYikge1xuICAgICAgYiA9IGJhKGIsIGMpO3ZhciBmID0gYi52YWx1ZSxcbiAgICAgICAgICBlID0gSyhjLnRhcmdldCwgYS5uYW1lKSxcbiAgICAgICAgICBrID0gZCA/IGQudG8ub3JpZ2luYWwgOiBlLFxuICAgICAgICAgIGsgPSBoLmFycihmKSA/IGZbMF0gOiBrLFxuICAgICAgICAgIHcgPSBMKGguYXJyKGYpID8gZlsxXSA6IGYsIGspLFxuICAgICAgICAgIGUgPSB5KHcpIHx8IHkoaykgfHwgeShlKTtiLmZyb20gPSBPKGssIGUpO2IudG8gPSBPKHcsIGUpO2Iuc3RhcnQgPSBkID8gZC5lbmQgOiBhLm9mZnNldDtiLmVuZCA9IGIuc3RhcnQgKyBiLmRlbGF5ICsgYi5kdXJhdGlvbjtiLmVhc2luZyA9IGNhKGIuZWFzaW5nKTtiLmVsYXN0aWNpdHkgPSAoMUUzIC0gTWF0aC5taW4oTWF0aC5tYXgoYi5lbGFzdGljaXR5LCAxKSwgOTk5KSkgLyAxRTM7Yi5pc1BhdGggPSBoLnB0aChmKTtiLmlzQ29sb3IgPSBoLmNvbChiLmZyb20ub3JpZ2luYWwpO2IuaXNDb2xvciAmJiAoYi5yb3VuZCA9IDEpO3JldHVybiBkID0gYjtcbiAgICB9KTtcbiAgfWZ1bmN0aW9uIGVhKGEsIGMpIHtcbiAgICByZXR1cm4gcihwKGEubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gYy5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGMgPSBKKGEudGFyZ2V0LCBiLm5hbWUpO2lmIChjKSB7XG4gICAgICAgICAgdmFyIGQgPSBkYShiLCBhKTtiID0geyB0eXBlOiBjLCBwcm9wZXJ0eTogYi5uYW1lLCBhbmltYXRhYmxlOiBhLCB0d2VlbnM6IGQsIGR1cmF0aW9uOiBkW2QubGVuZ3RoIC0gMV0uZW5kLCBkZWxheTogZFswXS5kZWxheSB9O1xuICAgICAgICB9IGVsc2UgYiA9IHZvaWQgMDtyZXR1cm4gYjtcbiAgICAgIH0pO1xuICAgIH0pKSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiAhaC51bmQoYSk7XG4gICAgfSk7XG4gIH1mdW5jdGlvbiBSKGEsIGMsIGQsIGIpIHtcbiAgICB2YXIgZiA9IFwiZGVsYXlcIiA9PT0gYTtyZXR1cm4gYy5sZW5ndGggPyAoZiA/IE1hdGgubWluIDogTWF0aC5tYXgpLmFwcGx5KE1hdGgsIGMubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gYlthXTtcbiAgICB9KSkgOiBmID8gYi5kZWxheSA6IGQub2Zmc2V0ICsgYi5kZWxheSArIGIuZHVyYXRpb247XG4gIH1mdW5jdGlvbiBmYShhKSB7XG4gICAgdmFyIGMgPSBEKGdhLCBhKSxcbiAgICAgICAgZCA9IEQoUywgYSksXG4gICAgICAgIGIgPSBaKGEudGFyZ2V0cyksXG4gICAgICAgIGYgPSBbXSxcbiAgICAgICAgZSA9IHooYywgZCksXG4gICAgICAgIGs7Zm9yIChrIGluIGEpIHtcbiAgICAgIGUuaGFzT3duUHJvcGVydHkoaykgfHwgXCJ0YXJnZXRzXCIgPT09IGsgfHwgZi5wdXNoKHsgbmFtZTogaywgb2Zmc2V0OiBlLm9mZnNldCwgdHdlZW5zOiBhYShhW2tdLCBkKSB9KTtcbiAgICB9YSA9IGVhKGIsIGYpO3JldHVybiB6KGMsIHsgY2hpbGRyZW46IFtdLCBhbmltYXRhYmxlczogYiwgYW5pbWF0aW9uczogYSwgZHVyYXRpb246IFIoXCJkdXJhdGlvblwiLCBhLCBjLCBkKSwgZGVsYXk6IFIoXCJkZWxheVwiLCBhLCBjLCBkKSB9KTtcbiAgfWZ1bmN0aW9uIHEoYSkge1xuICAgIGZ1bmN0aW9uIGMoKSB7XG4gICAgICByZXR1cm4gd2luZG93LlByb21pc2UgJiYgbmV3IFByb21pc2UoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHAgPSBhO1xuICAgICAgfSk7XG4gICAgfWZ1bmN0aW9uIGQoYSkge1xuICAgICAgcmV0dXJuIGcucmV2ZXJzZWQgPyBnLmR1cmF0aW9uIC0gYSA6IGE7XG4gICAgfWZ1bmN0aW9uIGIoYSkge1xuICAgICAgZm9yICh2YXIgYiA9IDAsIGMgPSB7fSwgZCA9IGcuYW5pbWF0aW9ucywgZiA9IGQubGVuZ3RoOyBiIDwgZjspIHtcbiAgICAgICAgdmFyIGUgPSBkW2JdLFxuICAgICAgICAgICAgayA9IGUuYW5pbWF0YWJsZSxcbiAgICAgICAgICAgIGggPSBlLnR3ZWVucyxcbiAgICAgICAgICAgIG4gPSBoLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBsID0gaFtuXTtuICYmIChsID0gcihoLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBhIDwgYi5lbmQ7XG4gICAgICAgIH0pWzBdIHx8IGwpO2ZvciAodmFyIGggPSBNYXRoLm1pbihNYXRoLm1heChhIC0gbC5zdGFydCAtIGwuZGVsYXksIDApLCBsLmR1cmF0aW9uKSAvIGwuZHVyYXRpb24sIHcgPSBpc05hTihoKSA/IDEgOiBsLmVhc2luZyhoLCBsLmVsYXN0aWNpdHkpLCBoID0gbC50by5zdHJpbmdzLCBwID0gbC5yb3VuZCwgbiA9IFtdLCBtID0gdm9pZCAwLCBtID0gbC50by5udW1iZXJzLmxlbmd0aCwgdCA9IDA7IHQgPCBtOyB0KyspIHtcbiAgICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgeCA9IGwudG8ubnVtYmVyc1t0XSxcbiAgICAgICAgICAgICAgcSA9IGwuZnJvbS5udW1iZXJzW3RdLFxuICAgICAgICAgICAgICB4ID0gbC5pc1BhdGggPyBZKGwudmFsdWUsIHcgKiB4KSA6IHEgKyB3ICogKHggLSBxKTtwICYmIChsLmlzQ29sb3IgJiYgMiA8IHQgfHwgKHggPSBNYXRoLnJvdW5kKHggKiBwKSAvIHApKTtuLnB1c2goeCk7XG4gICAgICAgIH1pZiAobCA9IGgubGVuZ3RoKSBmb3IgKG0gPSBoWzBdLCB3ID0gMDsgdyA8IGw7IHcrKykge1xuICAgICAgICAgIHAgPSBoW3cgKyAxXSwgdCA9IG5bd10sIGlzTmFOKHQpIHx8IChtID0gcCA/IG0gKyAodCArIHApIDogbSArICh0ICsgXCIgXCIpKTtcbiAgICAgICAgfSBlbHNlIG0gPSBuWzBdO2hhW2UudHlwZV0oay50YXJnZXQsIGUucHJvcGVydHksIG0sIGMsIGsuaWQpO2UuY3VycmVudFZhbHVlID0gbTtiKys7XG4gICAgICB9aWYgKGIgPSBPYmplY3Qua2V5cyhjKS5sZW5ndGgpIGZvciAoZCA9IDA7IGQgPCBiOyBkKyspIHtcbiAgICAgICAgSCB8fCAoSCA9IEUoZG9jdW1lbnQuYm9keSwgXCJ0cmFuc2Zvcm1cIikgPyBcInRyYW5zZm9ybVwiIDogXCItd2Via2l0LXRyYW5zZm9ybVwiKSwgZy5hbmltYXRhYmxlc1tkXS50YXJnZXQuc3R5bGVbSF0gPSBjW2RdLmpvaW4oXCIgXCIpO1xuICAgICAgfWcuY3VycmVudFRpbWUgPSBhO2cucHJvZ3Jlc3MgPSBhIC8gZy5kdXJhdGlvbiAqIDEwMDtcbiAgICB9ZnVuY3Rpb24gZihhKSB7XG4gICAgICBpZiAoZ1thXSkgZ1thXShnKTtcbiAgICB9ZnVuY3Rpb24gZSgpIHtcbiAgICAgIGcucmVtYWluaW5nICYmICEwICE9PSBnLnJlbWFpbmluZyAmJiBnLnJlbWFpbmluZy0tO1xuICAgIH1mdW5jdGlvbiBrKGEpIHtcbiAgICAgIHZhciBrID0gZy5kdXJhdGlvbixcbiAgICAgICAgICBuID0gZy5vZmZzZXQsXG4gICAgICAgICAgdyA9IG4gKyBnLmRlbGF5LFxuICAgICAgICAgIHIgPSBnLmN1cnJlbnRUaW1lLFxuICAgICAgICAgIHggPSBnLnJldmVyc2VkLFxuICAgICAgICAgIHEgPSBkKGEpO2lmIChnLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgdSA9IGcuY2hpbGRyZW4sXG4gICAgICAgICAgICB2ID0gdS5sZW5ndGg7XG4gICAgICAgIGlmIChxID49IGcuY3VycmVudFRpbWUpIGZvciAodmFyIEcgPSAwOyBHIDwgdjsgRysrKSB7XG4gICAgICAgICAgdVtHXS5zZWVrKHEpO1xuICAgICAgICB9IGVsc2UgZm9yICg7IHYtLTspIHtcbiAgICAgICAgICB1W3ZdLnNlZWsocSk7XG4gICAgICAgIH1cbiAgICAgIH1pZiAocSA+PSB3IHx8ICFrKSBnLmJlZ2FuIHx8IChnLmJlZ2FuID0gITAsIGYoXCJiZWdpblwiKSksIGYoXCJydW5cIik7aWYgKHEgPiBuICYmIHEgPCBrKSBiKHEpO2Vsc2UgaWYgKHEgPD0gbiAmJiAwICE9PSByICYmIChiKDApLCB4ICYmIGUoKSksIHEgPj0gayAmJiByICE9PSBrIHx8ICFrKSBiKGspLCB4IHx8IGUoKTtmKFwidXBkYXRlXCIpO2EgPj0gayAmJiAoZy5yZW1haW5pbmcgPyAodCA9IGgsIFwiYWx0ZXJuYXRlXCIgPT09IGcuZGlyZWN0aW9uICYmIChnLnJldmVyc2VkID0gIWcucmV2ZXJzZWQpKSA6IChnLnBhdXNlKCksIGcuY29tcGxldGVkIHx8IChnLmNvbXBsZXRlZCA9ICEwLCBmKFwiY29tcGxldGVcIiksIFwiUHJvbWlzZVwiIGluIHdpbmRvdyAmJiAocCgpLCBtID0gYygpKSkpLCBsID0gMCk7XG4gICAgfWEgPSB2b2lkIDAgPT09IGEgPyB7fSA6IGE7dmFyIGgsXG4gICAgICAgIHQsXG4gICAgICAgIGwgPSAwLFxuICAgICAgICBwID0gbnVsbCxcbiAgICAgICAgbSA9IGMoKSxcbiAgICAgICAgZyA9IGZhKGEpO2cucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYSA9IGcuZGlyZWN0aW9uLFxuICAgICAgICAgIGMgPSBnLmxvb3A7Zy5jdXJyZW50VGltZSA9IDA7Zy5wcm9ncmVzcyA9IDA7Zy5wYXVzZWQgPSAhMDtnLmJlZ2FuID0gITE7Zy5jb21wbGV0ZWQgPSAhMTtnLnJldmVyc2VkID0gXCJyZXZlcnNlXCIgPT09IGE7Zy5yZW1haW5pbmcgPSBcImFsdGVybmF0ZVwiID09PSBhICYmIDEgPT09IGMgPyAyIDogYztiKDApO2ZvciAoYSA9IGcuY2hpbGRyZW4ubGVuZ3RoOyBhLS07KSB7XG4gICAgICAgIGcuY2hpbGRyZW5bYV0ucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9O2cudGljayA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICBoID0gYTt0IHx8ICh0ID0gaCk7aygobCArIGggLSB0KSAqIHEuc3BlZWQpO1xuICAgIH07Zy5zZWVrID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgIGsoZChhKSk7XG4gICAgfTtnLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGEgPSB2LmluZGV4T2YoZyk7LTEgPCBhICYmIHYuc3BsaWNlKGEsIDEpO2cucGF1c2VkID0gITA7XG4gICAgfTtnLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnLnBhdXNlZCAmJiAoZy5wYXVzZWQgPSAhMSwgdCA9IDAsIGwgPSBkKGcuY3VycmVudFRpbWUpLCB2LnB1c2goZyksIEIgfHwgaWEoKSk7XG4gICAgfTtnLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnLnJldmVyc2VkID0gIWcucmV2ZXJzZWQ7dCA9IDA7bCA9IGQoZy5jdXJyZW50VGltZSk7XG4gICAgfTtnLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnLnBhdXNlKCk7XG4gICAgICBnLnJlc2V0KCk7Zy5wbGF5KCk7XG4gICAgfTtnLmZpbmlzaGVkID0gbTtnLnJlc2V0KCk7Zy5hdXRvcGxheSAmJiBnLnBsYXkoKTtyZXR1cm4gZztcbiAgfXZhciBnYSA9IHsgdXBkYXRlOiB2b2lkIDAsIGJlZ2luOiB2b2lkIDAsIHJ1bjogdm9pZCAwLCBjb21wbGV0ZTogdm9pZCAwLCBsb29wOiAxLCBkaXJlY3Rpb246IFwibm9ybWFsXCIsIGF1dG9wbGF5OiAhMCwgb2Zmc2V0OiAwIH0sXG4gICAgICBTID0geyBkdXJhdGlvbjogMUUzLCBkZWxheTogMCwgZWFzaW5nOiBcImVhc2VPdXRFbGFzdGljXCIsIGVsYXN0aWNpdHk6IDUwMCwgcm91bmQ6IDAgfSxcbiAgICAgIFcgPSBcInRyYW5zbGF0ZVggdHJhbnNsYXRlWSB0cmFuc2xhdGVaIHJvdGF0ZSByb3RhdGVYIHJvdGF0ZVkgcm90YXRlWiBzY2FsZSBzY2FsZVggc2NhbGVZIHNjYWxlWiBza2V3WCBza2V3WSBwZXJzcGVjdGl2ZVwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIEgsXG4gICAgICBoID0geyBhcnI6IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKTtcbiAgICB9LCBvYmo6IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gLTEgPCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkuaW5kZXhPZihcIk9iamVjdFwiKTtcbiAgICB9LFxuICAgIHB0aDogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBoLm9iaihhKSAmJiBhLmhhc093blByb3BlcnR5KFwidG90YWxMZW5ndGhcIik7XG4gICAgfSwgc3ZnOiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH0sIGRvbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBhLm5vZGVUeXBlIHx8IGguc3ZnKGEpO1xuICAgIH0sIHN0cjogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgYTtcbiAgICB9LCBmbmM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYTtcbiAgICB9LCB1bmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGE7XG4gICAgfSwgaGV4OiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuICgvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKVxuICAgICAgKTtcbiAgICB9LCByZ2I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gKC9ecmdiLy50ZXN0KGEpXG4gICAgICApO1xuICAgIH0sIGhzbDogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiAoL15oc2wvLnRlc3QoYSlcbiAgICAgICk7XG4gICAgfSwgY29sOiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGguaGV4KGEpIHx8IGgucmdiKGEpIHx8IGguaHNsKGEpO1xuICAgIH0gfSxcbiAgICAgIEEgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gYShhLCBkLCBiKSB7XG4gICAgICByZXR1cm4gKCgoMSAtIDMgKiBiICsgMyAqIGQpICogYSArICgzICogYiAtIDYgKiBkKSkgKiBhICsgMyAqIGQpICogYTtcbiAgICB9cmV0dXJuIGZ1bmN0aW9uIChjLCBkLCBiLCBmKSB7XG4gICAgICBpZiAoMCA8PSBjICYmIDEgPj0gYyAmJiAwIDw9IGIgJiYgMSA+PSBiKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEZsb2F0MzJBcnJheSgxMSk7aWYgKGMgIT09IGQgfHwgYiAhPT0gZikgZm9yICh2YXIgayA9IDA7IDExID4gazsgKytrKSB7XG4gICAgICAgICAgZVtrXSA9IGEoLjEgKiBrLCBjLCBiKTtcbiAgICAgICAgfXJldHVybiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgIGlmIChjID09PSBkICYmIGIgPT09IGYpIHJldHVybiBrO2lmICgwID09PSBrKSByZXR1cm4gMDtpZiAoMSA9PT0gaykgcmV0dXJuIDE7Zm9yICh2YXIgaCA9IDAsIGwgPSAxOyAxMCAhPT0gbCAmJiBlW2xdIDw9IGs7ICsrbCkge1xuICAgICAgICAgICAgaCArPSAuMTtcbiAgICAgICAgICB9LS1sO3ZhciBsID0gaCArIChrIC0gZVtsXSkgLyAoZVtsICsgMV0gLSBlW2xdKSAqIC4xLFxuICAgICAgICAgICAgICBuID0gMyAqICgxIC0gMyAqIGIgKyAzICogYykgKiBsICogbCArIDIgKiAoMyAqIGIgLSA2ICogYykgKiBsICsgMyAqIGM7aWYgKC4wMDEgPD0gbikge1xuICAgICAgICAgICAgZm9yIChoID0gMDsgNCA+IGg7ICsraCkge1xuICAgICAgICAgICAgICBuID0gMyAqICgxIC0gMyAqIGIgKyAzICogYykgKiBsICogbCArIDIgKiAoMyAqIGIgLSA2ICogYykgKiBsICsgMyAqIGM7aWYgKDAgPT09IG4pIGJyZWFrO3ZhciBtID0gYShsLCBjLCBiKSAtIGssXG4gICAgICAgICAgICAgICAgICBsID0gbCAtIG0gLyBuO1xuICAgICAgICAgICAgfWsgPSBsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gbikgayA9IGw7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgbCA9IGgsXG4gICAgICAgICAgICAgICAgaCA9IGggKyAuMSxcbiAgICAgICAgICAgICAgICBnID0gMDtkbyB7XG4gICAgICAgICAgICAgIG0gPSBsICsgKGggLSBsKSAvIDIsIG4gPSBhKG0sIGMsIGIpIC0gaywgMCA8IG4gPyBoID0gbSA6IGwgPSBtO1xuICAgICAgICAgICAgfSB3aGlsZSAoMWUtNyA8IE1hdGguYWJzKG4pICYmIDEwID4gKytnKTtrID0gbTtcbiAgICAgICAgICB9cmV0dXJuIGEoaywgZCwgZik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSgpLFxuICAgICAgUSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBhKGEsIGIpIHtcbiAgICAgIHJldHVybiAwID09PSBhIHx8IDEgPT09IGEgPyBhIDogLU1hdGgucG93KDIsIDEwICogKGEgLSAxKSkgKiBNYXRoLnNpbigyICogKGEgLSAxIC0gYiAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSkpICogTWF0aC5QSSAvIGIpO1xuICAgIH12YXIgYyA9IFwiUXVhZCBDdWJpYyBRdWFydCBRdWludCBTaW5lIEV4cG8gQ2lyYyBCYWNrIEVsYXN0aWNcIi5zcGxpdChcIiBcIiksXG4gICAgICAgIGQgPSB7IEluOiBbWy41NSwgLjA4NSwgLjY4LCAuNTNdLCBbLjU1LCAuMDU1LCAuNjc1LCAuMTldLCBbLjg5NSwgLjAzLCAuNjg1LCAuMjJdLCBbLjc1NSwgLjA1LCAuODU1LCAuMDZdLCBbLjQ3LCAwLCAuNzQ1LCAuNzE1XSwgWy45NSwgLjA1LCAuNzk1LCAuMDM1XSwgWy42LCAuMDQsIC45OCwgLjMzNV0sIFsuNiwgLS4yOCwgLjczNSwgLjA0NV0sIGFdLCBPdXQ6IFtbLjI1LCAuNDYsIC40NSwgLjk0XSwgWy4yMTUsIC42MSwgLjM1NSwgMV0sIFsuMTY1LCAuODQsIC40NCwgMV0sIFsuMjMsIDEsIC4zMiwgMV0sIFsuMzksIC41NzUsIC41NjUsIDFdLCBbLjE5LCAxLCAuMjIsIDFdLCBbLjA3NSwgLjgyLCAuMTY1LCAxXSwgWy4xNzUsIC44ODUsIC4zMiwgMS4yNzVdLCBmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICByZXR1cm4gMSAtIGEoMSAtIGIsIGMpO1xuICAgICAgfV0sIEluT3V0OiBbWy40NTUsIC4wMywgLjUxNSwgLjk1NV0sIFsuNjQ1LCAuMDQ1LCAuMzU1LCAxXSwgWy43NywgMCwgLjE3NSwgMV0sIFsuODYsIDAsIC4wNywgMV0sIFsuNDQ1LCAuMDUsIC41NSwgLjk1XSwgWzEsIDAsIDAsIDFdLCBbLjc4NSwgLjEzNSwgLjE1LCAuODZdLCBbLjY4LCAtLjU1LCAuMjY1LCAxLjU1XSwgZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgcmV0dXJuIC41ID4gYiA/IGEoMiAqIGIsIGMpIC8gMiA6IDEgLSBhKC0yICogYiArIDIsIGMpIC8gMjtcbiAgICAgIH1dIH0sXG4gICAgICAgIGIgPSB7IGxpbmVhcjogQSguMjUsIC4yNSwgLjc1LCAuNzUpIH0sXG4gICAgICAgIGYgPSB7fSxcbiAgICAgICAgZTtmb3IgKGUgaW4gZCkge1xuICAgICAgZi50eXBlID0gZSwgZFtmLnR5cGVdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBmKSB7XG4gICAgICAgICAgYltcImVhc2VcIiArIGEudHlwZSArIGNbZl1dID0gaC5mbmMoZCkgPyBkIDogQS5hcHBseSgkanNjb21wJHRoaXMsIGQpO1xuICAgICAgICB9O1xuICAgICAgfShmKSksIGYgPSB7IHR5cGU6IGYudHlwZSB9O1xuICAgIH1yZXR1cm4gYjtcbiAgfSgpLFxuICAgICAgaGEgPSB7IGNzczogZnVuY3Rpb24gKGEsIGMsIGQpIHtcbiAgICAgIHJldHVybiBhLnN0eWxlW2NdID0gZDtcbiAgICB9LCBhdHRyaWJ1dGU6IGZ1bmN0aW9uIChhLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYS5zZXRBdHRyaWJ1dGUoYywgZCk7XG4gICAgfSwgb2JqZWN0OiBmdW5jdGlvbiAoYSwgYywgZCkge1xuICAgICAgcmV0dXJuIGFbY10gPSBkO1xuICAgIH0sIHRyYW5zZm9ybTogZnVuY3Rpb24gKGEsIGMsIGQsIGIsIGYpIHtcbiAgICAgIGJbZl0gfHwgKGJbZl0gPSBbXSk7YltmXS5wdXNoKGMgKyBcIihcIiArIGQgKyBcIilcIik7XG4gICAgfSB9LFxuICAgICAgdiA9IFtdLFxuICAgICAgQiA9IDAsXG4gICAgICBpYSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgQiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjKTtcbiAgICB9ZnVuY3Rpb24gYyhjKSB7XG4gICAgICB2YXIgYiA9IHYubGVuZ3RoO2lmIChiKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgYjspIHtcbiAgICAgICAgICB2W2RdICYmIHZbZF0udGljayhjKSwgZCsrO1xuICAgICAgICB9YSgpO1xuICAgICAgfSBlbHNlIGNhbmNlbEFuaW1hdGlvbkZyYW1lKEIpLCBCID0gMDtcbiAgICB9cmV0dXJuIGE7XG4gIH0oKTtxLnZlcnNpb24gPSBcIjIuMi4wXCI7cS5zcGVlZCA9IDE7cS5ydW5uaW5nID0gdjtxLnJlbW92ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgYSA9IFAoYSk7Zm9yICh2YXIgYyA9IHYubGVuZ3RoOyBjLS07KSB7XG4gICAgICBmb3IgKHZhciBkID0gdltjXSwgYiA9IGQuYW5pbWF0aW9ucywgZiA9IGIubGVuZ3RoOyBmLS07KSB7XG4gICAgICAgIHUoYSwgYltmXS5hbmltYXRhYmxlLnRhcmdldCkgJiYgKGIuc3BsaWNlKGYsIDEpLCBiLmxlbmd0aCB8fCBkLnBhdXNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtxLmdldFZhbHVlID0gSztxLnBhdGggPSBmdW5jdGlvbiAoYSwgYykge1xuICAgIHZhciBkID0gaC5zdHIoYSkgPyBlKGEpWzBdIDogYSxcbiAgICAgICAgYiA9IGMgfHwgMTAwO3JldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIHsgZWw6IGQsIHByb3BlcnR5OiBhLCB0b3RhbExlbmd0aDogTihkKSAqIChiIC8gMTAwKSB9O1xuICAgIH07XG4gIH07cS5zZXREYXNob2Zmc2V0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYyA9IE4oYSk7YS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGMpO3JldHVybiBjO1xuICB9O3EuYmV6aWVyID0gQTtxLmVhc2luZ3MgPSBRO3EudGltZWxpbmUgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBjID0gcShhKTtjLnBhdXNlKCk7Yy5kdXJhdGlvbiA9IDA7Yy5hZGQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgYy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEuYmVnYW4gPSAhMDthLmNvbXBsZXRlZCA9ICEwO1xuICAgICAgfSk7bShkKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBkID0geihiLCBEKFMsIGEgfHwge30pKTtkLnRhcmdldHMgPSBkLnRhcmdldHMgfHwgYS50YXJnZXRzO2IgPSBjLmR1cmF0aW9uO3ZhciBlID0gZC5vZmZzZXQ7ZC5hdXRvcGxheSA9ICExO2QuZGlyZWN0aW9uID0gYy5kaXJlY3Rpb247ZC5vZmZzZXQgPSBoLnVuZChlKSA/IGIgOiBMKGUsIGIpO2MuYmVnYW4gPSAhMDtjLmNvbXBsZXRlZCA9ICEwO2Muc2VlayhkLm9mZnNldCk7ZCA9IHEoZCk7ZC5iZWdhbiA9ICEwO2QuY29tcGxldGVkID0gITA7ZC5kdXJhdGlvbiA+IGIgJiYgKGMuZHVyYXRpb24gPSBkLmR1cmF0aW9uKTtjLmNoaWxkcmVuLnB1c2goZCk7XG4gICAgICB9KTtjLnNlZWsoMCk7Yy5yZXNldCgpO2MuYXV0b3BsYXkgJiYgYy5yZXN0YXJ0KCk7cmV0dXJuIGM7XG4gICAgfTtyZXR1cm4gYztcbiAgfTtxLnJhbmRvbSA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChjIC0gYSArIDEpKSArIGE7XG4gIH07cmV0dXJuIHE7XG59KTtcbjsoZnVuY3Rpb24gKCQsIGFuaW0pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgYWNjb3JkaW9uOiB0cnVlLFxuICAgIG9uT3BlblN0YXJ0OiB1bmRlZmluZWQsXG4gICAgb25PcGVuRW5kOiB1bmRlZmluZWQsXG4gICAgb25DbG9zZVN0YXJ0OiB1bmRlZmluZWQsXG4gICAgb25DbG9zZUVuZDogdW5kZWZpbmVkLFxuICAgIGluRHVyYXRpb246IDMwMCxcbiAgICBvdXREdXJhdGlvbjogMzAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgQ29sbGFwc2libGUgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhDb2xsYXBzaWJsZSwgX0NvbXBvbmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgQ29sbGFwc2libGUgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb2xsYXBzaWJsZShlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxhcHNpYmxlKTtcblxuICAgICAgdmFyIF90aGlzMyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xsYXBzaWJsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbGxhcHNpYmxlKSkuY2FsbCh0aGlzLCBDb2xsYXBzaWJsZSwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMzLmVsLk1fQ29sbGFwc2libGUgPSBfdGhpczM7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIGNvbGxhcHNpYmxlXG4gICAgICAgKiBAbWVtYmVyIENvbGxhcHNpYmxlI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbYWNjb3JkaW9uPWZhbHNlXSAtIFR5cGUgb2YgdGhlIGNvbGxhcHNpYmxlXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uT3BlblN0YXJ0IC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGJlZm9yZSBjb2xsYXBzaWJsZSBpcyBvcGVuZWRcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25PcGVuRW5kIC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIGNvbGxhcHNpYmxlIGlzIG9wZW5lZFxuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbkNsb3NlU3RhcnQgLSBDYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGNvbGxhcHNpYmxlIGlzIGNsb3NlZFxuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbkNsb3NlRW5kIC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIGNvbGxhcHNpYmxlIGlzIGNsb3NlZFxuICAgICAgICogQHByb3Age051bWJlcn0gaW5EdXJhdGlvbiAtIFRyYW5zaXRpb24gaW4gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICogQHByb3Age051bWJlcn0gb3V0RHVyYXRpb24gLSBUcmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqL1xuICAgICAgX3RoaXMzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ29sbGFwc2libGUuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBTZXR1cCB0YWIgaW5kaWNlc1xuICAgICAgX3RoaXMzLiRoZWFkZXJzID0gX3RoaXMzLiRlbC5jaGlsZHJlbignbGknKS5jaGlsZHJlbignLmNvbGxhcHNpYmxlLWhlYWRlcicpO1xuICAgICAgX3RoaXMzLiRoZWFkZXJzLmF0dHIoJ3RhYmluZGV4JywgMCk7XG5cbiAgICAgIF90aGlzMy5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIE9wZW4gZmlyc3QgYWN0aXZlXG4gICAgICB2YXIgJGFjdGl2ZUJvZGllcyA9IF90aGlzMy4kZWwuY2hpbGRyZW4oJ2xpLmFjdGl2ZScpLmNoaWxkcmVuKCcuY29sbGFwc2libGUtYm9keScpO1xuICAgICAgaWYgKF90aGlzMy5vcHRpb25zLmFjY29yZGlvbikge1xuICAgICAgICAvLyBIYW5kbGUgQWNjb3JkaW9uXG4gICAgICAgICRhY3RpdmVCb2RpZXMuZmlyc3QoKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBFeHBhbmRhYmxlc1xuICAgICAgICAkYWN0aXZlQm9kaWVzLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29sbGFwc2libGUsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuZWwuTV9Db2xsYXBzaWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZUNvbGxhcHNpYmxlQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUNvbGxhcHNpYmxlQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ29sbGFwc2libGVLZXlkb3duQm91bmQgPSB0aGlzLl9oYW5kbGVDb2xsYXBzaWJsZUtleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNvbGxhcHNpYmxlQ2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuJGhlYWRlcnMuZWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgaGVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBfdGhpczQuX2hhbmRsZUNvbGxhcHNpYmxlS2V5ZG93bkJvdW5kKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ29sbGFwc2libGVDbGlja0JvdW5kKTtcbiAgICAgICAgdGhpcy4kaGVhZGVycy5lYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICBoZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF90aGlzNS5faGFuZGxlQ29sbGFwc2libGVLZXlkb3duQm91bmQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgQ29sbGFwc2libGUgQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDb2xsYXBzaWJsZUNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbGxhcHNpYmxlQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGhlYWRlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jb2xsYXBzaWJsZS1oZWFkZXInKTtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICYmICRoZWFkZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyICRjb2xsYXBzaWJsZSA9ICRoZWFkZXIuY2xvc2VzdCgnLmNvbGxhcHNpYmxlJyk7XG4gICAgICAgICAgaWYgKCRjb2xsYXBzaWJsZVswXSA9PT0gdGhpcy5lbCkge1xuICAgICAgICAgICAgdmFyICRjb2xsYXBzaWJsZUxpID0gJGhlYWRlci5jbG9zZXN0KCdsaScpO1xuICAgICAgICAgICAgdmFyICRjb2xsYXBzaWJsZUxpcyA9ICRjb2xsYXBzaWJsZS5jaGlsZHJlbignbGknKTtcbiAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9ICRjb2xsYXBzaWJsZUxpWzBdLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAkY29sbGFwc2libGVMaXMuaW5kZXgoJGNvbGxhcHNpYmxlTGkpO1xuXG4gICAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZShpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm9wZW4oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBDb2xsYXBzaWJsZSBLZXlkb3duXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ29sbGFwc2libGVLZXlkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbGxhcHNpYmxlS2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlQ29sbGFwc2libGVDbGlja0JvdW5kKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0ZSBpbiBjb2xsYXBzaWJsZSBzbGlkZVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gMHRoIGluZGV4IG9mIHNsaWRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZUluXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJbihpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgJGNvbGxhcHNpYmxlTGkgPSB0aGlzLiRlbC5jaGlsZHJlbignbGknKS5lcShpbmRleCk7XG4gICAgICAgIGlmICgkY29sbGFwc2libGVMaS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgJGJvZHkgPSAkY29sbGFwc2libGVMaS5jaGlsZHJlbignLmNvbGxhcHNpYmxlLWJvZHknKTtcblxuICAgICAgICAgIGFuaW0ucmVtb3ZlKCRib2R5WzBdKTtcbiAgICAgICAgICAkYm9keS5jc3Moe1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6ICcnLFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogJydcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBwVG9wID0gJGJvZHkuY3NzKCdwYWRkaW5nLXRvcCcpO1xuICAgICAgICAgIHZhciBwQm90dG9tID0gJGJvZHkuY3NzKCdwYWRkaW5nLWJvdHRvbScpO1xuICAgICAgICAgIHZhciBmaW5hbEhlaWdodCA9ICRib2R5WzBdLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAkYm9keS5jc3Moe1xuICAgICAgICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDBcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGFuaW0oe1xuICAgICAgICAgICAgdGFyZ2V0czogJGJvZHlbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IGZpbmFsSGVpZ2h0LFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogcFRvcCxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHBCb3R0b20sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmluRHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlSW5PdXRDdWJpYycsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGFuaW0pIHtcbiAgICAgICAgICAgICAgJGJvZHkuY3NzKHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJycsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogJycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBvbk9wZW5FbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYub3B0aW9ucy5vbk9wZW5FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBfdGhpczYub3B0aW9ucy5vbk9wZW5FbmQuY2FsbChfdGhpczYsICRjb2xsYXBzaWJsZUxpWzBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0ZSBvdXQgY29sbGFwc2libGUgc2xpZGVcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIDB0aCBpbmRleCBvZiBzbGlkZSB0byBvcGVuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3V0KGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciAkY29sbGFwc2libGVMaSA9IHRoaXMuJGVsLmNoaWxkcmVuKCdsaScpLmVxKGluZGV4KTtcbiAgICAgICAgaWYgKCRjb2xsYXBzaWJsZUxpLmxlbmd0aCkge1xuICAgICAgICAgIHZhciAkYm9keSA9ICRjb2xsYXBzaWJsZUxpLmNoaWxkcmVuKCcuY29sbGFwc2libGUtYm9keScpO1xuICAgICAgICAgIGFuaW0ucmVtb3ZlKCRib2R5WzBdKTtcbiAgICAgICAgICAkYm9keS5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuICAgICAgICAgIGFuaW0oe1xuICAgICAgICAgICAgdGFyZ2V0czogJGJvZHlbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAwLFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlSW5PdXRDdWJpYycsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkYm9keS5jc3Moe1xuICAgICAgICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICcnXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIG9uQ2xvc2VFbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczcub3B0aW9ucy5vbkNsb3NlRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3Lm9wdGlvbnMub25DbG9zZUVuZC5jYWxsKF90aGlzNywgJGNvbGxhcHNpYmxlTGlbMF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVuIENvbGxhcHNpYmxlXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSAwdGggaW5kZXggb2Ygc2xpZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgIHZhciAkY29sbGFwc2libGVMaSA9IHRoaXMuJGVsLmNoaWxkcmVuKCdsaScpLmVxKGluZGV4KTtcbiAgICAgICAgaWYgKCRjb2xsYXBzaWJsZUxpLmxlbmd0aCAmJiAhJGNvbGxhcHNpYmxlTGlbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgIC8vIG9uT3BlblN0YXJ0IGNhbGxiYWNrXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25PcGVuU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydC5jYWxsKHRoaXMsICRjb2xsYXBzaWJsZUxpWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIYW5kbGUgYWNjb3JkaW9uIGJlaGF2aW9yXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY2NvcmRpb24pIHtcbiAgICAgICAgICAgIHZhciAkY29sbGFwc2libGVMaXMgPSB0aGlzLiRlbC5jaGlsZHJlbignbGknKTtcbiAgICAgICAgICAgIHZhciAkYWN0aXZlTGlzID0gdGhpcy4kZWwuY2hpbGRyZW4oJ2xpLmFjdGl2ZScpO1xuICAgICAgICAgICAgJGFjdGl2ZUxpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSAkY29sbGFwc2libGVMaXMuaW5kZXgoJChlbCkpO1xuICAgICAgICAgICAgICBfdGhpczguY2xvc2UoaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQW5pbWF0ZSBpblxuICAgICAgICAgICRjb2xsYXBzaWJsZUxpWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVJbihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBDb2xsYXBzaWJsZVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gMHRoIGluZGV4IG9mIHNsaWRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKGluZGV4KSB7XG4gICAgICAgIHZhciAkY29sbGFwc2libGVMaSA9IHRoaXMuJGVsLmNoaWxkcmVuKCdsaScpLmVxKGluZGV4KTtcbiAgICAgICAgaWYgKCRjb2xsYXBzaWJsZUxpLmxlbmd0aCAmJiAkY29sbGFwc2libGVMaVswXS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgLy8gb25DbG9zZVN0YXJ0IGNhbGxiYWNrXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25DbG9zZVN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbG9zZVN0YXJ0LmNhbGwodGhpcywgJGNvbGxhcHNpYmxlTGlbMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFuaW1hdGUgb3V0XG4gICAgICAgICAgJGNvbGxhcHNpYmxlTGlbMF0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU91dChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoQ29sbGFwc2libGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xsYXBzaWJsZSksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMsIGVscywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IEluc3RhbmNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJbnN0YW5jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlKGVsKSB7XG4gICAgICAgIHZhciBkb21FbGVtID0gISFlbC5qcXVlcnkgPyBlbFswXSA6IGVsO1xuICAgICAgICByZXR1cm4gZG9tRWxlbS5NX0NvbGxhcHNpYmxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbGxhcHNpYmxlO1xuICB9KENvbXBvbmVudCk7XG5cbiAgTS5Db2xsYXBzaWJsZSA9IENvbGxhcHNpYmxlO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoQ29sbGFwc2libGUsICdjb2xsYXBzaWJsZScsICdNX0NvbGxhcHNpYmxlJyk7XG4gIH1cbn0pKGNhc2gsIE0uYW5pbWUpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBhbGlnbm1lbnQ6ICdsZWZ0JyxcbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgY29uc3RyYWluV2lkdGg6IHRydWUsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIGNvdmVyVHJpZ2dlcjogdHJ1ZSxcbiAgICBjbG9zZU9uQ2xpY2s6IHRydWUsXG4gICAgaG92ZXI6IGZhbHNlLFxuICAgIGluRHVyYXRpb246IDE1MCxcbiAgICBvdXREdXJhdGlvbjogMjUwLFxuICAgIG9uT3BlblN0YXJ0OiBudWxsLFxuICAgIG9uT3BlbkVuZDogbnVsbCxcbiAgICBvbkNsb3NlU3RhcnQ6IG51bGwsXG4gICAgb25DbG9zZUVuZDogbnVsbCxcbiAgICBvbkl0ZW1DbGljazogbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICovXG5cbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKF9Db21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKERyb3Bkb3duLCBfQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBEcm9wZG93bihlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duKTtcblxuICAgICAgdmFyIF90aGlzOSA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEcm9wZG93bi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3Bkb3duKSkuY2FsbCh0aGlzLCBEcm9wZG93biwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXM5LmVsLk1fRHJvcGRvd24gPSBfdGhpczk7XG4gICAgICBEcm9wZG93bi5fZHJvcGRvd25zLnB1c2goX3RoaXM5KTtcblxuICAgICAgX3RoaXM5LmlkID0gTS5nZXRJZEZyb21UcmlnZ2VyKGVsKTtcbiAgICAgIF90aGlzOS5kcm9wZG93bkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXM5LmlkKTtcbiAgICAgIF90aGlzOS4kZHJvcGRvd25FbCA9ICQoX3RoaXM5LmRyb3Bkb3duRWwpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBkcm9wZG93blxuICAgICAgICogQG1lbWJlciBEcm9wZG93biNvcHRpb25zXG4gICAgICAgKiBAcHJvcCB7U3RyaW5nfSBbYWxpZ25tZW50PSdsZWZ0J10gLSBFZGdlIHdoaWNoIHRoZSBkcm9wZG93biBpcyBhbGlnbmVkIHRvXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gW2F1dG9Gb2N1cz10cnVlXSAtIEF1dG9tYXRpY2FsbHkgZm9jdXMgZHJvcGRvd24gZWwgZm9yIGtleWJvYXJkXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gW2NvbnN0cmFpbldpZHRoPXRydWVdIC0gQ29uc3RyYWluIHdpZHRoIHRvIHdpZHRoIG9mIHRoZSBidXR0b25cbiAgICAgICAqIEBwcm9wIHtFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgZWxlbWVudCB0byBhdHRhY2ggZHJvcGRvd24gdG8gKG9wdGlvbmFsKVxuICAgICAgICogQHByb3Age0Jvb2xlYW59IFtjb3ZlclRyaWdnZXI9dHJ1ZV0gLSBQbGFjZSBkcm9wZG93biBvdmVyIHRyaWdnZXJcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbY2xvc2VPbkNsaWNrPXRydWVdIC0gQ2xvc2Ugb24gY2xpY2sgb2YgZHJvcGRvd24gaXRlbVxuICAgICAgICogQHByb3Age0Jvb2xlYW59IFtob3Zlcj1mYWxzZV0gLSBPcGVuIGRyb3Bkb3duIG9uIGhvdmVyXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbaW5EdXJhdGlvbj0xNTBdIC0gRHVyYXRpb24gb2Ygb3BlbiBhbmltYXRpb24gaW4gbXNcbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IFtvdXREdXJhdGlvbj0yNTBdIC0gRHVyYXRpb24gb2YgY2xvc2UgYW5pbWF0aW9uIGluIG1zXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uT3BlblN0YXJ0IC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gZHJvcGRvd24gc3RhcnRzIG9wZW5pbmdcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25PcGVuRW5kIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gZHJvcGRvd24gZmluaXNoZXMgb3BlbmluZ1xuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbkNsb3NlU3RhcnQgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiBkcm9wZG93biBzdGFydHMgY2xvc2luZ1xuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbkNsb3NlRW5kIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gZHJvcGRvd24gZmluaXNoZXMgY2xvc2luZ1xuICAgICAgICovXG4gICAgICBfdGhpczkub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcm9wZG93bi5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzY3JpYmVzIG9wZW4vY2xvc2Ugc3RhdGUgb2YgZHJvcGRvd25cbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpczkuaXNPcGVuID0gZmFsc2U7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzY3JpYmVzIGlmIGRyb3Bkb3duIGNvbnRlbnQgaXMgc2Nyb2xsYWJsZVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90aGlzOS5pc1Njcm9sbGFibGUgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNjcmliZXMgaWYgdG91Y2ggbW92aW5nIG9uIGRyb3Bkb3duIGNvbnRlbnRcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpczkuaXNUb3VjaE1vdmluZyA9IGZhbHNlO1xuXG4gICAgICBfdGhpczkuZm9jdXNlZEluZGV4ID0gLTE7XG4gICAgICBfdGhpczkuZmlsdGVyUXVlcnkgPSBbXTtcblxuICAgICAgLy8gTW92ZSBkcm9wZG93bi1jb250ZW50IGFmdGVyIGRyb3Bkb3duLXRyaWdnZXJcbiAgICAgIGlmICghIV90aGlzOS5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAkKF90aGlzOS5vcHRpb25zLmNvbnRhaW5lcikuYXBwZW5kKF90aGlzOS5kcm9wZG93bkVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzOS4kZWwuYWZ0ZXIoX3RoaXM5LmRyb3Bkb3duRWwpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczkuX21ha2VEcm9wZG93bkZvY3VzYWJsZSgpO1xuICAgICAgX3RoaXM5Ll9yZXNldEZpbHRlclF1ZXJ5Qm91bmQgPSBfdGhpczkuX3Jlc2V0RmlsdGVyUXVlcnkuYmluZChfdGhpczkpO1xuICAgICAgX3RoaXM5Ll9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQgPSBfdGhpczkuX2hhbmRsZURvY3VtZW50Q2xpY2suYmluZChfdGhpczkpO1xuICAgICAgX3RoaXM5Ll9oYW5kbGVEb2N1bWVudFRvdWNobW92ZUJvdW5kID0gX3RoaXM5Ll9oYW5kbGVEb2N1bWVudFRvdWNobW92ZS5iaW5kKF90aGlzOSk7XG4gICAgICBfdGhpczkuX2hhbmRsZURyb3Bkb3duQ2xpY2tCb3VuZCA9IF90aGlzOS5faGFuZGxlRHJvcGRvd25DbGljay5iaW5kKF90aGlzOSk7XG4gICAgICBfdGhpczkuX2hhbmRsZURyb3Bkb3duS2V5ZG93bkJvdW5kID0gX3RoaXM5Ll9oYW5kbGVEcm9wZG93bktleWRvd24uYmluZChfdGhpczkpO1xuICAgICAgX3RoaXM5Ll9oYW5kbGVUcmlnZ2VyS2V5ZG93bkJvdW5kID0gX3RoaXM5Ll9oYW5kbGVUcmlnZ2VyS2V5ZG93bi5iaW5kKF90aGlzOSk7XG4gICAgICBfdGhpczkuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgcmV0dXJuIF90aGlzOTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZXNldERyb3Bkb3duU3R5bGVzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgRHJvcGRvd24uX2Ryb3Bkb3ducy5zcGxpY2UoRHJvcGRvd24uX2Ryb3Bkb3ducy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgdGhpcy5lbC5NX0Ryb3Bkb3duID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgLy8gVHJpZ2dlciBrZXlkb3duIGhhbmRsZXJcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlVHJpZ2dlcktleWRvd25Cb3VuZCk7XG5cbiAgICAgICAgLy8gSXRlbSBjbGljayBoYW5kbGVyXG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2tCb3VuZCk7XG5cbiAgICAgICAgLy8gSG92ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3Zlcikge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlRW50ZXJCb3VuZCA9IHRoaXMuX2hhbmRsZU1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9oYW5kbGVNb3VzZUVudGVyQm91bmQpO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlTGVhdmVCb3VuZCA9IHRoaXMuX2hhbmRsZU1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlQm91bmQpO1xuICAgICAgICAgIHRoaXMuZHJvcGRvd25FbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5faGFuZGxlTW91c2VMZWF2ZUJvdW5kKTtcblxuICAgICAgICAgIC8vIENsaWNrIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNsaWNrQm91bmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVUcmlnZ2VyS2V5ZG93bkJvdW5kKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bkVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlRHJvcGRvd25DbGlja0JvdW5kKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyKSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5faGFuZGxlTW91c2VFbnRlckJvdW5kKTtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlQm91bmQpO1xuICAgICAgICAgIHRoaXMuZHJvcGRvd25FbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5faGFuZGxlTW91c2VMZWF2ZUJvdW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2tCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwVGVtcG9yYXJ5RXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFRlbXBvcmFyeUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIC8vIFVzZSBjYXB0dXJlIHBoYXNlIGV2ZW50IGhhbmRsZXIgdG8gcHJldmVudCBjbGlja1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0JvdW5kLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tCb3VuZCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRG9jdW1lbnRUb3VjaG1vdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlRHJvcGRvd25LZXlkb3duQm91bmQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlVGVtcG9yYXJ5RXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVUZW1wb3JhcnlFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAvLyBVc2UgY2FwdHVyZSBwaGFzZSBldmVudCBoYW5kbGVyIHRvIHByZXZlbnQgY2xpY2tcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tCb3VuZCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZURvY3VtZW50VG91Y2htb3ZlQm91bmQpO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZURyb3Bkb3duS2V5ZG93bkJvdW5kKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1vdXNlRW50ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VFbnRlcigpIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVNb3VzZUxlYXZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1vdXNlTGVhdmUoZSkge1xuICAgICAgICB2YXIgdG9FbCA9IGUudG9FbGVtZW50IHx8IGUucmVsYXRlZFRhcmdldDtcbiAgICAgICAgdmFyIGxlYXZlVG9Ecm9wZG93bkNvbnRlbnQgPSAhISQodG9FbCkuY2xvc2VzdCgnLmRyb3Bkb3duLWNvbnRlbnQnKS5sZW5ndGg7XG4gICAgICAgIHZhciBsZWF2ZVRvQWN0aXZlRHJvcGRvd25UcmlnZ2VyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyICRjbG9zZXN0VHJpZ2dlciA9ICQodG9FbCkuY2xvc2VzdCgnLmRyb3Bkb3duLXRyaWdnZXInKTtcbiAgICAgICAgaWYgKCRjbG9zZXN0VHJpZ2dlci5sZW5ndGggJiYgISEkY2xvc2VzdFRyaWdnZXJbMF0uTV9Ecm9wZG93biAmJiAkY2xvc2VzdFRyaWdnZXJbMF0uTV9Ecm9wZG93bi5pc09wZW4pIHtcbiAgICAgICAgICBsZWF2ZVRvQWN0aXZlRHJvcGRvd25UcmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsb3NlIGhvdmVyIGRyb3Bkb3duIGlmIG1vdXNlIGRpZCBub3QgbGVhdmUgdG8gZWl0aGVyIGFjdGl2ZSBkcm9wZG93bi10cmlnZ2VyIG9yIGRyb3Bkb3duLWNvbnRlbnRcbiAgICAgICAgaWYgKCFsZWF2ZVRvQWN0aXZlRHJvcGRvd25UcmlnZ2VyICYmICFsZWF2ZVRvRHJvcGRvd25Db250ZW50KSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudENsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgJHRhcmdldC5jbG9zZXN0KCcuZHJvcGRvd24tY29udGVudCcpLmxlbmd0aCAmJiAhdGhpcy5pc1RvdWNoTW92aW5nKSB7XG4gICAgICAgICAgLy8gaXNUb3VjaE1vdmluZyB0byBjaGVjayBpZiBzY3JvbGxpbmcgb24gbW9iaWxlLlxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMxMC5jbG9zZSgpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdCgnLmRyb3Bkb3duLXRyaWdnZXInKS5sZW5ndGggfHwgISR0YXJnZXQuY2xvc2VzdCgnLmRyb3Bkb3duLWNvbnRlbnQnKS5sZW5ndGgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMTAuY2xvc2UoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVG91Y2hNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVRyaWdnZXJLZXlkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRyaWdnZXJLZXlkb3duKGUpIHtcbiAgICAgICAgLy8gQVJST1cgRE9XTiBPUiBFTlRFUiBXSEVOIFNFTEVDVCBJUyBDTE9TRUQgLSBvcGVuIERyb3Bkb3duXG4gICAgICAgIGlmICgoZS53aGljaCA9PT0gTS5rZXlzLkFSUk9XX0RPV04gfHwgZS53aGljaCA9PT0gTS5rZXlzLkVOVEVSKSAmJiAhdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgRG9jdW1lbnQgVG91Y2htb3ZlXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRG9jdW1lbnRUb3VjaG1vdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRG9jdW1lbnRUb3VjaG1vdmUoZSkge1xuICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KCcuZHJvcGRvd24tY29udGVudCcpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaXNUb3VjaE1vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgRHJvcGRvd24gQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEcm9wZG93bkNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURyb3Bkb3duQ2xpY2soZSkge1xuICAgICAgICAvLyBvbkl0ZW1DbGljayBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkl0ZW1DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBpdGVtRWwgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdsaScpWzBdO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkl0ZW1DbGljay5jYWxsKHRoaXMsIGl0ZW1FbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgRHJvcGRvd24gS2V5ZG93blxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZURyb3Bkb3duS2V5ZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVEcm9wZG93bktleWRvd24oZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gTS5rZXlzLlRBQikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAvLyBOYXZpZ2F0ZSBkb3duIGRyb3Bkb3duIGxpc3RcbiAgICAgICAgfSBlbHNlIGlmICgoZS53aGljaCA9PT0gTS5rZXlzLkFSUk9XX0RPV04gfHwgZS53aGljaCA9PT0gTS5rZXlzLkFSUk9XX1VQKSAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZS53aGljaCA9PT0gTS5rZXlzLkFSUk9XX0RPV04gPyAxIDogLTE7XG4gICAgICAgICAgdmFyIG5ld0ZvY3VzZWRJbmRleCA9IHRoaXMuZm9jdXNlZEluZGV4O1xuICAgICAgICAgIHZhciBmb3VuZE5ld0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmV3Rm9jdXNlZEluZGV4ID0gbmV3Rm9jdXNlZEluZGV4ICsgZGlyZWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAoISF0aGlzLmRyb3Bkb3duRWwuY2hpbGRyZW5bbmV3Rm9jdXNlZEluZGV4XSAmJiB0aGlzLmRyb3Bkb3duRWwuY2hpbGRyZW5bbmV3Rm9jdXNlZEluZGV4XS50YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZm91bmROZXdJbmRleCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKG5ld0ZvY3VzZWRJbmRleCA8IHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlbi5sZW5ndGggJiYgbmV3Rm9jdXNlZEluZGV4ID49IDApO1xuXG4gICAgICAgICAgaWYgKGZvdW5kTmV3SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZEluZGV4ID0gbmV3Rm9jdXNlZEluZGV4O1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNGb2N1c2VkSXRlbSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVOVEVSIHNlbGVjdHMgY2hvaWNlIG9uIGZvY3VzZWQgaXRlbVxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IE0ua2V5cy5FTlRFUiAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgIC8vIFNlYXJjaCBmb3IgPGE+IGFuZCA8YnV0dG9uPlxuICAgICAgICAgIHZhciBmb2N1c2VkRWxlbWVudCA9IHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlblt0aGlzLmZvY3VzZWRJbmRleF07XG4gICAgICAgICAgdmFyICRhY3RpdmF0YWJsZUVsZW1lbnQgPSAkKGZvY3VzZWRFbGVtZW50KS5maW5kKCdhLCBidXR0b24nKS5maXJzdCgpO1xuXG4gICAgICAgICAgLy8gQ2xpY2sgYSBvciBidXR0b24gdGFnIGlmIGV4aXN0cywgb3RoZXJ3aXNlIGNsaWNrIGxpIHRhZ1xuICAgICAgICAgICEhJGFjdGl2YXRhYmxlRWxlbWVudC5sZW5ndGggPyAkYWN0aXZhdGFibGVFbGVtZW50WzBdLmNsaWNrKCkgOiBmb2N1c2VkRWxlbWVudC5jbGljaygpO1xuXG4gICAgICAgICAgLy8gQ2xvc2UgZHJvcGRvd24gb24gRVNDXG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gTS5rZXlzLkVTQyAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDQVNFIFdIRU4gVVNFUiBUWVBFIExFVFRFUlNcbiAgICAgICAgdmFyIGxldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIG5vbkxldHRlcnMgPSBbOSwgMTMsIDI3LCAzOCwgNDBdO1xuICAgICAgICBpZiAobGV0dGVyICYmIG5vbkxldHRlcnMuaW5kZXhPZihlLndoaWNoKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmZpbHRlclF1ZXJ5LnB1c2gobGV0dGVyKTtcblxuICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLmZpbHRlclF1ZXJ5LmpvaW4oJycpLFxuICAgICAgICAgICAgICBuZXdPcHRpb25FbCA9ICQodGhpcy5kcm9wZG93bkVsKS5maW5kKCdsaScpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkKGVsKS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZykgPT09IDA7XG4gICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICBpZiAobmV3T3B0aW9uRWwpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZEluZGV4ID0gJChuZXdPcHRpb25FbCkuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzRm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbHRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0RmlsdGVyUXVlcnlCb3VuZCwgMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZXNldEZpbHRlclF1ZXJ5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0RmlsdGVyUXVlcnkoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyUXVlcnkgPSBbXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3Jlc2V0RHJvcGRvd25TdHlsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXREcm9wZG93blN0eWxlcygpIHtcbiAgICAgICAgdGhpcy4kZHJvcGRvd25FbC5jc3Moe1xuICAgICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAnJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICAgIG9wYWNpdHk6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbWFrZURyb3Bkb3duRm9jdXNhYmxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VEcm9wZG93bkZvY3VzYWJsZSgpIHtcbiAgICAgICAgLy8gTmVlZGVkIGZvciBhcnJvdyBrZXkgbmF2aWdhdGlvblxuICAgICAgICB0aGlzLmRyb3Bkb3duRWwudGFiSW5kZXggPSAwO1xuXG4gICAgICAgIC8vIE9ubHkgc2V0IHRhYmluZGV4IGlmIGl0IGhhc24ndCBiZWVuIHNldCBieSB1c2VyXG4gICAgICAgICQodGhpcy5kcm9wZG93bkVsKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgaWYgKCFlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZm9jdXNGb2N1c2VkSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mb2N1c0ZvY3VzZWRJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkSW5kZXggPj0gMCAmJiB0aGlzLmZvY3VzZWRJbmRleCA8IHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlbi5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlblt0aGlzLmZvY3VzZWRJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0RHJvcGRvd25Qb3NpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREcm9wZG93blBvc2l0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50QlJlY3QgPSB0aGlzLmVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRyaWdnZXJCUmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBkcm9wZG93bkJSZWN0ID0gdGhpcy5kcm9wZG93bkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHZhciBpZGVhbEhlaWdodCA9IGRyb3Bkb3duQlJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgaWRlYWxXaWR0aCA9IGRyb3Bkb3duQlJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBpZGVhbFhQb3MgPSB0cmlnZ2VyQlJlY3QubGVmdCAtIGRyb3Bkb3duQlJlY3QubGVmdDtcbiAgICAgICAgdmFyIGlkZWFsWVBvcyA9IHRyaWdnZXJCUmVjdC50b3AgLSBkcm9wZG93bkJSZWN0LnRvcDtcblxuICAgICAgICB2YXIgZHJvcGRvd25Cb3VuZHMgPSB7XG4gICAgICAgICAgbGVmdDogaWRlYWxYUG9zLFxuICAgICAgICAgIHRvcDogaWRlYWxZUG9zLFxuICAgICAgICAgIGhlaWdodDogaWRlYWxIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IGlkZWFsV2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb3VudGFpbmVyIGhlcmUgd2lsbCBiZSBjbG9zZXN0IGFuY2VzdG9yIHdpdGggb3ZlcmZsb3c6IGhpZGRlblxuICAgICAgICB2YXIgY2xvc2VzdE92ZXJmbG93UGFyZW50ID0gISF0aGlzLmRyb3Bkb3duRWwub2Zmc2V0UGFyZW50ID8gdGhpcy5kcm9wZG93bkVsLm9mZnNldFBhcmVudCA6IHRoaXMuZHJvcGRvd25FbC5wYXJlbnROb2RlO1xuXG4gICAgICAgIHZhciBhbGlnbm1lbnRzID0gTS5jaGVja1Bvc3NpYmxlQWxpZ25tZW50cyh0aGlzLmVsLCBjbG9zZXN0T3ZlcmZsb3dQYXJlbnQsIGRyb3Bkb3duQm91bmRzLCB0aGlzLm9wdGlvbnMuY292ZXJUcmlnZ2VyID8gMCA6IHRyaWdnZXJCUmVjdC5oZWlnaHQpO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9ICd0b3AnO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWdubWVudCA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQ7XG4gICAgICAgIGlkZWFsWVBvcyArPSB0aGlzLm9wdGlvbnMuY292ZXJUcmlnZ2VyID8gMCA6IHRyaWdnZXJCUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gUmVzZXQgaXNTY3JvbGxhYmxlXG4gICAgICAgIHRoaXMuaXNTY3JvbGxhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFhbGlnbm1lbnRzLnRvcCkge1xuICAgICAgICAgIGlmIChhbGlnbm1lbnRzLmJvdHRvbSkge1xuICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2lkZSBoYXMgbW9zdCBzcGFjZSBhbmQgY3V0b2ZmIGF0IGNvcnJlY3QgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50cy5zcGFjZU9uVG9wID4gYWxpZ25tZW50cy5zcGFjZU9uQm90dG9tKSB7XG4gICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIGlkZWFsSGVpZ2h0ICs9IGFsaWdubWVudHMuc3BhY2VPblRvcDtcbiAgICAgICAgICAgICAgaWRlYWxZUG9zIC09IGFsaWdubWVudHMuc3BhY2VPblRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlkZWFsSGVpZ2h0ICs9IGFsaWdubWVudHMuc3BhY2VPbkJvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBwcmVmZXJyZWQgaG9yaXpvbnRhbCBhbGlnbm1lbnQgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCFhbGlnbm1lbnRzW2hvcml6b250YWxBbGlnbm1lbnRdKSB7XG4gICAgICAgICAgdmFyIG9wcG9zaXRlQWxpZ25tZW50ID0gaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICBpZiAoYWxpZ25tZW50c1tvcHBvc2l0ZUFsaWdubWVudF0pIHtcbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSBvcHBvc2l0ZUFsaWdubWVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpZGUgaGFzIG1vc3Qgc3BhY2UgYW5kIGN1dG9mZiBhdCBjb3JyZWN0IGhlaWdodFxuICAgICAgICAgICAgaWYgKGFsaWdubWVudHMuc3BhY2VPbkxlZnQgPiBhbGlnbm1lbnRzLnNwYWNlT25SaWdodCkge1xuICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgaWRlYWxXaWR0aCArPSBhbGlnbm1lbnRzLnNwYWNlT25MZWZ0O1xuICAgICAgICAgICAgICBpZGVhbFhQb3MgLT0gYWxpZ25tZW50cy5zcGFjZU9uTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgIGlkZWFsV2lkdGggKz0gYWxpZ25tZW50cy5zcGFjZU9uUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ25tZW50ID09PSAnYm90dG9tJykge1xuICAgICAgICAgIGlkZWFsWVBvcyA9IGlkZWFsWVBvcyAtIGRyb3Bkb3duQlJlY3QuaGVpZ2h0ICsgKHRoaXMub3B0aW9ucy5jb3ZlclRyaWdnZXIgPyB0cmlnZ2VyQlJlY3QuaGVpZ2h0IDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWxBbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBpZGVhbFhQb3MgPSBpZGVhbFhQb3MgLSBkcm9wZG93bkJSZWN0LndpZHRoICsgdHJpZ2dlckJSZWN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogaWRlYWxYUG9zLFxuICAgICAgICAgIHk6IGlkZWFsWVBvcyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudDogdmVydGljYWxBbGlnbm1lbnQsXG4gICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogaG9yaXpvbnRhbEFsaWdubWVudCxcbiAgICAgICAgICBoZWlnaHQ6IGlkZWFsSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBpZGVhbFdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0ZSBpbiBkcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FuaW1hdGVJblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlSW4oKSB7XG4gICAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLmRyb3Bkb3duRWwpO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLmRyb3Bkb3duRWwsXG4gICAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgdmFsdWU6IFswLCAxXSxcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NhbGVYOiBbMC4zLCAxXSxcbiAgICAgICAgICBzY2FsZVk6IFswLjMsIDFdLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuaW5EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVpbnQnLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzMTEub3B0aW9ucy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICAgICAgX3RoaXMxMS5kcm9wZG93bkVsLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uT3BlbkVuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczExLm9wdGlvbnMub25PcGVuRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtID0gYW5pbS5hbmltYXRhYmxlc1swXS50YXJnZXQ7XG4gICAgICAgICAgICAgIF90aGlzMTEub3B0aW9ucy5vbk9wZW5FbmQuY2FsbChlbGVtLCBfdGhpczExLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgb3V0IGRyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy5kcm9wZG93bkVsKTtcbiAgICAgICAgYW5pbSh7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy5kcm9wZG93bkVsLFxuICAgICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1aW50J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NhbGVYOiAwLjMsXG4gICAgICAgICAgc2NhbGVZOiAwLjMsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5vdXREdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVpbnQnLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICAgICAgX3RoaXMxMi5fcmVzZXREcm9wZG93blN0eWxlcygpO1xuXG4gICAgICAgICAgICAvLyBvbkNsb3NlRW5kIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzMTIub3B0aW9ucy5vbkNsb3NlRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtID0gYW5pbS5hbmltYXRhYmxlc1swXS50YXJnZXQ7XG4gICAgICAgICAgICAgIF90aGlzMTIub3B0aW9ucy5vbkNsb3NlRW5kLmNhbGwoX3RoaXMxMiwgX3RoaXMxMi5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZSBkcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3BsYWNlRHJvcGRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VEcm9wZG93bigpIHtcbiAgICAgICAgLy8gU2V0IHdpZHRoIGJlZm9yZSBjYWxjdWxhdGluZyBwb3NpdGlvbkluZm9cbiAgICAgICAgdmFyIGlkZWFsV2lkdGggPSB0aGlzLm9wdGlvbnMuY29uc3RyYWluV2lkdGggPyB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIDogdGhpcy5kcm9wZG93bkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwuc3R5bGUud2lkdGggPSBpZGVhbFdpZHRoICsgJ3B4JztcblxuICAgICAgICB2YXIgcG9zaXRpb25JbmZvID0gdGhpcy5fZ2V0RHJvcGRvd25Qb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwuc3R5bGUubGVmdCA9IHBvc2l0aW9uSW5mby54ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kcm9wZG93bkVsLnN0eWxlLnRvcCA9IHBvc2l0aW9uSW5mby55ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kcm9wZG93bkVsLnN0eWxlLmhlaWdodCA9IHBvc2l0aW9uSW5mby5oZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwuc3R5bGUud2lkdGggPSBwb3NpdGlvbkluZm8ud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKHBvc2l0aW9uSW5mby5ob3Jpem9udGFsQWxpZ25tZW50ID09PSAnbGVmdCcgPyAnMCcgOiAnMTAwJScpICsgXCIgXCIgKyAocG9zaXRpb25JbmZvLnZlcnRpY2FsQWxpZ25tZW50ID09PSAndG9wJyA/ICcwJyA6ICcxMDAlJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbiBEcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3BlblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgLy8gb25PcGVuU3RhcnQgY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25PcGVuU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25PcGVuU3RhcnQuY2FsbCh0aGlzLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHN0eWxlc1xuICAgICAgICB0aGlzLl9yZXNldERyb3Bkb3duU3R5bGVzKCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICB0aGlzLl9wbGFjZURyb3Bkb3duKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVJbigpO1xuICAgICAgICB0aGlzLl9zZXR1cFRlbXBvcmFyeUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBEcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzZWRJbmRleCA9IC0xO1xuXG4gICAgICAgIC8vIG9uQ2xvc2VTdGFydCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbG9zZVN0YXJ0LmNhbGwodGhpcywgdGhpcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hbmltYXRlT3V0KCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVRlbXBvcmFyeUV2ZW50SGFuZGxlcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRoaXMuZWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlY2FsY3VsYXRlIGRpbWVuc2lvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlY2FsY3VsYXRlRGltZW5zaW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY3VsYXRlRGltZW5zaW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy4kZHJvcGRvd25FbC5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9wbGFjZURyb3Bkb3duKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoRHJvcGRvd24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcm9wZG93biksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMsIGVscywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IEluc3RhbmNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJbnN0YW5jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlKGVsKSB7XG4gICAgICAgIHZhciBkb21FbGVtID0gISFlbC5qcXVlcnkgPyBlbFswXSA6IGVsO1xuICAgICAgICByZXR1cm4gZG9tRWxlbS5NX0Ryb3Bkb3duO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERyb3Bkb3duO1xuICB9KENvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIERyb3Bkb3duXG4gICAqL1xuXG5cbiAgRHJvcGRvd24uX2Ryb3Bkb3ducyA9IFtdO1xuXG4gIHdpbmRvdy5NLkRyb3Bkb3duID0gRHJvcGRvd247XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihEcm9wZG93biwgJ2Ryb3Bkb3duJywgJ01fRHJvcGRvd24nKTtcbiAgfVxufSkoY2FzaCwgTS5hbmltZSk7XG47KGZ1bmN0aW9uICgkLCBhbmltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIG9wYWNpdHk6IDAuNSxcbiAgICBpbkR1cmF0aW9uOiAyNTAsXG4gICAgb3V0RHVyYXRpb246IDI1MCxcbiAgICBvbk9wZW5TdGFydDogbnVsbCxcbiAgICBvbk9wZW5FbmQ6IG51bGwsXG4gICAgb25DbG9zZVN0YXJ0OiBudWxsLFxuICAgIG9uQ2xvc2VFbmQ6IG51bGwsXG4gICAgcHJldmVudFNjcm9sbGluZzogdHJ1ZSxcbiAgICBkaXNtaXNzaWJsZTogdHJ1ZSxcbiAgICBzdGFydGluZ1RvcDogJzQlJyxcbiAgICBlbmRpbmdUb3A6ICcxMCUnXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudDMpIHtcbiAgICBfaW5oZXJpdHMoTW9kYWwsIF9Db21wb25lbnQzKTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBNb2RhbCBpbnN0YW5jZSBhbmQgc2V0IHVwIG92ZXJsYXlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb2RhbChlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsKTtcblxuICAgICAgdmFyIF90aGlzMTMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTW9kYWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNb2RhbCkpLmNhbGwodGhpcywgTW9kYWwsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzMTMuZWwuTV9Nb2RhbCA9IF90aGlzMTM7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIG1vZGFsXG4gICAgICAgKiBAbWVtYmVyIE1vZGFsI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IFtvcGFjaXR5PTAuNV0gLSBPcGFjaXR5IG9mIHRoZSBtb2RhbCBvdmVybGF5XG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbaW5EdXJhdGlvbj0yNTBdIC0gTGVuZ3RoIGluIG1zIG9mIGVudGVyIHRyYW5zaXRpb25cbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IFtvdXREdXJhdGlvbj0yNTBdIC0gTGVuZ3RoIGluIG1zIG9mIGV4aXQgdHJhbnNpdGlvblxuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbk9wZW5TdGFydCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBiZWZvcmUgbW9kYWwgaXMgb3BlbmVkXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uT3BlbkVuZCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBhZnRlciBtb2RhbCBpcyBvcGVuZWRcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25DbG9zZVN0YXJ0IC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGJlZm9yZSBtb2RhbCBpcyBjbG9zZWRcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25DbG9zZUVuZCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBhZnRlciBtb2RhbCBpcyBjbG9zZWRcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbZGlzbWlzc2libGU9dHJ1ZV0gLSBBbGxvdyBtb2RhbCB0byBiZSBkaXNtaXNzZWQgYnkga2V5Ym9hcmQgb3Igb3ZlcmxheSBjbGlja1xuICAgICAgICogQHByb3Age1N0cmluZ30gW3N0YXJ0aW5nVG9wPSc0JSddIC0gc3RhcnRpbmdUb3BcbiAgICAgICAqIEBwcm9wIHtTdHJpbmd9IFtlbmRpbmdUb3A9JzEwJSddIC0gZW5kaW5nVG9wXG4gICAgICAgKi9cbiAgICAgIF90aGlzMTMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzY3JpYmVzIG9wZW4vY2xvc2Ugc3RhdGUgb2YgbW9kYWxcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpczEzLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICBfdGhpczEzLmlkID0gX3RoaXMxMy4kZWwuYXR0cignaWQnKTtcbiAgICAgIF90aGlzMTMuX29wZW5pbmdUcmlnZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgX3RoaXMxMy4kb3ZlcmxheSA9ICQoJzxkaXYgY2xhc3M9XCJtb2RhbC1vdmVybGF5XCI+PC9kaXY+Jyk7XG4gICAgICBfdGhpczEzLmVsLnRhYkluZGV4ID0gMDtcbiAgICAgIF90aGlzMTMuX250aE1vZGFsT3BlbmVkID0gMDtcblxuICAgICAgTW9kYWwuX2NvdW50Kys7XG4gICAgICBfdGhpczEzLl9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczEzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhNb2RhbCwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIE1vZGFsLl9jb3VudC0tO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmVsLk1fTW9kYWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVPdmVybGF5Q2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZU92ZXJsYXlDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNb2RhbENsb3NlQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZU1vZGFsQ2xvc2VDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmIChNb2RhbC5fY291bnQgPT09IDEpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlVHJpZ2dlckNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRvdmVybGF5WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlT3ZlcmxheUNsaWNrQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlTW9kYWxDbG9zZUNsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgaWYgKE1vZGFsLl9jb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVUcmlnZ2VyQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG92ZXJsYXlbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVPdmVybGF5Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVNb2RhbENsb3NlQ2xpY2tCb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFRyaWdnZXIgQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVUcmlnZ2VyQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVHJpZ2dlckNsaWNrKGUpIHtcbiAgICAgICAgdmFyICR0cmlnZ2VyID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLm1vZGFsLXRyaWdnZXInKTtcbiAgICAgICAgaWYgKCR0cmlnZ2VyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBtb2RhbElkID0gTS5nZXRJZEZyb21UcmlnZ2VyKCR0cmlnZ2VyWzBdKTtcbiAgICAgICAgICB2YXIgbW9kYWxJbnN0YW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpLk1fTW9kYWw7XG4gICAgICAgICAgaWYgKG1vZGFsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIG1vZGFsSW5zdGFuY2Uub3BlbigkdHJpZ2dlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBPdmVybGF5IENsaWNrXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlT3ZlcmxheUNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU92ZXJsYXlDbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNtaXNzaWJsZSkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBNb2RhbCBDbG9zZSBDbGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1vZGFsQ2xvc2VDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVNb2RhbENsb3NlQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGNsb3NlVHJpZ2dlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5tb2RhbC1jbG9zZScpO1xuICAgICAgICBpZiAoJGNsb3NlVHJpZ2dlci5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgS2V5ZG93blxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUtleWRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5ZG93bihlKSB7XG4gICAgICAgIC8vIEVTQyBrZXlcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcgJiYgdGhpcy5vcHRpb25zLmRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIEZvY3VzXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRm9jdXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRm9jdXMoZSkge1xuICAgICAgICAvLyBPbmx5IHRyYXAgZm9jdXMgaWYgdGhpcyBtb2RhbCBpcyB0aGUgbGFzdCBtb2RlbCBvcGVuZWQgKHByZXZlbnRzIGxvb3BzIGluIG5lc3RlZCBtb2RhbHMpLlxuICAgICAgICBpZiAoIXRoaXMuZWwuY29udGFpbnMoZS50YXJnZXQpICYmIHRoaXMuX250aE1vZGFsT3BlbmVkID09PSBNb2RhbC5fbW9kYWxzT3Blbikge1xuICAgICAgICAgIHRoaXMuZWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgaW4gbW9kYWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZUluKCkge1xuICAgICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgc3R5bGVzXG4gICAgICAgICQuZXh0ZW5kKHRoaXMuZWwuc3R5bGUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG4gICAgICAgICQuZXh0ZW5kKHRoaXMuJG92ZXJsYXlbMF0uc3R5bGUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQW5pbWF0ZSBvdmVybGF5XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuJG92ZXJsYXlbMF0sXG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLm9wYWNpdHksXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5pbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZWZpbmUgbW9kYWwgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICAgICAgdmFyIGVudGVyQW5pbU9wdGlvbnMgPSB7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy5lbCxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmluRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEN1YmljJyxcbiAgICAgICAgICAvLyBIYW5kbGUgbW9kYWwgb25PcGVuRW5kIGNhbGxiYWNrXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMxNC5vcHRpb25zLm9uT3BlbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczE0Lm9wdGlvbnMub25PcGVuRW5kLmNhbGwoX3RoaXMxNCwgX3RoaXMxNC5lbCwgX3RoaXMxNC5fb3BlbmluZ1RyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBCb3R0b20gc2hlZXQgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucygnYm90dG9tLXNoZWV0JykpIHtcbiAgICAgICAgICAkLmV4dGVuZChlbnRlckFuaW1PcHRpb25zLCB7XG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5pbShlbnRlckFuaW1PcHRpb25zKTtcblxuICAgICAgICAgIC8vIE5vcm1hbCBtb2RhbCBhbmltYXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkLmV4dGVuZChlbnRlckFuaW1PcHRpb25zLCB7XG4gICAgICAgICAgICB0b3A6IFt0aGlzLm9wdGlvbnMuc3RhcnRpbmdUb3AsIHRoaXMub3B0aW9ucy5lbmRpbmdUb3BdLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNjYWxlWDogWzAuOCwgMV0sXG4gICAgICAgICAgICBzY2FsZVk6IFswLjgsIDFdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5pbShlbnRlckFuaW1PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgb3V0IG1vZGFsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgICAgLy8gQW5pbWF0ZSBvdmVybGF5XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuJG92ZXJsYXlbMF0sXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLm91dER1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIG1vZGFsIGFuaW1hdGlvbiBvcHRpb25zXG4gICAgICAgIHZhciBleGl0QW5pbU9wdGlvbnMgPSB7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy5lbCxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLm91dER1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYycsXG4gICAgICAgICAgLy8gSGFuZGxlIG1vZGFsIHJlYWR5IGNhbGxiYWNrXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMTUuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIF90aGlzMTUuJG92ZXJsYXkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgb25DbG9zZUVuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczE1Lm9wdGlvbnMub25DbG9zZUVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczE1Lm9wdGlvbnMub25DbG9zZUVuZC5jYWxsKF90aGlzMTUsIF90aGlzMTUuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBCb3R0b20gc2hlZXQgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucygnYm90dG9tLXNoZWV0JykpIHtcbiAgICAgICAgICAkLmV4dGVuZChleGl0QW5pbU9wdGlvbnMsIHtcbiAgICAgICAgICAgIGJvdHRvbTogJy0xMDAlJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhbmltKGV4aXRBbmltT3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyBOb3JtYWwgbW9kYWwgYW5pbWF0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJC5leHRlbmQoZXhpdEFuaW1PcHRpb25zLCB7XG4gICAgICAgICAgICB0b3A6IFt0aGlzLm9wdGlvbnMuZW5kaW5nVG9wLCB0aGlzLm9wdGlvbnMuc3RhcnRpbmdUb3BdLFxuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHNjYWxlWDogMC44LFxuICAgICAgICAgICAgc2NhbGVZOiAwLjhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhbmltKGV4aXRBbmltT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVuIE1vZGFsXG4gICAgICAgKiBAcGFyYW0ge2Nhc2h9IFskdHJpZ2dlcl1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCR0cmlnZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgTW9kYWwuX21vZGFsc09wZW4rKztcbiAgICAgICAgdGhpcy5fbnRoTW9kYWxPcGVuZWQgPSBNb2RhbC5fbW9kYWxzT3BlbjtcblxuICAgICAgICAvLyBTZXQgWi1JbmRleCBiYXNlZCBvbiBudW1iZXIgb2YgY3VycmVudGx5IG9wZW4gbW9kYWxzXG4gICAgICAgIHRoaXMuJG92ZXJsYXlbMF0uc3R5bGUuekluZGV4ID0gMTAwMCArIE1vZGFsLl9tb2RhbHNPcGVuICogMjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS56SW5kZXggPSAxMDAwICsgTW9kYWwuX21vZGFsc09wZW4gKiAyICsgMTtcblxuICAgICAgICAvLyBTZXQgb3BlbmluZyB0cmlnZ2VyLCB1bmRlZmluZWQgaW5kaWNhdGVzIG1vZGFsIHdhcyBvcGVuZWQgYnkgamF2YXNjcmlwdFxuICAgICAgICB0aGlzLl9vcGVuaW5nVHJpZ2dlciA9ICEhJHRyaWdnZXIgPyAkdHJpZ2dlclswXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBvbk9wZW5TdGFydCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydC5jYWxsKHRoaXMsIHRoaXMuZWwsIHRoaXMuX29wZW5pbmdUcmlnZ2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudFNjcm9sbGluZykge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICB0aGlzLmVsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCB0aGlzLiRvdmVybGF5WzBdKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlS2V5ZG93bkJvdW5kID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUZvY3VzQm91bmQgPSB0aGlzLl9oYW5kbGVGb2N1cy5iaW5kKHRoaXMpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlkb3duQm91bmQpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlRm9jdXNCb3VuZCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLmVsKTtcbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy4kb3ZlcmxheVswXSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVJbigpO1xuXG4gICAgICAgIC8vIEZvY3VzIG1vZGFsXG4gICAgICAgIHRoaXMuZWwuZm9jdXMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBNb2RhbFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIE1vZGFsLl9tb2RhbHNPcGVuLS07XG4gICAgICAgIHRoaXMuX250aE1vZGFsT3BlbmVkID0gMDtcblxuICAgICAgICAvLyBDYWxsIG9uQ2xvc2VTdGFydCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbG9zZVN0YXJ0LmNhbGwodGhpcywgdGhpcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcblxuICAgICAgICAvLyBFbmFibGUgYm9keSBzY3JvbGxpbmcgb25seSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBtb2RhbHMgb3Blbi5cbiAgICAgICAgaWYgKE1vZGFsLl9tb2RhbHNPcGVuID09PSAwKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNtaXNzaWJsZSkge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlkb3duQm91bmQpO1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlRm9jdXNCb3VuZCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLmVsKTtcbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy4kb3ZlcmxheVswXSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVPdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KE1vZGFsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9kYWwpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9Nb2RhbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNb2RhbDtcbiAgfShDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBNb2RhbFxuICAgKi9cblxuXG4gIE1vZGFsLl9tb2RhbHNPcGVuID0gMDtcblxuICAvKipcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgTW9kYWxcbiAgICovXG4gIE1vZGFsLl9jb3VudCA9IDA7XG5cbiAgTS5Nb2RhbCA9IE1vZGFsO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoTW9kYWwsICdtb2RhbCcsICdNX01vZGFsJyk7XG4gIH1cbn0pKGNhc2gsIE0uYW5pbWUpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBpbkR1cmF0aW9uOiAyNzUsXG4gICAgb3V0RHVyYXRpb246IDIwMCxcbiAgICBvbk9wZW5TdGFydDogbnVsbCxcbiAgICBvbk9wZW5FbmQ6IG51bGwsXG4gICAgb25DbG9zZVN0YXJ0OiBudWxsLFxuICAgIG9uQ2xvc2VFbmQ6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBNYXRlcmlhbGJveCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50NCkge1xuICAgIF9pbmhlcml0cyhNYXRlcmlhbGJveCwgX0NvbXBvbmVudDQpO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IE1hdGVyaWFsYm94IGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxib3goZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRlcmlhbGJveCk7XG5cbiAgICAgIHZhciBfdGhpczE2ID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE1hdGVyaWFsYm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWF0ZXJpYWxib3gpKS5jYWxsKHRoaXMsIE1hdGVyaWFsYm94LCBlbCwgb3B0aW9ucykpO1xuXG4gICAgICBfdGhpczE2LmVsLk1fTWF0ZXJpYWxib3ggPSBfdGhpczE2O1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBtb2RhbFxuICAgICAgICogQG1lbWJlciBNYXRlcmlhbGJveCNvcHRpb25zXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbaW5EdXJhdGlvbj0yNzVdIC0gTGVuZ3RoIGluIG1zIG9mIGVudGVyIHRyYW5zaXRpb25cbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IFtvdXREdXJhdGlvbj0yMDBdIC0gTGVuZ3RoIGluIG1zIG9mIGV4aXQgdHJhbnNpdGlvblxuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbk9wZW5TdGFydCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBiZWZvcmUgbWF0ZXJpYWxib3ggaXMgb3BlbmVkXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uT3BlbkVuZCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBhZnRlciBtYXRlcmlhbGJveCBpcyBvcGVuZWRcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25DbG9zZVN0YXJ0IC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGJlZm9yZSBtYXRlcmlhbGJveCBpcyBjbG9zZWRcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25DbG9zZUVuZCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBhZnRlciBtYXRlcmlhbGJveCBpcyBjbG9zZWRcbiAgICAgICAqL1xuICAgICAgX3RoaXMxNi5vcHRpb25zID0gJC5leHRlbmQoe30sIE1hdGVyaWFsYm94LmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgX3RoaXMxNi5vdmVybGF5QWN0aXZlID0gZmFsc2U7XG4gICAgICBfdGhpczE2LmRvbmVBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgX3RoaXMxNi5wbGFjZWhvbGRlciA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hdGVyaWFsLXBsYWNlaG9sZGVyJyk7XG4gICAgICBfdGhpczE2Lm9yaWdpbmFsV2lkdGggPSAwO1xuICAgICAgX3RoaXMxNi5vcmlnaW5hbEhlaWdodCA9IDA7XG4gICAgICBfdGhpczE2Lm9yaWdpbklubGluZVN0eWxlcyA9IF90aGlzMTYuJGVsLmF0dHIoJ3N0eWxlJyk7XG4gICAgICBfdGhpczE2LmNhcHRpb24gPSBfdGhpczE2LmVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jYXB0aW9uJykgfHwgJyc7XG5cbiAgICAgIC8vIFdyYXBcbiAgICAgIF90aGlzMTYuJGVsLmJlZm9yZShfdGhpczE2LnBsYWNlaG9sZGVyKTtcbiAgICAgIF90aGlzMTYucGxhY2Vob2xkZXIuYXBwZW5kKF90aGlzMTYuJGVsKTtcblxuICAgICAgX3RoaXMxNi5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXMxNjtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTWF0ZXJpYWxib3gsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuZWwuTV9NYXRlcmlhbGJveCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBVbndyYXAgaW1hZ2VcbiAgICAgICAgJCh0aGlzLnBsYWNlaG9sZGVyKS5hZnRlcih0aGlzLmVsKS5yZW1vdmUoKTtcblxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlTWF0ZXJpYWxib3hDbGlja0JvdW5kID0gdGhpcy5faGFuZGxlTWF0ZXJpYWxib3hDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlTWF0ZXJpYWxib3hDbGlja0JvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVNYXRlcmlhbGJveENsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBNYXRlcmlhbGJveCBDbGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1hdGVyaWFsYm94Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTWF0ZXJpYWxib3hDbGljayhlKSB7XG4gICAgICAgIC8vIElmIGFscmVhZHkgbW9kYWwsIHJldHVybiB0byBvcmlnaW5hbFxuICAgICAgICBpZiAodGhpcy5kb25lQW5pbWF0aW5nID09PSBmYWxzZSB8fCB0aGlzLm92ZXJsYXlBY3RpdmUgJiYgdGhpcy5kb25lQW5pbWF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFdpbmRvdyBTY3JvbGxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVXaW5kb3dTY3JvbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93U2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5QWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFdpbmRvdyBSZXNpemVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVXaW5kb3dSZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5QWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFdpbmRvdyBSZXNpemVcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVXaW5kb3dFc2NhcGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93RXNjYXBlKGUpIHtcbiAgICAgICAgLy8gRVNDIGtleVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiB0aGlzLmRvbmVBbmltYXRpbmcgJiYgdGhpcy5vdmVybGF5QWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhbmNlc3RvcnMgd2l0aCBvdmVyZmxvdzogaGlkZGVuOyBhbmQgbWFrZSB2aXNpYmxlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbWFrZUFuY2VzdG9yc092ZXJmbG93VmlzaWJsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQW5jZXN0b3JzT3ZlcmZsb3dWaXNpYmxlKCkge1xuICAgICAgICB0aGlzLmFuY2VzdG9yc0NoYW5nZWQgPSAkKCk7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHRoaXMucGxhY2Vob2xkZXJbMF0ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yICE9PSBudWxsICYmICEkKGFuY2VzdG9yKS5pcyhkb2N1bWVudCkpIHtcbiAgICAgICAgICB2YXIgY3VyciA9ICQoYW5jZXN0b3IpO1xuICAgICAgICAgIGlmIChjdXJyLmNzcygnb3ZlcmZsb3cnKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICBjdXJyLmNzcygnb3ZlcmZsb3cnLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3JzQ2hhbmdlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuYW5jZXN0b3JzQ2hhbmdlZCA9IGN1cnI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFuY2VzdG9yc0NoYW5nZWQgPSB0aGlzLmFuY2VzdG9yc0NoYW5nZWQuYWRkKGN1cnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbmltYXRlIGltYWdlIGluXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZUltYWdlSW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZUltYWdlSW4oKSB7XG4gICAgICAgIHZhciBfdGhpczE3ID0gdGhpcztcblxuICAgICAgICB2YXIgYW5pbU9wdGlvbnMgPSB7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy5lbCxcbiAgICAgICAgICBoZWlnaHQ6IFt0aGlzLm9yaWdpbmFsSGVpZ2h0LCB0aGlzLm5ld0hlaWdodF0sXG4gICAgICAgICAgd2lkdGg6IFt0aGlzLm9yaWdpbmFsV2lkdGgsIHRoaXMubmV3V2lkdGhdLFxuICAgICAgICAgIGxlZnQ6IE0uZ2V0RG9jdW1lbnRTY3JvbGxMZWZ0KCkgKyB0aGlzLndpbmRvd1dpZHRoIC8gMiAtIHRoaXMucGxhY2Vob2xkZXIub2Zmc2V0KCkubGVmdCAtIHRoaXMubmV3V2lkdGggLyAyLFxuICAgICAgICAgIHRvcDogTS5nZXREb2N1bWVudFNjcm9sbFRvcCgpICsgdGhpcy53aW5kb3dIZWlnaHQgLyAyIC0gdGhpcy5wbGFjZWhvbGRlci5vZmZzZXQoKS50b3AgLSB0aGlzLm5ld0hlaWdodCAvIDIsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5pbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMxNy5kb25lQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gb25PcGVuRW5kIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzMTcub3B0aW9ucy5vbk9wZW5FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXMxNy5vcHRpb25zLm9uT3BlbkVuZC5jYWxsKF90aGlzMTcsIF90aGlzMTcuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPdmVycmlkZSBtYXgtd2lkdGggb3IgbWF4LWhlaWdodCBpZiBuZWVkZWRcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IHRoaXMuJGVsLmNzcygnbWF4LXdpZHRoJyk7XG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gdGhpcy4kZWwuY3NzKCdtYXgtaGVpZ2h0Jyk7XG4gICAgICAgIGlmICh0aGlzLm1heFdpZHRoICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBhbmltT3B0aW9ucy5tYXhXaWR0aCA9IHRoaXMubmV3V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4SGVpZ2h0ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBhbmltT3B0aW9ucy5tYXhIZWlnaHQgPSB0aGlzLm5ld0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0oYW5pbU9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgaW1hZ2Ugb3V0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZUltYWdlT3V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJbWFnZU91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzMTggPSB0aGlzO1xuXG4gICAgICAgIHZhciBhbmltT3B0aW9ucyA9IHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLmVsLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLm9yaWdpbmFsV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLm9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczE4LnBsYWNlaG9sZGVyLmNzcyh7XG4gICAgICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICAgICAgICB0b3A6ICcnLFxuICAgICAgICAgICAgICBsZWZ0OiAnJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJldmVydCB0byB3aWR0aCBvciBoZWlnaHQgYXR0cmlidXRlXG4gICAgICAgICAgICBpZiAoX3RoaXMxOC5hdHRyV2lkdGgpIHtcbiAgICAgICAgICAgICAgX3RoaXMxOC4kZWwuYXR0cignd2lkdGgnLCBfdGhpczE4LmF0dHJXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMxOC5hdHRySGVpZ2h0KSB7XG4gICAgICAgICAgICAgIF90aGlzMTguJGVsLmF0dHIoJ2hlaWdodCcsIF90aGlzMTguYXR0ckhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzMTguJGVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgICBfdGhpczE4Lm9yaWdpbklubGluZVN0eWxlcyAmJiBfdGhpczE4LiRlbC5hdHRyKCdzdHlsZScsIF90aGlzMTgub3JpZ2luSW5saW5lU3R5bGVzKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNsYXNzXG4gICAgICAgICAgICBfdGhpczE4LiRlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBfdGhpczE4LmRvbmVBbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgb3ZlcmZsb3cgb3ZlcnJpZGVzIG9uIGFuY2VzdG9yc1xuICAgICAgICAgICAgaWYgKF90aGlzMTguYW5jZXN0b3JzQ2hhbmdlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgX3RoaXMxOC5hbmNlc3RvcnNDaGFuZ2VkLmNzcygnb3ZlcmZsb3cnLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uQ2xvc2VFbmQgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMxOC5vcHRpb25zLm9uQ2xvc2VFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXMxOC5vcHRpb25zLm9uQ2xvc2VFbmQuY2FsbChfdGhpczE4LCBfdGhpczE4LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pbShhbmltT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIG9wZW4gYW5kIGNsb3NlIHZhcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl91cGRhdGVWYXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZhcnMoKSB7XG4gICAgICAgIHRoaXMud2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdGhpcy53aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FwdGlvbiA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcHRpb24nKSB8fCAnJztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVuIE1hdGVyaWFsYm94XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvcGVuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgdmFyIF90aGlzMTkgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhcnMoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgIC8vIFNldCBzdGF0ZXNcbiAgICAgICAgdGhpcy5kb25lQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy5vdmVybGF5QWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAvLyBvbk9wZW5TdGFydCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydC5jYWxsKHRoaXMsIHRoaXMuZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHBvc2l0aW9uaW5nIGZvciBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IHRoaXMucGxhY2Vob2xkZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyAncHgnLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5wbGFjZWhvbGRlclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyAncHgnLFxuICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX21ha2VBbmNlc3RvcnNPdmVyZmxvd1Zpc2libGUoKTtcblxuICAgICAgICAvLyBTZXQgY3NzIG9uIG9yaWdpblxuICAgICAgICB0aGlzLiRlbC5jc3Moe1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICd6LWluZGV4JzogMTAwMCxcbiAgICAgICAgICAnd2lsbC1jaGFuZ2UnOiAnbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGFuZ2UgZnJvbSB3aWR0aCBvciBoZWlnaHQgYXR0cmlidXRlIHRvIGNzc1xuICAgICAgICB0aGlzLmF0dHJXaWR0aCA9IHRoaXMuJGVsLmF0dHIoJ3dpZHRoJyk7XG4gICAgICAgIHRoaXMuYXR0ckhlaWdodCA9IHRoaXMuJGVsLmF0dHIoJ2hlaWdodCcpO1xuICAgICAgICBpZiAodGhpcy5hdHRyV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLiRlbC5jc3MoJ3dpZHRoJywgdGhpcy5hdHRyV2lkdGggKyAncHgnKTtcbiAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyKCd3aWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLiRlbC5jc3MoJ3dpZHRoJywgdGhpcy5hdHRySGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQXR0cignaGVpZ2h0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgb3ZlcmxheVxuICAgICAgICB0aGlzLiRvdmVybGF5ID0gJCgnPGRpdiBpZD1cIm1hdGVyaWFsYm94LW92ZXJsYXlcIj48L2Rpdj4nKS5jc3Moe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSkub25lKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMxOS5kb25lQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICBfdGhpczE5LmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQdXQgYmVmb3JlIGluIG9yaWdpbiBpbWFnZSB0byBwcmVzZXJ2ZSB6LWluZGV4IGxheWVyaW5nLlxuICAgICAgICB0aGlzLiRlbC5iZWZvcmUodGhpcy4kb3ZlcmxheSk7XG5cbiAgICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgaWYgbmVlZGVkXG4gICAgICAgIHZhciBvdmVybGF5T2Zmc2V0ID0gdGhpcy4kb3ZlcmxheVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jc3Moe1xuICAgICAgICAgIHdpZHRoOiB0aGlzLndpbmRvd1dpZHRoICsgJ3B4JyxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMud2luZG93SGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICBsZWZ0OiAtMSAqIG92ZXJsYXlPZmZzZXQubGVmdCArICdweCcsXG4gICAgICAgICAgdG9wOiAtMSAqIG92ZXJsYXlPZmZzZXQudG9wICsgJ3B4J1xuICAgICAgICB9KTtcblxuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLmVsKTtcbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy4kb3ZlcmxheVswXSk7XG5cbiAgICAgICAgLy8gQW5pbWF0ZSBPdmVybGF5XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuJG92ZXJsYXlbMF0sXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmluRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBhbmQgYW5pbWF0ZSBjYXB0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5jYXB0aW9uICE9PSAnJykge1xuICAgICAgICAgIGlmICh0aGlzLiRwaG90b2NhcHRpb24pIHtcbiAgICAgICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuJHBob3RvQ2FwdGlvblswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuJHBob3RvQ2FwdGlvbiA9ICQoJzxkaXYgY2xhc3M9XCJtYXRlcmlhbGJveC1jYXB0aW9uXCI+PC9kaXY+Jyk7XG4gICAgICAgICAgdGhpcy4kcGhvdG9DYXB0aW9uLnRleHQodGhpcy5jYXB0aW9uKTtcbiAgICAgICAgICAkKCdib2R5JykuYXBwZW5kKHRoaXMuJHBob3RvQ2FwdGlvbik7XG4gICAgICAgICAgdGhpcy4kcGhvdG9DYXB0aW9uLmNzcyh7IGRpc3BsYXk6ICdpbmxpbmUnIH0pO1xuXG4gICAgICAgICAgYW5pbSh7XG4gICAgICAgICAgICB0YXJnZXRzOiB0aGlzLiRwaG90b0NhcHRpb25bMF0sXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5pbkR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNpemUgSW1hZ2VcbiAgICAgICAgdmFyIHJhdGlvID0gMDtcbiAgICAgICAgdmFyIHdpZHRoUGVyY2VudCA9IHRoaXMub3JpZ2luYWxXaWR0aCAvIHRoaXMud2luZG93V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRQZXJjZW50ID0gdGhpcy5vcmlnaW5hbEhlaWdodCAvIHRoaXMud2luZG93SGVpZ2h0O1xuICAgICAgICB0aGlzLm5ld1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5uZXdIZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmICh3aWR0aFBlcmNlbnQgPiBoZWlnaHRQZXJjZW50KSB7XG4gICAgICAgICAgcmF0aW8gPSB0aGlzLm9yaWdpbmFsSGVpZ2h0IC8gdGhpcy5vcmlnaW5hbFdpZHRoO1xuICAgICAgICAgIHRoaXMubmV3V2lkdGggPSB0aGlzLndpbmRvd1dpZHRoICogMC45O1xuICAgICAgICAgIHRoaXMubmV3SGVpZ2h0ID0gdGhpcy53aW5kb3dXaWR0aCAqIDAuOSAqIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdGlvID0gdGhpcy5vcmlnaW5hbFdpZHRoIC8gdGhpcy5vcmlnaW5hbEhlaWdodDtcbiAgICAgICAgICB0aGlzLm5ld1dpZHRoID0gdGhpcy53aW5kb3dIZWlnaHQgKiAwLjkgKiByYXRpbztcbiAgICAgICAgICB0aGlzLm5ld0hlaWdodCA9IHRoaXMud2luZG93SGVpZ2h0ICogMC45O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUltYWdlSW4oKTtcblxuICAgICAgICAvLyBIYW5kbGUgRXhpdCB0cmlnZ2Vyc1xuICAgICAgICB0aGlzLl9oYW5kbGVXaW5kb3dTY3JvbGxCb3VuZCA9IHRoaXMuX2hhbmRsZVdpbmRvd1Njcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemVCb3VuZCA9IHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVXaW5kb3dFc2NhcGVCb3VuZCA9IHRoaXMuX2hhbmRsZVdpbmRvd0VzY2FwZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9oYW5kbGVXaW5kb3dTY3JvbGxCb3VuZCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemVCb3VuZCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX2hhbmRsZVdpbmRvd0VzY2FwZUJvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBNYXRlcmlhbGJveFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMjAgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhcnMoKTtcbiAgICAgICAgdGhpcy5kb25lQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gb25DbG9zZVN0YXJ0IGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2xvc2VTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQuY2FsbCh0aGlzLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLiRvdmVybGF5WzBdKTtcblxuICAgICAgICBpZiAodGhpcy5jYXB0aW9uICE9PSAnJykge1xuICAgICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuJHBob3RvQ2FwdGlvblswXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaXNhYmxlIGV4aXQgaGFuZGxlcnNcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZVdpbmRvd1Njcm9sbEJvdW5kKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZUJvdW5kKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5faGFuZGxlV2luZG93RXNjYXBlQm91bmQpO1xuXG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuJG92ZXJsYXlbMF0sXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLm91dER1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyMC5vdmVybGF5QWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpczIwLiRvdmVybGF5LnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUltYWdlT3V0KCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIENhcHRpb24gKyByZXNldCBjc3Mgc2V0dGluZ3Mgb24gaW1hZ2VcbiAgICAgICAgaWYgKHRoaXMuY2FwdGlvbiAhPT0gJycpIHtcbiAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuJHBob3RvQ2FwdGlvblswXSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLm91dER1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyMC4kcGhvdG9DYXB0aW9uLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KE1hdGVyaWFsYm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWF0ZXJpYWxib3gpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9NYXRlcmlhbGJveDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNYXRlcmlhbGJveDtcbiAgfShDb21wb25lbnQpO1xuXG4gIE0uTWF0ZXJpYWxib3ggPSBNYXRlcmlhbGJveDtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKE1hdGVyaWFsYm94LCAnbWF0ZXJpYWxib3gnLCAnTV9NYXRlcmlhbGJveCcpO1xuICB9XG59KShjYXNoLCBNLmFuaW1lKTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgcmVzcG9uc2l2ZVRocmVzaG9sZDogMCAvLyBicmVha3BvaW50IGZvciBzd2lwZWFibGVcbiAgfTtcblxuICB2YXIgUGFyYWxsYXggPSBmdW5jdGlvbiAoX0NvbXBvbmVudDUpIHtcbiAgICBfaW5oZXJpdHMoUGFyYWxsYXgsIF9Db21wb25lbnQ1KTtcblxuICAgIGZ1bmN0aW9uIFBhcmFsbGF4KGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyYWxsYXgpO1xuXG4gICAgICB2YXIgX3RoaXMyMSA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQYXJhbGxheC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhcmFsbGF4KSkuY2FsbCh0aGlzLCBQYXJhbGxheCwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMyMS5lbC5NX1BhcmFsbGF4ID0gX3RoaXMyMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgUGFyYWxsYXhcbiAgICAgICAqIEBtZW1iZXIgUGFyYWxsYXgjb3B0aW9uc1xuICAgICAgICogQHByb3Age051bWJlcn0gcmVzcG9uc2l2ZVRocmVzaG9sZFxuICAgICAgICovXG4gICAgICBfdGhpczIxLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUGFyYWxsYXguZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgX3RoaXMyMS5fZW5hYmxlZCA9IHdpbmRvdy5pbm5lcldpZHRoID4gX3RoaXMyMS5vcHRpb25zLnJlc3BvbnNpdmVUaHJlc2hvbGQ7XG5cbiAgICAgIF90aGlzMjEuJGltZyA9IF90aGlzMjEuJGVsLmZpbmQoJ2ltZycpLmZpcnN0KCk7XG4gICAgICBfdGhpczIxLiRpbWcuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgIGlmIChlbC5jb21wbGV0ZSkgJChlbCkudHJpZ2dlcignbG9hZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzMjEuX3VwZGF0ZVBhcmFsbGF4KCk7XG4gICAgICBfdGhpczIxLl9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIF90aGlzMjEuX3NldHVwU3R5bGVzKCk7XG5cbiAgICAgIFBhcmFsbGF4Ll9wYXJhbGxheGVzLnB1c2goX3RoaXMyMSk7XG4gICAgICByZXR1cm4gX3RoaXMyMTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGFyYWxsYXgsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBQYXJhbGxheC5fcGFyYWxsYXhlcy5zcGxpY2UoUGFyYWxsYXguX3BhcmFsbGF4ZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgIHRoaXMuJGltZ1swXS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuXG4gICAgICAgIHRoaXMuJGVsWzBdLk1fUGFyYWxsYXggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVJbWFnZUxvYWRCb3VuZCA9IHRoaXMuX2hhbmRsZUltYWdlTG9hZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiRpbWdbMF0uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2hhbmRsZUltYWdlTG9hZEJvdW5kKTtcblxuICAgICAgICBpZiAoUGFyYWxsYXguX3BhcmFsbGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgUGFyYWxsYXguX2hhbmRsZVNjcm9sbFRocm90dGxlZCA9IE0udGhyb3R0bGUoUGFyYWxsYXguX2hhbmRsZVNjcm9sbCwgNSk7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIFBhcmFsbGF4Ll9oYW5kbGVTY3JvbGxUaHJvdHRsZWQpO1xuXG4gICAgICAgICAgUGFyYWxsYXguX2hhbmRsZVdpbmRvd1Jlc2l6ZVRocm90dGxlZCA9IE0udGhyb3R0bGUoUGFyYWxsYXguX2hhbmRsZVdpbmRvd1Jlc2l6ZSwgNSk7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIFBhcmFsbGF4Ll9oYW5kbGVXaW5kb3dSZXNpemVUaHJvdHRsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuJGltZ1swXS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faGFuZGxlSW1hZ2VMb2FkQm91bmQpO1xuXG4gICAgICAgIGlmIChQYXJhbGxheC5fcGFyYWxsYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgUGFyYWxsYXguX2hhbmRsZVNjcm9sbFRocm90dGxlZCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIFBhcmFsbGF4Ll9oYW5kbGVXaW5kb3dSZXNpemVUaHJvdHRsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cFN0eWxlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFN0eWxlcygpIHtcbiAgICAgICAgdGhpcy4kaW1nWzBdLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW1hZ2VMb2FkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUltYWdlTG9hZCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGFyYWxsYXgoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZVBhcmFsbGF4XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBhcmFsbGF4KCkge1xuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWwuaGVpZ2h0KCkgPiAwID8gdGhpcy5lbC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCA6IDUwMDtcbiAgICAgICAgdmFyIGltZ0hlaWdodCA9IHRoaXMuJGltZ1swXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBwYXJhbGxheERpc3QgPSBpbWdIZWlnaHQgLSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgIHZhciBib3R0b20gPSB0aGlzLiRlbC5vZmZzZXQoKS50b3AgKyBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLiRlbC5vZmZzZXQoKS50b3A7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSBNLmdldERvY3VtZW50U2Nyb2xsVG9wKCk7XG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciB3aW5kb3dCb3R0b20gPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQ7XG4gICAgICAgIHZhciBwZXJjZW50U2Nyb2xsZWQgPSAod2luZG93Qm90dG9tIC0gdG9wKSAvIChjb250YWluZXJIZWlnaHQgKyB3aW5kb3dIZWlnaHQpO1xuICAgICAgICB2YXIgcGFyYWxsYXggPSBwYXJhbGxheERpc3QgKiBwZXJjZW50U2Nyb2xsZWQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy4kaW1nWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IHNjcm9sbFRvcCAmJiB0b3AgPCBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLiRpbWdbMF0uc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzRCgtNTAlLCBcIiArIHBhcmFsbGF4ICsgXCJweCwgMClcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX2dldChQYXJhbGxheC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhcmFsbGF4KSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fUGFyYWxsYXg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVTY3JvbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU2Nyb2xsKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBhcmFsbGF4Ll9wYXJhbGxheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmFsbGF4SW5zdGFuY2UgPSBQYXJhbGxheC5fcGFyYWxsYXhlc1tpXTtcbiAgICAgICAgICBwYXJhbGxheEluc3RhbmNlLl91cGRhdGVQYXJhbGxheC5jYWxsKHBhcmFsbGF4SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVXaW5kb3dSZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBhcmFsbGF4Ll9wYXJhbGxheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmFsbGF4SW5zdGFuY2UgPSBQYXJhbGxheC5fcGFyYWxsYXhlc1tpXTtcbiAgICAgICAgICBwYXJhbGxheEluc3RhbmNlLl9lbmFibGVkID0gd2luZG93LmlubmVyV2lkdGggPiBwYXJhbGxheEluc3RhbmNlLm9wdGlvbnMucmVzcG9uc2l2ZVRocmVzaG9sZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBhcmFsbGF4O1xuICB9KENvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBhcmFsbGF4XG4gICAqL1xuXG5cbiAgUGFyYWxsYXguX3BhcmFsbGF4ZXMgPSBbXTtcblxuICBNLlBhcmFsbGF4ID0gUGFyYWxsYXg7XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihQYXJhbGxheCwgJ3BhcmFsbGF4JywgJ01fUGFyYWxsYXgnKTtcbiAgfVxufSkoY2FzaCk7XG47KGZ1bmN0aW9uICgkLCBhbmltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgb25TaG93OiBudWxsLFxuICAgIHN3aXBlYWJsZTogZmFsc2UsXG4gICAgcmVzcG9uc2l2ZVRocmVzaG9sZDogSW5maW5pdHkgLy8gYnJlYWtwb2ludCBmb3Igc3dpcGVhYmxlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgVGFicyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50Nikge1xuICAgIF9pbmhlcml0cyhUYWJzLCBfQ29tcG9uZW50Nik7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgVGFicyBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhYnMoZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJzKTtcblxuICAgICAgdmFyIF90aGlzMjIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGFicy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhYnMpKS5jYWxsKHRoaXMsIFRhYnMsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzMjIuZWwuTV9UYWJzID0gX3RoaXMyMjtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgVGFic1xuICAgICAgICogQG1lbWJlciBUYWJzI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uU2hvd1xuICAgICAgICogQHByb3Age0Jvb2xlYW59IHN3aXBlYWJsZVxuICAgICAgICogQHByb3Age051bWJlcn0gcmVzcG9uc2l2ZVRocmVzaG9sZFxuICAgICAgICovXG4gICAgICBfdGhpczIyLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVGFicy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldHVwXG4gICAgICBfdGhpczIyLiR0YWJMaW5rcyA9IF90aGlzMjIuJGVsLmNoaWxkcmVuKCdsaS50YWInKS5jaGlsZHJlbignYScpO1xuICAgICAgX3RoaXMyMi5pbmRleCA9IDA7XG4gICAgICBfdGhpczIyLl9zZXR1cEFjdGl2ZVRhYkxpbmsoKTtcblxuICAgICAgLy8gU2V0dXAgdGFicyBjb250ZW50XG4gICAgICBpZiAoX3RoaXMyMi5vcHRpb25zLnN3aXBlYWJsZSkge1xuICAgICAgICBfdGhpczIyLl9zZXR1cFN3aXBlYWJsZVRhYnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzMjIuX3NldHVwTm9ybWFsVGFicygpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCB0YWJzIGluZGljYXRvciBhZnRlciBjb250ZW50IHRvIGVuc3VyZSBhY2N1cmF0ZSB3aWR0aHNcbiAgICAgIF90aGlzMjIuX3NldFRhYnNBbmRUYWJXaWR0aCgpO1xuICAgICAgX3RoaXMyMi5fY3JlYXRlSW5kaWNhdG9yKCk7XG5cbiAgICAgIF90aGlzMjIuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgcmV0dXJuIF90aGlzMjI7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRhYnMsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX2luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2luZGljYXRvcik7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zd2lwZWFibGUpIHtcbiAgICAgICAgICB0aGlzLl90ZWFyZG93blN3aXBlYWJsZVRhYnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90ZWFyZG93bk5vcm1hbFRhYnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsWzBdLk1fVGFicyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZUJvdW5kID0gdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemVCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlVGFiQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZVRhYkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVUYWJDbGlja0JvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVUYWJDbGlja0JvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgd2luZG93IFJlc2l6ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVdpbmRvd1Jlc2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVXaW5kb3dSZXNpemUoKSB7XG4gICAgICAgIHRoaXMuX3NldFRhYnNBbmRUYWJXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRhYldpZHRoICE9PSAwICYmIHRoaXMudGFic1dpZHRoICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5faW5kaWNhdG9yLnN0eWxlLmxlZnQgPSB0aGlzLl9jYWxjTGVmdFBvcyh0aGlzLiRhY3RpdmVUYWJMaW5rKSArICdweCc7XG4gICAgICAgICAgdGhpcy5faW5kaWNhdG9yLnN0eWxlLnJpZ2h0ID0gdGhpcy5fY2FsY1JpZ2h0UG9zKHRoaXMuJGFjdGl2ZVRhYkxpbmspICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSB0YWIgY2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVUYWJDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVUYWJDbGljayhlKSB7XG4gICAgICAgIHZhciBfdGhpczIzID0gdGhpcztcblxuICAgICAgICB2YXIgdGFiID0gJChlLnRhcmdldCkuY2xvc2VzdCgnbGkudGFiJyk7XG4gICAgICAgIHZhciB0YWJMaW5rID0gJChlLnRhcmdldCkuY2xvc2VzdCgnYScpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBjbGljayBvbiB0YWIgbGluayBvbmx5XG4gICAgICAgIGlmICghdGFiTGluay5sZW5ndGggfHwgIXRhYkxpbmsucGFyZW50KCkuaGFzQ2xhc3MoJ3RhYicpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhYi5oYXNDbGFzcygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3QgYXMgcmVndWxhciBsaW5rIGlmIHRhcmdldCBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICBpZiAoISF0YWJMaW5rLmF0dHIoJ3RhcmdldCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgb2xkIHRhYiBpbmFjdGl2ZS5cbiAgICAgICAgdGhpcy4kYWN0aXZlVGFiTGluay5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHZhciAkb2xkQ29udGVudCA9IHRoaXMuJGNvbnRlbnQ7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YXJpYWJsZXMgd2l0aCB0aGUgbmV3IGxpbmsgYW5kIGNvbnRlbnRcbiAgICAgICAgdGhpcy4kYWN0aXZlVGFiTGluayA9IHRhYkxpbms7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSAkKE0uZXNjYXBlSGFzaCh0YWJMaW5rWzBdLmhhc2gpKTtcbiAgICAgICAgdGhpcy4kdGFiTGlua3MgPSB0aGlzLiRlbC5jaGlsZHJlbignbGkudGFiJykuY2hpbGRyZW4oJ2EnKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSB0YWIgYWN0aXZlLlxuICAgICAgICB0aGlzLiRhY3RpdmVUYWJMaW5rLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1heCh0aGlzLiR0YWJMaW5rcy5pbmRleCh0YWJMaW5rKSwgMCk7XG5cbiAgICAgICAgLy8gU3dhcCBjb250ZW50XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3dpcGVhYmxlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RhYnNDYXJvdXNlbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFic0Nhcm91c2VsLnNldCh0aGlzLmluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMyMy5vcHRpb25zLm9uU2hvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF90aGlzMjMub3B0aW9ucy5vblNob3cuY2FsbChfdGhpczIzLCBfdGhpczIzLiRjb250ZW50WzBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLiRjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy4kY29udGVudFswXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25TaG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNob3cuY2FsbCh0aGlzLCB0aGlzLiRjb250ZW50WzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCRvbGRDb250ZW50Lmxlbmd0aCAmJiAhJG9sZENvbnRlbnQuaXModGhpcy4kY29udGVudCkpIHtcbiAgICAgICAgICAgICAgJG9sZENvbnRlbnRbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgJG9sZENvbnRlbnQucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB3aWR0aHMgYWZ0ZXIgY29udGVudCBpcyBzd2FwcGVkIChzY3JvbGxiYXIgYnVnZml4KVxuICAgICAgICB0aGlzLl9zZXRUYWJzQW5kVGFiV2lkdGgoKTtcblxuICAgICAgICAvLyBVcGRhdGUgaW5kaWNhdG9yXG4gICAgICAgIHRoaXMuX2FuaW1hdGVJbmRpY2F0b3IocHJldkluZGV4KTtcblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBhbmNob3IncyBkZWZhdWx0IGNsaWNrIGFjdGlvblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGUgZWxlbWVudHMgZm9yIHRhYiBpbmRpY2F0b3IuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlSW5kaWNhdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUluZGljYXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzMjQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICBpbmRpY2F0b3IuY2xhc3NMaXN0LmFkZCgnaW5kaWNhdG9yJyk7XG5cbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChpbmRpY2F0b3IpO1xuICAgICAgICB0aGlzLl9pbmRpY2F0b3IgPSBpbmRpY2F0b3I7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyNC5faW5kaWNhdG9yLnN0eWxlLmxlZnQgPSBfdGhpczI0Ll9jYWxjTGVmdFBvcyhfdGhpczI0LiRhY3RpdmVUYWJMaW5rKSArICdweCc7XG4gICAgICAgICAgX3RoaXMyNC5faW5kaWNhdG9yLnN0eWxlLnJpZ2h0ID0gX3RoaXMyNC5fY2FsY1JpZ2h0UG9zKF90aGlzMjQuJGFjdGl2ZVRhYkxpbmspICsgJ3B4JztcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgZmlyc3QgYWN0aXZlIHRhYiBsaW5rLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwQWN0aXZlVGFiTGlua1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEFjdGl2ZVRhYkxpbmsoKSB7XG4gICAgICAgIC8vIElmIHRoZSBsb2NhdGlvbi5oYXNoIG1hdGNoZXMgb25lIG9mIHRoZSBsaW5rcywgdXNlIHRoYXQgYXMgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAgIHRoaXMuJGFjdGl2ZVRhYkxpbmsgPSAkKHRoaXMuJHRhYkxpbmtzLmZpbHRlcignW2hyZWY9XCInICsgbG9jYXRpb24uaGFzaCArICdcIl0nKSk7XG5cbiAgICAgICAgLy8gSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHVzZSB0aGUgZmlyc3QgbGluayBvciBhbnkgd2l0aCBjbGFzcyAnYWN0aXZlJyBhcyB0aGUgaW5pdGlhbCBhY3RpdmUgdGFiLlxuICAgICAgICBpZiAodGhpcy4kYWN0aXZlVGFiTGluay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLiRhY3RpdmVUYWJMaW5rID0gdGhpcy4kZWwuY2hpbGRyZW4oJ2xpLnRhYicpLmNoaWxkcmVuKCdhLmFjdGl2ZScpLmZpcnN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGFjdGl2ZVRhYkxpbmsubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy4kYWN0aXZlVGFiTGluayA9IHRoaXMuJGVsLmNoaWxkcmVuKCdsaS50YWInKS5jaGlsZHJlbignYScpLmZpcnN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiR0YWJMaW5rcy5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMuJGFjdGl2ZVRhYkxpbmtbMF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICAgICAgdGhpcy5pbmRleCA9IE1hdGgubWF4KHRoaXMuJHRhYkxpbmtzLmluZGV4KHRoaXMuJGFjdGl2ZVRhYkxpbmspLCAwKTtcblxuICAgICAgICBpZiAodGhpcy4kYWN0aXZlVGFiTGluay5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRjb250ZW50ID0gJChNLmVzY2FwZUhhc2godGhpcy4kYWN0aXZlVGFiTGlua1swXS5oYXNoKSk7XG4gICAgICAgICAgdGhpcy4kY29udGVudC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBzd2lwZWFibGUgdGFic1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwU3dpcGVhYmxlVGFic1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFN3aXBlYWJsZVRhYnMoKSB7XG4gICAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcblxuICAgICAgICAvLyBDaGFuZ2Ugc3dpcGVhYmxlIGFjY29yZGluZyB0byByZXNwb25zaXZlIHRocmVzaG9sZFxuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPiB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZVRocmVzaG9sZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zd2lwZWFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkdGFic0NvbnRlbnQgPSAkKCk7XG4gICAgICAgIHRoaXMuJHRhYkxpbmtzLmVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICB2YXIgJGN1cnJDb250ZW50ID0gJChNLmVzY2FwZUhhc2gobGluay5oYXNoKSk7XG4gICAgICAgICAgJGN1cnJDb250ZW50LmFkZENsYXNzKCdjYXJvdXNlbC1pdGVtJyk7XG4gICAgICAgICAgJHRhYnNDb250ZW50ID0gJHRhYnNDb250ZW50LmFkZCgkY3VyckNvbnRlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgJHRhYnNXcmFwcGVyID0gJCgnPGRpdiBjbGFzcz1cInRhYnMtY29udGVudCBjYXJvdXNlbCBjYXJvdXNlbC1zbGlkZXJcIj48L2Rpdj4nKTtcbiAgICAgICAgJHRhYnNDb250ZW50LmZpcnN0KCkuYmVmb3JlKCR0YWJzV3JhcHBlcik7XG4gICAgICAgICR0YWJzV3JhcHBlci5hcHBlbmQoJHRhYnNDb250ZW50KTtcbiAgICAgICAgJHRhYnNDb250ZW50WzBdLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICAvLyBLZWVwIGFjdGl2ZSB0YWIgaW5kZXggdG8gc2V0IGluaXRpYWwgY2Fyb3VzZWwgc2xpZGVcbiAgICAgICAgdmFyIGFjdGl2ZVRhYkluZGV4ID0gdGhpcy4kYWN0aXZlVGFiTGluay5jbG9zZXN0KCcudGFiJykuaW5kZXgoKTtcblxuICAgICAgICB0aGlzLl90YWJzQ2Fyb3VzZWwgPSBNLkNhcm91c2VsLmluaXQoJHRhYnNXcmFwcGVyWzBdLCB7XG4gICAgICAgICAgZnVsbFdpZHRoOiB0cnVlLFxuICAgICAgICAgIG5vV3JhcDogdHJ1ZSxcbiAgICAgICAgICBvbkN5Y2xlVG86IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gX3RoaXMyNS5pbmRleDtcbiAgICAgICAgICAgIF90aGlzMjUuaW5kZXggPSAkKGl0ZW0pLmluZGV4KCk7XG4gICAgICAgICAgICBfdGhpczI1LiRhY3RpdmVUYWJMaW5rLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIF90aGlzMjUuJGFjdGl2ZVRhYkxpbmsgPSBfdGhpczI1LiR0YWJMaW5rcy5lcShfdGhpczI1LmluZGV4KTtcbiAgICAgICAgICAgIF90aGlzMjUuJGFjdGl2ZVRhYkxpbmsuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgX3RoaXMyNS5fYW5pbWF0ZUluZGljYXRvcihwcmV2SW5kZXgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczI1Lm9wdGlvbnMub25TaG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIF90aGlzMjUub3B0aW9ucy5vblNob3cuY2FsbChfdGhpczI1LCBfdGhpczI1LiRjb250ZW50WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsIGNhcm91c2VsIHNsaWRlIHRvIGFjdGl2ZSB0YWJcbiAgICAgICAgdGhpcy5fdGFic0Nhcm91c2VsLnNldChhY3RpdmVUYWJJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gbm9ybWFsIHRhYnMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdGVhcmRvd25Td2lwZWFibGVUYWJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RlYXJkb3duU3dpcGVhYmxlVGFicygpIHtcbiAgICAgICAgdmFyICR0YWJzV3JhcHBlciA9IHRoaXMuX3RhYnNDYXJvdXNlbC4kZWw7XG4gICAgICAgIHRoaXMuX3RhYnNDYXJvdXNlbC5kZXN0cm95KCk7XG5cbiAgICAgICAgLy8gVW53cmFwXG4gICAgICAgICR0YWJzV3JhcHBlci5hZnRlcigkdGFic1dyYXBwZXIuY2hpbGRyZW4oKSk7XG4gICAgICAgICR0YWJzV3JhcHBlci5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBub3JtYWwgdGFicy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cE5vcm1hbFRhYnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBOb3JtYWxUYWJzKCkge1xuICAgICAgICAvLyBIaWRlIFRhYnMgQ29udGVudFxuICAgICAgICB0aGlzLiR0YWJMaW5rcy5ub3QodGhpcy4kYWN0aXZlVGFiTGluaykuZWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIGlmICghIWxpbmsuaGFzaCkge1xuICAgICAgICAgICAgdmFyICRjdXJyQ29udGVudCA9ICQoTS5lc2NhcGVIYXNoKGxpbmsuaGFzaCkpO1xuICAgICAgICAgICAgaWYgKCRjdXJyQ29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgJGN1cnJDb250ZW50WzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBub3JtYWwgdGFicy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl90ZWFyZG93bk5vcm1hbFRhYnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVhcmRvd25Ob3JtYWxUYWJzKCkge1xuICAgICAgICAvLyBzaG93IFRhYnMgQ29udGVudFxuICAgICAgICB0aGlzLiR0YWJMaW5rcy5lYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgaWYgKCEhbGluay5oYXNoKSB7XG4gICAgICAgICAgICB2YXIgJGN1cnJDb250ZW50ID0gJChNLmVzY2FwZUhhc2gobGluay5oYXNoKSk7XG4gICAgICAgICAgICBpZiAoJGN1cnJDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAkY3VyckNvbnRlbnRbMF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0IHRhYnMgYW5kIHRhYiB3aWR0aFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFRhYnNBbmRUYWJXaWR0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUYWJzQW5kVGFiV2lkdGgoKSB7XG4gICAgICAgIHRoaXMudGFic1dpZHRoID0gdGhpcy4kZWwud2lkdGgoKTtcbiAgICAgICAgdGhpcy50YWJXaWR0aCA9IE1hdGgubWF4KHRoaXMudGFic1dpZHRoLCB0aGlzLmVsLnNjcm9sbFdpZHRoKSAvIHRoaXMuJHRhYkxpbmtzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kcyByaWdodCBhdHRyaWJ1dGUgZm9yIGluZGljYXRvciBiYXNlZCBvbiBhY3RpdmUgdGFiLlxuICAgICAgICogQHBhcmFtIHtjYXNofSBlbFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NhbGNSaWdodFBvc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjUmlnaHRQb3MoZWwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLnRhYnNXaWR0aCAtIGVsLnBvc2l0aW9uKCkubGVmdCAtIGVsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kcyBsZWZ0IGF0dHJpYnV0ZSBmb3IgaW5kaWNhdG9yIGJhc2VkIG9uIGFjdGl2ZSB0YWIuXG4gICAgICAgKiBAcGFyYW0ge2Nhc2h9IGVsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2FsY0xlZnRQb3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY0xlZnRQb3MoZWwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZWwucG9zaXRpb24oKS5sZWZ0KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlVGFiSW5kaWNhdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGFiSW5kaWNhdG9yKCkge1xuICAgICAgICB0aGlzLl9zZXRUYWJzQW5kVGFiV2lkdGgoKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUluZGljYXRvcih0aGlzLmluZGV4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbmltYXRlcyBJbmRpY2F0b3IgdG8gYWN0aXZlIHRhYi5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcmV2SW5kZXhcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5kaWNhdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJbmRpY2F0b3IocHJldkluZGV4KSB7XG4gICAgICAgIHZhciBsZWZ0RGVsYXkgPSAwLFxuICAgICAgICAgICAgcmlnaHREZWxheSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZXggLSBwcmV2SW5kZXggPj0gMCkge1xuICAgICAgICAgIGxlZnREZWxheSA9IDkwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJpZ2h0RGVsYXkgPSA5MDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuaW1hdGVcbiAgICAgICAgdmFyIGFuaW1PcHRpb25zID0ge1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuX2luZGljYXRvcixcbiAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fY2FsY0xlZnRQb3ModGhpcy4kYWN0aXZlVGFiTGluayksXG4gICAgICAgICAgICBkZWxheTogbGVmdERlbGF5XG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2NhbGNSaWdodFBvcyh0aGlzLiRhY3RpdmVUYWJMaW5rKSxcbiAgICAgICAgICAgIGRlbGF5OiByaWdodERlbGF5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ1xuICAgICAgICB9O1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLl9pbmRpY2F0b3IpO1xuICAgICAgICBhbmltKGFuaW1PcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGFiLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRhYklkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZWxlY3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QodGFiSWQpIHtcbiAgICAgICAgdmFyIHRhYiA9IHRoaXMuJHRhYkxpbmtzLmZpbHRlcignW2hyZWY9XCIjJyArIHRhYklkICsgJ1wiXScpO1xuICAgICAgICBpZiAodGFiLmxlbmd0aCkge1xuICAgICAgICAgIHRhYi50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFRhYnMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUYWJzKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fVGFicztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUYWJzO1xuICB9KENvbXBvbmVudCk7XG5cbiAgd2luZG93Lk0uVGFicyA9IFRhYnM7XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihUYWJzLCAndGFicycsICdNX1RhYnMnKTtcbiAgfVxufSkoY2FzaCwgTS5hbmltZSk7XG47KGZ1bmN0aW9uICgkLCBhbmltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGV4aXREZWxheTogMjAwLFxuICAgIGVudGVyRGVsYXk6IDAsXG4gICAgaHRtbDogbnVsbCxcbiAgICBtYXJnaW46IDUsXG4gICAgaW5EdXJhdGlvbjogMjUwLFxuICAgIG91dER1cmF0aW9uOiAyMDAsXG4gICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgIHRyYW5zaXRpb25Nb3ZlbWVudDogMTBcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBUb29sdGlwID0gZnVuY3Rpb24gKF9Db21wb25lbnQ3KSB7XG4gICAgX2luaGVyaXRzKFRvb2x0aXAsIF9Db21wb25lbnQ3KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBUb29sdGlwIGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcChlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgICB2YXIgX3RoaXMyNiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUb29sdGlwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVG9vbHRpcCkpLmNhbGwodGhpcywgVG9vbHRpcCwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMyNi5lbC5NX1Rvb2x0aXAgPSBfdGhpczI2O1xuICAgICAgX3RoaXMyNi5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICBfdGhpczI2LmlzT3BlbiA9IGZhbHNlO1xuICAgICAgX3RoaXMyNi5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzMjYuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICBfdGhpczI2Ll9hcHBlbmRUb29sdGlwRWwoKTtcbiAgICAgIF90aGlzMjYuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgcmV0dXJuIF90aGlzMjY7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAkKHRoaXMudG9vbHRpcEVsKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmVsLk1fVG9vbHRpcCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FwcGVuZFRvb2x0aXBFbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRUb29sdGlwRWwoKSB7XG4gICAgICAgIHZhciB0b29sdGlwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQoJ21hdGVyaWFsLXRvb2x0aXAnKTtcbiAgICAgICAgdGhpcy50b29sdGlwRWwgPSB0b29sdGlwRWw7XG5cbiAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcENvbnRlbnRFbC5jbGFzc0xpc3QuYWRkKCd0b29sdGlwLWNvbnRlbnQnKTtcbiAgICAgICAgdG9vbHRpcENvbnRlbnRFbC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuaHRtbDtcbiAgICAgICAgdG9vbHRpcEVsLmFwcGVuZENoaWxkKHRvb2x0aXBDb250ZW50RWwpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXBFbCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl91cGRhdGVUb29sdGlwQ29udGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVUb29sdGlwQ29udGVudCgpIHtcbiAgICAgICAgdGhpcy50b29sdGlwRWwucXVlcnlTZWxlY3RvcignLnRvb2x0aXAtY29udGVudCcpLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5odG1sO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VFbnRlckJvdW5kID0gdGhpcy5faGFuZGxlTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlQm91bmQgPSB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUZvY3VzQm91bmQgPSB0aGlzLl9oYW5kbGVGb2N1cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVCbHVyQm91bmQgPSB0aGlzLl9oYW5kbGVCbHVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX2hhbmRsZU1vdXNlRW50ZXJCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZU1vdXNlTGVhdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVGb2N1c0JvdW5kLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlQmx1ckJvdW5kLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5faGFuZGxlTW91c2VFbnRlckJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5faGFuZGxlTW91c2VMZWF2ZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2hhbmRsZUZvY3VzQm91bmQsIHRydWUpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9oYW5kbGVCbHVyQm91bmQsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvcGVuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3Blbihpc01hbnVhbCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXNNYW51YWwgPSBpc01hbnVhbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHVuZGVmaW5lZDsgLy8gRGVmYXVsdCB2YWx1ZSB0cnVlXG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgLy8gVXBkYXRlIHRvb2x0aXAgY29udGVudCB3aXRoIEhUTUwgYXR0cmlidXRlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgdGhpcy5fZ2V0QXR0cmlidXRlT3B0aW9ucygpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVG9vbHRpcENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5fc2V0RW50ZXJEZWxheVRpbWVvdXQoaXNNYW51YWwpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2V0RXhpdERlbGF5VGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aW1lb3V0IHdoaWNoIGRlbGF5cyB3aGVuIHRoZSB0b29sdGlwIGNsb3Nlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldEV4aXREZWxheVRpbWVvdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0RXhpdERlbGF5VGltZW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzMjcgPSB0aGlzO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9leGl0RGVsYXlUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLl9leGl0RGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMjcuaXNIb3ZlcmVkIHx8IF90aGlzMjcuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMyNy5fYW5pbWF0ZU91dCgpO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZXhpdERlbGF5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGltZW91dCB3aGljaCBkZWxheXMgd2hlbiB0aGUgdG9hc3QgY2xvc2VzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0RW50ZXJEZWxheVRpbWVvdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0RW50ZXJEZWxheVRpbWVvdXQoaXNNYW51YWwpIHtcbiAgICAgICAgdmFyIF90aGlzMjggPSB0aGlzO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9lbnRlckRlbGF5VGltZW91dCk7XG5cbiAgICAgICAgdGhpcy5fZW50ZXJEZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzMjguaXNIb3ZlcmVkICYmICFfdGhpczI4LmlzRm9jdXNlZCAmJiAhaXNNYW51YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczI4Ll9hbmltYXRlSW4oKTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmVudGVyRGVsYXkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcG9zaXRpb25Ub29sdGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uVG9vbHRpcCgpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuZWwsXG4gICAgICAgICAgICB0b29sdGlwID0gdGhpcy50b29sdGlwRWwsXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPSBvcmlnaW4ub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgb3JpZ2luV2lkdGggPSBvcmlnaW4ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICB0b29sdGlwSGVpZ2h0ID0gdG9vbHRpcC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICB0b29sdGlwV2lkdGggPSB0b29sdGlwLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgbmV3Q29vcmRpbmF0ZXMgPSB2b2lkIDAsXG4gICAgICAgICAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luLFxuICAgICAgICAgICAgdGFyZ2V0VG9wID0gdm9pZCAwLFxuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IHZvaWQgMDtcblxuICAgICAgICB0aGlzLnhNb3ZlbWVudCA9IDAsIHRoaXMueU1vdmVtZW50ID0gMDtcblxuICAgICAgICB0YXJnZXRUb3AgPSBvcmlnaW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgTS5nZXREb2N1bWVudFNjcm9sbFRvcCgpO1xuICAgICAgICB0YXJnZXRMZWZ0ID0gb3JpZ2luLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBNLmdldERvY3VtZW50U2Nyb2xsTGVmdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgdGFyZ2V0VG9wICs9IC10b29sdGlwSGVpZ2h0IC0gbWFyZ2luO1xuICAgICAgICAgIHRhcmdldExlZnQgKz0gb3JpZ2luV2lkdGggLyAyIC0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgICAgICAgICB0aGlzLnlNb3ZlbWVudCA9IC10aGlzLm9wdGlvbnMudHJhbnNpdGlvbk1vdmVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRhcmdldFRvcCArPSBvcmlnaW5IZWlnaHQgLyAyIC0gdG9vbHRpcEhlaWdodCAvIDI7XG4gICAgICAgICAgdGFyZ2V0TGVmdCArPSBvcmlnaW5XaWR0aCArIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLnhNb3ZlbWVudCA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9uTW92ZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0YXJnZXRUb3AgKz0gb3JpZ2luSGVpZ2h0IC8gMiAtIHRvb2x0aXBIZWlnaHQgLyAyO1xuICAgICAgICAgIHRhcmdldExlZnQgKz0gLXRvb2x0aXBXaWR0aCAtIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLnhNb3ZlbWVudCA9IC10aGlzLm9wdGlvbnMudHJhbnNpdGlvbk1vdmVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFRvcCArPSBvcmlnaW5IZWlnaHQgKyBtYXJnaW47XG4gICAgICAgICAgdGFyZ2V0TGVmdCArPSBvcmlnaW5XaWR0aCAvIDIgLSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICAgIHRoaXMueU1vdmVtZW50ID0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb25Nb3ZlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0Nvb3JkaW5hdGVzID0gdGhpcy5fcmVwb3NpdGlvbldpdGhpblNjcmVlbih0YXJnZXRMZWZ0LCB0YXJnZXRUb3AsIHRvb2x0aXBXaWR0aCwgdG9vbHRpcEhlaWdodCk7XG4gICAgICAgICQodG9vbHRpcCkuY3NzKHtcbiAgICAgICAgICB0b3A6IG5ld0Nvb3JkaW5hdGVzLnkgKyAncHgnLFxuICAgICAgICAgIGxlZnQ6IG5ld0Nvb3JkaW5hdGVzLnggKyAncHgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVwb3NpdGlvbldpdGhpblNjcmVlblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBvc2l0aW9uV2l0aGluU2NyZWVuKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBNLmdldERvY3VtZW50U2Nyb2xsTGVmdCgpO1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gTS5nZXREb2N1bWVudFNjcm9sbFRvcCgpO1xuICAgICAgICB2YXIgbmV3WCA9IHggLSBzY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgbmV3WSA9IHkgLSBzY3JvbGxUb3A7XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nID0ge1xuICAgICAgICAgIGxlZnQ6IG5ld1gsXG4gICAgICAgICAgdG9wOiBuZXdZLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9wdGlvbnMubWFyZ2luICsgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25Nb3ZlbWVudDtcbiAgICAgICAgdmFyIGVkZ2VzID0gTS5jaGVja1dpdGhpbkNvbnRhaW5lcihkb2N1bWVudC5ib2R5LCBib3VuZGluZywgb2Zmc2V0KTtcblxuICAgICAgICBpZiAoZWRnZXMubGVmdCkge1xuICAgICAgICAgIG5ld1ggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMucmlnaHQpIHtcbiAgICAgICAgICBuZXdYIC09IG5ld1ggKyB3aWR0aCAtIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2VzLnRvcCkge1xuICAgICAgICAgIG5ld1kgPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMuYm90dG9tKSB7XG4gICAgICAgICAgbmV3WSAtPSBuZXdZICsgaGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBuZXdYICsgc2Nyb2xsTGVmdCxcbiAgICAgICAgICB5OiBuZXdZICsgc2Nyb2xsVG9wXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZUluKCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgdGhpcy50b29sdGlwRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy50b29sdGlwRWwpO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLnRvb2x0aXBFbCxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IHRoaXMueE1vdmVtZW50LFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IHRoaXMueU1vdmVtZW50LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuaW5EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0Q3ViaWMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3V0KCkge1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLnRvb2x0aXBFbCk7XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMudG9vbHRpcEVsLFxuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEN1YmljJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1vdXNlRW50ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VFbnRlcigpIHtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlOyAvLyBBbGxvd3MgY2xvc2Ugb2YgdG9vbHRpcCB3aGVuIG9wZW5lZCBieSBmb2N1cy5cbiAgICAgICAgdGhpcy5vcGVuKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1vdXNlTGVhdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTsgLy8gQWxsb3dzIGNsb3NlIG9mIHRvb2x0aXAgd2hlbiBvcGVuZWQgYnkgZm9jdXMuXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUZvY3VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUZvY3VzKCkge1xuICAgICAgICBpZiAoTS50YWJQcmVzc2VkKSB7XG4gICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMub3BlbihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUJsdXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQmx1cigpIHtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0QXR0cmlidXRlT3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVPcHRpb25zKCkge1xuICAgICAgICB2YXIgYXR0cmlidXRlT3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgdG9vbHRpcFRleHRPcHRpb24gPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwJyk7XG4gICAgICAgIHZhciBwb3NpdGlvbk9wdGlvbiA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXBvc2l0aW9uJyk7XG5cbiAgICAgICAgaWYgKHRvb2x0aXBUZXh0T3B0aW9uKSB7XG4gICAgICAgICAgYXR0cmlidXRlT3B0aW9ucy5odG1sID0gdG9vbHRpcFRleHRPcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb25PcHRpb24pIHtcbiAgICAgICAgICBhdHRyaWJ1dGVPcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb25PcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU9wdGlvbnM7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFRvb2x0aXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUb29sdGlwKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fVG9vbHRpcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUb29sdGlwO1xuICB9KENvbXBvbmVudCk7XG5cbiAgTS5Ub29sdGlwID0gVG9vbHRpcDtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKFRvb2x0aXAsICd0b29sdGlwJywgJ01fVG9vbHRpcCcpO1xuICB9XG59KShjYXNoLCBNLmFuaW1lKTtcbjsgLyohXHJcbiAgKiBXYXZlcyB2MC42LjRcclxuICAqIGh0dHA6Ly9maWFuLm15LmlkL1dhdmVzXHJcbiAgKlxyXG4gICogQ29weXJpZ2h0IDIwMTQgQWxmaWFuYSBFLiBTaWJ1ZWEgYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xyXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vZmlhbnMvV2F2ZXMvYmxvYi9tYXN0ZXIvTElDRU5TRVxyXG4gICovXG5cbjsoZnVuY3Rpb24gKHdpbmRvdykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFdhdmVzID0gV2F2ZXMgfHwge307XG4gIHZhciAkJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwuYmluZChkb2N1bWVudCk7XG5cbiAgLy8gRmluZCBleGFjdCBwb3NpdGlvbiBvZiBlbGVtZW50XG4gIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93KGVsZW0pIHtcbiAgICByZXR1cm4gaXNXaW5kb3coZWxlbSkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0KGVsZW0pIHtcbiAgICB2YXIgZG9jRWxlbSxcbiAgICAgICAgd2luLFxuICAgICAgICBib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuICAgICAgICBkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgaWYgKHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gdHlwZW9mIHVuZGVmaW5lZCkge1xuICAgICAgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgd2luID0gZ2V0V2luZG93KGRvYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuICAgICAgbGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFN0eWxlKG9iaikge1xuICAgIHZhciBzdHlsZSA9ICcnO1xuXG4gICAgZm9yICh2YXIgYSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoYSkpIHtcbiAgICAgICAgc3R5bGUgKz0gYSArICc6JyArIG9ialthXSArICc7JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICB2YXIgRWZmZWN0ID0ge1xuXG4gICAgLy8gRWZmZWN0IGRlbGF5XG4gICAgZHVyYXRpb246IDc1MCxcblxuICAgIHNob3c6IGZ1bmN0aW9uIChlLCBlbGVtZW50KSB7XG5cbiAgICAgIC8vIERpc2FibGUgcmlnaHQgY2xpY2tcbiAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbCA9IGVsZW1lbnQgfHwgdGhpcztcblxuICAgICAgLy8gQ3JlYXRlIHJpcHBsZVxuICAgICAgdmFyIHJpcHBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmlwcGxlLmNsYXNzTmFtZSA9ICd3YXZlcy1yaXBwbGUnO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQocmlwcGxlKTtcblxuICAgICAgLy8gR2V0IGNsaWNrIGNvb3JkaW5hdGUgYW5kIGVsZW1lbnQgd2l0ZGhcbiAgICAgIHZhciBwb3MgPSBvZmZzZXQoZWwpO1xuICAgICAgdmFyIHJlbGF0aXZlWSA9IGUucGFnZVkgLSBwb3MudG9wO1xuICAgICAgdmFyIHJlbGF0aXZlWCA9IGUucGFnZVggLSBwb3MubGVmdDtcbiAgICAgIHZhciBzY2FsZSA9ICdzY2FsZSgnICsgZWwuY2xpZW50V2lkdGggLyAxMDAgKiAxMCArICcpJztcblxuICAgICAgLy8gU3VwcG9ydCBmb3IgdG91Y2ggZGV2aWNlc1xuICAgICAgaWYgKCd0b3VjaGVzJyBpbiBlKSB7XG4gICAgICAgIHJlbGF0aXZlWSA9IGUudG91Y2hlc1swXS5wYWdlWSAtIHBvcy50b3A7XG4gICAgICAgIHJlbGF0aXZlWCA9IGUudG91Y2hlc1swXS5wYWdlWCAtIHBvcy5sZWZ0O1xuICAgICAgfVxuXG4gICAgICAvLyBBdHRhY2ggZGF0YSB0byBlbGVtZW50XG4gICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdkYXRhLWhvbGQnLCBEYXRlLm5vdygpKTtcbiAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2NhbGUnLCBzY2FsZSk7XG4gICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdkYXRhLXgnLCByZWxhdGl2ZVgpO1xuICAgICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnZGF0YS15JywgcmVsYXRpdmVZKTtcblxuICAgICAgLy8gU2V0IHJpcHBsZSBwb3NpdGlvblxuICAgICAgdmFyIHJpcHBsZVN0eWxlID0ge1xuICAgICAgICAndG9wJzogcmVsYXRpdmVZICsgJ3B4JyxcbiAgICAgICAgJ2xlZnQnOiByZWxhdGl2ZVggKyAncHgnXG4gICAgICB9O1xuXG4gICAgICByaXBwbGUuY2xhc3NOYW1lID0gcmlwcGxlLmNsYXNzTmFtZSArICcgd2F2ZXMtbm90cmFuc2l0aW9uJztcbiAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgY29udmVydFN0eWxlKHJpcHBsZVN0eWxlKSk7XG4gICAgICByaXBwbGUuY2xhc3NOYW1lID0gcmlwcGxlLmNsYXNzTmFtZS5yZXBsYWNlKCd3YXZlcy1ub3RyYW5zaXRpb24nLCAnJyk7XG5cbiAgICAgIC8vIFNjYWxlIHRoZSByaXBwbGVcbiAgICAgIHJpcHBsZVN0eWxlWyctd2Via2l0LXRyYW5zZm9ybSddID0gc2NhbGU7XG4gICAgICByaXBwbGVTdHlsZVsnLW1vei10cmFuc2Zvcm0nXSA9IHNjYWxlO1xuICAgICAgcmlwcGxlU3R5bGVbJy1tcy10cmFuc2Zvcm0nXSA9IHNjYWxlO1xuICAgICAgcmlwcGxlU3R5bGVbJy1vLXRyYW5zZm9ybSddID0gc2NhbGU7XG4gICAgICByaXBwbGVTdHlsZS50cmFuc2Zvcm0gPSBzY2FsZTtcbiAgICAgIHJpcHBsZVN0eWxlLm9wYWNpdHkgPSAnMSc7XG5cbiAgICAgIHJpcHBsZVN0eWxlWyctd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb24nXSA9IEVmZmVjdC5kdXJhdGlvbiArICdtcyc7XG4gICAgICByaXBwbGVTdHlsZVsnLW1vei10cmFuc2l0aW9uLWR1cmF0aW9uJ10gPSBFZmZlY3QuZHVyYXRpb24gKyAnbXMnO1xuICAgICAgcmlwcGxlU3R5bGVbJy1vLXRyYW5zaXRpb24tZHVyYXRpb24nXSA9IEVmZmVjdC5kdXJhdGlvbiArICdtcyc7XG4gICAgICByaXBwbGVTdHlsZVsndHJhbnNpdGlvbi1kdXJhdGlvbiddID0gRWZmZWN0LmR1cmF0aW9uICsgJ21zJztcblxuICAgICAgcmlwcGxlU3R5bGVbJy13ZWJraXQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXSA9ICdjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApJztcbiAgICAgIHJpcHBsZVN0eWxlWyctbW96LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSAnY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSc7XG4gICAgICByaXBwbGVTdHlsZVsnLW8tdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXSA9ICdjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApJztcbiAgICAgIHJpcHBsZVN0eWxlWyd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddID0gJ2N1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCknO1xuXG4gICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIGNvbnZlcnRTdHlsZShyaXBwbGVTdHlsZSkpO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgVG91Y2hIYW5kbGVyLnRvdWNodXAoZSk7XG5cbiAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aCAqIDEuNDtcblxuICAgICAgLy8gR2V0IGZpcnN0IHJpcHBsZVxuICAgICAgdmFyIHJpcHBsZSA9IG51bGw7XG4gICAgICB2YXIgcmlwcGxlcyA9IGVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3dhdmVzLXJpcHBsZScpO1xuICAgICAgaWYgKHJpcHBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByaXBwbGUgPSByaXBwbGVzW3JpcHBsZXMubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGl2ZVggPSByaXBwbGUuZ2V0QXR0cmlidXRlKCdkYXRhLXgnKTtcbiAgICAgIHZhciByZWxhdGl2ZVkgPSByaXBwbGUuZ2V0QXR0cmlidXRlKCdkYXRhLXknKTtcbiAgICAgIHZhciBzY2FsZSA9IHJpcHBsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2NhbGUnKTtcblxuICAgICAgLy8gR2V0IGRlbGF5IGJlZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2UgbGVhdmVcbiAgICAgIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIE51bWJlcihyaXBwbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhvbGQnKSk7XG4gICAgICB2YXIgZGVsYXkgPSAzNTAgLSBkaWZmO1xuXG4gICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gRmFkZSBvdXQgcmlwcGxlIGFmdGVyIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICd0b3AnOiByZWxhdGl2ZVkgKyAncHgnLFxuICAgICAgICAgICdsZWZ0JzogcmVsYXRpdmVYICsgJ3B4JyxcbiAgICAgICAgICAnb3BhY2l0eSc6ICcwJyxcblxuICAgICAgICAgIC8vIER1cmF0aW9uXG4gICAgICAgICAgJy13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvbic6IEVmZmVjdC5kdXJhdGlvbiArICdtcycsXG4gICAgICAgICAgJy1tb3otdHJhbnNpdGlvbi1kdXJhdGlvbic6IEVmZmVjdC5kdXJhdGlvbiArICdtcycsXG4gICAgICAgICAgJy1vLXRyYW5zaXRpb24tZHVyYXRpb24nOiBFZmZlY3QuZHVyYXRpb24gKyAnbXMnLFxuICAgICAgICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogRWZmZWN0LmR1cmF0aW9uICsgJ21zJyxcbiAgICAgICAgICAnLXdlYmtpdC10cmFuc2Zvcm0nOiBzY2FsZSxcbiAgICAgICAgICAnLW1vei10cmFuc2Zvcm0nOiBzY2FsZSxcbiAgICAgICAgICAnLW1zLXRyYW5zZm9ybSc6IHNjYWxlLFxuICAgICAgICAgICctby10cmFuc2Zvcm0nOiBzY2FsZSxcbiAgICAgICAgICAndHJhbnNmb3JtJzogc2NhbGVcbiAgICAgICAgfTtcblxuICAgICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIGNvbnZlcnRTdHlsZShzdHlsZSkpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChyaXBwbGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIEVmZmVjdC5kdXJhdGlvbik7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSxcblxuICAgIC8vIExpdHRsZSBoYWNrIHRvIG1ha2UgPGlucHV0PiBjYW4gcGVyZm9ybSB3YXZlcyBlZmZlY3RcbiAgICB3cmFwSW5wdXQ6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlbGVtZW50cy5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgZWwgPSBlbGVtZW50c1thXTtcblxuICAgICAgICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAvLyBJZiBpbnB1dCBhbHJlYWR5IGhhdmUgcGFyZW50IGp1c3QgcGFzcyB0aHJvdWdoXG4gICAgICAgICAgaWYgKHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpJyAmJiBwYXJlbnQuY2xhc3NOYW1lLmluZGV4T2YoJ3dhdmVzLWVmZmVjdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHV0IGVsZW1lbnQgY2xhc3MgYW5kIHN0eWxlIHRvIHRoZSBzcGVjaWZpZWQgcGFyZW50XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG4gICAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUgKyAnIHdhdmVzLWlucHV0LXdyYXBwZXInO1xuXG4gICAgICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgIGlmICghZWxlbWVudFN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGUgPSAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBlbGVtZW50U3R5bGUpO1xuXG4gICAgICAgICAgZWwuY2xhc3NOYW1lID0gJ3dhdmVzLWJ1dHRvbi1pbnB1dCc7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgLy8gUHV0IGVsZW1lbnQgYXMgY2hpbGRcbiAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHdyYXBwZXIsIGVsKTtcbiAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcclxuICAgKiBEaXNhYmxlIG1vdXNlZG93biBldmVudCBmb3IgNTAwbXMgZHVyaW5nIGFuZCBhZnRlciB0b3VjaFxyXG4gICAqL1xuICB2YXIgVG91Y2hIYW5kbGVyID0ge1xuICAgIC8qIHVzZXMgYW4gaW50ZWdlciByYXRoZXIgdGhhbiBib29sIHNvIHRoZXJlJ3Mgbm8gaXNzdWVzIHdpdGhcclxuICAgICAqIG5lZWRpbmcgdG8gY2xlYXIgdGltZW91dHMgaWYgYW5vdGhlciB0b3VjaCBldmVudCBvY2N1cnJlZFxyXG4gICAgICogd2l0aGluIHRoZSA1MDBtcy4gQ2Fubm90IG1vdXNldXAgYmV0d2VlbiB0b3VjaHN0YXJ0IGFuZFxyXG4gICAgICogdG91Y2hlbmQsIG5vciBpbiB0aGUgNTAwbXMgYWZ0ZXIgdG91Y2hlbmQuICovXG4gICAgdG91Y2hlczogMCxcbiAgICBhbGxvd0V2ZW50OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGFsbG93ID0gdHJ1ZTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIFRvdWNoSGFuZGxlci50b3VjaGVzICs9IDE7IC8vcHVzaFxuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcgfHwgZS50eXBlID09PSAndG91Y2hjYW5jZWwnKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChUb3VjaEhhbmRsZXIudG91Y2hlcyA+IDApIHtcbiAgICAgICAgICAgIFRvdWNoSGFuZGxlci50b3VjaGVzIC09IDE7IC8vcG9wIGFmdGVyIDUwMG1zXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nICYmIFRvdWNoSGFuZGxlci50b3VjaGVzID4gMCkge1xuICAgICAgICBhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsb3c7XG4gICAgfSxcbiAgICB0b3VjaHVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgVG91Y2hIYW5kbGVyLmFsbG93RXZlbnQoZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxyXG4gICAqIERlbGVnYXRlZCBjbGljayBoYW5kbGVyIGZvciAud2F2ZXMtZWZmZWN0IGVsZW1lbnQuXHJcbiAgICogcmV0dXJucyBudWxsIHdoZW4gLndhdmVzLWVmZmVjdCBlbGVtZW50IG5vdCBpbiBcImNsaWNrIHRyZWVcIlxyXG4gICAqL1xuICBmdW5jdGlvbiBnZXRXYXZlc0VmZmVjdEVsZW1lbnQoZSkge1xuICAgIGlmIChUb3VjaEhhbmRsZXIuYWxsb3dFdmVudChlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG4gICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3dhdmVzLWVmZmVjdCcpICE9PSAtMSkge1xuICAgICAgICBlbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEJ1YmJsZSB0aGUgY2xpY2sgYW5kIHNob3cgZWZmZWN0IGlmIC53YXZlcy1lZmZlY3QgZWxlbSB3YXMgZm91bmRcclxuICAgKi9cbiAgZnVuY3Rpb24gc2hvd0VmZmVjdChlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBnZXRXYXZlc0VmZmVjdEVsZW1lbnQoZSk7XG5cbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgRWZmZWN0LnNob3coZSwgZWxlbWVudCk7XG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIEVmZmVjdC5oaWRlLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBFZmZlY3QuaGlkZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBFZmZlY3QuaGlkZSwgZmFsc2UpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgRWZmZWN0LmhpZGUsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIEVmZmVjdC5oaWRlLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgV2F2ZXMuZGlzcGxheUVmZmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoJ2R1cmF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICBFZmZlY3QuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vV3JhcCBpbnB1dCBpbnNpZGUgPGk+IHRhZ1xuICAgIEVmZmVjdC53cmFwSW5wdXQoJCQoJy53YXZlcy1lZmZlY3QnKSk7XG5cbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBzaG93RWZmZWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzaG93RWZmZWN0LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXHJcbiAgICogQXR0YWNoIFdhdmVzIHRvIGFuIGlucHV0IGVsZW1lbnQgKG9yIGFueSBlbGVtZW50IHdoaWNoIGRvZXNuJ3RcclxuICAgKiBidWJibGUgbW91c2V1cC9tb3VzZWRvd24gZXZlbnRzKS5cclxuICAgKiAgIEludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCBkeW5hbWljYWxseSBsb2FkZWQgZm9ybXMvaW5wdXRzLCBvclxyXG4gICAqIHdoZXJlIHRoZSB1c2VyIGRvZXNuJ3Qgd2FudCBhIGRlbGVnYXRlZCBjbGljayBoYW5kbGVyLlxyXG4gICAqL1xuICBXYXZlcy5hdHRhY2ggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vRlVUVVJFOiBhdXRvbWF0aWNhbGx5IGFkZCB3YXZlcyBjbGFzc2VzIGFuZCBhbGxvdyB1c2Vyc1xuICAgIC8vIHRvIHNwZWNpZnkgdGhlbSB3aXRoIGFuIG9wdGlvbnMgcGFyYW0/IEVnLiBsaWdodC9jbGFzc2ljL2J1dHRvblxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgRWZmZWN0LndyYXBJbnB1dChbZWxlbWVudF0pO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBzaG93RWZmZWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzaG93RWZmZWN0LCBmYWxzZSk7XG4gIH07XG5cbiAgd2luZG93LldhdmVzID0gV2F2ZXM7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBXYXZlcy5kaXNwbGF5RWZmZWN0KCk7XG4gIH0sIGZhbHNlKTtcbn0pKHdpbmRvdyk7XG47KGZ1bmN0aW9uICgkLCBhbmltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGh0bWw6ICcnLFxuICAgIGRpc3BsYXlMZW5ndGg6IDQwMDAsXG4gICAgaW5EdXJhdGlvbjogMzAwLFxuICAgIG91dER1cmF0aW9uOiAzNzUsXG4gICAgY2xhc3NlczogJycsXG4gICAgY29tcGxldGVDYWxsYmFjazogbnVsbCxcbiAgICBhY3RpdmF0aW9uUGVyY2VudDogMC44XG4gIH07XG5cbiAgdmFyIFRvYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0KG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2FzdCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIHRvYXN0XG4gICAgICAgKiBAbWVtYmVyIFRvYXN0I29wdGlvbnNcbiAgICAgICAqL1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvYXN0LmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMub3B0aW9ucy5odG1sO1xuXG4gICAgICAvKipcbiAgICAgICAqIERlc2NyaWJlcyBjdXJyZW50IHBhbiBzdGF0ZSB0b2FzdFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRoaXMucGFubmluZyA9IGZhbHNlO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRpbWUgcmVtYWluaW5nIHVudGlsIHRvYXN0IGlzIHJlbW92ZWRcbiAgICAgICAqL1xuICAgICAgdGhpcy50aW1lUmVtYWluaW5nID0gdGhpcy5vcHRpb25zLmRpc3BsYXlMZW5ndGg7XG5cbiAgICAgIGlmIChUb2FzdC5fdG9hc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBUb2FzdC5fY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgdG9hc3RcbiAgICAgIFRvYXN0Ll90b2FzdHMucHVzaCh0aGlzKTtcbiAgICAgIHZhciB0b2FzdEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVUb2FzdCgpO1xuICAgICAgdG9hc3RFbGVtZW50Lk1fVG9hc3QgPSB0aGlzO1xuICAgICAgdGhpcy5lbCA9IHRvYXN0RWxlbWVudDtcbiAgICAgIHRoaXMuJGVsID0gJCh0b2FzdEVsZW1lbnQpO1xuICAgICAgdGhpcy5fYW5pbWF0ZUluKCk7XG4gICAgICB0aGlzLl9zZXRUaW1lcigpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUb2FzdCwgW3tcbiAgICAgIGtleTogXCJfY3JlYXRlVG9hc3RcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0b2FzdCBhbmQgYXBwZW5kIGl0IHRvIHRvYXN0IGNvbnRhaW5lclxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVRvYXN0KCkge1xuICAgICAgICB2YXIgdG9hc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9hc3QuY2xhc3NMaXN0LmFkZCgndG9hc3QnKTtcblxuICAgICAgICAvLyBBZGQgY3VzdG9tIGNsYXNzZXMgb250byB0b2FzdFxuICAgICAgICBpZiAoISF0aGlzLm9wdGlvbnMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAkKHRvYXN0KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3Nlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgY29udGVudFxuICAgICAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0JyA/IHRoaXMubWVzc2FnZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogdGhpcy5tZXNzYWdlICYmIHR5cGVvZiB0aGlzLm1lc3NhZ2UgPT09ICdvYmplY3QnICYmIHRoaXMubWVzc2FnZSAhPT0gbnVsbCAmJiB0aGlzLm1lc3NhZ2Uubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIHRoaXMubWVzc2FnZS5ub2RlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0b2FzdC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgalF1ZXJ5IG9iamVjdFxuICAgICAgICB9IGVsc2UgaWYgKCEhdGhpcy5tZXNzYWdlLmpxdWVyeSkge1xuICAgICAgICAgICQodG9hc3QpLmFwcGVuZCh0aGlzLm1lc3NhZ2VbMF0pO1xuXG4gICAgICAgICAgLy8gSW5zZXJ0IGFzIGh0bWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9hc3QuaW5uZXJIVE1MID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvYXNmdFxuICAgICAgICBUb2FzdC5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRvYXN0KTtcbiAgICAgICAgcmV0dXJuIHRvYXN0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgaW4gdG9hc3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZUluKCkge1xuICAgICAgICAvLyBBbmltYXRlIHRvYXN0IGluXG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuZWwsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5pbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYydcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHNldEludGVydmFsIHdoaWNoIGF1dG9tYXRpY2FsbHkgcmVtb3ZlcyB0b2FzdCB3aGVuIHRpbWVSZW1haW5pbmcgPj0gMFxuICAgICAgICogaGFzIGJlZW4gcmVhY2hlZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFRpbWVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFRpbWVyKCkge1xuICAgICAgICB2YXIgX3RoaXMyOSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMudGltZVJlbWFpbmluZyAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB0aGlzLmNvdW50ZXJJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRvYXN0IGlzIG5vdCBiZWluZyBkcmFnZ2VkLCBkZWNyZWFzZSBpdHMgdGltZSByZW1haW5pbmdcbiAgICAgICAgICAgIGlmICghX3RoaXMyOS5wYW5uaW5nKSB7XG4gICAgICAgICAgICAgIF90aGlzMjkudGltZVJlbWFpbmluZyAtPSAyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQW5pbWF0ZSB0b2FzdCBvdXRcbiAgICAgICAgICAgIGlmIChfdGhpczI5LnRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICBfdGhpczI5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNtaXNzIHRvYXN0IHdpdGggYW5pbWF0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNtaXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzbWlzcygpIHtcbiAgICAgICAgdmFyIF90aGlzMzAgPSB0aGlzO1xuXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuY291bnRlckludGVydmFsKTtcbiAgICAgICAgdmFyIGFjdGl2YXRpb25EaXN0YW5jZSA9IHRoaXMuZWwub2Zmc2V0V2lkdGggKiB0aGlzLm9wdGlvbnMuYWN0aXZhdGlvblBlcmNlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMud2FzU3dpcGVkKSB7XG4gICAgICAgICAgdGhpcy5lbC5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAuMDVzLCBvcGFjaXR5IC4wNXMnO1xuICAgICAgICAgIHRoaXMuZWwuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVYKFwiICsgYWN0aXZhdGlvbkRpc3RhbmNlICsgXCJweClcIjtcbiAgICAgICAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbSh7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy5lbCxcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIG1hcmdpblRvcDogLTQwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEV4cG8nLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBvcHRpb25hbCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczMwLm9wdGlvbnMuY29tcGxldGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczMwLm9wdGlvbnMuY29tcGxldGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRvYXN0IGZyb20gRE9NXG4gICAgICAgICAgICBfdGhpczMwLiRlbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIFRvYXN0Ll90b2FzdHMuc3BsaWNlKFRvYXN0Ll90b2FzdHMuaW5kZXhPZihfdGhpczMwKSwgMSk7XG4gICAgICAgICAgICBpZiAoVG9hc3QuX3RvYXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgVG9hc3QuX3JlbW92ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fVG9hc3Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQXBwZW5kIHRvYXN0IGNvbnRhaW5lciBhbmQgYWRkIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlQ29udGFpbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICd0b2FzdC1jb250YWluZXInKTtcblxuICAgICAgICAvLyBBZGQgZXZlbnQgaGFuZGxlclxuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIFRvYXN0Ll9vbkRyYWdTdGFydCk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBUb2FzdC5fb25EcmFnTW92ZSk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIFRvYXN0Ll9vbkRyYWdFbmQpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBUb2FzdC5fb25EcmFnU3RhcnQpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBUb2FzdC5fb25EcmFnTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBUb2FzdC5fb25EcmFnRW5kKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIFRvYXN0Ll9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRvYXN0IGNvbnRhaW5lciBhbmQgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVDb250YWluZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlQ29udGFpbmVyKCkge1xuICAgICAgICAvLyBBZGQgZXZlbnQgaGFuZGxlclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBUb2FzdC5fb25EcmFnTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBUb2FzdC5fb25EcmFnRW5kKTtcblxuICAgICAgICAkKFRvYXN0Ll9jb250YWluZXIpLnJlbW92ZSgpO1xuICAgICAgICBUb2FzdC5fY29udGFpbmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBCZWdpbiBkcmFnIGhhbmRsZXJcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9vbkRyYWdTdGFydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCAmJiAkKGUudGFyZ2V0KS5jbG9zZXN0KCcudG9hc3QnKS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgJHRvYXN0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLnRvYXN0Jyk7XG4gICAgICAgICAgdmFyIHRvYXN0ID0gJHRvYXN0WzBdLk1fVG9hc3Q7XG4gICAgICAgICAgdG9hc3QucGFubmluZyA9IHRydWU7XG4gICAgICAgICAgVG9hc3QuX2RyYWdnZWRUb2FzdCA9IHRvYXN0O1xuICAgICAgICAgIHRvYXN0LmVsLmNsYXNzTGlzdC5hZGQoJ3Bhbm5pbmcnKTtcbiAgICAgICAgICB0b2FzdC5lbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICAgICAgdG9hc3Quc3RhcnRpbmdYUG9zID0gVG9hc3QuX3hQb3MoZSk7XG4gICAgICAgICAgdG9hc3QudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgdG9hc3QueFBvcyA9IFRvYXN0Ll94UG9zKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRHJhZyBtb3ZlIGhhbmRsZXJcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9vbkRyYWdNb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ01vdmUoZSkge1xuICAgICAgICBpZiAoISFUb2FzdC5fZHJhZ2dlZFRvYXN0KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciB0b2FzdCA9IFRvYXN0Ll9kcmFnZ2VkVG9hc3Q7XG4gICAgICAgICAgdG9hc3QuZGVsdGFYID0gTWF0aC5hYnModG9hc3QueFBvcyAtIFRvYXN0Ll94UG9zKGUpKTtcbiAgICAgICAgICB0b2FzdC54UG9zID0gVG9hc3QuX3hQb3MoZSk7XG4gICAgICAgICAgdG9hc3QudmVsb2NpdHlYID0gdG9hc3QuZGVsdGFYIC8gKERhdGUubm93KCkgLSB0b2FzdC50aW1lKTtcbiAgICAgICAgICB0b2FzdC50aW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgIHZhciB0b3RhbERlbHRhWCA9IHRvYXN0LnhQb3MgLSB0b2FzdC5zdGFydGluZ1hQb3M7XG4gICAgICAgICAgdmFyIGFjdGl2YXRpb25EaXN0YW5jZSA9IHRvYXN0LmVsLm9mZnNldFdpZHRoICogdG9hc3Qub3B0aW9ucy5hY3RpdmF0aW9uUGVyY2VudDtcbiAgICAgICAgICB0b2FzdC5lbC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVgoXCIgKyB0b3RhbERlbHRhWCArIFwicHgpXCI7XG4gICAgICAgICAgdG9hc3QuZWwuc3R5bGUub3BhY2l0eSA9IDEgLSBNYXRoLmFicyh0b3RhbERlbHRhWCAvIGFjdGl2YXRpb25EaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmQgZHJhZyBoYW5kbGVyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfb25EcmFnRW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ0VuZCgpIHtcbiAgICAgICAgaWYgKCEhVG9hc3QuX2RyYWdnZWRUb2FzdCkge1xuICAgICAgICAgIHZhciB0b2FzdCA9IFRvYXN0Ll9kcmFnZ2VkVG9hc3Q7XG4gICAgICAgICAgdG9hc3QucGFubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRvYXN0LmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Bhbm5pbmcnKTtcblxuICAgICAgICAgIHZhciB0b3RhbERlbHRhWCA9IHRvYXN0LnhQb3MgLSB0b2FzdC5zdGFydGluZ1hQb3M7XG4gICAgICAgICAgdmFyIGFjdGl2YXRpb25EaXN0YW5jZSA9IHRvYXN0LmVsLm9mZnNldFdpZHRoICogdG9hc3Qub3B0aW9ucy5hY3RpdmF0aW9uUGVyY2VudDtcbiAgICAgICAgICB2YXIgc2hvdWxkQmVEaXNtaXNzZWQgPSBNYXRoLmFicyh0b3RhbERlbHRhWCkgPiBhY3RpdmF0aW9uRGlzdGFuY2UgfHwgdG9hc3QudmVsb2NpdHlYID4gMTtcblxuICAgICAgICAgIC8vIFJlbW92ZSB0b2FzdFxuICAgICAgICAgIGlmIChzaG91bGRCZURpc21pc3NlZCkge1xuICAgICAgICAgICAgdG9hc3Qud2FzU3dpcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRvYXN0LmRpc21pc3MoKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0ZSB0b2FzdCBiYWNrIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvYXN0LmVsLnN0eWxlLnRyYW5zaXRpb24gPSAndHJhbnNmb3JtIC4ycywgb3BhY2l0eSAuMnMnO1xuICAgICAgICAgICAgdG9hc3QuZWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgICAgICB0b2FzdC5lbC5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRvYXN0Ll9kcmFnZ2VkVG9hc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHggcG9zaXRpb24gb2YgbW91c2Ugb3IgdG91Y2ggZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl94UG9zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3hQb3MoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3VzZSBldmVudFxuICAgICAgICByZXR1cm4gZS5jbGllbnRYO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgdG9hc3RzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNtaXNzQWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzbWlzc0FsbCgpIHtcbiAgICAgICAgZm9yICh2YXIgdG9hc3RJbmRleCBpbiBUb2FzdC5fdG9hc3RzKSB7XG4gICAgICAgICAgVG9hc3QuX3RvYXN0c1t0b2FzdEluZGV4XS5kaXNtaXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUb2FzdDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBUb2FzdFxuICAgKiBAdHlwZSB7QXJyYXkuPFRvYXN0Pn1cbiAgICovXG5cblxuICBUb2FzdC5fdG9hc3RzID0gW107XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFRvYXN0XG4gICAqL1xuICBUb2FzdC5fY29udGFpbmVyID0gbnVsbDtcblxuICAvKipcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgVG9hc3RcbiAgICogQHR5cGUge1RvYXN0fVxuICAgKi9cbiAgVG9hc3QuX2RyYWdnZWRUb2FzdCA9IG51bGw7XG5cbiAgTS5Ub2FzdCA9IFRvYXN0O1xuICBNLnRvYXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRvYXN0KG9wdGlvbnMpO1xuICB9O1xufSkoY2FzaCwgTS5hbmltZSk7XG47KGZ1bmN0aW9uICgkLCBhbmltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGVkZ2U6ICdsZWZ0JyxcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgaW5EdXJhdGlvbjogMjUwLFxuICAgIG91dER1cmF0aW9uOiAyMDAsXG4gICAgb25PcGVuU3RhcnQ6IG51bGwsXG4gICAgb25PcGVuRW5kOiBudWxsLFxuICAgIG9uQ2xvc2VTdGFydDogbnVsbCxcbiAgICBvbkNsb3NlRW5kOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxpbmc6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqL1xuXG4gIHZhciBTaWRlbmF2ID0gZnVuY3Rpb24gKF9Db21wb25lbnQ4KSB7XG4gICAgX2luaGVyaXRzKFNpZGVuYXYsIF9Db21wb25lbnQ4KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBTaWRlbmF2IGluc3RhbmNlIGFuZCBzZXQgdXAgb3ZlcmxheVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZGVuYXYoZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWRlbmF2KTtcblxuICAgICAgdmFyIF90aGlzMzEgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2lkZW5hdi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNpZGVuYXYpKS5jYWxsKHRoaXMsIFNpZGVuYXYsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzMzEuZWwuTV9TaWRlbmF2ID0gX3RoaXMzMTtcbiAgICAgIF90aGlzMzEuaWQgPSBfdGhpczMxLiRlbC5hdHRyKCdpZCcpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBTaWRlbmF2XG4gICAgICAgKiBAbWVtYmVyIFNpZGVuYXYjb3B0aW9uc1xuICAgICAgICogQHByb3Age1N0cmluZ30gW2VkZ2U9J2xlZnQnXSAtIFNpZGUgb2Ygc2NyZWVuIG9uIHdoaWNoIFNpZGVuYXYgYXBwZWFyc1xuICAgICAgICogQHByb3Age0Jvb2xlYW59IFtkcmFnZ2FibGU9dHJ1ZV0gLSBBbGxvdyBzd2lwZSBnZXN0dXJlcyB0byBvcGVuL2Nsb3NlIFNpZGVuYXZcbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IFtpbkR1cmF0aW9uPTI1MF0gLSBMZW5ndGggaW4gbXMgb2YgZW50ZXIgdHJhbnNpdGlvblxuICAgICAgICogQHByb3Age051bWJlcn0gW291dER1cmF0aW9uPTIwMF0gLSBMZW5ndGggaW4gbXMgb2YgZXhpdCB0cmFuc2l0aW9uXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uT3BlblN0YXJ0IC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gc2lkZW5hdiBzdGFydHMgZW50ZXJpbmdcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25PcGVuRW5kIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gc2lkZW5hdiBmaW5pc2hlcyBlbnRlcmluZ1xuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbkNsb3NlU3RhcnQgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiBzaWRlbmF2IHN0YXJ0cyBleGl0aW5nXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uQ2xvc2VFbmQgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiBzaWRlbmF2IGZpbmlzaGVzIGV4aXRpbmdcbiAgICAgICAqL1xuICAgICAgX3RoaXMzMS5vcHRpb25zID0gJC5leHRlbmQoe30sIFNpZGVuYXYuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIERlc2NyaWJlcyBvcGVuL2Nsb3NlIHN0YXRlIG9mIFNpZGVuYXZcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpczMxLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAvKipcbiAgICAgICAqIERlc2NyaWJlcyBpZiBTaWRlbmF2IGlzIGZpeGVkXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3RoaXMzMS5pc0ZpeGVkID0gX3RoaXMzMS5lbC5jbGFzc0xpc3QuY29udGFpbnMoJ3NpZGVuYXYtZml4ZWQnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNjcmliZXMgaWYgU2lkZW5hdiBpcyBiZWluZyBkcmFnZ2VlZFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90aGlzMzEuaXNEcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIFdpbmRvdyBzaXplIHZhcmlhYmxlcyBmb3Igd2luZG93IHJlc2l6ZSBjaGVja3NcbiAgICAgIF90aGlzMzEubGFzdFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBfdGhpczMxLmxhc3RXaW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIF90aGlzMzEuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgIF90aGlzMzEuX2NyZWF0ZURyYWdUYXJnZXQoKTtcbiAgICAgIF90aGlzMzEuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgX3RoaXMzMS5fc2V0dXBDbGFzc2VzKCk7XG4gICAgICBfdGhpczMxLl9zZXR1cEZpeGVkKCk7XG5cbiAgICAgIFNpZGVuYXYuX3NpZGVuYXZzLnB1c2goX3RoaXMzMSk7XG4gICAgICByZXR1cm4gX3RoaXMzMTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2lkZW5hdiwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlQm9keVNjcm9sbGluZygpO1xuICAgICAgICB0aGlzLl9vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fb3ZlcmxheSk7XG4gICAgICAgIHRoaXMuZHJhZ1RhcmdldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZHJhZ1RhcmdldCk7XG4gICAgICAgIHRoaXMuZWwuTV9TaWRlbmF2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuXG4gICAgICAgIHZhciBpbmRleCA9IFNpZGVuYXYuX3NpZGVuYXZzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgU2lkZW5hdi5fc2lkZW5hdnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlT3ZlcmxheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVPdmVybGF5KCkge1xuICAgICAgICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9jbG9zZUJvdW5kID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3NpZGVuYXYtb3ZlcmxheScpO1xuXG4gICAgICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbG9zZUJvdW5kKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXkpO1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmIChTaWRlbmF2Ll9zaWRlbmF2cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlVHJpZ2dlckNsaWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hhbmRsZURyYWdUYXJnZXREcmFnQm91bmQgPSB0aGlzLl9oYW5kbGVEcmFnVGFyZ2V0RHJhZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVEcmFnVGFyZ2V0UmVsZWFzZUJvdW5kID0gdGhpcy5faGFuZGxlRHJhZ1RhcmdldFJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xvc2VEcmFnQm91bmQgPSB0aGlzLl9oYW5kbGVDbG9zZURyYWcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xvc2VSZWxlYXNlQm91bmQgPSB0aGlzLl9oYW5kbGVDbG9zZVJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xvc2VUcmlnZ2VyQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUNsb3NlVHJpZ2dlckNsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5kcmFnVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZURyYWdUYXJnZXREcmFnQm91bmQpO1xuICAgICAgICB0aGlzLmRyYWdUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVEcmFnVGFyZ2V0UmVsZWFzZUJvdW5kKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVDbG9zZURyYWdCb3VuZCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVDbG9zZVJlbGVhc2VCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlQ2xvc2VEcmFnQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlQ2xvc2VSZWxlYXNlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xvc2VUcmlnZ2VyQ2xpY2tCb3VuZCk7XG5cbiAgICAgICAgLy8gQWRkIHJlc2l6ZSBmb3Igc2lkZSBuYXYgZml4ZWRcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZUJvdW5kID0gdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZUJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoU2lkZW5hdi5fc2lkZW5hdnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZVRyaWdnZXJDbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRHJhZ1RhcmdldERyYWdCb3VuZCk7XG4gICAgICAgIHRoaXMuZHJhZ1RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZURyYWdUYXJnZXRSZWxlYXNlQm91bmQpO1xuICAgICAgICB0aGlzLl9vdmVybGF5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUNsb3NlRHJhZ0JvdW5kKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZUNsb3NlUmVsZWFzZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVDbG9zZURyYWdCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVDbG9zZVJlbGVhc2VCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDbG9zZVRyaWdnZXJDbGlja0JvdW5kKTtcblxuICAgICAgICAvLyBSZW1vdmUgcmVzaXplIGZvciBzaWRlIG5hdiBmaXhlZFxuICAgICAgICBpZiAodGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZUJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBUcmlnZ2VyIENsaWNrXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlVHJpZ2dlckNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRyaWdnZXJDbGljayhlKSB7XG4gICAgICAgIHZhciAkdHJpZ2dlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5zaWRlbmF2LXRyaWdnZXInKTtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICYmICR0cmlnZ2VyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzaWRlbmF2SWQgPSBNLmdldElkRnJvbVRyaWdnZXIoJHRyaWdnZXJbMF0pO1xuXG4gICAgICAgICAgdmFyIHNpZGVuYXZJbnN0YW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNpZGVuYXZJZCkuTV9TaWRlbmF2O1xuICAgICAgICAgIGlmIChzaWRlbmF2SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHNpZGVuYXZJbnN0YW5jZS5vcGVuKCR0cmlnZ2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHZhcmlhYmxlcyBuZWVkZWQgYXQgdGhlIGJlZ2dpbmluZyBvZiBkcmFnXG4gICAgICAgKiBhbmQgc3RvcCBhbnkgY3VycmVudCB0cmFuc2l0aW9uLlxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3N0YXJ0RHJhZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydERyYWcoZSkge1xuICAgICAgICB2YXIgY2xpZW50WCA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB0aGlzLmlzRHJhZ2dlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3N0YXJ0aW5nWHBvcyA9IGNsaWVudFg7XG4gICAgICAgIHRoaXMuX3hQb3MgPSB0aGlzLl9zdGFydGluZ1hwb3M7XG4gICAgICAgIHRoaXMuX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIHRoaXMuX292ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTY3JvbGxUb3AgPSB0aGlzLmlzT3BlbiA/IHRoaXMuZWwuc2Nyb2xsVG9wIDogTS5nZXREb2N1bWVudFNjcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbGx5U2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLl9vdmVybGF5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdmFyaWFibGVzIG5lZWRlZCBhdCBlYWNoIGRyYWcgbW92ZSB1cGRhdGUgdGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2RyYWdNb3ZlVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdNb3ZlVXBkYXRlKGUpIHtcbiAgICAgICAgdmFyIGNsaWVudFggPSBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxUb3AgPSB0aGlzLmlzT3BlbiA/IHRoaXMuZWwuc2Nyb2xsVG9wIDogTS5nZXREb2N1bWVudFNjcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLmRlbHRhWCA9IE1hdGguYWJzKHRoaXMuX3hQb3MgLSBjbGllbnRYKTtcbiAgICAgICAgdGhpcy5feFBvcyA9IGNsaWVudFg7XG4gICAgICAgIHRoaXMudmVsb2NpdHlYID0gdGhpcy5kZWx0YVggLyAoRGF0ZS5ub3coKSAtIHRoaXMuX3RpbWUpO1xuICAgICAgICB0aGlzLl90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxTY3JvbGxUb3AgIT09IGN1cnJlbnRTY3JvbGxUb3ApIHtcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNhbGx5U2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXMgRHJhZ2dpbmcgb2YgU2lkZW5hdlxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZURyYWdUYXJnZXREcmFnXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURyYWdUYXJnZXREcmFnKGUpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZHJhZ2dhYmxlXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRyYWdnYWJsZSB8fCB0aGlzLl9pc0N1cnJlbnRseUZpeGVkKCkgfHwgdGhpcy5fdmVydGljYWxseVNjcm9sbGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vdCBiZWluZyBkcmFnZ2VkLCBzZXQgaW5pdGlhbCBkcmFnIHN0YXJ0IHZhcmlhYmxlc1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2VkKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnREcmFnKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVuIHRvdWNobW92ZSB1cGRhdGVzXG4gICAgICAgIHRoaXMuX2RyYWdNb3ZlVXBkYXRlKGUpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSByYXcgZGVsdGFYXG4gICAgICAgIHZhciB0b3RhbERlbHRhWCA9IHRoaXMuX3hQb3MgLSB0aGlzLl9zdGFydGluZ1hwb3M7XG5cbiAgICAgICAgLy8gZHJhZ0RpcmVjdGlvbiBpcyB0aGUgYXR0ZW1wdGVkIHVzZXIgZHJhZyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGRyYWdEaXJlY3Rpb24gPSB0b3RhbERlbHRhWCA+IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gICAgICAgIC8vIERvbid0IGFsbG93IHRvdGFsRGVsdGFYIHRvIGV4Y2VlZCBTaWRlbmF2IHdpZHRoIG9yIGJlIGRyYWdnZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICB0b3RhbERlbHRhWCA9IE1hdGgubWluKHRoaXMuX3dpZHRoLCBNYXRoLmFicyh0b3RhbERlbHRhWCkpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkZ2UgPT09IGRyYWdEaXJlY3Rpb24pIHtcbiAgICAgICAgICB0b3RhbERlbHRhWCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogdHJhbnNmb3JtWCBpcyB0aGUgZHJhZyBkaXNwbGFjZW1lbnRcbiAgICAgICAgICogdHJhbnNmb3JtUHJlZml4IGlzIHRoZSBpbml0aWFsIHRyYW5zZm9ybSBwbGFjZW1lbnRcbiAgICAgICAgICogSW52ZXJ0IHZhbHVlcyBpZiBTaWRlbmF2IGlzIHJpZ2h0IGVkZ2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0cmFuc2Zvcm1YID0gdG90YWxEZWx0YVg7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1QcmVmaXggPSAndHJhbnNsYXRlWCgtMTAwJSknO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkZ2UgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1QcmVmaXggPSAndHJhbnNsYXRlWCgxMDAlKSc7XG4gICAgICAgICAgdHJhbnNmb3JtWCA9IC10cmFuc2Zvcm1YO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9wZW4vY2xvc2UgcGVyY2VudGFnZSBvZiBzaWRlbmF2LCB3aXRoIG9wZW4gPSAxIGFuZCBjbG9zZSA9IDBcbiAgICAgICAgdGhpcy5wZXJjZW50T3BlbiA9IE1hdGgubWluKDEsIHRvdGFsRGVsdGFYIC8gdGhpcy5fd2lkdGgpO1xuXG4gICAgICAgIC8vIFNldCB0cmFuc2Zvcm0gYW5kIG9wYWNpdHkgc3R5bGVzXG4gICAgICAgIHRoaXMuZWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtUHJlZml4ICsgXCIgdHJhbnNsYXRlWChcIiArIHRyYW5zZm9ybVggKyBcInB4KVwiO1xuICAgICAgICB0aGlzLl9vdmVybGF5LnN0eWxlLm9wYWNpdHkgPSB0aGlzLnBlcmNlbnRPcGVuO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBEcmFnIFRhcmdldCBSZWxlYXNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRHJhZ1RhcmdldFJlbGVhc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRHJhZ1RhcmdldFJlbGVhc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dlZCkge1xuICAgICAgICAgIGlmICh0aGlzLnBlcmNlbnRPcGVuID4gMC4yKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZU91dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaXNEcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fdmVydGljYWxseVNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIENsb3NlIERyYWdcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDbG9zZURyYWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xvc2VEcmFnKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZHJhZ2dhYmxlXG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlIHx8IHRoaXMuX2lzQ3VycmVudGx5Rml4ZWQoKSB8fCB0aGlzLl92ZXJ0aWNhbGx5U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgbm90IGJlaW5nIGRyYWdnZWQsIHNldCBpbml0aWFsIGRyYWcgc3RhcnQgdmFyaWFibGVzXG4gICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnREcmFnKGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJ1biB0b3VjaG1vdmUgdXBkYXRlc1xuICAgICAgICAgIHRoaXMuX2RyYWdNb3ZlVXBkYXRlKGUpO1xuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHJhdyBkZWx0YVhcbiAgICAgICAgICB2YXIgdG90YWxEZWx0YVggPSB0aGlzLl94UG9zIC0gdGhpcy5fc3RhcnRpbmdYcG9zO1xuXG4gICAgICAgICAgLy8gZHJhZ0RpcmVjdGlvbiBpcyB0aGUgYXR0ZW1wdGVkIHVzZXIgZHJhZyBkaXJlY3Rpb25cbiAgICAgICAgICB2YXIgZHJhZ0RpcmVjdGlvbiA9IHRvdGFsRGVsdGFYID4gMCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyB0b3RhbERlbHRhWCB0byBleGNlZWQgU2lkZW5hdiB3aWR0aCBvciBiZSBkcmFnZ2VkIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICB0b3RhbERlbHRhWCA9IE1hdGgubWluKHRoaXMuX3dpZHRoLCBNYXRoLmFicyh0b3RhbERlbHRhWCkpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRnZSAhPT0gZHJhZ0RpcmVjdGlvbikge1xuICAgICAgICAgICAgdG90YWxEZWx0YVggPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0cmFuc2Zvcm1YID0gLXRvdGFsRGVsdGFYO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRnZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdHJhbnNmb3JtWCA9IC10cmFuc2Zvcm1YO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBvcGVuL2Nsb3NlIHBlcmNlbnRhZ2Ugb2Ygc2lkZW5hdiwgd2l0aCBvcGVuID0gMSBhbmQgY2xvc2UgPSAwXG4gICAgICAgICAgdGhpcy5wZXJjZW50T3BlbiA9IE1hdGgubWluKDEsIDEgLSB0b3RhbERlbHRhWCAvIHRoaXMuX3dpZHRoKTtcblxuICAgICAgICAgIC8vIFNldCB0cmFuc2Zvcm0gYW5kIG9wYWNpdHkgc3R5bGVzXG4gICAgICAgICAgdGhpcy5lbC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVgoXCIgKyB0cmFuc2Zvcm1YICsgXCJweClcIjtcbiAgICAgICAgICB0aGlzLl9vdmVybGF5LnN0eWxlLm9wYWNpdHkgPSB0aGlzLnBlcmNlbnRPcGVuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIENsb3NlIFJlbGVhc2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDbG9zZVJlbGVhc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xvc2VSZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgdGhpcy5pc0RyYWdnZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5wZXJjZW50T3BlbiA+IDAuOCkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUluKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmlzRHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX3ZlcnRpY2FsbHlTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXMgY2xvc2luZyBvZiBTaWRlbmF2IHdoZW4gZWxlbWVudCB3aXRoIGNsYXNzIC5zaWRlbmF2LWNsb3NlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ2xvc2VUcmlnZ2VyQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xvc2VUcmlnZ2VyQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGNsb3NlVHJpZ2dlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5zaWRlbmF2LWNsb3NlJyk7XG4gICAgICAgIGlmICgkY2xvc2VUcmlnZ2VyLmxlbmd0aCAmJiAhdGhpcy5faXNDdXJyZW50bHlGaXhlZCgpKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFdpbmRvdyBSZXNpemVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVXaW5kb3dSZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgICAgICAvLyBPbmx5IGhhbmRsZSBob3Jpem9udGFsIHJlc2l6ZXNcbiAgICAgICAgaWYgKHRoaXMubGFzdFdpbmRvd1dpZHRoICE9PSB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDk5Mikge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB0aGlzLmxhc3RXaW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cENsYXNzZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkZ2UgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3JpZ2h0LWFsaWduZWQnKTtcbiAgICAgICAgICB0aGlzLmRyYWdUYXJnZXQuY2xhc3NMaXN0LmFkZCgncmlnaHQtYWxpZ25lZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVDbGFzc2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUNsYXNzZXMoKSB7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgncmlnaHQtYWxpZ25lZCcpO1xuICAgICAgICB0aGlzLmRyYWdUYXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgncmlnaHQtYWxpZ25lZCcpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBGaXhlZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEZpeGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlGaXhlZCgpKSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2lzQ3VycmVudGx5Rml4ZWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDdXJyZW50bHlGaXhlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaXhlZCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IDk5MjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NyZWF0ZURyYWdUYXJnZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRHJhZ1RhcmdldCgpIHtcbiAgICAgICAgdmFyIGRyYWdUYXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZHJhZ1RhcmdldC5jbGFzc0xpc3QuYWRkKCdkcmFnLXRhcmdldCcpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyYWdUYXJnZXQpO1xuICAgICAgICB0aGlzLmRyYWdUYXJnZXQgPSBkcmFnVGFyZ2V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcHJldmVudEJvZHlTY3JvbGxpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJldmVudEJvZHlTY3JvbGxpbmcoKSB7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZW5hYmxlQm9keVNjcm9sbGluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbmFibGVCb2R5U2Nyb2xsaW5nKCkge1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3BlblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBSdW4gb25PcGVuU3RhcnQgY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25PcGVuU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25PcGVuU3RhcnQuY2FsbCh0aGlzLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBmaXhlZCBTaWRlbmF2XG4gICAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseUZpeGVkKCkpIHtcbiAgICAgICAgICBhbmltLnJlbW92ZSh0aGlzLmVsKTtcbiAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZWwsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9lbmFibGVCb2R5U2Nyb2xsaW5nKCk7XG4gICAgICAgICAgdGhpcy5fb3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIG5vbi1maXhlZCBTaWRlbmF2XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Qm9keVNjcm9sbGluZygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnZWQgfHwgdGhpcy5wZXJjZW50T3BlbiAhPSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlSW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUnVuIG9uQ2xvc2VTdGFydCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbG9zZVN0YXJ0LmNhbGwodGhpcywgdGhpcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgZml4ZWQgU2lkZW5hdlxuICAgICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlGaXhlZCgpKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybVggPSB0aGlzLm9wdGlvbnMuZWRnZSA9PT0gJ2xlZnQnID8gJy0xMDUlJyA6ICcxMDUlJztcbiAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWChcIiArIHRyYW5zZm9ybVggKyBcIilcIjtcblxuICAgICAgICAgIC8vIEhhbmRsZSBub24tZml4ZWQgU2lkZW5hdlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZUJvZHlTY3JvbGxpbmcoKTtcblxuICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnZWQgfHwgdGhpcy5wZXJjZW50T3BlbiAhPSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlT3V0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FuaW1hdGVJblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlSW4oKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVTaWRlbmF2SW4oKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZU92ZXJsYXlJbigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZVNpZGVuYXZJblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlU2lkZW5hdkluKCkge1xuICAgICAgICB2YXIgX3RoaXMzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNsaWRlT3V0UGVyY2VudCA9IHRoaXMub3B0aW9ucy5lZGdlID09PSAnbGVmdCcgPyAtMSA6IDE7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dlZCkge1xuICAgICAgICAgIHNsaWRlT3V0UGVyY2VudCA9IHRoaXMub3B0aW9ucy5lZGdlID09PSAnbGVmdCcgPyBzbGlkZU91dFBlcmNlbnQgKyB0aGlzLnBlcmNlbnRPcGVuIDogc2xpZGVPdXRQZXJjZW50IC0gdGhpcy5wZXJjZW50T3BlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLmVsLFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IFtzbGlkZU91dFBlcmNlbnQgKiAxMDAgKyBcIiVcIiwgMF0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5pbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUnVuIG9uT3BlbkVuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczMyLm9wdGlvbnMub25PcGVuRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIF90aGlzMzIub3B0aW9ucy5vbk9wZW5FbmQuY2FsbChfdGhpczMyLCBfdGhpczMyLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU92ZXJsYXlJblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3ZlcmxheUluKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnZWQpIHtcbiAgICAgICAgICBzdGFydCA9IHRoaXMucGVyY2VudE9wZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCh0aGlzLl9vdmVybGF5KS5jc3Moe1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy5fb3ZlcmxheSk7XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuX292ZXJsYXksXG4gICAgICAgICAgb3BhY2l0eTogW3N0YXJ0LCAxXSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmluRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3V0KCkge1xuICAgICAgICB0aGlzLl9hbmltYXRlU2lkZW5hdk91dCgpO1xuICAgICAgICB0aGlzLl9hbmltYXRlT3ZlcmxheU91dCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZVNpZGVuYXZPdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZVNpZGVuYXZPdXQoKSB7XG4gICAgICAgIHZhciBfdGhpczMzID0gdGhpcztcblxuICAgICAgICB2YXIgZW5kUGVyY2VudCA9IHRoaXMub3B0aW9ucy5lZGdlID09PSAnbGVmdCcgPyAtMSA6IDE7XG4gICAgICAgIHZhciBzbGlkZU91dFBlcmNlbnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnZWQpIHtcbiAgICAgICAgICBzbGlkZU91dFBlcmNlbnQgPSB0aGlzLm9wdGlvbnMuZWRnZSA9PT0gJ2xlZnQnID8gZW5kUGVyY2VudCArIHRoaXMucGVyY2VudE9wZW4gOiBlbmRQZXJjZW50IC0gdGhpcy5wZXJjZW50T3BlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLmVsLFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IFtzbGlkZU91dFBlcmNlbnQgKiAxMDAgKyBcIiVcIiwgZW5kUGVyY2VudCAqIDEwNSArIFwiJVwiXSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLm91dER1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUnVuIG9uT3BlbkVuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczMzLm9wdGlvbnMub25DbG9zZUVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczMzLm9wdGlvbnMub25DbG9zZUVuZC5jYWxsKF90aGlzMzMsIF90aGlzMzMuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlT3ZlcmxheU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3ZlcmxheU91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzMzQgPSB0aGlzO1xuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuX292ZXJsYXkpO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLl9vdmVybGF5LFxuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5vdXREdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoX3RoaXMzNC5fb3ZlcmxheSkuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX2dldChTaWRlbmF2Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2lkZW5hdiksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMsIGVscywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IEluc3RhbmNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJbnN0YW5jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlKGVsKSB7XG4gICAgICAgIHZhciBkb21FbGVtID0gISFlbC5qcXVlcnkgPyBlbFswXSA6IGVsO1xuICAgICAgICByZXR1cm4gZG9tRWxlbS5NX1NpZGVuYXY7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2lkZW5hdjtcbiAgfShDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBTaWRlbmF2XG4gICAqIEB0eXBlIHtBcnJheS48U2lkZW5hdj59XG4gICAqL1xuXG5cbiAgU2lkZW5hdi5fc2lkZW5hdnMgPSBbXTtcblxuICB3aW5kb3cuTS5TaWRlbmF2ID0gU2lkZW5hdjtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKFNpZGVuYXYsICdzaWRlbmF2JywgJ01fU2lkZW5hdicpO1xuICB9XG59KShjYXNoLCBNLmFuaW1lKTtcbjsoZnVuY3Rpb24gKCQsIGFuaW0pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgdGhyb3R0bGU6IDEwMCxcbiAgICBzY3JvbGxPZmZzZXQ6IDIwMCwgLy8gb2Zmc2V0IC0gMjAwIGFsbG93cyBlbGVtZW50cyBuZWFyIGJvdHRvbSBvZiBwYWdlIHRvIHNjcm9sbFxuICAgIGFjdGl2ZUNsYXNzOiAnYWN0aXZlJyxcbiAgICBnZXRBY3RpdmVFbGVtZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiAnYVtocmVmPVwiIycgKyBpZCArICdcIl0nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBTY3JvbGxTcHkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudDkpIHtcbiAgICBfaW5oZXJpdHMoU2Nyb2xsU3B5LCBfQ29tcG9uZW50OSk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgU2Nyb2xsU3B5IGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2Nyb2xsU3B5KGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsU3B5KTtcblxuICAgICAgdmFyIF90aGlzMzUgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2Nyb2xsU3B5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsU3B5KSkuY2FsbCh0aGlzLCBTY3JvbGxTcHksIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzMzUuZWwuTV9TY3JvbGxTcHkgPSBfdGhpczM1O1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBtb2RhbFxuICAgICAgICogQG1lbWJlciBNb2RhbCNvcHRpb25zXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbdGhyb3R0bGU9MTAwXSAtIFRocm90dGxlIG9mIHNjcm9sbCBoYW5kbGVyXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbc2Nyb2xsT2Zmc2V0PTIwMF0gLSBPZmZzZXQgZm9yIGNlbnRlcmluZyBlbGVtZW50IHdoZW4gc2Nyb2xsZWQgdG9cbiAgICAgICAqIEBwcm9wIHtTdHJpbmd9IFthY3RpdmVDbGFzcz0nYWN0aXZlJ10gLSBDbGFzcyBhcHBsaWVkIHRvIGFjdGl2ZSBlbGVtZW50c1xuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBbZ2V0QWN0aXZlRWxlbWVudF0gLSBVc2VkIHRvIGZpbmQgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgX3RoaXMzNS5vcHRpb25zID0gJC5leHRlbmQoe30sIFNjcm9sbFNweS5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHNldHVwXG4gICAgICBTY3JvbGxTcHkuX2VsZW1lbnRzLnB1c2goX3RoaXMzNSk7XG4gICAgICBTY3JvbGxTcHkuX2NvdW50Kys7XG4gICAgICBTY3JvbGxTcHkuX2luY3JlbWVudCsrO1xuICAgICAgX3RoaXMzNS50aWNrSWQgPSAtMTtcbiAgICAgIF90aGlzMzUuaWQgPSBTY3JvbGxTcHkuX2luY3JlbWVudDtcbiAgICAgIF90aGlzMzUuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgX3RoaXMzNS5faGFuZGxlV2luZG93U2Nyb2xsKCk7XG4gICAgICByZXR1cm4gX3RoaXMzNTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2Nyb2xsU3B5LCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgU2Nyb2xsU3B5Ll9lbGVtZW50cy5zcGxpY2UoU2Nyb2xsU3B5Ll9lbGVtZW50cy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgU2Nyb2xsU3B5Ll9lbGVtZW50c0luVmlldy5zcGxpY2UoU2Nyb2xsU3B5Ll9lbGVtZW50c0luVmlldy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHMuc3BsaWNlKFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzLmluZGV4T2YodGhpcy4kZWwpLCAxKTtcbiAgICAgICAgU2Nyb2xsU3B5Ll9jb3VudC0tO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICQodGhpcy5vcHRpb25zLmdldEFjdGl2ZUVsZW1lbnQodGhpcy4kZWwuYXR0cignaWQnKSkpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG4gICAgICAgIHRoaXMuZWwuTV9TY3JvbGxTcHkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB2YXIgdGhyb3R0bGVkUmVzaXplID0gTS50aHJvdHRsZSh0aGlzLl9oYW5kbGVXaW5kb3dTY3JvbGwsIDIwMCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVRocm90dGxlZFJlc2l6ZUJvdW5kID0gdGhyb3R0bGVkUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVdpbmRvd1Njcm9sbEJvdW5kID0gdGhpcy5faGFuZGxlV2luZG93U2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIGlmIChTY3JvbGxTcHkuX2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZVdpbmRvd1Njcm9sbEJvdW5kKTtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5faGFuZGxlVGhyb3R0bGVkUmVzaXplQm91bmQpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVUcmlnZ2VyQ2xpY2spO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoU2Nyb2xsU3B5Ll9jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9oYW5kbGVXaW5kb3dTY3JvbGxCb3VuZCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVRocm90dGxlZFJlc2l6ZUJvdW5kKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlVHJpZ2dlckNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBUcmlnZ2VyIENsaWNrXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlVHJpZ2dlckNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRyaWdnZXJDbGljayhlKSB7XG4gICAgICAgIHZhciAkdHJpZ2dlciA9ICQoZS50YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpID0gU2Nyb2xsU3B5Ll9lbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBzY3JvbGxzcHkgPSBTY3JvbGxTcHkuX2VsZW1lbnRzW2ldO1xuICAgICAgICAgIGlmICgkdHJpZ2dlci5pcygnYVtocmVmPVwiIycgKyBzY3JvbGxzcHkuJGVsLmF0dHIoJ2lkJykgKyAnXCJdJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzY3JvbGxzcHkuJGVsLm9mZnNldCgpLnRvcCArIDE7XG5cbiAgICAgICAgICAgIGFuaW0oe1xuICAgICAgICAgICAgICB0YXJnZXRzOiBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSxcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBvZmZzZXQgLSBzY3JvbGxzcHkub3B0aW9ucy5zY3JvbGxPZmZzZXQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFdpbmRvdyBTY3JvbGxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVXaW5kb3dTY3JvbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93U2Nyb2xsKCkge1xuICAgICAgICAvLyB1bmlxdWUgdGljayBpZFxuICAgICAgICBTY3JvbGxTcHkuX3RpY2tzKys7XG5cbiAgICAgICAgLy8gdmlld3BvcnQgcmVjdGFuZ2xlXG4gICAgICAgIHZhciB0b3AgPSBNLmdldERvY3VtZW50U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBsZWZ0ID0gTS5nZXREb2N1bWVudFNjcm9sbExlZnQoKSxcbiAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgYm90dG9tID0gdG9wICsgd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBlbGVtZW50cyBhcmUgaW4gdmlld1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFNjcm9sbFNweS5fZmluZEVsZW1lbnRzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzY3JvbGxzcHkgPSBpbnRlcnNlY3Rpb25zW2ldO1xuICAgICAgICAgIHZhciBsYXN0VGljayA9IHNjcm9sbHNweS50aWNrSWQ7XG4gICAgICAgICAgaWYgKGxhc3RUaWNrIDwgMCkge1xuICAgICAgICAgICAgLy8gZW50ZXJlZCBpbnRvIHZpZXdcbiAgICAgICAgICAgIHNjcm9sbHNweS5fZW50ZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGljayBpZFxuICAgICAgICAgIHNjcm9sbHNweS50aWNrSWQgPSBTY3JvbGxTcHkuX3RpY2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFNjcm9sbFNweS5fZWxlbWVudHNJblZpZXcubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9zY3JvbGxzcHkgPSBTY3JvbGxTcHkuX2VsZW1lbnRzSW5WaWV3W19pXTtcbiAgICAgICAgICB2YXIgX2xhc3RUaWNrID0gX3Njcm9sbHNweS50aWNrSWQ7XG4gICAgICAgICAgaWYgKF9sYXN0VGljayA+PSAwICYmIF9sYXN0VGljayAhPT0gU2Nyb2xsU3B5Ll90aWNrcykge1xuICAgICAgICAgICAgLy8gZXhpdGVkIGZyb20gdmlld1xuICAgICAgICAgICAgX3Njcm9sbHNweS5fZXhpdCgpO1xuICAgICAgICAgICAgX3Njcm9sbHNweS50aWNrSWQgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1lbWJlciBlbGVtZW50cyBpbiB2aWV3IGZvciBuZXh0IHRpY2tcbiAgICAgICAgU2Nyb2xsU3B5Ll9lbGVtZW50c0luVmlldyA9IGludGVyc2VjdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBlbGVtZW50cyB0aGF0IGFyZSB3aXRoaW4gdGhlIGJvdW5kYXJ5XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmlnaHRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gICAgICAgKiBAcmV0dXJuIHtBcnJheS48U2Nyb2xsU3B5Pn0gICBBIGNvbGxlY3Rpb24gb2YgZWxlbWVudHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9lbnRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnRlcigpIHtcbiAgICAgICAgU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHMgPSBTY3JvbGxTcHkuX3Zpc2libGVFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmhlaWdodCgpICE9IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChTY3JvbGxTcHkuX3Zpc2libGVFbGVtZW50c1swXSkge1xuICAgICAgICAgICQodGhpcy5vcHRpb25zLmdldEFjdGl2ZUVsZW1lbnQoU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHNbMF0uYXR0cignaWQnKSkpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG4gICAgICAgICAgaWYgKFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzWzBdWzBdLk1fU2Nyb2xsU3B5ICYmIHRoaXMuaWQgPCBTY3JvbGxTcHkuX3Zpc2libGVFbGVtZW50c1swXVswXS5NX1Njcm9sbFNweS5pZCkge1xuICAgICAgICAgICAgU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHMudW5zaGlmdCh0aGlzLiRlbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzLnB1c2godGhpcy4kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBTY3JvbGxTcHkuX3Zpc2libGVFbGVtZW50cy5wdXNoKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcy5vcHRpb25zLmdldEFjdGl2ZUVsZW1lbnQoU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHNbMF0uYXR0cignaWQnKSkpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9leGl0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4aXQoKSB7XG4gICAgICAgIHZhciBfdGhpczM2ID0gdGhpcztcblxuICAgICAgICBTY3JvbGxTcHkuX3Zpc2libGVFbGVtZW50cyA9IFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuaGVpZ2h0KCkgIT0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzWzBdKSB7XG4gICAgICAgICAgJCh0aGlzLm9wdGlvbnMuZ2V0QWN0aXZlRWxlbWVudChTY3JvbGxTcHkuX3Zpc2libGVFbGVtZW50c1swXS5hdHRyKCdpZCcpKSkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblxuICAgICAgICAgIFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzID0gU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmF0dHIoJ2lkJykgIT0gX3RoaXMzNi4kZWwuYXR0cignaWQnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoU2Nyb2xsU3B5Ll92aXNpYmxlRWxlbWVudHNbMF0pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGVtcHR5XG4gICAgICAgICAgICAkKHRoaXMub3B0aW9ucy5nZXRBY3RpdmVFbGVtZW50KFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzWzBdLmF0dHIoJ2lkJykpKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX2dldChTY3JvbGxTcHkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGxTcHkpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9TY3JvbGxTcHk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9maW5kRWxlbWVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEVsZW1lbnRzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xuICAgICAgICB2YXIgaGl0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNjcm9sbFNweS5fZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2Nyb2xsc3B5ID0gU2Nyb2xsU3B5Ll9lbGVtZW50c1tpXTtcbiAgICAgICAgICB2YXIgY3VyclRvcCA9IHRvcCArIHNjcm9sbHNweS5vcHRpb25zLnNjcm9sbE9mZnNldCB8fCAyMDA7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsc3B5LiRlbC5oZWlnaHQoKSA+IDApIHtcbiAgICAgICAgICAgIHZhciBlbFRvcCA9IHNjcm9sbHNweS4kZWwub2Zmc2V0KCkudG9wLFxuICAgICAgICAgICAgICAgIGVsTGVmdCA9IHNjcm9sbHNweS4kZWwub2Zmc2V0KCkubGVmdCxcbiAgICAgICAgICAgICAgICBlbFJpZ2h0ID0gZWxMZWZ0ICsgc2Nyb2xsc3B5LiRlbC53aWR0aCgpLFxuICAgICAgICAgICAgICAgIGVsQm90dG9tID0gZWxUb3AgKyBzY3JvbGxzcHkuJGVsLmhlaWdodCgpO1xuXG4gICAgICAgICAgICB2YXIgaXNJbnRlcnNlY3QgPSAhKGVsTGVmdCA+IHJpZ2h0IHx8IGVsUmlnaHQgPCBsZWZ0IHx8IGVsVG9wID4gYm90dG9tIHx8IGVsQm90dG9tIDwgY3VyclRvcCk7XG5cbiAgICAgICAgICAgIGlmIChpc0ludGVyc2VjdCkge1xuICAgICAgICAgICAgICBoaXRzLnB1c2goc2Nyb2xsc3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2Nyb2xsU3B5O1xuICB9KENvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFNjcm9sbFNweVxuICAgKiBAdHlwZSB7QXJyYXkuPFNjcm9sbFNweT59XG4gICAqL1xuXG5cbiAgU2Nyb2xsU3B5Ll9lbGVtZW50cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBTY3JvbGxTcHlcbiAgICogQHR5cGUge0FycmF5LjxTY3JvbGxTcHk+fVxuICAgKi9cbiAgU2Nyb2xsU3B5Ll9lbGVtZW50c0luVmlldyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBTY3JvbGxTcHlcbiAgICogQHR5cGUge0FycmF5LjxjYXNoPn1cbiAgICovXG4gIFNjcm9sbFNweS5fdmlzaWJsZUVsZW1lbnRzID0gW107XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFNjcm9sbFNweVxuICAgKi9cbiAgU2Nyb2xsU3B5Ll9jb3VudCA9IDA7XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFNjcm9sbFNweVxuICAgKi9cbiAgU2Nyb2xsU3B5Ll9pbmNyZW1lbnQgPSAwO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBTY3JvbGxTcHlcbiAgICovXG4gIFNjcm9sbFNweS5fdGlja3MgPSAwO1xuXG4gIE0uU2Nyb2xsU3B5ID0gU2Nyb2xsU3B5O1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoU2Nyb2xsU3B5LCAnc2Nyb2xsU3B5JywgJ01fU2Nyb2xsU3B5Jyk7XG4gIH1cbn0pKGNhc2gsIE0uYW5pbWUpO1xuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBkYXRhOiB7fSwgLy8gQXV0b2NvbXBsZXRlIGRhdGEgc2V0XG4gICAgbGltaXQ6IEluZmluaXR5LCAvLyBMaW1pdCBvZiByZXN1bHRzIHRoZSBhdXRvY29tcGxldGUgc2hvd3NcbiAgICBvbkF1dG9jb21wbGV0ZTogbnVsbCwgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gYXV0b2NvbXBsZXRlZFxuICAgIG1pbkxlbmd0aDogMSwgLy8gTWluIGNoYXJhY3RlcnMgYmVmb3JlIGF1dG9jb21wbGV0ZSBzdGFydHNcbiAgICBzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChhLCBiLCBpbnB1dFN0cmluZykge1xuICAgICAgLy8gU29ydCBmdW5jdGlvbiBmb3Igc29ydGluZyBhdXRvY29tcGxldGUgcmVzdWx0c1xuICAgICAgcmV0dXJuIGEuaW5kZXhPZihpbnB1dFN0cmluZykgLSBiLmluZGV4T2YoaW5wdXRTdHJpbmcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBBdXRvY29tcGxldGUgPSBmdW5jdGlvbiAoX0NvbXBvbmVudDEwKSB7XG4gICAgX2luaGVyaXRzKEF1dG9jb21wbGV0ZSwgX0NvbXBvbmVudDEwKTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBBdXRvY29tcGxldGUgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdXRvY29tcGxldGUoZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRvY29tcGxldGUpO1xuXG4gICAgICB2YXIgX3RoaXMzNyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBdXRvY29tcGxldGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBdXRvY29tcGxldGUpKS5jYWxsKHRoaXMsIEF1dG9jb21wbGV0ZSwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMzNy5lbC5NX0F1dG9jb21wbGV0ZSA9IF90aGlzMzc7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIGF1dG9jb21wbGV0ZVxuICAgICAgICogQG1lbWJlciBBdXRvY29tcGxldGUjb3B0aW9uc1xuICAgICAgICogQHByb3Age051bWJlcn0gZHVyYXRpb25cbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IGRpc3RcbiAgICAgICAqIEBwcm9wIHtudW1iZXJ9IHNoaWZ0XG4gICAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZnVsbFdpZHRoXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gaW5kaWNhdG9yc1xuICAgICAgICogQHByb3Age0Jvb2xlYW59IG5vV3JhcFxuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbkN5Y2xlVG9cbiAgICAgICAqL1xuICAgICAgX3RoaXMzNy5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9jb21wbGV0ZS5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldHVwXG4gICAgICBfdGhpczM3LmlzT3BlbiA9IGZhbHNlO1xuICAgICAgX3RoaXMzNy5jb3VudCA9IDA7XG4gICAgICBfdGhpczM3LmFjdGl2ZUluZGV4ID0gLTE7XG4gICAgICBfdGhpczM3Lm9sZFZhbDtcbiAgICAgIF90aGlzMzcuJGlucHV0RmllbGQgPSBfdGhpczM3LiRlbC5jbG9zZXN0KCcuaW5wdXQtZmllbGQnKTtcbiAgICAgIF90aGlzMzcuJGFjdGl2ZSA9ICQoKTtcbiAgICAgIF90aGlzMzcuX21vdXNlZG93biA9IGZhbHNlO1xuICAgICAgX3RoaXMzNy5fc2V0dXBEcm9wZG93bigpO1xuXG4gICAgICBfdGhpczM3Ll9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczM3O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBdXRvY29tcGxldGUsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZURyb3Bkb3duKCk7XG4gICAgICAgIHRoaXMuZWwuTV9BdXRvY29tcGxldGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dEJsdXJCb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0Qmx1ci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dEtleXVwQW5kRm9jdXNCb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0S2V5dXBBbmRGb2N1cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dEtleWRvd25Cb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVJbnB1dENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNvbnRhaW5lck1vdXNlZG93bkFuZFRvdWNoc3RhcnRCb3VuZCA9IHRoaXMuX2hhbmRsZUNvbnRhaW5lck1vdXNlZG93bkFuZFRvdWNoc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ29udGFpbmVyTW91c2V1cEFuZFRvdWNoZW5kQm91bmQgPSB0aGlzLl9oYW5kbGVDb250YWluZXJNb3VzZXVwQW5kVG91Y2hlbmQuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9oYW5kbGVJbnB1dEJsdXJCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9oYW5kbGVJbnB1dEtleXVwQW5kRm9jdXNCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVJbnB1dEtleXVwQW5kRm9jdXNCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZUNvbnRhaW5lck1vdXNlZG93bkFuZFRvdWNoc3RhcnRCb3VuZCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVDb250YWluZXJNb3VzZXVwQW5kVG91Y2hlbmRCb3VuZCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVDb250YWluZXJNb3VzZWRvd25BbmRUb3VjaHN0YXJ0Qm91bmQpO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlQ29udGFpbmVyTW91c2V1cEFuZFRvdWNoZW5kQm91bmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9oYW5kbGVJbnB1dEJsdXJCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9oYW5kbGVJbnB1dEtleXVwQW5kRm9jdXNCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVJbnB1dEtleXVwQW5kRm9jdXNCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZUNvbnRhaW5lck1vdXNlZG93bkFuZFRvdWNoc3RhcnRCb3VuZCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVDb250YWluZXJNb3VzZXVwQW5kVG91Y2hlbmRCb3VuZCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVDb250YWluZXJNb3VzZWRvd25BbmRUb3VjaHN0YXJ0Qm91bmQpO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlQ29udGFpbmVyTW91c2V1cEFuZFRvdWNoZW5kQm91bmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cERyb3Bkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRHJvcGRvd24oKSB7XG4gICAgICAgIHZhciBfdGhpczM4ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlkID0gXCJhdXRvY29tcGxldGUtb3B0aW9ucy1cIiArIE0uZ3VpZCgpO1xuICAgICAgICAkKHRoaXMuY29udGFpbmVyKS5hZGRDbGFzcygnYXV0b2NvbXBsZXRlLWNvbnRlbnQgZHJvcGRvd24tY29udGVudCcpO1xuICAgICAgICB0aGlzLiRpbnB1dEZpZWxkLmFwcGVuZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcsIHRoaXMuY29udGFpbmVyLmlkKTtcblxuICAgICAgICB0aGlzLmRyb3Bkb3duID0gTS5Ecm9wZG93bi5pbml0KHRoaXMuZWwsIHtcbiAgICAgICAgICBhdXRvRm9jdXM6IGZhbHNlLFxuICAgICAgICAgIGNsb3NlT25DbGljazogZmFsc2UsXG4gICAgICAgICAgY292ZXJUcmlnZ2VyOiBmYWxzZSxcbiAgICAgICAgICBvbkl0ZW1DbGljazogZnVuY3Rpb24gKGl0ZW1FbCkge1xuICAgICAgICAgICAgX3RoaXMzOC5zZWxlY3RPcHRpb24oJChpdGVtRWwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNrZXRjaHkgcmVtb3ZhbCBvZiBkcm9wZG93biBjbGljayBoYW5kbGVyXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmRyb3Bkb3duLl9oYW5kbGVDbGlja0JvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVEcm9wZG93bigpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIElucHV0IEJsdXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnB1dEJsdXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRCbHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21vdXNlZG93bikge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLl9yZXNldEF1dG9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIElucHV0IEtleXVwIGFuZCBGb2N1c1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0S2V5dXBBbmRGb2N1c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVJbnB1dEtleXVwQW5kRm9jdXMoZSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgICAgQXV0b2NvbXBsZXRlLl9rZXlkb3duID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuZWwudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBEb24ndCBjYXB0dXJlIGVudGVyIG9yIGFycm93IGtleSB1c2FnZS5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgfHwgZS5rZXlDb2RlID09PSAzOCB8fCBlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGlucHV0IGlzbid0IGVtcHR5XG4gICAgICAgIC8vIENoZWNrIGlmIGZvY3VzIHRyaWdnZXJlZCBieSB0YWJcbiAgICAgICAgaWYgKHRoaXMub2xkVmFsICE9PSB2YWwgJiYgKE0udGFiUHJlc3NlZCB8fCBlLnR5cGUgIT09ICdmb2N1cycpKSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgb2xkVmFsXG4gICAgICAgIHRoaXMub2xkVmFsID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBJbnB1dCBLZXlkb3duXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW5wdXRLZXlkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUlucHV0S2V5ZG93bihlKSB7XG4gICAgICAgIEF1dG9jb21wbGV0ZS5fa2V5ZG93biA9IHRydWU7XG5cbiAgICAgICAgLy8gQXJyb3cga2V5cyBhbmQgZW50ZXIga2V5IHVzYWdlXG4gICAgICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLFxuICAgICAgICAgICAgbGlFbGVtZW50ID0gdm9pZCAwLFxuICAgICAgICAgICAgbnVtSXRlbXMgPSAkKHRoaXMuY29udGFpbmVyKS5jaGlsZHJlbignbGknKS5sZW5ndGg7XG5cbiAgICAgICAgLy8gc2VsZWN0IGVsZW1lbnQgb24gRW50ZXJcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IE0ua2V5cy5FTlRFUiAmJiB0aGlzLmFjdGl2ZUluZGV4ID49IDApIHtcbiAgICAgICAgICBsaUVsZW1lbnQgPSAkKHRoaXMuY29udGFpbmVyKS5jaGlsZHJlbignbGknKS5lcSh0aGlzLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICBpZiAobGlFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RPcHRpb24obGlFbGVtZW50KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FwdHVyZSB1cCBhbmQgZG93biBrZXlcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IE0ua2V5cy5BUlJPV19VUCB8fCBrZXlDb2RlID09PSBNLmtleXMuQVJST1dfRE9XTikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBNLmtleXMuQVJST1dfVVAgJiYgdGhpcy5hY3RpdmVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXgtLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gTS5rZXlzLkFSUk9XX0RPV04gJiYgdGhpcy5hY3RpdmVJbmRleCA8IG51bUl0ZW1zIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy4kYWN0aXZlID0gJCh0aGlzLmNvbnRhaW5lcikuY2hpbGRyZW4oJ2xpJykuZXEodGhpcy5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgICB0aGlzLiRhY3RpdmUuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBJbnB1dCBDbGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRDbGljayhlKSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBDb250YWluZXIgTW91c2Vkb3duIGFuZCBUb3VjaHN0YXJ0XG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duQW5kVG91Y2hzdGFydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb250YWluZXJNb3VzZWRvd25BbmRUb3VjaHN0YXJ0KGUpIHtcbiAgICAgICAgdGhpcy5fbW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgQ29udGFpbmVyIE1vdXNldXAgYW5kIFRvdWNoZW5kXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ29udGFpbmVyTW91c2V1cEFuZFRvdWNoZW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbnRhaW5lck1vdXNldXBBbmRUb3VjaGVuZChlKSB7XG4gICAgICAgIHRoaXMuX21vdXNlZG93biA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhpZ2hsaWdodCBwYXJ0aWFsIG1hdGNoXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGlnaGxpZ2h0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZ2hsaWdodChzdHJpbmcsICRlbCkge1xuICAgICAgICB2YXIgaW1nID0gJGVsLmZpbmQoJ2ltZycpO1xuICAgICAgICB2YXIgbWF0Y2hTdGFydCA9ICRlbC50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcnICsgc3RyaW5nLnRvTG93ZXJDYXNlKCkgKyAnJyksXG4gICAgICAgICAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyBzdHJpbmcubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGJlZm9yZU1hdGNoID0gJGVsLnRleHQoKS5zbGljZSgwLCBtYXRjaFN0YXJ0KSxcbiAgICAgICAgICAgIG1hdGNoVGV4dCA9ICRlbC50ZXh0KCkuc2xpY2UobWF0Y2hTdGFydCwgbWF0Y2hFbmQgKyAxKSxcbiAgICAgICAgICAgIGFmdGVyTWF0Y2ggPSAkZWwudGV4dCgpLnNsaWNlKG1hdGNoRW5kICsgMSk7XG4gICAgICAgICRlbC5odG1sKFwiPHNwYW4+XCIgKyBiZWZvcmVNYXRjaCArIFwiPHNwYW4gY2xhc3M9J2hpZ2hsaWdodCc+XCIgKyBtYXRjaFRleHQgKyBcIjwvc3Bhbj5cIiArIGFmdGVyTWF0Y2ggKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgIGlmIChpbWcubGVuZ3RoKSB7XG4gICAgICAgICAgJGVsLnByZXBlbmQoaW1nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0IGN1cnJlbnQgZWxlbWVudCBwb3NpdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3Jlc2V0Q3VycmVudEVsZW1lbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXRDdXJyZW50RWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0IGF1dG9jb21wbGV0ZSBlbGVtZW50c1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3Jlc2V0QXV0b2NvbXBsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0QXV0b2NvbXBsZXRlKCkge1xuICAgICAgICAkKHRoaXMuY29udGFpbmVyKS5lbXB0eSgpO1xuICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRFbGVtZW50KCk7XG4gICAgICAgIHRoaXMub2xkVmFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGF1dG9jb21wbGV0ZSBvcHRpb25cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgIEF1dG9jb21wbGV0ZSBvcHRpb24gbGlzdCBpdGVtIGVsZW1lbnRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNlbGVjdE9wdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9wdGlvbihlbCkge1xuICAgICAgICB2YXIgdGV4dCA9IGVsLnRleHQoKS50cmltKCk7XG4gICAgICAgIHRoaXMuZWwudmFsdWUgPSB0ZXh0O1xuICAgICAgICB0aGlzLiRlbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy5fcmVzZXRBdXRvY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBvbkF1dG9jb21wbGV0ZSBjYWxsYmFjay5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25BdXRvY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25BdXRvY29tcGxldGUuY2FsbCh0aGlzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbmRlciBkcm9wZG93biBjb250ZW50XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgZGF0YSBzZXRcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgIGN1cnJlbnQgaW5wdXQgdmFsdWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW5kZXJEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJEcm9wZG93bihkYXRhLCB2YWwpIHtcbiAgICAgICAgdmFyIF90aGlzMzkgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0QXV0b2NvbXBsZXRlKCk7XG5cbiAgICAgICAgdmFyIG1hdGNoaW5nRGF0YSA9IFtdO1xuXG4gICAgICAgIC8vIEdhdGhlciBhbGwgbWF0Y2hpbmcgZGF0YVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWwpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gQnJlYWsgaWYgcGFzdCBsaW1pdFxuICAgICAgICAgICAgaWYgKHRoaXMuY291bnQgPj0gdGhpcy5vcHRpb25zLmxpbWl0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgICAgIGRhdGE6IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXRjaGluZ0RhdGEucHVzaChlbnRyeSk7XG5cbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKSB7XG4gICAgICAgICAgdmFyIHNvcnRGdW5jdGlvbkJvdW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczM5Lm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEua2V5LnRvTG93ZXJDYXNlKCksIGIua2V5LnRvTG93ZXJDYXNlKCksIHZhbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1hdGNoaW5nRGF0YS5zb3J0KHNvcnRGdW5jdGlvbkJvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfZW50cnkgPSBtYXRjaGluZ0RhdGFbaV07XG4gICAgICAgICAgdmFyICRhdXRvY29tcGxldGVPcHRpb24gPSAkKCc8bGk+PC9saT4nKTtcbiAgICAgICAgICBpZiAoISFfZW50cnkuZGF0YSkge1xuICAgICAgICAgICAgJGF1dG9jb21wbGV0ZU9wdGlvbi5hcHBlbmQoXCI8aW1nIHNyYz1cXFwiXCIgKyBfZW50cnkuZGF0YSArIFwiXFxcIiBjbGFzcz1cXFwicmlnaHQgY2lyY2xlXFxcIj48c3Bhbj5cIiArIF9lbnRyeS5rZXkgKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhdXRvY29tcGxldGVPcHRpb24uYXBwZW5kKCc8c3Bhbj4nICsgX2VudHJ5LmtleSArICc8L3NwYW4+Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJCh0aGlzLmNvbnRhaW5lcikuYXBwZW5kKCRhdXRvY29tcGxldGVPcHRpb24pO1xuICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodCh2YWwsICRhdXRvY29tcGxldGVPcHRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbiBBdXRvY29tcGxldGUgRHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5lbC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0QXV0b2NvbXBsZXRlKCk7XG5cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1pbkxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJEcm9wZG93bih0aGlzLm9wdGlvbnMuZGF0YSwgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wZW4gZHJvcGRvd25cbiAgICAgICAgaWYgKCF0aGlzLmRyb3Bkb3duLmlzT3Blbikge1xuICAgICAgICAgIHRoaXMuZHJvcGRvd24ub3BlbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIGRyb3Bkb3duIHdoZW4gaXRzIGFscmVhZHkgb3BlblxuICAgICAgICAgIHRoaXMuZHJvcGRvd24ucmVjYWxjdWxhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBBdXRvY29tcGxldGUgRHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgRGF0YVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInVwZGF0ZURhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuZWwudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHRoaXMuX3JlbmRlckRyb3Bkb3duKGRhdGEsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoQXV0b2NvbXBsZXRlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXV0b2NvbXBsZXRlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fQXV0b2NvbXBsZXRlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEF1dG9jb21wbGV0ZTtcbiAgfShDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBBdXRvY29tcGxldGVcbiAgICovXG5cblxuICBBdXRvY29tcGxldGUuX2tleWRvd24gPSBmYWxzZTtcblxuICBNLkF1dG9jb21wbGV0ZSA9IEF1dG9jb21wbGV0ZTtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKEF1dG9jb21wbGV0ZSwgJ2F1dG9jb21wbGV0ZScsICdNX0F1dG9jb21wbGV0ZScpO1xuICB9XG59KShjYXNoKTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIGxhYmVscyBvZiB0ZXh0IGZpZWxkc1xuICBNLnVwZGF0ZVRleHRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0X3NlbGVjdG9yID0gJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9cGFzc3dvcmRdLCBpbnB1dFt0eXBlPWVtYWlsXSwgaW5wdXRbdHlwZT11cmxdLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0W3R5cGU9bnVtYmVyXSwgaW5wdXRbdHlwZT1zZWFyY2hdLCBpbnB1dFt0eXBlPWRhdGVdLCBpbnB1dFt0eXBlPXRpbWVdLCB0ZXh0YXJlYSc7XG4gICAgJChpbnB1dF9zZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICBpZiAoZWxlbWVudC52YWx1ZS5sZW5ndGggPiAwIHx8ICQoZWxlbWVudCkuaXMoJzpmb2N1cycpIHx8IGVsZW1lbnQuYXV0b2ZvY3VzIHx8ICR0aGlzLmF0dHIoJ3BsYWNlaG9sZGVyJykgIT09IG51bGwpIHtcbiAgICAgICAgJHRoaXMuc2libGluZ3MoJ2xhYmVsJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnZhbGlkaXR5KSB7XG4gICAgICAgICR0aGlzLnNpYmxpbmdzKCdsYWJlbCcpLnRvZ2dsZUNsYXNzKCdhY3RpdmUnLCBlbGVtZW50LnZhbGlkaXR5LmJhZElucHV0ID09PSB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR0aGlzLnNpYmxpbmdzKCdsYWJlbCcpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBNLnZhbGlkYXRlX2ZpZWxkID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBoYXNMZW5ndGggPSBvYmplY3QuYXR0cignZGF0YS1sZW5ndGgnKSAhPT0gbnVsbDtcbiAgICB2YXIgbGVuQXR0ciA9IHBhcnNlSW50KG9iamVjdC5hdHRyKCdkYXRhLWxlbmd0aCcpKTtcbiAgICB2YXIgbGVuID0gb2JqZWN0WzBdLnZhbHVlLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPT09IDAgJiYgb2JqZWN0WzBdLnZhbGlkaXR5LmJhZElucHV0ID09PSBmYWxzZSAmJiAhb2JqZWN0LmlzKCc6cmVxdWlyZWQnKSkge1xuICAgICAgaWYgKG9iamVjdC5oYXNDbGFzcygndmFsaWRhdGUnKSkge1xuICAgICAgICBvYmplY3QucmVtb3ZlQ2xhc3MoJ3ZhbGlkJyk7XG4gICAgICAgIG9iamVjdC5yZW1vdmVDbGFzcygnaW52YWxpZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc0NsYXNzKCd2YWxpZGF0ZScpKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaGFyYWN0ZXIgY291bnRlciBhdHRyaWJ1dGVzXG4gICAgICAgIGlmIChvYmplY3QuaXMoJzp2YWxpZCcpICYmIGhhc0xlbmd0aCAmJiBsZW4gPD0gbGVuQXR0ciB8fCBvYmplY3QuaXMoJzp2YWxpZCcpICYmICFoYXNMZW5ndGgpIHtcbiAgICAgICAgICBvYmplY3QucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICAgICAgICBvYmplY3QuYWRkQ2xhc3MoJ3ZhbGlkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCd2YWxpZCcpO1xuICAgICAgICAgIG9iamVjdC5hZGRDbGFzcygnaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE0udGV4dGFyZWFBdXRvUmVzaXplID0gZnVuY3Rpb24gKCR0ZXh0YXJlYSkge1xuICAgIC8vIFdyYXAgaWYgbmF0aXZlIGVsZW1lbnRcbiAgICBpZiAoJHRleHRhcmVhIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgJHRleHRhcmVhID0gJCgkdGV4dGFyZWEpO1xuICAgIH1cblxuICAgIGlmICghJHRleHRhcmVhLmxlbmd0aCkge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gdGV4dGFyZWEgZWxlbWVudCBmb3VuZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRleHRhcmVhIEF1dG8gUmVzaXplXG4gICAgdmFyIGhpZGRlbkRpdiA9ICQoJy5oaWRkZW5kaXYnKS5maXJzdCgpO1xuICAgIGlmICghaGlkZGVuRGl2Lmxlbmd0aCkge1xuICAgICAgaGlkZGVuRGl2ID0gJCgnPGRpdiBjbGFzcz1cImhpZGRlbmRpdiBjb21tb25cIj48L2Rpdj4nKTtcbiAgICAgICQoJ2JvZHknKS5hcHBlbmQoaGlkZGVuRGl2KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZm9udCBwcm9wZXJ0aWVzIG9mIGhpZGRlbkRpdlxuICAgIHZhciBmb250RmFtaWx5ID0gJHRleHRhcmVhLmNzcygnZm9udC1mYW1pbHknKTtcbiAgICB2YXIgZm9udFNpemUgPSAkdGV4dGFyZWEuY3NzKCdmb250LXNpemUnKTtcbiAgICB2YXIgbGluZUhlaWdodCA9ICR0ZXh0YXJlYS5jc3MoJ2xpbmUtaGVpZ2h0Jyk7XG5cbiAgICAvLyBGaXJlZm94IGNhbid0IGhhbmRsZSBwYWRkaW5nIHNob3J0aGFuZC5cbiAgICB2YXIgcGFkZGluZ1RvcCA9ICR0ZXh0YXJlYS5jc3MoJ3BhZGRpbmctdG9wJyk7XG4gICAgdmFyIHBhZGRpbmdSaWdodCA9ICR0ZXh0YXJlYS5jc3MoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICB2YXIgcGFkZGluZ0JvdHRvbSA9ICR0ZXh0YXJlYS5jc3MoJ3BhZGRpbmctYm90dG9tJyk7XG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gJHRleHRhcmVhLmNzcygncGFkZGluZy1sZWZ0Jyk7XG5cbiAgICBpZiAoZm9udFNpemUpIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICB9XG4gICAgaWYgKGZvbnRGYW1pbHkpIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ2ZvbnQtZmFtaWx5JywgZm9udEZhbWlseSk7XG4gICAgfVxuICAgIGlmIChsaW5lSGVpZ2h0KSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCdsaW5lLWhlaWdodCcsIGxpbmVIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAocGFkZGluZ1RvcCkge1xuICAgICAgaGlkZGVuRGl2LmNzcygncGFkZGluZy10b3AnLCBwYWRkaW5nVG9wKTtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmdSaWdodCkge1xuICAgICAgaGlkZGVuRGl2LmNzcygncGFkZGluZy1yaWdodCcsIHBhZGRpbmdSaWdodCk7XG4gICAgfVxuICAgIGlmIChwYWRkaW5nQm90dG9tKSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCdwYWRkaW5nLWJvdHRvbScsIHBhZGRpbmdCb3R0b20pO1xuICAgIH1cbiAgICBpZiAocGFkZGluZ0xlZnQpIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ3BhZGRpbmctbGVmdCcsIHBhZGRpbmdMZWZ0KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgb3JpZ2luYWwtaGVpZ2h0LCBpZiBub25lXG4gICAgaWYgKCEkdGV4dGFyZWEuZGF0YSgnb3JpZ2luYWwtaGVpZ2h0JykpIHtcbiAgICAgICR0ZXh0YXJlYS5kYXRhKCdvcmlnaW5hbC1oZWlnaHQnLCAkdGV4dGFyZWEuaGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIGlmICgkdGV4dGFyZWEuYXR0cignd3JhcCcpID09PSAnb2ZmJykge1xuICAgICAgaGlkZGVuRGl2LmNzcygnb3ZlcmZsb3ctd3JhcCcsICdub3JtYWwnKS5jc3MoJ3doaXRlLXNwYWNlJywgJ3ByZScpO1xuICAgIH1cblxuICAgIGhpZGRlbkRpdi50ZXh0KCR0ZXh0YXJlYVswXS52YWx1ZSArICdcXG4nKTtcbiAgICB2YXIgY29udGVudCA9IGhpZGRlbkRpdi5odG1sKCkucmVwbGFjZSgvXFxuL2csICc8YnI+Jyk7XG4gICAgaGlkZGVuRGl2Lmh0bWwoY29udGVudCk7XG5cbiAgICAvLyBXaGVuIHRleHRhcmVhIGlzIGhpZGRlbiwgd2lkdGggZ29lcyBjcmF6eS5cbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGhhbGYgb2Ygd2luZG93IHNpemVcblxuICAgIGlmICgkdGV4dGFyZWFbMF0ub2Zmc2V0V2lkdGggPiAwICYmICR0ZXh0YXJlYVswXS5vZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCd3aWR0aCcsICR0ZXh0YXJlYS53aWR0aCgpICsgJ3B4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ3dpZHRoJywgd2luZG93LmlubmVyV2lkdGggLyAyICsgJ3B4Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGlmIHRoZSBuZXcgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgKiBvcmlnaW5hbCBoZWlnaHQgb2YgdGhlIHRleHRhcmVhXG4gICAgICovXG4gICAgaWYgKCR0ZXh0YXJlYS5kYXRhKCdvcmlnaW5hbC1oZWlnaHQnKSA8PSBoaWRkZW5EaXYuaW5uZXJIZWlnaHQoKSkge1xuICAgICAgJHRleHRhcmVhLmNzcygnaGVpZ2h0JywgaGlkZGVuRGl2LmlubmVySGVpZ2h0KCkgKyAncHgnKTtcbiAgICB9IGVsc2UgaWYgKCR0ZXh0YXJlYVswXS52YWx1ZS5sZW5ndGggPCAkdGV4dGFyZWEuZGF0YSgncHJldmlvdXMtbGVuZ3RoJykpIHtcbiAgICAgIC8qKlxuICAgICAgICogSW4gY2FzZSB0aGUgbmV3IGhlaWdodCBpcyBsZXNzIHRoYW4gb3JpZ2luYWwgaGVpZ2h0LCBpdFxuICAgICAgICogbWVhbnMgdGhlIHRleHRhcmVhIGhhcyBsZXNzIHRleHQgdGhhbiBiZWZvcmVcbiAgICAgICAqIFNvIHdlIHNldCB0aGUgaGVpZ2h0IHRvIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgICAqL1xuICAgICAgJHRleHRhcmVhLmNzcygnaGVpZ2h0JywgJHRleHRhcmVhLmRhdGEoJ29yaWdpbmFsLWhlaWdodCcpICsgJ3B4Jyk7XG4gICAgfVxuICAgICR0ZXh0YXJlYS5kYXRhKCdwcmV2aW91cy1sZW5ndGgnLCAkdGV4dGFyZWFbMF0udmFsdWUubGVuZ3RoKTtcbiAgfTtcblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGV4dCBiYXNlZCBpbnB1dHNcbiAgICB2YXIgaW5wdXRfc2VsZWN0b3IgPSAnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1wYXNzd29yZF0sIGlucHV0W3R5cGU9ZW1haWxdLCBpbnB1dFt0eXBlPXVybF0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXRbdHlwZT1udW1iZXJdLCBpbnB1dFt0eXBlPXNlYXJjaF0sIGlucHV0W3R5cGU9ZGF0ZV0sIGlucHV0W3R5cGU9dGltZV0sIHRleHRhcmVhJztcblxuICAgIC8vIEFkZCBhY3RpdmUgaWYgZm9ybSBhdXRvIGNvbXBsZXRlXG4gICAgJChkb2N1bWVudCkub24oJ2NoYW5nZScsIGlucHV0X3NlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT09IDAgfHwgJCh0aGlzKS5hdHRyKCdwbGFjZWhvbGRlcicpICE9PSBudWxsKSB7XG4gICAgICAgICQodGhpcykuc2libGluZ3MoJ2xhYmVsJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgICAgTS52YWxpZGF0ZV9maWVsZCgkKHRoaXMpKTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBhY3RpdmUgaWYgaW5wdXQgZWxlbWVudCBoYXMgYmVlbiBwcmUtcG9wdWxhdGVkIG9uIGRvY3VtZW50IHJlYWR5XG4gICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgTS51cGRhdGVUZXh0RmllbGRzKCk7XG4gICAgfSk7XG5cbiAgICAvLyBIVE1MIERPTSBGT1JNIFJFU0VUIGhhbmRsaW5nXG4gICAgJChkb2N1bWVudCkub24oJ3Jlc2V0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBmb3JtUmVzZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgIGlmIChmb3JtUmVzZXQuaXMoJ2Zvcm0nKSkge1xuICAgICAgICBmb3JtUmVzZXQuZmluZChpbnB1dF9zZWxlY3RvcikucmVtb3ZlQ2xhc3MoJ3ZhbGlkJykucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICAgICAgZm9ybVJlc2V0LmZpbmQoaW5wdXRfc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICQodGhpcykuc2libGluZ3MoJ2xhYmVsJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzZXQgc2VsZWN0IChhZnRlciBuYXRpdmUgcmVzZXQpXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvcm1SZXNldC5maW5kKCdzZWxlY3QnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluaXRpYWxpemVkXG4gICAgICAgICAgICBpZiAodGhpcy5NX0Zvcm1TZWxlY3QpIHtcbiAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYWN0aXZlIHdoZW4gZWxlbWVudCBoYXMgZm9jdXNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKGlucHV0X3NlbGVjdG9yKSkge1xuICAgICAgICAkKGUudGFyZ2V0KS5zaWJsaW5ncygnbGFiZWwsIC5wcmVmaXgnKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWN0aXZlIHdoZW4gZWxlbWVudCBpcyBibHVycmVkXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyICRpbnB1dEVsZW1lbnQgPSAkKGUudGFyZ2V0KTtcbiAgICAgIGlmICgkaW5wdXRFbGVtZW50LmlzKGlucHV0X3NlbGVjdG9yKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSAnLnByZWZpeCc7XG5cbiAgICAgICAgaWYgKCRpbnB1dEVsZW1lbnRbMF0udmFsdWUubGVuZ3RoID09PSAwICYmICRpbnB1dEVsZW1lbnRbMF0udmFsaWRpdHkuYmFkSW5wdXQgIT09IHRydWUgJiYgJGlucHV0RWxlbWVudC5hdHRyKCdwbGFjZWhvbGRlcicpID09PSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0b3IgKz0gJywgbGFiZWwnO1xuICAgICAgICB9XG4gICAgICAgICRpbnB1dEVsZW1lbnQuc2libGluZ3Moc2VsZWN0b3IpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgTS52YWxpZGF0ZV9maWVsZCgkaW5wdXRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIFJhZGlvIGFuZCBDaGVja2JveCBmb2N1cyBjbGFzc1xuICAgIHZhciByYWRpb19jaGVja2JveCA9ICdpbnB1dFt0eXBlPXJhZGlvXSwgaW5wdXRbdHlwZT1jaGVja2JveF0nO1xuICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cCcsIHJhZGlvX2NoZWNrYm94LCBmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gVEFCLCBjaGVjayBpZiB0YWJiaW5nIHRvIHJhZGlvIG9yIGNoZWNrYm94LlxuICAgICAgaWYgKGUud2hpY2ggPT09IE0ua2V5cy5UQUIpIHtcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygndGFiYmVkJyk7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICR0aGlzLm9uZSgnYmx1cicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygndGFiYmVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdGV4dF9hcmVhX3NlbGVjdG9yID0gJy5tYXRlcmlhbGl6ZS10ZXh0YXJlYSc7XG4gICAgJCh0ZXh0X2FyZWFfc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0ZXh0YXJlYSA9ICQodGhpcyk7XG4gICAgICAvKipcbiAgICAgICAqIFJlc2l6ZSB0ZXh0YXJlYSBvbiBkb2N1bWVudCBsb2FkIGFmdGVyIHN0b3JpbmdcbiAgICAgICAqIHRoZSBvcmlnaW5hbCBoZWlnaHQgYW5kIHRoZSBvcmlnaW5hbCBsZW5ndGhcbiAgICAgICAqL1xuICAgICAgJHRleHRhcmVhLmRhdGEoJ29yaWdpbmFsLWhlaWdodCcsICR0ZXh0YXJlYS5oZWlnaHQoKSk7XG4gICAgICAkdGV4dGFyZWEuZGF0YSgncHJldmlvdXMtbGVuZ3RoJywgdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgICAgTS50ZXh0YXJlYUF1dG9SZXNpemUoJHRleHRhcmVhKTtcbiAgICB9KTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cCcsIHRleHRfYXJlYV9zZWxlY3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgTS50ZXh0YXJlYUF1dG9SZXNpemUoJCh0aGlzKSk7XG4gICAgfSk7XG4gICAgJChkb2N1bWVudCkub24oJ2tleWRvd24nLCB0ZXh0X2FyZWFfc2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIE0udGV4dGFyZWFBdXRvUmVzaXplKCQodGhpcykpO1xuICAgIH0pO1xuXG4gICAgLy8gRmlsZSBJbnB1dCBQYXRoXG4gICAgJChkb2N1bWVudCkub24oJ2NoYW5nZScsICcuZmlsZS1maWVsZCBpbnB1dFt0eXBlPVwiZmlsZVwiXScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlX2ZpZWxkID0gJCh0aGlzKS5jbG9zZXN0KCcuZmlsZS1maWVsZCcpO1xuICAgICAgdmFyIHBhdGhfaW5wdXQgPSBmaWxlX2ZpZWxkLmZpbmQoJ2lucHV0LmZpbGUtcGF0aCcpO1xuICAgICAgdmFyIGZpbGVzID0gJCh0aGlzKVswXS5maWxlcztcbiAgICAgIHZhciBmaWxlX25hbWVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZpbGVfbmFtZXMucHVzaChmaWxlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHBhdGhfaW5wdXRbMF0udmFsdWUgPSBmaWxlX25hbWVzLmpvaW4oJywgJyk7XG4gICAgICBwYXRoX2lucHV0LnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9KTsgLy8gRW5kIG9mICQoZG9jdW1lbnQpLnJlYWR5XG59KShjYXNoKTtcbjsoZnVuY3Rpb24gKCQsIGFuaW0pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgaW5kaWNhdG9yczogdHJ1ZSxcbiAgICBoZWlnaHQ6IDQwMCxcbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIGludGVydmFsOiA2MDAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgU2xpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQxMSkge1xuICAgIF9pbmhlcml0cyhTbGlkZXIsIF9Db21wb25lbnQxMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgU2xpZGVyIGluc3RhbmNlIGFuZCBzZXQgdXAgb3ZlcmxheVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNsaWRlcihlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XG5cbiAgICAgIHZhciBfdGhpczQwID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNsaWRlcikpLmNhbGwodGhpcywgU2xpZGVyLCBlbCwgb3B0aW9ucykpO1xuXG4gICAgICBfdGhpczQwLmVsLk1fU2xpZGVyID0gX3RoaXM0MDtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgbW9kYWxcbiAgICAgICAqIEBtZW1iZXIgU2xpZGVyI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbaW5kaWNhdG9ycz10cnVlXSAtIFNob3cgaW5kaWNhdG9yc1xuICAgICAgICogQHByb3Age051bWJlcn0gW2hlaWdodD00MDBdIC0gaGVpZ2h0IG9mIHNsaWRlclxuICAgICAgICogQHByb3Age051bWJlcn0gW2R1cmF0aW9uPTUwMF0gLSBMZW5ndGggaW4gbXMgb2Ygc2xpZGUgdHJhbnNpdGlvblxuICAgICAgICogQHByb3Age051bWJlcn0gW2ludGVydmFsPTYwMDBdIC0gTGVuZ3RoIGluIG1zIG9mIHNsaWRlIGludGVydmFsXG4gICAgICAgKi9cbiAgICAgIF90aGlzNDAub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBTbGlkZXIuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBzZXR1cFxuICAgICAgX3RoaXM0MC4kc2xpZGVyID0gX3RoaXM0MC4kZWwuZmluZCgnLnNsaWRlcycpO1xuICAgICAgX3RoaXM0MC4kc2xpZGVzID0gX3RoaXM0MC4kc2xpZGVyLmNoaWxkcmVuKCdsaScpO1xuICAgICAgX3RoaXM0MC5hY3RpdmVJbmRleCA9IF90aGlzNDAuJHNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICQoaXRlbSkuaGFzQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfSkuZmlyc3QoKS5pbmRleCgpO1xuICAgICAgaWYgKF90aGlzNDAuYWN0aXZlSW5kZXggIT0gLTEpIHtcbiAgICAgICAgX3RoaXM0MC4kYWN0aXZlID0gX3RoaXM0MC4kc2xpZGVzLmVxKF90aGlzNDAuYWN0aXZlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczQwLl9zZXRTbGlkZXJIZWlnaHQoKTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgcG9zaXRpb25zIG9mIGNhcHRpb25zXG4gICAgICBfdGhpczQwLiRzbGlkZXMuZmluZCgnLmNhcHRpb24nKS5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBfdGhpczQwLl9hbmltYXRlQ2FwdGlvbkluKGVsLCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb3ZlIGltZyBzcmMgaW50byBiYWNrZ3JvdW5kLWltYWdlXG4gICAgICBfdGhpczQwLiRzbGlkZXMuZmluZCgnaW1nJykuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyQmFzZTY0ID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFCQVAvLy93QUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT0nO1xuICAgICAgICBpZiAoJChlbCkuYXR0cignc3JjJykgIT09IHBsYWNlaG9sZGVyQmFzZTY0KSB7XG4gICAgICAgICAgJChlbCkuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybChcIicgKyAkKGVsKS5hdHRyKCdzcmMnKSArICdcIiknKTtcbiAgICAgICAgICAkKGVsKS5hdHRyKCdzcmMnLCBwbGFjZWhvbGRlckJhc2U2NCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfdGhpczQwLl9zZXR1cEluZGljYXRvcnMoKTtcblxuICAgICAgLy8gU2hvdyBhY3RpdmUgc2xpZGVcbiAgICAgIGlmIChfdGhpczQwLiRhY3RpdmUpIHtcbiAgICAgICAgX3RoaXM0MC4kYWN0aXZlLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXM0MC4kc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiBfdGhpczQwLiRzbGlkZXMuZmlyc3QoKVswXSxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiBfdGhpczQwLm9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzNDAuYWN0aXZlSW5kZXggPSAwO1xuICAgICAgICBfdGhpczQwLiRhY3RpdmUgPSBfdGhpczQwLiRzbGlkZXMuZXEoX3RoaXM0MC5hY3RpdmVJbmRleCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGluZGljYXRvcnNcbiAgICAgICAgaWYgKF90aGlzNDAub3B0aW9ucy5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgX3RoaXM0MC4kaW5kaWNhdG9ycy5lcShfdGhpczQwLmFjdGl2ZUluZGV4KS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRqdXN0IGhlaWdodCB0byBjdXJyZW50IHNsaWRlXG4gICAgICBfdGhpczQwLiRhY3RpdmUuZmluZCgnaW1nJykuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYW5pbSh7XG4gICAgICAgICAgdGFyZ2V0czogX3RoaXM0MC4kYWN0aXZlLmZpbmQoJy5jYXB0aW9uJylbMF0sXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IF90aGlzNDAub3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgX3RoaXM0MC5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIGF1dG8gc2Nyb2xsXG4gICAgICBfdGhpczQwLnN0YXJ0KCk7XG4gICAgICByZXR1cm4gX3RoaXM0MDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLl9yZW1vdmVJbmRpY2F0b3JzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5lbC5NX1NsaWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczQxID0gdGhpcztcblxuICAgICAgICB0aGlzLl9oYW5kbGVJbnRlcnZhbEJvdW5kID0gdGhpcy5faGFuZGxlSW50ZXJ2YWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5kaWNhdG9yQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUluZGljYXRvckNsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgdGhpcy4kaW5kaWNhdG9ycy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpczQxLl9oYW5kbGVJbmRpY2F0b3JDbGlja0JvdW5kKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNDIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycykge1xuICAgICAgICAgIHRoaXMuJGluZGljYXRvcnMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXM0Mi5faGFuZGxlSW5kaWNhdG9yQ2xpY2tCb3VuZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgaW5kaWNhdG9yIGNsaWNrXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW5kaWNhdG9yQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5kaWNhdG9yQ2xpY2soZSkge1xuICAgICAgICB2YXIgY3VyckluZGV4ID0gJChlLnRhcmdldCkuaW5kZXgoKTtcbiAgICAgICAgdGhpcy5zZXQoY3VyckluZGV4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgSW50ZXJ2YWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnRlcnZhbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVJbnRlcnZhbCgpIHtcbiAgICAgICAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gdGhpcy4kc2xpZGVyLmZpbmQoJy5hY3RpdmUnKS5pbmRleCgpO1xuICAgICAgICBpZiAodGhpcy4kc2xpZGVzLmxlbmd0aCA9PT0gbmV3QWN0aXZlSW5kZXggKyAxKSBuZXdBY3RpdmVJbmRleCA9IDA7XG4gICAgICAgIC8vIGxvb3AgdG8gc3RhcnRcbiAgICAgICAgZWxzZSBuZXdBY3RpdmVJbmRleCArPSAxO1xuXG4gICAgICAgIHRoaXMuc2V0KG5ld0FjdGl2ZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbmltYXRlIGluIGNhcHRpb25cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY2FwdGlvblxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZUNhcHRpb25JblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlQ2FwdGlvbkluKGNhcHRpb24sIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBhbmltT3B0aW9ucyA9IHtcbiAgICAgICAgICB0YXJnZXRzOiBjYXB0aW9uLFxuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgkKGNhcHRpb24pLmhhc0NsYXNzKCdjZW50ZXItYWxpZ24nKSkge1xuICAgICAgICAgIGFuaW1PcHRpb25zLnRyYW5zbGF0ZVkgPSAtMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKCQoY2FwdGlvbikuaGFzQ2xhc3MoJ3JpZ2h0LWFsaWduJykpIHtcbiAgICAgICAgICBhbmltT3B0aW9ucy50cmFuc2xhdGVYID0gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKCQoY2FwdGlvbikuaGFzQ2xhc3MoJ2xlZnQtYWxpZ24nKSkge1xuICAgICAgICAgIGFuaW1PcHRpb25zLnRyYW5zbGF0ZVggPSAtMTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbShhbmltT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IGhlaWdodCBvZiBzbGlkZXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRTbGlkZXJIZWlnaHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2xpZGVySGVpZ2h0KCkge1xuICAgICAgICAvLyBJZiBmdWxsc2NyZWVuLCBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy4kZWwuaGFzQ2xhc3MoJ2Z1bGxzY3JlZW4nKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycykge1xuICAgICAgICAgICAgLy8gQWRkIGhlaWdodCBpZiBpbmRpY2F0b3JzIGFyZSBwcmVzZW50XG4gICAgICAgICAgICB0aGlzLiRlbC5jc3MoJ2hlaWdodCcsIHRoaXMub3B0aW9ucy5oZWlnaHQgKyA0MCArICdweCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5jc3MoJ2hlaWdodCcsIHRoaXMub3B0aW9ucy5oZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4kc2xpZGVyLmNzcygnaGVpZ2h0JywgdGhpcy5vcHRpb25zLmhlaWdodCArICdweCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgaW5kaWNhdG9yc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwSW5kaWNhdG9yc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEluZGljYXRvcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczQzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluZGljYXRvcnMpIHtcbiAgICAgICAgICB0aGlzLiRpbmRpY2F0b3JzID0gJCgnPHVsIGNsYXNzPVwiaW5kaWNhdG9yc1wiPjwvdWw+Jyk7XG4gICAgICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyICRpbmRpY2F0b3IgPSAkKCc8bGkgY2xhc3M9XCJpbmRpY2F0b3ItaXRlbVwiPjwvbGk+Jyk7XG4gICAgICAgICAgICBfdGhpczQzLiRpbmRpY2F0b3JzLmFwcGVuZCgkaW5kaWNhdG9yWzBdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kaW5kaWNhdG9yc1swXSk7XG4gICAgICAgICAgdGhpcy4kaW5kaWNhdG9ycyA9IHRoaXMuJGluZGljYXRvcnMuY2hpbGRyZW4oJ2xpLmluZGljYXRvci1pdGVtJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgaW5kaWNhdG9yc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUluZGljYXRvcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW5kaWNhdG9ycygpIHtcbiAgICAgICAgdGhpcy4kZWwuZmluZCgndWwuaW5kaWNhdG9ycycpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEN5Y2xlIHRvIG50aCBpdGVtXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXM0NCA9IHRoaXM7XG5cbiAgICAgICAgLy8gV3JhcCBhcm91bmQgaW5kaWNlcy5cbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuJHNsaWRlcy5sZW5ndGgpIGluZGV4ID0gMDtlbHNlIGlmIChpbmRleCA8IDApIGluZGV4ID0gdGhpcy4kc2xpZGVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgLy8gT25seSBkbyBpZiBpbmRleCBjaGFuZ2VzXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kc2xpZGVzLmVxKHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgICAgICAgIHZhciAkY2FwdGlvbiA9IHRoaXMuJGFjdGl2ZS5maW5kKCcuY2FwdGlvbicpO1xuICAgICAgICAgIHRoaXMuJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuJGFjdGl2ZVswXSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXM0NC4kc2xpZGVzLm5vdCgnLmFjdGl2ZScpLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgYW5pbSh7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRzOiBlbCxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogMCxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZUNhcHRpb25JbigkY2FwdGlvblswXSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgICB0aGlzLiRpbmRpY2F0b3JzLmVxKHRoaXMuYWN0aXZlSW5kZXgpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHRoaXMuJGluZGljYXRvcnMuZXEoaW5kZXgpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuJHNsaWRlcy5lcShpbmRleClbMF0sXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYW5pbSh7XG4gICAgICAgICAgICB0YXJnZXRzOiB0aGlzLiRzbGlkZXMuZXEoaW5kZXgpLmZpbmQoJy5jYXB0aW9uJylbMF0sXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLmVxKGluZGV4KS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgLy8gUmVzZXQgaW50ZXJ2YWxcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXVzZSBzbGlkZXIgaW50ZXJ2YWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnQgc2xpZGVyIGludGVydmFsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5faGFuZGxlSW50ZXJ2YWxCb3VuZCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICsgdGhpcy5vcHRpb25zLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlIHRvIG5leHQgc2xpZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm5leHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgbmV3SW5kZXggPSB0aGlzLmFjdGl2ZUluZGV4ICsgMTtcblxuICAgICAgICAvLyBXcmFwIGFyb3VuZCBpbmRpY2VzLlxuICAgICAgICBpZiAobmV3SW5kZXggPj0gdGhpcy4kc2xpZGVzLmxlbmd0aCkgbmV3SW5kZXggPSAwO2Vsc2UgaWYgKG5ld0luZGV4IDwgMCkgbmV3SW5kZXggPSB0aGlzLiRzbGlkZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB0aGlzLnNldChuZXdJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTW92ZSB0byBwcmV2aW91cyBzbGlkZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJldlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggLSAxO1xuXG4gICAgICAgIC8vIFdyYXAgYXJvdW5kIGluZGljZXMuXG4gICAgICAgIGlmIChuZXdJbmRleCA+PSB0aGlzLiRzbGlkZXMubGVuZ3RoKSBuZXdJbmRleCA9IDA7ZWxzZSBpZiAobmV3SW5kZXggPCAwKSBuZXdJbmRleCA9IHRoaXMuJHNsaWRlcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHRoaXMuc2V0KG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoU2xpZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2xpZGVyKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fU2xpZGVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNsaWRlcjtcbiAgfShDb21wb25lbnQpO1xuXG4gIE0uU2xpZGVyID0gU2xpZGVyO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoU2xpZGVyLCAnc2xpZGVyJywgJ01fU2xpZGVyJyk7XG4gIH1cbn0pKGNhc2gsIE0uYW5pbWUpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmNhcmQnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICgkKHRoaXMpLmNoaWxkcmVuKCcuY2FyZC1yZXZlYWwnKS5sZW5ndGgpIHtcbiAgICAgIHZhciAkY2FyZCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jYXJkJyk7XG4gICAgICBpZiAoJGNhcmQuZGF0YSgnaW5pdGlhbE92ZXJmbG93JykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAkY2FyZC5kYXRhKCdpbml0aWFsT3ZlcmZsb3cnLCAkY2FyZC5jc3MoJ292ZXJmbG93JykgPT09IHVuZGVmaW5lZCA/ICcnIDogJGNhcmQuY3NzKCdvdmVyZmxvdycpKTtcbiAgICAgIH1cbiAgICAgIHZhciAkY2FyZFJldmVhbCA9ICQodGhpcykuZmluZCgnLmNhcmQtcmV2ZWFsJyk7XG4gICAgICBpZiAoJChlLnRhcmdldCkuaXMoJCgnLmNhcmQtcmV2ZWFsIC5jYXJkLXRpdGxlJykpIHx8ICQoZS50YXJnZXQpLmlzKCQoJy5jYXJkLXJldmVhbCAuY2FyZC10aXRsZSBpJykpKSB7XG4gICAgICAgIC8vIE1ha2UgUmV2ZWFsIGFuaW1hdGUgZG93biBhbmQgZGlzcGxheSBub25lXG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6ICRjYXJkUmV2ZWFsWzBdLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IDIyNSxcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJyxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGFuaW0pIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGFuaW0uYW5pbWF0YWJsZXNbMF0udGFyZ2V0O1xuICAgICAgICAgICAgJChlbCkuY3NzKHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgICAgICAgICAgJGNhcmQuY3NzKCdvdmVyZmxvdycsICRjYXJkLmRhdGEoJ2luaXRpYWxPdmVyZmxvdycpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICgkKGUudGFyZ2V0KS5pcygkKCcuY2FyZCAuYWN0aXZhdG9yJykpIHx8ICQoZS50YXJnZXQpLmlzKCQoJy5jYXJkIC5hY3RpdmF0b3IgaScpKSkge1xuICAgICAgICAkY2FyZC5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuICAgICAgICAkY2FyZFJldmVhbC5jc3MoeyBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICBhbmltKHtcbiAgICAgICAgICB0YXJnZXRzOiAkY2FyZFJldmVhbFswXSxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAnLTEwMCUnLFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZUluT3V0UXVhZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKGNhc2gsIE0uYW5pbWUpO1xuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBkYXRhOiBbXSxcbiAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgc2Vjb25kYXJ5UGxhY2Vob2xkZXI6ICcnLFxuICAgIGF1dG9jb21wbGV0ZU9wdGlvbnM6IHt9LFxuICAgIGxpbWl0OiBJbmZpbml0eSxcbiAgICBvbkNoaXBBZGQ6IG51bGwsXG4gICAgb25DaGlwU2VsZWN0OiBudWxsLFxuICAgIG9uQ2hpcERlbGV0ZTogbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBjaGlwXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0YWcgIGNoaXAgdGFnIHN0cmluZ1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2ltYWdlXSAgY2hpcCBhdmF0YXIgaW1hZ2Ugc3RyaW5nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICovXG5cbiAgdmFyIENoaXBzID0gZnVuY3Rpb24gKF9Db21wb25lbnQxMikge1xuICAgIF9pbmhlcml0cyhDaGlwcywgX0NvbXBvbmVudDEyKTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBDaGlwcyBpbnN0YW5jZSBhbmQgc2V0IHVwIG92ZXJsYXlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDaGlwcyhlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoaXBzKTtcblxuICAgICAgdmFyIF90aGlzNDUgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2hpcHMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaGlwcykpLmNhbGwodGhpcywgQ2hpcHMsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzNDUuZWwuTV9DaGlwcyA9IF90aGlzNDU7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIG1vZGFsXG4gICAgICAgKiBAbWVtYmVyIENoaXBzI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtBcnJheX0gZGF0YVxuICAgICAgICogQHByb3Age1N0cmluZ30gcGxhY2Vob2xkZXJcbiAgICAgICAqIEBwcm9wIHtTdHJpbmd9IHNlY29uZGFyeVBsYWNlaG9sZGVyXG4gICAgICAgKiBAcHJvcCB7T2JqZWN0fSBhdXRvY29tcGxldGVPcHRpb25zXG4gICAgICAgKi9cbiAgICAgIF90aGlzNDUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDaGlwcy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIF90aGlzNDUuJGVsLmFkZENsYXNzKCdjaGlwcyBpbnB1dC1maWVsZCcpO1xuICAgICAgX3RoaXM0NS5jaGlwc0RhdGEgPSBbXTtcbiAgICAgIF90aGlzNDUuJGNoaXBzID0gJCgpO1xuICAgICAgX3RoaXM0NS5fc2V0dXBJbnB1dCgpO1xuICAgICAgX3RoaXM0NS5oYXNBdXRvY29tcGxldGUgPSBPYmplY3Qua2V5cyhfdGhpczQ1Lm9wdGlvbnMuYXV0b2NvbXBsZXRlT3B0aW9ucykubGVuZ3RoID4gMDtcblxuICAgICAgLy8gU2V0IGlucHV0IGlkXG4gICAgICBpZiAoIV90aGlzNDUuJGlucHV0LmF0dHIoJ2lkJykpIHtcbiAgICAgICAgX3RoaXM0NS4kaW5wdXQuYXR0cignaWQnLCBNLmd1aWQoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBpbml0aWFsIGNoaXBzXG4gICAgICBpZiAoX3RoaXM0NS5vcHRpb25zLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIF90aGlzNDUuY2hpcHNEYXRhID0gX3RoaXM0NS5vcHRpb25zLmRhdGE7XG4gICAgICAgIF90aGlzNDUuX3JlbmRlckNoaXBzKF90aGlzNDUuY2hpcHNEYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgYXV0b2NvbXBsZXRlIGlmIG5lZWRlZFxuICAgICAgaWYgKF90aGlzNDUuaGFzQXV0b2NvbXBsZXRlKSB7XG4gICAgICAgIF90aGlzNDUuX3NldHVwQXV0b2NvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzNDUuX3NldFBsYWNlaG9sZGVyKCk7XG4gICAgICBfdGhpczQ1Ll9zZXR1cExhYmVsKCk7XG4gICAgICBfdGhpczQ1Ll9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczQ1O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaGlwcywgW3tcbiAgICAgIGtleTogXCJnZXREYXRhXCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgQ2hpcHMgRGF0YVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpcHNEYXRhO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy4kY2hpcHMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZWwuTV9DaGlwcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNoaXBDbGlja0JvdW5kID0gdGhpcy5faGFuZGxlQ2hpcENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kID0gdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0Rm9jdXNCb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0Rm9jdXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5wdXRCbHVyQm91bmQgPSB0aGlzLl9oYW5kbGVJbnB1dEJsdXIuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2hpcENsaWNrQm91bmQpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgQ2hpcHMuX2hhbmRsZUNoaXBzS2V5ZG93bik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgQ2hpcHMuX2hhbmRsZUNoaXBzS2V5dXApO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBDaGlwcy5faGFuZGxlQ2hpcHNCbHVyLCB0cnVlKTtcbiAgICAgICAgdGhpcy4kaW5wdXRbMF0uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzQm91bmQpO1xuICAgICAgICB0aGlzLiRpbnB1dFswXS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlSW5wdXRCbHVyQm91bmQpO1xuICAgICAgICB0aGlzLiRpbnB1dFswXS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNoaXBDbGlja0JvdW5kKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIENoaXBzLl9oYW5kbGVDaGlwc0tleWRvd24pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIENoaXBzLl9oYW5kbGVDaGlwc0tleXVwKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgQ2hpcHMuX2hhbmRsZUNoaXBzQmx1ciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuJGlucHV0WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlSW5wdXRGb2N1c0JvdW5kKTtcbiAgICAgICAgdGhpcy4kaW5wdXRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2hhbmRsZUlucHV0Qmx1ckJvdW5kKTtcbiAgICAgICAgdGhpcy4kaW5wdXRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgQ2hpcCBDbGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNoaXBDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDaGlwQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGNoaXAgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuY2hpcCcpO1xuICAgICAgICB2YXIgY2xpY2tlZENsb3NlID0gJChlLnRhcmdldCkuaXMoJy5jbG9zZScpO1xuICAgICAgICBpZiAoJGNoaXAubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gJGNoaXAuaW5kZXgoKTtcbiAgICAgICAgICBpZiAoY2xpY2tlZENsb3NlKSB7XG4gICAgICAgICAgICAvLyBkZWxldGUgY2hpcFxuICAgICAgICAgICAgdGhpcy5kZWxldGVDaGlwKGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0WzBdLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNlbGVjdCBjaGlwXG4gICAgICAgICAgICB0aGlzLnNlbGVjdENoaXAoaW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlZmF1bHQgaGFuZGxlIGNsaWNrIHRvIGZvY3VzIG9uIGlucHV0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXRbMF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBDaGlwcyBLZXlkb3duXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW5wdXRGb2N1c1wiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIElucHV0IEZvY3VzXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRGb2N1cygpIHtcbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2ZvY3VzJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIElucHV0IEJsdXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnB1dEJsdXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRCbHVyKCkge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnZm9jdXMnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgSW5wdXQgS2V5ZG93blxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0S2V5ZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVJbnB1dEtleWRvd24oZSkge1xuICAgICAgICBDaGlwcy5fa2V5ZG93biA9IHRydWU7XG5cbiAgICAgICAgLy8gZW50ZXJcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAvLyBPdmVycmlkZSBlbnRlciBpZiBhdXRvY29tcGxldGluZy5cbiAgICAgICAgICBpZiAodGhpcy5oYXNBdXRvY29tcGxldGUgJiYgdGhpcy5hdXRvY29tcGxldGUgJiYgdGhpcy5hdXRvY29tcGxldGUuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuYWRkQ2hpcCh7XG4gICAgICAgICAgICB0YWc6IHRoaXMuJGlucHV0WzBdLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4kaW5wdXRbMF0udmFsdWUgPSAnJztcblxuICAgICAgICAgIC8vIGRlbGV0ZSBvciBsZWZ0XG4gICAgICAgIH0gZWxzZSBpZiAoKGUua2V5Q29kZSA9PT0gOCB8fCBlLmtleUNvZGUgPT09IDM3KSAmJiB0aGlzLiRpbnB1dFswXS52YWx1ZSA9PT0gJycgJiYgdGhpcy5jaGlwc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0Q2hpcCh0aGlzLmNoaXBzRGF0YS5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbmRlciBDaGlwXG4gICAgICAgKiBAcGFyYW0ge2NoaXB9IGNoaXBcbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVuZGVyQ2hpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJDaGlwKGNoaXApIHtcbiAgICAgICAgaWYgKCFjaGlwLnRhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlZENoaXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGNsb3NlSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICAgICAgcmVuZGVyZWRDaGlwLmNsYXNzTGlzdC5hZGQoJ2NoaXAnKTtcbiAgICAgICAgcmVuZGVyZWRDaGlwLnRleHRDb250ZW50ID0gY2hpcC50YWc7XG4gICAgICAgIHJlbmRlcmVkQ2hpcC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgICQoY2xvc2VJY29uKS5hZGRDbGFzcygnbWF0ZXJpYWwtaWNvbnMgY2xvc2UnKTtcbiAgICAgICAgY2xvc2VJY29uLnRleHRDb250ZW50ID0gJ2Nsb3NlJztcblxuICAgICAgICAvLyBhdHRhY2ggaW1hZ2UgaWYgbmVlZGVkXG4gICAgICAgIGlmIChjaGlwLmltYWdlKSB7XG4gICAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGNoaXAuaW1hZ2UpO1xuICAgICAgICAgIHJlbmRlcmVkQ2hpcC5pbnNlcnRCZWZvcmUoaW1nLCByZW5kZXJlZENoaXAuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlZENoaXAuYXBwZW5kQ2hpbGQoY2xvc2VJY29uKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpcDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW5kZXIgQ2hpcHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW5kZXJDaGlwc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJDaGlwcygpIHtcbiAgICAgICAgdGhpcy4kY2hpcHMucmVtb3ZlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlwc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpcEVsID0gdGhpcy5fcmVuZGVyQ2hpcCh0aGlzLmNoaXBzRGF0YVtpXSk7XG4gICAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGNoaXBFbCk7XG4gICAgICAgICAgdGhpcy4kY2hpcHMuYWRkKGNoaXBFbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIGlucHV0IHRvIGVuZFxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kaW5wdXRbMF0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIEF1dG9jb21wbGV0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwQXV0b2NvbXBsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwQXV0b2NvbXBsZXRlKCkge1xuICAgICAgICB2YXIgX3RoaXM0NiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmF1dG9jb21wbGV0ZU9wdGlvbnMub25BdXRvY29tcGxldGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgX3RoaXM0Ni5hZGRDaGlwKHtcbiAgICAgICAgICAgIHRhZzogdmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXM0Ni4kaW5wdXRbMF0udmFsdWUgPSAnJztcbiAgICAgICAgICBfdGhpczQ2LiRpbnB1dFswXS5mb2N1cygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlID0gTS5BdXRvY29tcGxldGUuaW5pdCh0aGlzLiRpbnB1dFswXSwgdGhpcy5vcHRpb25zLmF1dG9jb21wbGV0ZU9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIElucHV0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBJbnB1dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cElucHV0KCkge1xuICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJGVsLmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgIGlmICghdGhpcy4kaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXQgPSAkKCc8aW5wdXQ+PC9pbnB1dD4nKTtcbiAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kaW5wdXQuYWRkQ2xhc3MoJ2lucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgTGFiZWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cExhYmVsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuJGxhYmVsID0gdGhpcy4kZWwuZmluZCgnbGFiZWwnKTtcbiAgICAgICAgaWYgKHRoaXMuJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgdGhpcy4kaW5wdXQuYXR0cignaWQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgcGxhY2Vob2xkZXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRQbGFjZWhvbGRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQbGFjZWhvbGRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpcHNEYXRhICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuY2hpcHNEYXRhLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAkKHRoaXMuJGlucHV0KS5wcm9wKCdwbGFjZWhvbGRlcicsIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH0gZWxzZSBpZiAoKHRoaXMuY2hpcHNEYXRhID09PSB1bmRlZmluZWQgfHwgISF0aGlzLmNoaXBzRGF0YS5sZW5ndGgpICYmIHRoaXMub3B0aW9ucy5zZWNvbmRhcnlQbGFjZWhvbGRlcikge1xuICAgICAgICAgICQodGhpcy4kaW5wdXQpLnByb3AoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zLnNlY29uZGFyeVBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIGNoaXAgaXMgdmFsaWRcbiAgICAgICAqIEBwYXJhbSB7Y2hpcH0gY2hpcFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2lzVmFsaWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNWYWxpZChjaGlwKSB7XG4gICAgICAgIGlmIChjaGlwLmhhc093blByb3BlcnR5KCd0YWcnKSAmJiBjaGlwLnRhZyAhPT0gJycpIHtcbiAgICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaXBzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpcHNEYXRhW2ldLnRhZyA9PT0gY2hpcC50YWcpIHtcbiAgICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhZXhpc3RzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBjaGlwXG4gICAgICAgKiBAcGFyYW0ge2NoaXB9IGNoaXBcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZENoaXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDaGlwKGNoaXApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkKGNoaXApIHx8IHRoaXMuY2hpcHNEYXRhLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZWRDaGlwID0gdGhpcy5fcmVuZGVyQ2hpcChjaGlwKTtcbiAgICAgICAgdGhpcy4kY2hpcHMuYWRkKHJlbmRlcmVkQ2hpcCk7XG4gICAgICAgIHRoaXMuY2hpcHNEYXRhLnB1c2goY2hpcCk7XG4gICAgICAgICQodGhpcy4kaW5wdXQpLmJlZm9yZShyZW5kZXJlZENoaXApO1xuICAgICAgICB0aGlzLl9zZXRQbGFjZWhvbGRlcigpO1xuXG4gICAgICAgIC8vIGZpcmUgY2hpcEFkZCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNoaXBBZGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DaGlwQWRkLmNhbGwodGhpcywgdGhpcy4kZWwsIHJlbmRlcmVkQ2hpcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgY2hpcFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoaXBcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZUNoaXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDaGlwKGNoaXBJbmRleCkge1xuICAgICAgICB2YXIgJGNoaXAgPSB0aGlzLiRjaGlwcy5lcShjaGlwSW5kZXgpO1xuICAgICAgICB0aGlzLiRjaGlwcy5lcShjaGlwSW5kZXgpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLiRjaGlwcyA9IHRoaXMuJGNoaXBzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gJChlbCkuaW5kZXgoKSA+PSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlwc0RhdGEuc3BsaWNlKGNoaXBJbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX3NldFBsYWNlaG9sZGVyKCk7XG5cbiAgICAgICAgLy8gZmlyZSBjaGlwRGVsZXRlIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2hpcERlbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNoaXBEZWxldGUuY2FsbCh0aGlzLCB0aGlzLiRlbCwgJGNoaXBbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGNoaXBcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGlwXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZWxlY3RDaGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0Q2hpcChjaGlwSW5kZXgpIHtcbiAgICAgICAgdmFyICRjaGlwID0gdGhpcy4kY2hpcHMuZXEoY2hpcEluZGV4KTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRDaGlwID0gJGNoaXA7XG4gICAgICAgICRjaGlwWzBdLmZvY3VzKCk7XG5cbiAgICAgICAgLy8gZmlyZSBjaGlwU2VsZWN0IGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2hpcFNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNoaXBTZWxlY3QuY2FsbCh0aGlzLCB0aGlzLiRlbCwgJGNoaXBbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KENoaXBzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2hpcHMpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9DaGlwcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNoaXBzS2V5ZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDaGlwc0tleWRvd24oZSkge1xuICAgICAgICBDaGlwcy5fa2V5ZG93biA9IHRydWU7XG5cbiAgICAgICAgdmFyICRjaGlwcyA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jaGlwcycpO1xuICAgICAgICB2YXIgY2hpcHNLZXlkb3duID0gZS50YXJnZXQgJiYgJGNoaXBzLmxlbmd0aDtcblxuICAgICAgICAvLyBEb24ndCBoYW5kbGUga2V5ZG93biBpbnB1dHMgb24gaW5wdXQgYW5kIHRleHRhcmVhXG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnaW5wdXQsIHRleHRhcmVhJykgfHwgIWNoaXBzS2V5ZG93bikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyQ2hpcHMgPSAkY2hpcHNbMF0uTV9DaGlwcztcblxuICAgICAgICAvLyBiYWNrc3BhY2UgYW5kIGRlbGV0ZVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA4IHx8IGUua2V5Q29kZSA9PT0gNDYpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB2YXIgc2VsZWN0SW5kZXggPSBjdXJyQ2hpcHMuY2hpcHNEYXRhLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY3VyckNoaXBzLl9zZWxlY3RlZENoaXApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGN1cnJDaGlwcy5fc2VsZWN0ZWRDaGlwLmluZGV4KCk7XG4gICAgICAgICAgICBjdXJyQ2hpcHMuZGVsZXRlQ2hpcChpbmRleCk7XG4gICAgICAgICAgICBjdXJyQ2hpcHMuX3NlbGVjdGVkQ2hpcCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzZWxlY3RJbmRleCBkb2Vzbid0IGdvIG5lZ2F0aXZlXG4gICAgICAgICAgICBzZWxlY3RJbmRleCA9IE1hdGgubWF4KGluZGV4IC0gMSwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJDaGlwcy5jaGlwc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyQ2hpcHMuc2VsZWN0Q2hpcChzZWxlY3RJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGVmdCBhcnJvdyBrZXlcbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM3KSB7XG4gICAgICAgICAgaWYgKGN1cnJDaGlwcy5fc2VsZWN0ZWRDaGlwKSB7XG4gICAgICAgICAgICB2YXIgX3NlbGVjdEluZGV4ID0gY3VyckNoaXBzLl9zZWxlY3RlZENoaXAuaW5kZXgoKSAtIDE7XG4gICAgICAgICAgICBpZiAoX3NlbGVjdEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyQ2hpcHMuc2VsZWN0Q2hpcChfc2VsZWN0SW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJpZ2h0IGFycm93IGtleVxuICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgICAgICBpZiAoY3VyckNoaXBzLl9zZWxlY3RlZENoaXApIHtcbiAgICAgICAgICAgIHZhciBfc2VsZWN0SW5kZXgyID0gY3VyckNoaXBzLl9zZWxlY3RlZENoaXAuaW5kZXgoKSArIDE7XG5cbiAgICAgICAgICAgIGlmIChfc2VsZWN0SW5kZXgyID49IGN1cnJDaGlwcy5jaGlwc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGN1cnJDaGlwcy4kaW5wdXRbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJDaGlwcy5zZWxlY3RDaGlwKF9zZWxlY3RJbmRleDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBDaGlwcyBLZXl1cFxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNoaXBzS2V5dXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2hpcHNLZXl1cChlKSB7XG4gICAgICAgIENoaXBzLl9rZXlkb3duID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIENoaXBzIEJsdXJcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDaGlwc0JsdXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2hpcHNCbHVyKGUpIHtcbiAgICAgICAgaWYgKCFDaGlwcy5fa2V5ZG93bikge1xuICAgICAgICAgIHZhciAkY2hpcHMgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuY2hpcHMnKTtcbiAgICAgICAgICB2YXIgY3VyckNoaXBzID0gJGNoaXBzWzBdLk1fQ2hpcHM7XG5cbiAgICAgICAgICBjdXJyQ2hpcHMuX3NlbGVjdGVkQ2hpcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaGlwcztcbiAgfShDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBDaGlwc1xuICAgKi9cblxuXG4gIENoaXBzLl9rZXlkb3duID0gZmFsc2U7XG5cbiAgTS5DaGlwcyA9IENoaXBzO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoQ2hpcHMsICdjaGlwcycsICdNX0NoaXBzJyk7XG4gIH1cblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgLy8gSGFuZGxlIHJlbW92YWwgb2Ygc3RhdGljIGNoaXBzLlxuICAgICQoZG9jdW1lbnQuYm9keSkub24oJ2NsaWNrJywgJy5jaGlwIC5jbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkY2hpcHMgPSAkKHRoaXMpLmNsb3Nlc3QoJy5jaGlwcycpO1xuICAgICAgaWYgKCRjaGlwcy5sZW5ndGggJiYgJGNoaXBzWzBdLk1fQ2hpcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuY2hpcCcpLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9KTtcbn0pKGNhc2gpO1xuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBJbmZpbml0eSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgb25Qb3NpdGlvbkNoYW5nZTogbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICovXG5cbiAgdmFyIFB1c2hwaW4gPSBmdW5jdGlvbiAoX0NvbXBvbmVudDEzKSB7XG4gICAgX2luaGVyaXRzKFB1c2hwaW4sIF9Db21wb25lbnQxMyk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgUHVzaHBpbiBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFB1c2hwaW4oZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdXNocGluKTtcblxuICAgICAgdmFyIF90aGlzNDcgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUHVzaHBpbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFB1c2hwaW4pKS5jYWxsKHRoaXMsIFB1c2hwaW4sIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzNDcuZWwuTV9QdXNocGluID0gX3RoaXM0NztcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgbW9kYWxcbiAgICAgICAqIEBtZW1iZXIgUHVzaHBpbiNvcHRpb25zXG4gICAgICAgKi9cbiAgICAgIF90aGlzNDcub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBQdXNocGluLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgX3RoaXM0Ny5vcmlnaW5hbE9mZnNldCA9IF90aGlzNDcuZWwub2Zmc2V0VG9wO1xuICAgICAgUHVzaHBpbi5fcHVzaHBpbnMucHVzaChfdGhpczQ3KTtcbiAgICAgIF90aGlzNDcuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgX3RoaXM0Ny5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIHJldHVybiBfdGhpczQ3O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQdXNocGluLCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmVQaW5DbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcblxuICAgICAgICAvLyBSZW1vdmUgcHVzaHBpbiBJbnN0XG4gICAgICAgIHZhciBpbmRleCA9IFB1c2hwaW4uX3B1c2hwaW5zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIFB1c2hwaW4uX3B1c2hwaW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBQdXNocGluLl91cGRhdGVFbGVtZW50cyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIFB1c2hwaW4uX3VwZGF0ZUVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZVBvc2l0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICB2YXIgc2Nyb2xsZWQgPSBNLmdldERvY3VtZW50U2Nyb2xsVG9wKCkgKyB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG9wIDw9IHNjcm9sbGVkICYmIHRoaXMub3B0aW9ucy5ib3R0b20gPj0gc2Nyb2xsZWQgJiYgIXRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdwaW5uZWQnKSkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVBpbkNsYXNzZXMoKTtcbiAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRoaXMub3B0aW9ucy5vZmZzZXQgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdwaW5uZWQnKTtcblxuICAgICAgICAgIC8vIG9uUG9zaXRpb25DaGFuZ2UgY2FsbGJhY2tcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblBvc2l0aW9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub25Qb3NpdGlvbkNoYW5nZS5jYWxsKHRoaXMsICdwaW5uZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcGluLXRvcCAod2hlbiBzY3JvbGxlZCBwb3NpdGlvbiBpcyBhYm92ZSB0b3ApXG4gICAgICAgIGlmIChzY3JvbGxlZCA8IHRoaXMub3B0aW9ucy50b3AgJiYgIXRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdwaW4tdG9wJykpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVQaW5DbGFzc2VzKCk7XG4gICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSAwO1xuICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgncGluLXRvcCcpO1xuXG4gICAgICAgICAgLy8gb25Qb3NpdGlvbkNoYW5nZSBjYWxsYmFja1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uUG9zaXRpb25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblBvc2l0aW9uQ2hhbmdlLmNhbGwodGhpcywgJ3Bpbi10b3AnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcGluLWJvdHRvbSAod2hlbiBzY3JvbGxlZCBwb3NpdGlvbiBpcyBiZWxvdyBib3R0b20pXG4gICAgICAgIGlmIChzY3JvbGxlZCA+IHRoaXMub3B0aW9ucy5ib3R0b20gJiYgIXRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdwaW4tYm90dG9tJykpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVQaW5DbGFzc2VzKCk7XG4gICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdwaW4tYm90dG9tJyk7XG4gICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSB0aGlzLm9wdGlvbnMuYm90dG9tIC0gdGhpcy5vcmlnaW5hbE9mZnNldCArIFwicHhcIjtcblxuICAgICAgICAgIC8vIG9uUG9zaXRpb25DaGFuZ2UgY2FsbGJhY2tcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblBvc2l0aW9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub25Qb3NpdGlvbkNoYW5nZS5jYWxsKHRoaXMsICdwaW4tYm90dG9tJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVQaW5DbGFzc2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVBpbkNsYXNzZXMoKSB7XG4gICAgICAgIC8vIElFIDExIGJ1ZyAoY2FuJ3QgcmVtb3ZlIG11bHRpcGxlIGNsYXNzZXMgaW4gb25lIGxpbmUpXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgncGluLXRvcCcpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbm5lZCcpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbi1ib3R0b20nKTtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoUHVzaHBpbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFB1c2hwaW4pLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9QdXNocGluO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdXBkYXRlRWxlbWVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRWxlbWVudHMoKSB7XG4gICAgICAgIGZvciAodmFyIGVsSW5kZXggaW4gUHVzaHBpbi5fcHVzaHBpbnMpIHtcbiAgICAgICAgICB2YXIgcEluc3RhbmNlID0gUHVzaHBpbi5fcHVzaHBpbnNbZWxJbmRleF07XG4gICAgICAgICAgcEluc3RhbmNlLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUHVzaHBpbjtcbiAgfShDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQdXNocGluXG4gICAqL1xuXG5cbiAgUHVzaHBpbi5fcHVzaHBpbnMgPSBbXTtcblxuICBNLlB1c2hwaW4gPSBQdXNocGluO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoUHVzaHBpbiwgJ3B1c2hwaW4nLCAnTV9QdXNocGluJyk7XG4gIH1cbn0pKGNhc2gpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBkaXJlY3Rpb246ICd0b3AnLFxuICAgIGhvdmVyRW5hYmxlZDogdHJ1ZSxcbiAgICB0b29sYmFyRW5hYmxlZDogZmFsc2VcbiAgfTtcblxuICAkLmZuLnJldmVyc2UgPSBbXS5yZXZlcnNlO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICovXG5cbiAgdmFyIEZsb2F0aW5nQWN0aW9uQnV0dG9uID0gZnVuY3Rpb24gKF9Db21wb25lbnQxNCkge1xuICAgIF9pbmhlcml0cyhGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgX0NvbXBvbmVudDE0KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBGbG9hdGluZ0FjdGlvbkJ1dHRvbiBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZsb2F0aW5nQWN0aW9uQnV0dG9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxvYXRpbmdBY3Rpb25CdXR0b24pO1xuXG4gICAgICB2YXIgX3RoaXM0OCA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGbG9hdGluZ0FjdGlvbkJ1dHRvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsb2F0aW5nQWN0aW9uQnV0dG9uKSkuY2FsbCh0aGlzLCBGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXM0OC5lbC5NX0Zsb2F0aW5nQWN0aW9uQnV0dG9uID0gX3RoaXM0ODtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgZmFiXG4gICAgICAgKiBAbWVtYmVyIEZsb2F0aW5nQWN0aW9uQnV0dG9uI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbZGlyZWN0aW9uXSAtIERpcmVjdGlvbiBmYWIgbWVudSBvcGVuc1xuICAgICAgICogQHByb3Age0Jvb2xlYW59IFtob3ZlckVuYWJsZWQ9dHJ1ZV0gLSBFbmFibGUgaG92ZXIgdnMgY2xpY2tcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbdG9vbGJhckVuYWJsZWQ9ZmFsc2VdIC0gRW5hYmxlIHRvb2xiYXIgdHJhbnNpdGlvblxuICAgICAgICovXG4gICAgICBfdGhpczQ4Lm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRmxvYXRpbmdBY3Rpb25CdXR0b24uZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICBfdGhpczQ4LmlzT3BlbiA9IGZhbHNlO1xuICAgICAgX3RoaXM0OC4kYW5jaG9yID0gX3RoaXM0OC4kZWwuY2hpbGRyZW4oJ2EnKS5maXJzdCgpO1xuICAgICAgX3RoaXM0OC4kbWVudSA9IF90aGlzNDguJGVsLmNoaWxkcmVuKCd1bCcpLmZpcnN0KCk7XG4gICAgICBfdGhpczQ4LiRmbG9hdGluZ0J0bnMgPSBfdGhpczQ4LiRlbC5maW5kKCd1bCAuYnRuLWZsb2F0aW5nJyk7XG4gICAgICBfdGhpczQ4LiRmbG9hdGluZ0J0bnNSZXZlcnNlID0gX3RoaXM0OC4kZWwuZmluZCgndWwgLmJ0bi1mbG9hdGluZycpLnJldmVyc2UoKTtcbiAgICAgIF90aGlzNDgub2Zmc2V0WSA9IDA7XG4gICAgICBfdGhpczQ4Lm9mZnNldFggPSAwO1xuXG4gICAgICBfdGhpczQ4LiRlbC5hZGRDbGFzcyhcImRpcmVjdGlvbi1cIiArIF90aGlzNDgub3B0aW9ucy5kaXJlY3Rpb24pO1xuICAgICAgaWYgKF90aGlzNDgub3B0aW9ucy5kaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIF90aGlzNDgub2Zmc2V0WSA9IDQwO1xuICAgICAgfSBlbHNlIGlmIChfdGhpczQ4Lm9wdGlvbnMuZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIF90aGlzNDgub2Zmc2V0WCA9IC00MDtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXM0OC5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgX3RoaXM0OC5vZmZzZXRZID0gLTQwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXM0OC5vZmZzZXRYID0gNDA7XG4gICAgICB9XG4gICAgICBfdGhpczQ4Ll9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczQ4O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5lbC5NX0Zsb2F0aW5nQWN0aW9uQnV0dG9uID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlRkFCQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUZBQkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU9wZW5Cb3VuZCA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVDbG9zZUJvdW5kID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJFbmFibGVkICYmICF0aGlzLm9wdGlvbnMudG9vbGJhckVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9oYW5kbGVPcGVuQm91bmQpO1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZUNsb3NlQm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVGQUJDbGlja0JvdW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlckVuYWJsZWQgJiYgIXRoaXMub3B0aW9ucy50b29sYmFyRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX2hhbmRsZU9wZW5Cb3VuZCk7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5faGFuZGxlQ2xvc2VCb3VuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUZBQkNsaWNrQm91bmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIEZBQiBDbGlja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUZBQkNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUZBQkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgRG9jdW1lbnQgQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudENsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICBpZiAoISQoZS50YXJnZXQpLmNsb3Nlc3QodGhpcy4kbWVudSkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbiBGQUJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvb2xiYXJFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZUluVG9vbGJhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVJbkZBQigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBGQUJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvb2xiYXJFbmFibGVkKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZUNsb3NlQm91bmQsIHRydWUpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVPdXRUb29sYmFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU91dEZBQigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xhc3NpYyBGQUIgTWVudSBvcGVuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZUluRkFCXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJbkZBQigpIHtcbiAgICAgICAgdmFyIF90aGlzNDkgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdhY3RpdmUnKTtcblxuICAgICAgICB2YXIgdGltZSA9IDA7XG4gICAgICAgIHRoaXMuJGZsb2F0aW5nQnRuc1JldmVyc2UuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNjYWxlOiBbMC40LCAxXSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IFtfdGhpczQ5Lm9mZnNldFksIDBdLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogW190aGlzNDkub2Zmc2V0WCwgMF0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMjc1LFxuICAgICAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRpbWUgKz0gNDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsYXNzaWMgRkFCIE1lbnUgY2xvc2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlT3V0RkFCXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVPdXRGQUIoKSB7XG4gICAgICAgIHZhciBfdGhpczUwID0gdGhpcztcblxuICAgICAgICB0aGlzLiRmbG9hdGluZ0J0bnNSZXZlcnNlLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgYW5pbS5yZW1vdmUoZWwpO1xuICAgICAgICAgIGFuaW0oe1xuICAgICAgICAgICAgdGFyZ2V0czogZWwsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgc2NhbGU6IDAuNCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IF90aGlzNTAub2Zmc2V0WSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IF90aGlzNTAub2Zmc2V0WCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxNzUsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczUwLiRlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvb2xiYXIgdHJhbnNpdGlvbiBNZW51IG9wZW5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5Ub29sYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJblRvb2xiYXIoKSB7XG4gICAgICAgIHZhciBfdGhpczUxID0gdGhpcztcblxuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB2YXIgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgYnRuUmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBiYWNrZHJvcCA9ICQoJzxkaXYgY2xhc3M9XCJmYWItYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgdmFyIGZhYkNvbG9yID0gdGhpcy4kYW5jaG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICB0aGlzLiRhbmNob3IuYXBwZW5kKGJhY2tkcm9wKTtcblxuICAgICAgICB0aGlzLm9mZnNldFggPSBidG5SZWN0LmxlZnQgLSB3aW5kb3dXaWR0aCAvIDIgKyBidG5SZWN0LndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gd2luZG93SGVpZ2h0IC0gYnRuUmVjdC5ib3R0b207XG4gICAgICAgIHNjYWxlRmFjdG9yID0gd2luZG93V2lkdGggLyBiYWNrZHJvcFswXS5jbGllbnRXaWR0aDtcbiAgICAgICAgdGhpcy5idG5Cb3R0b20gPSBidG5SZWN0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5idG5MZWZ0ID0gYnRuUmVjdC5sZWZ0O1xuICAgICAgICB0aGlzLmJ0bldpZHRoID0gYnRuUmVjdC53aWR0aDtcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoJyArIHRoaXMub2Zmc2V0WCArICdweCknLFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kYW5jaG9yLmNzcyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgnICsgLXRoaXMub2Zmc2V0WSArICdweCknLFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgICAgYmFja2Ryb3AuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGZhYkNvbG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNTEuJGVsLmNzcyh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMgY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA4NSwgMC42ODAsIDAuNTMwKSwgYmFja2dyb3VuZC1jb2xvciAwcyBsaW5lYXIgLjJzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzNTEuJGFuY2hvci5jc3Moe1xuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJycsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycydcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1MS4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGZhYkNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJhY2tkcm9wLmNzcyh7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyBzY2FsZUZhY3RvciArICcpJyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMgY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA1NSwgMC42NzUsIDAuMTkwKSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXM1MS4kbWVudS5jaGlsZHJlbignbGknKS5jaGlsZHJlbignYScpLmNzcyh7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTY3JvbGwgdG8gY2xvc2UuXG4gICAgICAgICAgICBfdGhpczUxLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQgPSBfdGhpczUxLl9oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQoX3RoaXM1MSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXM1MS5faGFuZGxlQ2xvc2VCb3VuZCwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXM1MS5faGFuZGxlRG9jdW1lbnRDbGlja0JvdW5kLCB0cnVlKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb29sYmFyIHRyYW5zaXRpb24gTWVudSBjbG9zZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FuaW1hdGVPdXRUb29sYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVPdXRUb29sYmFyKCkge1xuICAgICAgICB2YXIgX3RoaXM1MiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBiYWNrZHJvcCA9IHRoaXMuJGVsLmZpbmQoJy5mYWItYmFja2Ryb3AnKTtcbiAgICAgICAgdmFyIGZhYkNvbG9yID0gdGhpcy4kYW5jaG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuXG4gICAgICAgIHRoaXMub2Zmc2V0WCA9IHRoaXMuYnRuTGVmdCAtIHdpbmRvd1dpZHRoIC8gMiArIHRoaXMuYnRuV2lkdGggLyAyO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSB3aW5kb3dIZWlnaHQgLSB0aGlzLmJ0bkJvdHRvbTtcblxuICAgICAgICAvLyBIaWRlIGJhY2tkcm9wXG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRhbmNob3IuY3NzKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGJhY2tkcm9wLmNzcyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogZmFiQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJG1lbnUuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKS5jc3Moe1xuICAgICAgICAgIG9wYWNpdHk6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJhY2tkcm9wLnJlbW92ZSgpO1xuXG4gICAgICAgICAgLy8gU2V0IGluaXRpYWwgc3RhdGUuXG4gICAgICAgICAgX3RoaXM1Mi4kZWwuY3NzKHtcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJycsXG4gICAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgICBib3R0b206ICcnLFxuICAgICAgICAgICAgbGVmdDogJycsXG4gICAgICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIC1fdGhpczUyLm9mZnNldFggKyAncHgsMCwwKSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpczUyLiRhbmNob3IuY3NzKHtcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsJyArIF90aGlzNTIub2Zmc2V0WSArICdweCwwKSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1Mi4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwwLDApJyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzNTIuJGFuY2hvci5jc3Moe1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLDAsMCknLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycyBjdWJpYy1iZXppZXIoMC41NTAsIDAuMDU1LCAwLjY3NSwgMC4xOTApJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMjApO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX2dldChGbG9hdGluZ0FjdGlvbkJ1dHRvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsb2F0aW5nQWN0aW9uQnV0dG9uKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fRmxvYXRpbmdBY3Rpb25CdXR0b247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRmxvYXRpbmdBY3Rpb25CdXR0b247XG4gIH0oQ29tcG9uZW50KTtcblxuICBNLkZsb2F0aW5nQWN0aW9uQnV0dG9uID0gRmxvYXRpbmdBY3Rpb25CdXR0b247XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgJ2Zsb2F0aW5nQWN0aW9uQnV0dG9uJywgJ01fRmxvYXRpbmdBY3Rpb25CdXR0b24nKTtcbiAgfVxufSkoY2FzaCwgTS5hbmltZSk7XG47KGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIC8vIENsb3NlIHdoZW4gZGF0ZSBpcyBzZWxlY3RlZFxuICAgIGF1dG9DbG9zZTogZmFsc2UsXG5cbiAgICAvLyB0aGUgZGVmYXVsdCBvdXRwdXQgZm9ybWF0IGZvciB0aGUgaW5wdXQgZmllbGQgdmFsdWVcbiAgICBmb3JtYXQ6ICdtbW0gZGQsIHl5eXknLFxuXG4gICAgLy8gVXNlZCB0byBjcmVhdGUgZGF0ZSBvYmplY3QgZnJvbSBjdXJyZW50IGlucHV0IHN0cmluZ1xuICAgIHBhcnNlOiBudWxsLFxuXG4gICAgLy8gVGhlIGluaXRpYWwgZGF0ZSB0byB2aWV3IHdoZW4gZmlyc3Qgb3BlbmVkXG4gICAgZGVmYXVsdERhdGU6IG51bGwsXG5cbiAgICAvLyBNYWtlIHRoZSBgZGVmYXVsdERhdGVgIHRoZSBpbml0aWFsIHNlbGVjdGVkIHZhbHVlXG4gICAgc2V0RGVmYXVsdERhdGU6IGZhbHNlLFxuXG4gICAgZGlzYWJsZVdlZWtlbmRzOiBmYWxzZSxcblxuICAgIGRpc2FibGVEYXlGbjogbnVsbCxcblxuICAgIC8vIEZpcnN0IGRheSBvZiB3ZWVrICgwOiBTdW5kYXksIDE6IE1vbmRheSBldGMpXG4gICAgZmlyc3REYXk6IDAsXG5cbiAgICAvLyBUaGUgZWFybGllc3QgZGF0ZSB0aGF0IGNhbiBiZSBzZWxlY3RlZFxuICAgIG1pbkRhdGU6IG51bGwsXG4gICAgLy8gVGhlbGF0ZXN0IGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcbiAgICBtYXhEYXRlOiBudWxsLFxuXG4gICAgLy8gTnVtYmVyIG9mIHllYXJzIGVpdGhlciBzaWRlLCBvciBhcnJheSBvZiB1cHBlci9sb3dlciByYW5nZVxuICAgIHllYXJSYW5nZTogMTAsXG5cbiAgICAvLyB1c2VkIGludGVybmFsbHkgKGRvbid0IGNvbmZpZyBvdXRzaWRlKVxuICAgIG1pblllYXI6IDAsXG4gICAgbWF4WWVhcjogOTk5OSxcbiAgICBtaW5Nb250aDogdW5kZWZpbmVkLFxuICAgIG1heE1vbnRoOiB1bmRlZmluZWQsXG5cbiAgICBzdGFydFJhbmdlOiBudWxsLFxuICAgIGVuZFJhbmdlOiBudWxsLFxuXG4gICAgaXNSVEw6IGZhbHNlLFxuXG4gICAgLy8gUmVuZGVyIHRoZSBtb250aCBhZnRlciB5ZWFyIGluIHRoZSBjYWxlbmRhciB0aXRsZVxuICAgIHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cbiAgICAvLyBSZW5kZXIgZGF5cyBvZiB0aGUgY2FsZW5kYXIgZ3JpZCB0aGF0IGZhbGwgaW4gdGhlIG5leHQgb3IgcHJldmlvdXMgbW9udGhcbiAgICBzaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBmYWxzZSxcblxuICAgIC8vIFNwZWNpZnkgYSBET00gZWxlbWVudCB0byByZW5kZXIgdGhlIGNhbGVuZGFyIGluXG4gICAgY29udGFpbmVyOiBudWxsLFxuXG4gICAgLy8gU2hvdyBjbGVhciBidXR0b25cbiAgICBzaG93Q2xlYXJCdG46IGZhbHNlLFxuXG4gICAgLy8gaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICBpMThuOiB7XG4gICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgY2xlYXI6ICdDbGVhcicsXG4gICAgICBkb25lOiAnT2snLFxuICAgICAgcHJldmlvdXNNb250aDogJ+KAuScsXG4gICAgICBuZXh0TW9udGg6ICfigLonLFxuICAgICAgbW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgIG1vbnRoc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gICAgICB3ZWVrZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICAgd2Vla2RheXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgIHdlZWtkYXlzQWJicmV2OiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVxuICAgIH0sXG5cbiAgICAvLyBldmVudHMgYXJyYXlcbiAgICBldmVudHM6IFtdLFxuXG4gICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBvblNlbGVjdDogbnVsbCxcbiAgICBvbk9wZW46IG51bGwsXG4gICAgb25DbG9zZTogbnVsbCxcbiAgICBvbkRyYXc6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBEYXRlcGlja2VyID0gZnVuY3Rpb24gKF9Db21wb25lbnQxNSkge1xuICAgIF9pbmhlcml0cyhEYXRlcGlja2VyLCBfQ29tcG9uZW50MTUpO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IERhdGVwaWNrZXIgaW5zdGFuY2UgYW5kIHNldCB1cCBvdmVybGF5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0ZXBpY2tlcihlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVwaWNrZXIpO1xuXG4gICAgICB2YXIgX3RoaXM1MyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEYXRlcGlja2VyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGF0ZXBpY2tlcikpLmNhbGwodGhpcywgRGF0ZXBpY2tlciwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXM1My5lbC5NX0RhdGVwaWNrZXIgPSBfdGhpczUzO1xuXG4gICAgICBfdGhpczUzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRGF0ZXBpY2tlci5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBpMThuIGRlZmF1bHRzIGFyZSBub3QgbG9zdCB3aGVuIG9ubHkgZmV3IGkxOG4gb3B0aW9uIHByb3BlcnRpZXMgYXJlIHBhc3NlZFxuICAgICAgaWYgKCEhb3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdpMThuJykgJiYgdHlwZW9mIG9wdGlvbnMuaTE4biA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgX3RoaXM1My5vcHRpb25zLmkxOG4gPSAkLmV4dGVuZCh7fSwgRGF0ZXBpY2tlci5kZWZhdWx0cy5pMThuLCBvcHRpb25zLmkxOG4pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGltZSBjb21wb25lbnQgZnJvbSBtaW5EYXRlIGFuZCBtYXhEYXRlIG9wdGlvbnNcbiAgICAgIGlmIChfdGhpczUzLm9wdGlvbnMubWluRGF0ZSkgX3RoaXM1My5vcHRpb25zLm1pbkRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBpZiAoX3RoaXM1My5vcHRpb25zLm1heERhdGUpIF90aGlzNTMub3B0aW9ucy5tYXhEYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgICBfdGhpczUzLmlkID0gTS5ndWlkKCk7XG5cbiAgICAgIF90aGlzNTMuX3NldHVwVmFyaWFibGVzKCk7XG4gICAgICBfdGhpczUzLl9pbnNlcnRIVE1MSW50b0RPTSgpO1xuICAgICAgX3RoaXM1My5fc2V0dXBNb2RhbCgpO1xuXG4gICAgICBfdGhpczUzLl9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcblxuICAgICAgaWYgKCFfdGhpczUzLm9wdGlvbnMuZGVmYXVsdERhdGUpIHtcbiAgICAgICAgX3RoaXM1My5vcHRpb25zLmRlZmF1bHREYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShfdGhpczUzLmVsLnZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZEYXRlID0gX3RoaXM1My5vcHRpb25zLmRlZmF1bHREYXRlO1xuICAgICAgaWYgKERhdGVwaWNrZXIuX2lzRGF0ZShkZWZEYXRlKSkge1xuICAgICAgICBpZiAoX3RoaXM1My5vcHRpb25zLnNldERlZmF1bHREYXRlKSB7XG4gICAgICAgICAgX3RoaXM1My5zZXREYXRlKGRlZkRhdGUsIHRydWUpO1xuICAgICAgICAgIF90aGlzNTMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNTMuZ290b0RhdGUoZGVmRGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzNTMuZ290b0RhdGUobmV3IERhdGUoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzY3JpYmVzIG9wZW4vY2xvc2Ugc3RhdGUgb2YgZGF0ZXBpY2tlclxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90aGlzNTMuaXNPcGVuID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM1MztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRGF0ZXBpY2tlciwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5tb2RhbC5kZXN0cm95KCk7XG4gICAgICAgICQodGhpcy5tb2RhbEVsKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95U2VsZWN0cygpO1xuICAgICAgICB0aGlzLmVsLk1fRGF0ZXBpY2tlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVzdHJveVNlbGVjdHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95U2VsZWN0cygpIHtcbiAgICAgICAgdmFyIG9sZFllYXJTZWxlY3QgPSB0aGlzLmNhbGVuZGFyRWwucXVlcnlTZWxlY3RvcignLm9yaWctc2VsZWN0LXllYXInKTtcbiAgICAgICAgaWYgKG9sZFllYXJTZWxlY3QpIHtcbiAgICAgICAgICBNLkZvcm1TZWxlY3QuZ2V0SW5zdGFuY2Uob2xkWWVhclNlbGVjdCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRNb250aFNlbGVjdCA9IHRoaXMuY2FsZW5kYXJFbC5xdWVyeVNlbGVjdG9yKCcub3JpZy1zZWxlY3QtbW9udGgnKTtcbiAgICAgICAgaWYgKG9sZE1vbnRoU2VsZWN0KSB7XG4gICAgICAgICAgTS5Gb3JtU2VsZWN0LmdldEluc3RhbmNlKG9sZE1vbnRoU2VsZWN0KS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2luc2VydEhUTUxJbnRvRE9NXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydEhUTUxJbnRvRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dDbGVhckJ0bikge1xuICAgICAgICAgICQodGhpcy5jbGVhckJ0bikuY3NzKHsgdmlzaWJpbGl0eTogJycgfSk7XG4gICAgICAgICAgdGhpcy5jbGVhckJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuaTE4bi5jbGVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9uZUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuaTE4bi5kb25lO1xuICAgICAgICB0aGlzLmNhbmNlbEJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuaTE4bi5jYW5jZWw7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgICB0aGlzLiRtb2RhbEVsLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJG1vZGFsRWwuaW5zZXJ0QmVmb3JlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cE1vZGFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwTW9kYWwoKSB7XG4gICAgICAgIHZhciBfdGhpczU0ID0gdGhpcztcblxuICAgICAgICB0aGlzLm1vZGFsRWwuaWQgPSAnbW9kYWwtJyArIHRoaXMuaWQ7XG4gICAgICAgIHRoaXMubW9kYWwgPSBNLk1vZGFsLmluaXQodGhpcy5tb2RhbEVsLCB7XG4gICAgICAgICAgb25DbG9zZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1NC5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGZvcm1hdCkge1xuICAgICAgICB2YXIgX3RoaXM1NSA9IHRoaXM7XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgIGlmICghRGF0ZXBpY2tlci5faXNEYXRlKHRoaXMuZGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybWF0QXJyYXkgPSBmb3JtYXQuc3BsaXQoLyhkezEsNH18bXsxLDR9fHl7NH18eXl8IS4pL2cpO1xuICAgICAgICB2YXIgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdEFycmF5Lm1hcChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICBpZiAoX3RoaXM1NS5mb3JtYXRzW2xhYmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNTUuZm9ybWF0c1tsYWJlbF0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkRGF0ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGUoZGF0ZSwgcHJldmVudE9uU2VsZWN0KSB7XG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgIHRoaXMuZGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyRGF0ZURpc3BsYXkoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIURhdGVwaWNrZXIuX2lzRGF0ZShkYXRlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4gPSB0aGlzLm9wdGlvbnMubWluRGF0ZSxcbiAgICAgICAgICAgIG1heCA9IHRoaXMub3B0aW9ucy5tYXhEYXRlO1xuXG4gICAgICAgIGlmIChEYXRlcGlja2VyLl9pc0RhdGUobWluKSAmJiBkYXRlIDwgbWluKSB7XG4gICAgICAgICAgZGF0ZSA9IG1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChEYXRlcGlja2VyLl9pc0RhdGUobWF4KSAmJiBkYXRlID4gbWF4KSB7XG4gICAgICAgICAgZGF0ZSA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJEYXRlRGlzcGxheSgpO1xuXG4gICAgICAgIERhdGVwaWNrZXIuX3NldFRvU3RhcnRPZkRheSh0aGlzLmRhdGUpO1xuICAgICAgICB0aGlzLmdvdG9EYXRlKHRoaXMuZGF0ZSk7XG5cbiAgICAgICAgaWYgKCFwcmV2ZW50T25TZWxlY3QgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5vblNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNlbGVjdC5jYWxsKHRoaXMsIHRoaXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0SW5wdXRWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldElucHV0VmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZWwudmFsdWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuJGVsLnRyaWdnZXIoJ2NoYW5nZScsIHsgZmlyZWRCeTogdGhpcyB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbmRlckRhdGVEaXNwbGF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckRhdGVEaXNwbGF5KCkge1xuICAgICAgICB2YXIgZGlzcGxheURhdGUgPSBEYXRlcGlja2VyLl9pc0RhdGUodGhpcy5kYXRlKSA/IHRoaXMuZGF0ZSA6IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBpMThuID0gdGhpcy5vcHRpb25zLmkxOG47XG4gICAgICAgIHZhciBkYXkgPSBpMThuLndlZWtkYXlzU2hvcnRbZGlzcGxheURhdGUuZ2V0RGF5KCldO1xuICAgICAgICB2YXIgbW9udGggPSBpMThuLm1vbnRoc1Nob3J0W2Rpc3BsYXlEYXRlLmdldE1vbnRoKCldO1xuICAgICAgICB2YXIgZGF0ZSA9IGRpc3BsYXlEYXRlLmdldERhdGUoKTtcbiAgICAgICAgdGhpcy55ZWFyVGV4dEVsLmlubmVySFRNTCA9IGRpc3BsYXlEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHRoaXMuZGF0ZVRleHRFbC5pbm5lckhUTUwgPSBkYXkgKyBcIiwgXCIgKyBtb250aCArIFwiIFwiICsgZGF0ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIGRhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdvdG9EYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ290b0RhdGUoZGF0ZSkge1xuICAgICAgICB2YXIgbmV3Q2FsZW5kYXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICghRGF0ZXBpY2tlci5faXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0VmlzaWJsZURhdGUgPSBuZXcgRGF0ZSh0aGlzLmNhbGVuZGFyc1swXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1swXS5tb250aCwgMSksXG4gICAgICAgICAgICAgIGxhc3RWaXNpYmxlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuY2FsZW5kYXJzW3RoaXMuY2FsZW5kYXJzLmxlbmd0aCAtIDFdLnllYXIsIHRoaXMuY2FsZW5kYXJzW3RoaXMuY2FsZW5kYXJzLmxlbmd0aCAtIDFdLm1vbnRoLCAxKSxcbiAgICAgICAgICAgICAgdmlzaWJsZURhdGUgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAvLyBnZXQgdGhlIGVuZCBvZiB0aGUgbW9udGhcbiAgICAgICAgICBsYXN0VmlzaWJsZURhdGUuc2V0TW9udGgobGFzdFZpc2libGVEYXRlLmdldE1vbnRoKCkgKyAxKTtcbiAgICAgICAgICBsYXN0VmlzaWJsZURhdGUuc2V0RGF0ZShsYXN0VmlzaWJsZURhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgICAgbmV3Q2FsZW5kYXIgPSB2aXNpYmxlRGF0ZSA8IGZpcnN0VmlzaWJsZURhdGUuZ2V0VGltZSgpIHx8IGxhc3RWaXNpYmxlRGF0ZS5nZXRUaW1lKCkgPCB2aXNpYmxlRGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdDYWxlbmRhcikge1xuICAgICAgICAgIHRoaXMuY2FsZW5kYXJzID0gW3tcbiAgICAgICAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkanVzdENhbGVuZGFyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENhbGVuZGFycygpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0gPSB0aGlzLmFkanVzdENhbGVuZGFyKHRoaXMuY2FsZW5kYXJzWzBdKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkanVzdENhbGVuZGFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0Q2FsZW5kYXIoY2FsZW5kYXIpIHtcbiAgICAgICAgaWYgKGNhbGVuZGFyLm1vbnRoIDwgMCkge1xuICAgICAgICAgIGNhbGVuZGFyLnllYXIgLT0gTWF0aC5jZWlsKE1hdGguYWJzKGNhbGVuZGFyLm1vbnRoKSAvIDEyKTtcbiAgICAgICAgICBjYWxlbmRhci5tb250aCArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsZW5kYXIubW9udGggPiAxMSkge1xuICAgICAgICAgIGNhbGVuZGFyLnllYXIgKz0gTWF0aC5mbG9vcihNYXRoLmFicyhjYWxlbmRhci5tb250aCkgLyAxMik7XG4gICAgICAgICAgY2FsZW5kYXIubW9udGggLT0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0TW9udGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0TW9udGgoKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoKys7XG4gICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByZXZNb250aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXZNb250aCgpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgtLTtcbiAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHllYXIsIG1vbnRoLCByYW5kSWQpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBub3cgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgZGF5cyA9IERhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSxcbiAgICAgICAgICAgIGJlZm9yZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKSxcbiAgICAgICAgICAgIGRhdGEgPSBbXSxcbiAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICBEYXRlcGlja2VyLl9zZXRUb1N0YXJ0T2ZEYXkobm93KTtcbiAgICAgICAgaWYgKG9wdHMuZmlyc3REYXkgPiAwKSB7XG4gICAgICAgICAgYmVmb3JlIC09IG9wdHMuZmlyc3REYXk7XG4gICAgICAgICAgaWYgKGJlZm9yZSA8IDApIHtcbiAgICAgICAgICAgIGJlZm9yZSArPSA3O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNNb250aCA9IG1vbnRoID09PSAwID8gMTEgOiBtb250aCAtIDEsXG4gICAgICAgICAgICBuZXh0TW9udGggPSBtb250aCA9PT0gMTEgPyAwIDogbW9udGggKyAxLFxuICAgICAgICAgICAgeWVhck9mUHJldmlvdXNNb250aCA9IG1vbnRoID09PSAwID8geWVhciAtIDEgOiB5ZWFyLFxuICAgICAgICAgICAgeWVhck9mTmV4dE1vbnRoID0gbW9udGggPT09IDExID8geWVhciArIDEgOiB5ZWFyLFxuICAgICAgICAgICAgZGF5c0luUHJldmlvdXNNb250aCA9IERhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXJPZlByZXZpb3VzTW9udGgsIHByZXZpb3VzTW9udGgpO1xuICAgICAgICB2YXIgY2VsbHMgPSBkYXlzICsgYmVmb3JlLFxuICAgICAgICAgICAgYWZ0ZXIgPSBjZWxscztcbiAgICAgICAgd2hpbGUgKGFmdGVyID4gNykge1xuICAgICAgICAgIGFmdGVyIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbHMgKz0gNyAtIGFmdGVyO1xuICAgICAgICB2YXIgaXNXZWVrU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHIgPSAwOyBpIDwgY2VsbHM7IGkrKykge1xuICAgICAgICAgIHZhciBkYXkgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSArIChpIC0gYmVmb3JlKSksXG4gICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBEYXRlcGlja2VyLl9pc0RhdGUodGhpcy5kYXRlKSA/IERhdGVwaWNrZXIuX2NvbXBhcmVEYXRlcyhkYXksIHRoaXMuZGF0ZSkgOiBmYWxzZSxcbiAgICAgICAgICAgICAgaXNUb2RheSA9IERhdGVwaWNrZXIuX2NvbXBhcmVEYXRlcyhkYXksIG5vdyksXG4gICAgICAgICAgICAgIGhhc0V2ZW50ID0gb3B0cy5ldmVudHMuaW5kZXhPZihkYXkudG9EYXRlU3RyaW5nKCkpICE9PSAtMSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgaXNFbXB0eSA9IGkgPCBiZWZvcmUgfHwgaSA+PSBkYXlzICsgYmVmb3JlLFxuICAgICAgICAgICAgICBkYXlOdW1iZXIgPSAxICsgKGkgLSBiZWZvcmUpLFxuICAgICAgICAgICAgICBtb250aE51bWJlciA9IG1vbnRoLFxuICAgICAgICAgICAgICB5ZWFyTnVtYmVyID0geWVhcixcbiAgICAgICAgICAgICAgaXNTdGFydFJhbmdlID0gb3B0cy5zdGFydFJhbmdlICYmIERhdGVwaWNrZXIuX2NvbXBhcmVEYXRlcyhvcHRzLnN0YXJ0UmFuZ2UsIGRheSksXG4gICAgICAgICAgICAgIGlzRW5kUmFuZ2UgPSBvcHRzLmVuZFJhbmdlICYmIERhdGVwaWNrZXIuX2NvbXBhcmVEYXRlcyhvcHRzLmVuZFJhbmdlLCBkYXkpLFxuICAgICAgICAgICAgICBpc0luUmFuZ2UgPSBvcHRzLnN0YXJ0UmFuZ2UgJiYgb3B0cy5lbmRSYW5nZSAmJiBvcHRzLnN0YXJ0UmFuZ2UgPCBkYXkgJiYgZGF5IDwgb3B0cy5lbmRSYW5nZSxcbiAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IG9wdHMubWluRGF0ZSAmJiBkYXkgPCBvcHRzLm1pbkRhdGUgfHwgb3B0cy5tYXhEYXRlICYmIGRheSA+IG9wdHMubWF4RGF0ZSB8fCBvcHRzLmRpc2FibGVXZWVrZW5kcyAmJiBEYXRlcGlja2VyLl9pc1dlZWtlbmQoZGF5KSB8fCBvcHRzLmRpc2FibGVEYXlGbiAmJiBvcHRzLmRpc2FibGVEYXlGbihkYXkpO1xuXG4gICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYmVmb3JlKSB7XG4gICAgICAgICAgICAgIGRheU51bWJlciA9IGRheXNJblByZXZpb3VzTW9udGggKyBkYXlOdW1iZXI7XG4gICAgICAgICAgICAgIG1vbnRoTnVtYmVyID0gcHJldmlvdXNNb250aDtcbiAgICAgICAgICAgICAgeWVhck51bWJlciA9IHllYXJPZlByZXZpb3VzTW9udGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXlOdW1iZXIgPSBkYXlOdW1iZXIgLSBkYXlzO1xuICAgICAgICAgICAgICBtb250aE51bWJlciA9IG5leHRNb250aDtcbiAgICAgICAgICAgICAgeWVhck51bWJlciA9IHllYXJPZk5leHRNb250aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF5Q29uZmlnID0ge1xuICAgICAgICAgICAgZGF5OiBkYXlOdW1iZXIsXG4gICAgICAgICAgICBtb250aDogbW9udGhOdW1iZXIsXG4gICAgICAgICAgICB5ZWFyOiB5ZWFyTnVtYmVyLFxuICAgICAgICAgICAgaGFzRXZlbnQ6IGhhc0V2ZW50LFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICAgICAgICAgIGlzVG9kYXk6IGlzVG9kYXksXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgICAgIGlzU3RhcnRSYW5nZTogaXNTdGFydFJhbmdlLFxuICAgICAgICAgICAgaXNFbmRSYW5nZTogaXNFbmRSYW5nZSxcbiAgICAgICAgICAgIGlzSW5SYW5nZTogaXNJblJhbmdlLFxuICAgICAgICAgICAgc2hvd0RheXNJbk5leHRBbmRQcmV2aW91c01vbnRoczogb3B0cy5zaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJvdy5wdXNoKHRoaXMucmVuZGVyRGF5KGRheUNvbmZpZykpO1xuXG4gICAgICAgICAgaWYgKCsrciA9PT0gNykge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMucmVuZGVyUm93KHJvdywgb3B0cy5pc1JUTCwgaXNXZWVrU2VsZWN0ZWQpKTtcbiAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgciA9IDA7XG4gICAgICAgICAgICBpc1dlZWtTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJUYWJsZShvcHRzLCBkYXRhLCByYW5kSWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJEYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJEYXkob3B0cykge1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBhcmlhU2VsZWN0ZWQgPSAnZmFsc2UnO1xuICAgICAgICBpZiAob3B0cy5pc0VtcHR5KSB7XG4gICAgICAgICAgaWYgKG9wdHMuc2hvd0RheXNJbk5leHRBbmRQcmV2aW91c01vbnRocykge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLW91dHNpZGUtY3VycmVudC1tb250aCcpO1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLXNlbGVjdGlvbi1kaXNhYmxlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImlzLWVtcHR5XCI+PC90ZD4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgYXJyLnB1c2goJ2lzLWRpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5pc1RvZGF5KSB7XG4gICAgICAgICAgYXJyLnB1c2goJ2lzLXRvZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNTZWxlY3RlZCkge1xuICAgICAgICAgIGFyci5wdXNoKCdpcy1zZWxlY3RlZCcpO1xuICAgICAgICAgIGFyaWFTZWxlY3RlZCA9ICd0cnVlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5oYXNFdmVudCkge1xuICAgICAgICAgIGFyci5wdXNoKCdoYXMtZXZlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc0luUmFuZ2UpIHtcbiAgICAgICAgICBhcnIucHVzaCgnaXMtaW5yYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzU3RhcnRSYW5nZSkge1xuICAgICAgICAgIGFyci5wdXNoKCdpcy1zdGFydHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNFbmRSYW5nZSkge1xuICAgICAgICAgIGFyci5wdXNoKCdpcy1lbmRyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjx0ZCBkYXRhLWRheT1cXFwiXCIgKyBvcHRzLmRheSArIFwiXFxcIiBjbGFzcz1cXFwiXCIgKyBhcnIuam9pbignICcpICsgXCJcXFwiIGFyaWEtc2VsZWN0ZWQ9XFxcIlwiICsgYXJpYVNlbGVjdGVkICsgXCJcXFwiPlwiICsgKFwiPGJ1dHRvbiBjbGFzcz1cXFwiZGF0ZXBpY2tlci1kYXktYnV0dG9uXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEteWVhcj1cXFwiXCIgKyBvcHRzLnllYXIgKyBcIlxcXCIgZGF0YS1tb250aD1cXFwiXCIgKyBvcHRzLm1vbnRoICsgXCJcXFwiIGRhdGEtZGF5PVxcXCJcIiArIG9wdHMuZGF5ICsgXCJcXFwiPlwiICsgb3B0cy5kYXkgKyBcIjwvYnV0dG9uPlwiKSArICc8L3RkPic7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclJvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclJvdyhkYXlzLCBpc1JUTCwgaXNSb3dTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cImRhdGVwaWNrZXItcm93JyArIChpc1Jvd1NlbGVjdGVkID8gJyBpcy1zZWxlY3RlZCcgOiAnJykgKyAnXCI+JyArIChpc1JUTCA/IGRheXMucmV2ZXJzZSgpIDogZGF5cykuam9pbignJykgKyAnPC90cj4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJUYWJsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRhYmxlKG9wdHMsIGRhdGEsIHJhbmRJZCkge1xuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXRhYmxlLXdyYXBwZXJcIj48dGFibGUgY2VsbHBhZGRpbmc9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgY2xhc3M9XCJkYXRlcGlja2VyLXRhYmxlXCIgcm9sZT1cImdyaWRcIiBhcmlhLWxhYmVsbGVkYnk9XCInICsgcmFuZElkICsgJ1wiPicgKyB0aGlzLnJlbmRlckhlYWQob3B0cykgKyB0aGlzLnJlbmRlckJvZHkoZGF0YSkgKyAnPC90YWJsZT48L2Rpdj4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJIZWFkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySGVhZChvcHRzKSB7XG4gICAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgICAgYXJyID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICBhcnIucHVzaChcIjx0aCBzY29wZT1cXFwiY29sXFxcIj48YWJiciB0aXRsZT1cXFwiXCIgKyB0aGlzLnJlbmRlckRheU5hbWUob3B0cywgaSkgKyBcIlxcXCI+XCIgKyB0aGlzLnJlbmRlckRheU5hbWUob3B0cywgaSwgdHJ1ZSkgKyBcIjwvYWJicj48L3RoPlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzx0aGVhZD48dHI+JyArIChvcHRzLmlzUlRMID8gYXJyLnJldmVyc2UoKSA6IGFycikuam9pbignJykgKyAnPC90cj48L3RoZWFkPic7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlckJvZHlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJCb2R5KHJvd3MpIHtcbiAgICAgICAgcmV0dXJuICc8dGJvZHk+JyArIHJvd3Muam9pbignJykgKyAnPC90Ym9keT4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJUaXRsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRpdGxlKGluc3RhbmNlLCBjLCB5ZWFyLCBtb250aCwgcmVmWWVhciwgcmFuZElkKSB7XG4gICAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgICAgaiA9IHZvaWQgMCxcbiAgICAgICAgICAgIGFyciA9IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBpc01pblllYXIgPSB5ZWFyID09PSBvcHRzLm1pblllYXIsXG4gICAgICAgICAgICBpc01heFllYXIgPSB5ZWFyID09PSBvcHRzLm1heFllYXIsXG4gICAgICAgICAgICBodG1sID0gJzxkaXYgaWQ9XCInICsgcmFuZElkICsgJ1wiIGNsYXNzPVwiZGF0ZXBpY2tlci1jb250cm9sc1wiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCI+JyxcbiAgICAgICAgICAgIG1vbnRoSHRtbCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHllYXJIdG1sID0gdm9pZCAwLFxuICAgICAgICAgICAgcHJldiA9IHRydWUsXG4gICAgICAgICAgICBuZXh0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGFyciA9IFtdLCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICBhcnIucHVzaCgnPG9wdGlvbiB2YWx1ZT1cIicgKyAoeWVhciA9PT0gcmVmWWVhciA/IGkgLSBjIDogMTIgKyBpIC0gYykgKyAnXCInICsgKGkgPT09IG1vbnRoID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICsgKGlzTWluWWVhciAmJiBpIDwgb3B0cy5taW5Nb250aCB8fCBpc01heFllYXIgJiYgaSA+IG9wdHMubWF4TW9udGggPyAnZGlzYWJsZWQ9XCJkaXNhYmxlZFwiJyA6ICcnKSArICc+JyArIG9wdHMuaTE4bi5tb250aHNbaV0gKyAnPC9vcHRpb24+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBtb250aEh0bWwgPSAnPHNlbGVjdCBjbGFzcz1cImRhdGVwaWNrZXItc2VsZWN0IG9yaWctc2VsZWN0LW1vbnRoXCIgdGFiaW5kZXg9XCItMVwiPicgKyBhcnIuam9pbignJykgKyAnPC9zZWxlY3Q+JztcblxuICAgICAgICBpZiAoJC5pc0FycmF5KG9wdHMueWVhclJhbmdlKSkge1xuICAgICAgICAgIGkgPSBvcHRzLnllYXJSYW5nZVswXTtcbiAgICAgICAgICBqID0gb3B0cy55ZWFyUmFuZ2VbMV0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB5ZWFyIC0gb3B0cy55ZWFyUmFuZ2U7XG4gICAgICAgICAgaiA9IDEgKyB5ZWFyICsgb3B0cy55ZWFyUmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGFyciA9IFtdOyBpIDwgaiAmJiBpIDw9IG9wdHMubWF4WWVhcjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPj0gb3B0cy5taW5ZZWFyKSB7XG4gICAgICAgICAgICBhcnIucHVzaChcIjxvcHRpb24gdmFsdWU9XFxcIlwiICsgaSArIFwiXFxcIiBcIiArIChpID09PSB5ZWFyID8gJ3NlbGVjdGVkPVwic2VsZWN0ZWRcIicgOiAnJykgKyBcIj5cIiArIGkgKyBcIjwvb3B0aW9uPlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB5ZWFySHRtbCA9IFwiPHNlbGVjdCBjbGFzcz1cXFwiZGF0ZXBpY2tlci1zZWxlY3Qgb3JpZy1zZWxlY3QteWVhclxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cIiArIGFyci5qb2luKCcnKSArIFwiPC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgdmFyIGxlZnRBcnJvdyA9ICc8c3ZnIGZpbGw9XCIjMDAwMDAwXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE1LjQxIDE2LjA5bC00LjU4LTQuNTkgNC41OC00LjU5TDE0IDUuNWwtNiA2IDYgNnpcIi8+PHBhdGggZD1cIk0wLS41aDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PC9zdmc+JztcbiAgICAgICAgaHRtbCArPSBcIjxidXR0b24gY2xhc3M9XFxcIm1vbnRoLXByZXZcIiArIChwcmV2ID8gJycgOiAnIGlzLWRpc2FibGVkJykgKyBcIlxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIiArIGxlZnRBcnJvdyArIFwiPC9idXR0b24+XCI7XG5cbiAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInNlbGVjdHMtY29udGFpbmVyXCI+JztcbiAgICAgICAgaWYgKG9wdHMuc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XG4gICAgICAgICAgaHRtbCArPSB5ZWFySHRtbCArIG1vbnRoSHRtbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBodG1sICs9IG1vbnRoSHRtbCArIHllYXJIdG1sO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG5cbiAgICAgICAgaWYgKGlzTWluWWVhciAmJiAobW9udGggPT09IDAgfHwgb3B0cy5taW5Nb250aCA+PSBtb250aCkpIHtcbiAgICAgICAgICBwcmV2ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNYXhZZWFyICYmIChtb250aCA9PT0gMTEgfHwgb3B0cy5tYXhNb250aCA8PSBtb250aCkpIHtcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmlnaHRBcnJvdyA9ICc8c3ZnIGZpbGw9XCIjMDAwMDAwXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTguNTkgMTYuMzRsNC41OC00LjU5LTQuNTgtNC41OUwxMCA1Ljc1bDYgNi02IDZ6XCIvPjxwYXRoIGQ9XCJNMC0uMjVoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz48L3N2Zz4nO1xuICAgICAgICBodG1sICs9IFwiPGJ1dHRvbiBjbGFzcz1cXFwibW9udGgtbmV4dFwiICsgKG5leHQgPyAnJyA6ICcgaXMtZGlzYWJsZWQnKSArIFwiXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiICsgcmlnaHRBcnJvdyArIFwiPC9idXR0b24+XCI7XG5cbiAgICAgICAgcmV0dXJuIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmVmcmVzaCB0aGUgSFRNTFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoZm9yY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiAmJiAhZm9yY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBtaW5ZZWFyID0gb3B0cy5taW5ZZWFyLFxuICAgICAgICAgICAgbWF4WWVhciA9IG9wdHMubWF4WWVhcixcbiAgICAgICAgICAgIG1pbk1vbnRoID0gb3B0cy5taW5Nb250aCxcbiAgICAgICAgICAgIG1heE1vbnRoID0gb3B0cy5tYXhNb250aCxcbiAgICAgICAgICAgIGh0bWwgPSAnJyxcbiAgICAgICAgICAgIHJhbmRJZCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodGhpcy5feSA8PSBtaW5ZZWFyKSB7XG4gICAgICAgICAgdGhpcy5feSA9IG1pblllYXI7XG4gICAgICAgICAgaWYgKCFpc05hTihtaW5Nb250aCkgJiYgdGhpcy5fbSA8IG1pbk1vbnRoKSB7XG4gICAgICAgICAgICB0aGlzLl9tID0gbWluTW9udGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl95ID49IG1heFllYXIpIHtcbiAgICAgICAgICB0aGlzLl95ID0gbWF4WWVhcjtcbiAgICAgICAgICBpZiAoIWlzTmFOKG1heE1vbnRoKSAmJiB0aGlzLl9tID4gbWF4TW9udGgpIHtcbiAgICAgICAgICAgIHRoaXMuX20gPSBtYXhNb250aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByYW5kSWQgPSAnZGF0ZXBpY2tlci10aXRsZS0nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikucmVwbGFjZSgvW15hLXpdKy9nLCAnJykuc3Vic3RyKDAsIDIpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMTsgYysrKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyRGF0ZURpc3BsYXkoKTtcbiAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyVGl0bGUodGhpcywgYywgdGhpcy5jYWxlbmRhcnNbY10ueWVhciwgdGhpcy5jYWxlbmRhcnNbY10ubW9udGgsIHRoaXMuY2FsZW5kYXJzWzBdLnllYXIsIHJhbmRJZCkgKyB0aGlzLnJlbmRlcih0aGlzLmNhbGVuZGFyc1tjXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1tjXS5tb250aCwgcmFuZElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVzdHJveVNlbGVjdHMoKTtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyRWwuaW5uZXJIVE1MID0gaHRtbDtcblxuICAgICAgICAvLyBJbml0IE1hdGVyaWFsaXplIFNlbGVjdFxuICAgICAgICB2YXIgeWVhclNlbGVjdCA9IHRoaXMuY2FsZW5kYXJFbC5xdWVyeVNlbGVjdG9yKCcub3JpZy1zZWxlY3QteWVhcicpO1xuICAgICAgICB2YXIgbW9udGhTZWxlY3QgPSB0aGlzLmNhbGVuZGFyRWwucXVlcnlTZWxlY3RvcignLm9yaWctc2VsZWN0LW1vbnRoJyk7XG4gICAgICAgIE0uRm9ybVNlbGVjdC5pbml0KHllYXJTZWxlY3QsIHtcbiAgICAgICAgICBjbGFzc2VzOiAnc2VsZWN0LXllYXInLFxuICAgICAgICAgIGRyb3Bkb3duT3B0aW9uczogeyBjb250YWluZXI6IGRvY3VtZW50LmJvZHksIGNvbnN0cmFpbldpZHRoOiBmYWxzZSB9XG4gICAgICAgIH0pO1xuICAgICAgICBNLkZvcm1TZWxlY3QuaW5pdChtb250aFNlbGVjdCwge1xuICAgICAgICAgIGNsYXNzZXM6ICdzZWxlY3QtbW9udGgnLFxuICAgICAgICAgIGRyb3Bkb3duT3B0aW9uczogeyBjb250YWluZXI6IGRvY3VtZW50LmJvZHksIGNvbnN0cmFpbldpZHRoOiBmYWxzZSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBjaGFuZ2UgaGFuZGxlcnMgZm9yIHNlbGVjdFxuICAgICAgICB5ZWFyU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2hhbmRsZVllYXJDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIG1vbnRoU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2hhbmRsZU1vbnRoQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uRHJhdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkRyYXcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kID0gdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2VCb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNhbGVuZGFyQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUNhbGVuZGFyQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZmluaXNoU2VsZWN0aW9uQm91bmQgPSB0aGlzLl9maW5pc2hTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlTW9udGhDaGFuZ2UgPSB0aGlzLl9oYW5kbGVNb250aENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9jbG9zZUJvdW5kID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVJbnB1dEtleWRvd25Cb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2VCb3VuZCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNhbGVuZGFyQ2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuZG9uZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNlbGVjdGlvbkJvdW5kKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbG9zZUJvdW5kKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dDbGVhckJ0bikge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUNsZWFyQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUNsZWFyQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmNsZWFyQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xlYXJDbGlja0JvdW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBWYXJpYWJsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBWYXJpYWJsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpczU2ID0gdGhpcztcblxuICAgICAgICB0aGlzLiRtb2RhbEVsID0gJChEYXRlcGlja2VyLl90ZW1wbGF0ZSk7XG4gICAgICAgIHRoaXMubW9kYWxFbCA9IHRoaXMuJG1vZGFsRWxbMF07XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhckVsID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRlcGlja2VyLWNhbGVuZGFyJyk7XG5cbiAgICAgICAgdGhpcy55ZWFyVGV4dEVsID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy55ZWFyLXRleHQnKTtcbiAgICAgICAgdGhpcy5kYXRlVGV4dEVsID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRlLXRleHQnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q2xlYXJCdG4pIHtcbiAgICAgICAgICB0aGlzLmNsZWFyQnRuID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRlcGlja2VyLWNsZWFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb25lQnRuID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRlcGlja2VyLWRvbmUnKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdG4gPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLmRhdGVwaWNrZXItY2FuY2VsJyk7XG5cbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge1xuICAgICAgICAgIGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczU2LmRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkID0gX3RoaXM1Ni5kYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAoZCA8IDEwID8gJzAnIDogJycpICsgZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNTYub3B0aW9ucy5pMThuLndlZWtkYXlzU2hvcnRbX3RoaXM1Ni5kYXRlLmdldERheSgpXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRkZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczU2Lm9wdGlvbnMuaTE4bi53ZWVrZGF5c1tfdGhpczU2LmRhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNTYuZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IF90aGlzNTYuZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgICAgIHJldHVybiAobSA8IDEwID8gJzAnIDogJycpICsgbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1tbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNTYub3B0aW9ucy5pMThuLm1vbnRoc1Nob3J0W190aGlzNTYuZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1tbW06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczU2Lm9wdGlvbnMuaTE4bi5tb250aHNbX3RoaXM1Ni5kYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoJycgKyBfdGhpczU2LmRhdGUuZ2V0RnVsbFllYXIoKSkuc2xpY2UoMik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB5eXl5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM1Ni5kYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVJbnB1dENoYW5nZUJvdW5kKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2FsZW5kYXJDbGlja0JvdW5kKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRDbGljaygpIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnB1dEtleWRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRLZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IE0ua2V5cy5FTlRFUikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ2FsZW5kYXJDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDYWxlbmRhckNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICghJHRhcmdldC5oYXNDbGFzcygnaXMtZGlzYWJsZWQnKSkge1xuICAgICAgICAgIGlmICgkdGFyZ2V0Lmhhc0NsYXNzKCdkYXRlcGlja2VyLWRheS1idXR0b24nKSAmJiAhJHRhcmdldC5oYXNDbGFzcygnaXMtZW1wdHknKSAmJiAhJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRlKG5ldyBEYXRlKGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS15ZWFyJyksIGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1tb250aCcpLCBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF5JykpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoJHRhcmdldC5jbG9zZXN0KCcubW9udGgtcHJldicpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2TW9udGgoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdCgnLm1vbnRoLW5leHQnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dE1vbnRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDbGVhckNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNsZWFyQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVNb250aENoYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVNb250aENoYW5nZShlKSB7XG4gICAgICAgIHRoaXMuZ290b01vbnRoKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVllYXJDaGFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlWWVhckNoYW5nZShlKSB7XG4gICAgICAgIHRoaXMuZ290b1llYXIoZS50YXJnZXQudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoYW5nZSB2aWV3IHRvIGEgc3BlY2lmaWMgbW9udGggKHplcm8taW5kZXgsIGUuZy4gMDogSmFudWFyeSlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdvdG9Nb250aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvdG9Nb250aChtb250aCkge1xuICAgICAgICBpZiAoIWlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoID0gcGFyc2VJbnQobW9udGgsIDEwKTtcbiAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2hhbmdlIHZpZXcgdG8gYSBzcGVjaWZpYyBmdWxsIHllYXIgKGUuZy4gXCIyMDEyXCIpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnb3RvWWVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvdG9ZZWFyKHllYXIpIHtcbiAgICAgICAgaWYgKCFpc05hTih5ZWFyKSkge1xuICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLnllYXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG4gICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW5wdXRDaGFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRDaGFuZ2UoZSkge1xuICAgICAgICB2YXIgZGF0ZSA9IHZvaWQgMDtcblxuICAgICAgICAvLyBQcmV2ZW50IGNoYW5nZSBldmVudCBmcm9tIGJlaW5nIGZpcmVkIHdoZW4gdHJpZ2dlcmVkIGJ5IHRoZSBwbHVnaW5cbiAgICAgICAgaWYgKGUuZmlyZWRCeSA9PT0gdGhpcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcnNlKSB7XG4gICAgICAgICAgZGF0ZSA9IHRoaXMub3B0aW9ucy5wYXJzZSh0aGlzLmVsLnZhbHVlLCB0aGlzLm9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZSh0aGlzLmVsLnZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGF0ZXBpY2tlci5faXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgdGhpcy5zZXREYXRlKGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlckRheU5hbWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJEYXlOYW1lKG9wdHMsIGRheSwgYWJicikge1xuICAgICAgICBkYXkgKz0gb3B0cy5maXJzdERheTtcbiAgICAgICAgd2hpbGUgKGRheSA+PSA3KSB7XG4gICAgICAgICAgZGF5IC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFiYnIgPyBvcHRzLmkxOG4ud2Vla2RheXNBYmJyZXZbZGF5XSA6IG9wdHMuaTE4bi53ZWVrZGF5c1tkYXldO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBpbnB1dCB2YWx1ZSB0byB0aGUgc2VsZWN0ZWQgZGF0ZSBhbmQgY2xvc2UgRGF0ZXBpY2tlclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ZpbmlzaFNlbGVjdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5pc2hTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbiBEYXRlcGlja2VyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvcGVuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbk9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25PcGVuLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIHRoaXMubW9kYWwub3BlbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBEYXRlcGlja2VyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNsb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RhbC5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoRGF0ZXBpY2tlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGVwaWNrZXIpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaXNEYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzRGF0ZShvYmopIHtcbiAgICAgICAgcmV0dXJuICgvRGF0ZS8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgJiYgIWlzTmFOKG9iai5nZXRUaW1lKCkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pc1dlZWtlbmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNXZWVrZW5kKGRhdGUpIHtcbiAgICAgICAgdmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIHJldHVybiBkYXkgPT09IDAgfHwgZGF5ID09PSA2O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0VG9TdGFydE9mRGF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFRvU3RhcnRPZkRheShkYXRlKSB7XG4gICAgICAgIGlmIChEYXRlcGlja2VyLl9pc0RhdGUoZGF0ZSkpIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9nZXREYXlzSW5Nb250aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gWzMxLCBEYXRlcGlja2VyLl9pc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdW21vbnRoXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2lzTGVhcFllYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIC8vIHNvbHV0aW9uIGJ5IE1hdHRpIFZpcmtrdW5lbjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDg4MTk1MVxuICAgICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY29tcGFyZURhdGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBhcmVEYXRlcyhhLCBiKSB7XG4gICAgICAgIC8vIHdlYWsgZGF0ZSBjb21wYXJpc29uICh1c2Ugc2V0VG9TdGFydE9mRGF5KGRhdGUpIHRvIGVuc3VyZSBjb3JyZWN0IHJlc3VsdClcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFRvU3RhcnRPZkRheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUb1N0YXJ0T2ZEYXkoZGF0ZSkge1xuICAgICAgICBpZiAoRGF0ZXBpY2tlci5faXNEYXRlKGRhdGUpKSBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9EYXRlcGlja2VyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGVwaWNrZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBEYXRlcGlja2VyLl90ZW1wbGF0ZSA9IFsnPGRpdiBjbGFzcz0gXCJtb2RhbCBkYXRlcGlja2VyLW1vZGFsXCI+JywgJzxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50IGRhdGVwaWNrZXItY29udGFpbmVyXCI+JywgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRhdGUtZGlzcGxheVwiPicsICc8c3BhbiBjbGFzcz1cInllYXItdGV4dFwiPjwvc3Bhbj4nLCAnPHNwYW4gY2xhc3M9XCJkYXRlLXRleHRcIj48L3NwYW4+JywgJzwvZGl2PicsICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1jYWxlbmRhci1jb250YWluZXJcIj4nLCAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY2FsZW5kYXJcIj48L2Rpdj4nLCAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZm9vdGVyXCI+JywgJzxidXR0b24gY2xhc3M9XCJidG4tZmxhdCBkYXRlcGlja2VyLWNsZWFyIHdhdmVzLWVmZmVjdFwiIHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuO1wiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nLCAnPGRpdiBjbGFzcz1cImNvbmZpcm1hdGlvbi1idG5zXCI+JywgJzxidXR0b24gY2xhc3M9XCJidG4tZmxhdCBkYXRlcGlja2VyLWNhbmNlbCB3YXZlcy1lZmZlY3RcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+JywgJzxidXR0b24gY2xhc3M9XCJidG4tZmxhdCBkYXRlcGlja2VyLWRvbmUgd2F2ZXMtZWZmZWN0XCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPicsICc8L2Rpdj4nLCAnPC9kaXY+JywgJzwvZGl2PicsICc8L2Rpdj4nLCAnPC9kaXY+J10uam9pbignJyk7XG5cbiAgTS5EYXRlcGlja2VyID0gRGF0ZXBpY2tlcjtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKERhdGVwaWNrZXIsICdkYXRlcGlja2VyJywgJ01fRGF0ZXBpY2tlcicpO1xuICB9XG59KShjYXNoKTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgZGlhbFJhZGl1czogMTM1LFxuICAgIG91dGVyUmFkaXVzOiAxMDUsXG4gICAgaW5uZXJSYWRpdXM6IDcwLFxuICAgIHRpY2tSYWRpdXM6IDIwLFxuICAgIGR1cmF0aW9uOiAzNTAsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIGRlZmF1bHRUaW1lOiAnbm93JywgLy8gZGVmYXVsdCB0aW1lLCAnbm93JyBvciAnMTM6MTQnIGUuZy5cbiAgICBmcm9tTm93OiAwLCAvLyBNaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgZGVmYXVsdFRpbWVcbiAgICBzaG93Q2xlYXJCdG46IGZhbHNlLFxuXG4gICAgLy8gaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICBpMThuOiB7XG4gICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgY2xlYXI6ICdDbGVhcicsXG4gICAgICBkb25lOiAnT2snXG4gICAgfSxcblxuICAgIGF1dG9DbG9zZTogZmFsc2UsIC8vIGF1dG8gY2xvc2Ugd2hlbiBtaW51dGUgaXMgc2VsZWN0ZWRcbiAgICB0d2VsdmVIb3VyOiB0cnVlLCAvLyBjaGFuZ2UgdG8gMTIgaG91ciBBTS9QTSBjbG9jayBmcm9tIDI0IGhvdXJcbiAgICB2aWJyYXRlOiB0cnVlLCAvLyB2aWJyYXRlIHRoZSBkZXZpY2Ugd2hlbiBkcmFnZ2luZyBjbG9jayBoYW5kXG5cbiAgICAvLyBDYWxsYmFja3NcbiAgICBvbk9wZW5TdGFydDogbnVsbCxcbiAgICBvbk9wZW5FbmQ6IG51bGwsXG4gICAgb25DbG9zZVN0YXJ0OiBudWxsLFxuICAgIG9uQ2xvc2VFbmQ6IG51bGwsXG4gICAgb25TZWxlY3Q6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBUaW1lcGlja2VyID0gZnVuY3Rpb24gKF9Db21wb25lbnQxNikge1xuICAgIF9pbmhlcml0cyhUaW1lcGlja2VyLCBfQ29tcG9uZW50MTYpO1xuXG4gICAgZnVuY3Rpb24gVGltZXBpY2tlcihlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVwaWNrZXIpO1xuXG4gICAgICB2YXIgX3RoaXM1NyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUaW1lcGlja2VyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZXBpY2tlcikpLmNhbGwodGhpcywgVGltZXBpY2tlciwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXM1Ny5lbC5NX1RpbWVwaWNrZXIgPSBfdGhpczU3O1xuXG4gICAgICBfdGhpczU3Lm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVGltZXBpY2tlci5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIF90aGlzNTcuaWQgPSBNLmd1aWQoKTtcbiAgICAgIF90aGlzNTcuX2luc2VydEhUTUxJbnRvRE9NKCk7XG4gICAgICBfdGhpczU3Ll9zZXR1cE1vZGFsKCk7XG4gICAgICBfdGhpczU3Ll9zZXR1cFZhcmlhYmxlcygpO1xuICAgICAgX3RoaXM1Ny5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgIF90aGlzNTcuX2Nsb2NrU2V0dXAoKTtcbiAgICAgIF90aGlzNTcuX3BpY2tlclNldHVwKCk7XG4gICAgICByZXR1cm4gX3RoaXM1NztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZXBpY2tlciwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5tb2RhbC5kZXN0cm95KCk7XG4gICAgICAgICQodGhpcy5tb2RhbEVsKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5lbC5NX1RpbWVwaWNrZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dEtleWRvd25Cb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVJbnB1dENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNsb2NrQ2xpY2tTdGFydEJvdW5kID0gdGhpcy5faGFuZGxlQ2xvY2tDbGlja1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlQm91bmQgPSB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrRW5kQm91bmQgPSB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrRW5kLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kKTtcbiAgICAgICAgdGhpcy5wbGF0ZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVDbG9ja0NsaWNrU3RhcnRCb3VuZCk7XG4gICAgICAgIHRoaXMucGxhdGUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZUNsb2NrQ2xpY2tTdGFydEJvdW5kKTtcblxuICAgICAgICAkKHRoaXMuc3BhbkhvdXJzKS5vbignY2xpY2snLCB0aGlzLnNob3dWaWV3LmJpbmQodGhpcywgJ2hvdXJzJykpO1xuICAgICAgICAkKHRoaXMuc3Bhbk1pbnV0ZXMpLm9uKCdjbGljaycsIHRoaXMuc2hvd1ZpZXcuYmluZCh0aGlzLCAnbWludXRlcycpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRDbGljaygpIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnB1dEtleWRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRLZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IE0ua2V5cy5FTlRFUikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ2xvY2tDbGlja1N0YXJ0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNsb2NrQ2xpY2tTdGFydChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGNsb2NrUGxhdGVCUiA9IHRoaXMucGxhdGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB7IHg6IGNsb2NrUGxhdGVCUi5sZWZ0LCB5OiBjbG9ja1BsYXRlQlIudG9wIH07XG5cbiAgICAgICAgdGhpcy54MCA9IG9mZnNldC54ICsgdGhpcy5vcHRpb25zLmRpYWxSYWRpdXM7XG4gICAgICAgIHRoaXMueTAgPSBvZmZzZXQueSArIHRoaXMub3B0aW9ucy5kaWFsUmFkaXVzO1xuICAgICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBjbGlja1BvcyA9IFRpbWVwaWNrZXIuX1BvcyhlKTtcbiAgICAgICAgdGhpcy5keCA9IGNsaWNrUG9zLnggLSB0aGlzLngwO1xuICAgICAgICB0aGlzLmR5ID0gY2xpY2tQb3MueSAtIHRoaXMueTA7XG5cbiAgICAgICAgLy8gU2V0IGNsb2NrIGhhbmRzXG4gICAgICAgIHRoaXMuc2V0SGFuZCh0aGlzLmR4LCB0aGlzLmR5LCBmYWxzZSk7XG5cbiAgICAgICAgLy8gTW91c2Vtb3ZlIG9uIGRvY3VtZW50XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlQm91bmQpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrTW92ZUJvdW5kKTtcblxuICAgICAgICAvLyBNb3VzZXVwIG9uIGRvY3VtZW50XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrRW5kQm91bmQpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tFbmRCb3VuZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudENsaWNrTW92ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVEb2N1bWVudENsaWNrTW92ZShlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGNsaWNrUG9zID0gVGltZXBpY2tlci5fUG9zKGUpO1xuICAgICAgICB2YXIgeCA9IGNsaWNrUG9zLnggLSB0aGlzLngwO1xuICAgICAgICB2YXIgeSA9IGNsaWNrUG9zLnkgLSB0aGlzLnkwO1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRIYW5kKHgsIHksIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZURvY3VtZW50Q2xpY2tFbmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRG9jdW1lbnRDbGlja0VuZChlKSB7XG4gICAgICAgIHZhciBfdGhpczU4ID0gdGhpcztcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrRW5kQm91bmQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tFbmRCb3VuZCk7XG4gICAgICAgIHZhciBjbGlja1BvcyA9IFRpbWVwaWNrZXIuX1BvcyhlKTtcbiAgICAgICAgdmFyIHggPSBjbGlja1Bvcy54IC0gdGhpcy54MDtcbiAgICAgICAgdmFyIHkgPSBjbGlja1Bvcy55IC0gdGhpcy55MDtcbiAgICAgICAgaWYgKHRoaXMubW92ZWQgJiYgeCA9PT0gdGhpcy5keCAmJiB5ID09PSB0aGlzLmR5KSB7XG4gICAgICAgICAgdGhpcy5zZXRIYW5kKHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFZpZXcgPT09ICdob3VycycpIHtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KCdtaW51dGVzJywgdGhpcy5vcHRpb25zLmR1cmF0aW9uIC8gMik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmF1dG9DbG9zZSkge1xuICAgICAgICAgICQodGhpcy5taW51dGVzVmlldykuYWRkQ2xhc3MoJ3RpbWVwaWNrZXItZGlhbC1vdXQnKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNTguZG9uZSgpO1xuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25TZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25TZWxlY3QuY2FsbCh0aGlzLCB0aGlzLmhvdXJzLCB0aGlzLm1pbnV0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5iaW5kIG1vdXNlbW92ZSBldmVudFxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrTW92ZUJvdW5kKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja01vdmVCb3VuZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pbnNlcnRIVE1MSW50b0RPTVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRIVE1MSW50b0RPTSgpIHtcbiAgICAgICAgdGhpcy4kbW9kYWxFbCA9ICQoVGltZXBpY2tlci5fdGVtcGxhdGUpO1xuICAgICAgICB0aGlzLm1vZGFsRWwgPSB0aGlzLiRtb2RhbEVsWzBdO1xuICAgICAgICB0aGlzLm1vZGFsRWwuaWQgPSAnbW9kYWwtJyArIHRoaXMuaWQ7XG5cbiAgICAgICAgLy8gQXBwZW5kIHBvcG92ZXIgdG8gaW5wdXQgYnkgZGVmYXVsdFxuICAgICAgICB2YXIgY29udGFpbmVyRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAmJiAhIWNvbnRhaW5lckVsKSB7XG4gICAgICAgICAgdGhpcy4kbW9kYWxFbC5hcHBlbmRUbyhjb250YWluZXJFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kbW9kYWxFbC5pbnNlcnRCZWZvcmUodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwTW9kYWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBNb2RhbCgpIHtcbiAgICAgICAgdmFyIF90aGlzNTkgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubW9kYWwgPSBNLk1vZGFsLmluaXQodGhpcy5tb2RhbEVsLCB7XG4gICAgICAgICAgb25PcGVuU3RhcnQ6IHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydCxcbiAgICAgICAgICBvbk9wZW5FbmQ6IHRoaXMub3B0aW9ucy5vbk9wZW5FbmQsXG4gICAgICAgICAgb25DbG9zZVN0YXJ0OiB0aGlzLm9wdGlvbnMub25DbG9zZVN0YXJ0LFxuICAgICAgICAgIG9uQ2xvc2VFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXM1OS5vcHRpb25zLm9uQ2xvc2VFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXM1OS5vcHRpb25zLm9uQ2xvc2VFbmQuY2FsbChfdGhpczU5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNTkuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwVmFyaWFibGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwVmFyaWFibGVzKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ2hvdXJzJztcbiAgICAgICAgdGhpcy52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgPyAndmlicmF0ZScgOiBuYXZpZ2F0b3Iud2Via2l0VmlicmF0ZSA/ICd3ZWJraXRWaWJyYXRlJyA6IG51bGw7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLWNhbnZhcycpO1xuICAgICAgICB0aGlzLnBsYXRlID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLXBsYXRlJyk7XG5cbiAgICAgICAgdGhpcy5ob3Vyc1ZpZXcgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItaG91cnMnKTtcbiAgICAgICAgdGhpcy5taW51dGVzVmlldyA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcudGltZXBpY2tlci1taW51dGVzJyk7XG4gICAgICAgIHRoaXMuc3BhbkhvdXJzID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLXNwYW4taG91cnMnKTtcbiAgICAgICAgdGhpcy5zcGFuTWludXRlcyA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcudGltZXBpY2tlci1zcGFuLW1pbnV0ZXMnKTtcbiAgICAgICAgdGhpcy5zcGFuQW1QbSA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcudGltZXBpY2tlci1zcGFuLWFtLXBtJyk7XG4gICAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLWZvb3RlcicpO1xuICAgICAgICB0aGlzLmFtT3JQbSA9ICdQTSc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9waWNrZXJTZXR1cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9waWNrZXJTZXR1cCgpIHtcbiAgICAgICAgdmFyICRjbGVhckJ0biA9ICQoXCI8YnV0dG9uIGNsYXNzPVxcXCJidG4tZmxhdCB0aW1lcGlja2VyLWNsZWFyIHdhdmVzLWVmZmVjdFxcXCIgc3R5bGU9XFxcInZpc2liaWxpdHk6IGhpZGRlbjtcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIlwiICsgKHRoaXMub3B0aW9ucy50d2VsdmVIb3VyID8gJzMnIDogJzEnKSArIFwiXFxcIj5cIiArIHRoaXMub3B0aW9ucy5pMThuLmNsZWFyICsgXCI8L2J1dHRvbj5cIikuYXBwZW5kVG8odGhpcy5mb290ZXIpLm9uKCdjbGljaycsIHRoaXMuY2xlYXIuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0NsZWFyQnRuKSB7XG4gICAgICAgICAgJGNsZWFyQnRuLmNzcyh7IHZpc2liaWxpdHk6ICcnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbmZpcm1hdGlvbkJ0bnNDb250YWluZXIgPSAkKCc8ZGl2IGNsYXNzPVwiY29uZmlybWF0aW9uLWJ0bnNcIj48L2Rpdj4nKTtcbiAgICAgICAgJCgnPGJ1dHRvbiBjbGFzcz1cImJ0bi1mbGF0IHRpbWVwaWNrZXItY2xvc2Ugd2F2ZXMtZWZmZWN0XCIgdHlwZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiJyArICh0aGlzLm9wdGlvbnMudHdlbHZlSG91ciA/ICczJyA6ICcxJykgKyAnXCI+JyArIHRoaXMub3B0aW9ucy5pMThuLmNhbmNlbCArICc8L2J1dHRvbj4nKS5hcHBlbmRUbyhjb25maXJtYXRpb25CdG5zQ29udGFpbmVyKS5vbignY2xpY2snLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICAkKCc8YnV0dG9uIGNsYXNzPVwiYnRuLWZsYXQgdGltZXBpY2tlci1jbG9zZSB3YXZlcy1lZmZlY3RcIiB0eXBlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCInICsgKHRoaXMub3B0aW9ucy50d2VsdmVIb3VyID8gJzMnIDogJzEnKSArICdcIj4nICsgdGhpcy5vcHRpb25zLmkxOG4uZG9uZSArICc8L2J1dHRvbj4nKS5hcHBlbmRUbyhjb25maXJtYXRpb25CdG5zQ29udGFpbmVyKS5vbignY2xpY2snLCB0aGlzLmRvbmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbmZpcm1hdGlvbkJ0bnNDb250YWluZXIuYXBwZW5kVG8odGhpcy5mb290ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2xvY2tTZXR1cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9ja1NldHVwKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR3ZWx2ZUhvdXIpIHtcbiAgICAgICAgICB0aGlzLiRhbUJ0biA9ICQoJzxkaXYgY2xhc3M9XCJhbS1idG5cIj5BTTwvZGl2PicpO1xuICAgICAgICAgIHRoaXMuJHBtQnRuID0gJCgnPGRpdiBjbGFzcz1cInBtLWJ0blwiPlBNPC9kaXY+Jyk7XG4gICAgICAgICAgdGhpcy4kYW1CdG4ub24oJ2NsaWNrJywgdGhpcy5faGFuZGxlQW1QbUNsaWNrLmJpbmQodGhpcykpLmFwcGVuZFRvKHRoaXMuc3BhbkFtUG0pO1xuICAgICAgICAgIHRoaXMuJHBtQnRuLm9uKCdjbGljaycsIHRoaXMuX2hhbmRsZUFtUG1DbGljay5iaW5kKHRoaXMpKS5hcHBlbmRUbyh0aGlzLnNwYW5BbVBtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1aWxkSG91cnNWaWV3KCk7XG4gICAgICAgIHRoaXMuX2J1aWxkTWludXRlc1ZpZXcoKTtcbiAgICAgICAgdGhpcy5fYnVpbGRTVkdDbG9jaygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYnVpbGRTVkdDbG9ja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZFNWR0Nsb2NrKCkge1xuICAgICAgICAvLyBEcmF3IGNsb2NrIGhhbmRzIGFuZCBvdGhlcnNcbiAgICAgICAgdmFyIGRpYWxSYWRpdXMgPSB0aGlzLm9wdGlvbnMuZGlhbFJhZGl1cztcbiAgICAgICAgdmFyIHRpY2tSYWRpdXMgPSB0aGlzLm9wdGlvbnMudGlja1JhZGl1cztcbiAgICAgICAgdmFyIGRpYW1ldGVyID0gZGlhbFJhZGl1cyAqIDI7XG5cbiAgICAgICAgdmFyIHN2ZyA9IFRpbWVwaWNrZXIuX2NyZWF0ZVNWR0VsKCdzdmcnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGltZXBpY2tlci1zdmcnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBkaWFtZXRlcik7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGRpYW1ldGVyKTtcbiAgICAgICAgdmFyIGcgPSBUaW1lcGlja2VyLl9jcmVhdGVTVkdFbCgnZycpO1xuICAgICAgICBnLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgZGlhbFJhZGl1cyArICcsJyArIGRpYWxSYWRpdXMgKyAnKScpO1xuICAgICAgICB2YXIgYmVhcmluZyA9IFRpbWVwaWNrZXIuX2NyZWF0ZVNWR0VsKCdjaXJjbGUnKTtcbiAgICAgICAgYmVhcmluZy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3RpbWVwaWNrZXItY2FudmFzLWJlYXJpbmcnKTtcbiAgICAgICAgYmVhcmluZy5zZXRBdHRyaWJ1dGUoJ2N4JywgMCk7XG4gICAgICAgIGJlYXJpbmcuc2V0QXR0cmlidXRlKCdjeScsIDApO1xuICAgICAgICBiZWFyaW5nLnNldEF0dHJpYnV0ZSgncicsIDQpO1xuICAgICAgICB2YXIgaGFuZCA9IFRpbWVwaWNrZXIuX2NyZWF0ZVNWR0VsKCdsaW5lJyk7XG4gICAgICAgIGhhbmQuc2V0QXR0cmlidXRlKCd4MScsIDApO1xuICAgICAgICBoYW5kLnNldEF0dHJpYnV0ZSgneTEnLCAwKTtcbiAgICAgICAgdmFyIGJnID0gVGltZXBpY2tlci5fY3JlYXRlU1ZHRWwoJ2NpcmNsZScpO1xuICAgICAgICBiZy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3RpbWVwaWNrZXItY2FudmFzLWJnJyk7XG4gICAgICAgIGJnLnNldEF0dHJpYnV0ZSgncicsIHRpY2tSYWRpdXMpO1xuICAgICAgICBnLmFwcGVuZENoaWxkKGhhbmQpO1xuICAgICAgICBnLmFwcGVuZENoaWxkKGJnKTtcbiAgICAgICAgZy5hcHBlbmRDaGlsZChiZWFyaW5nKTtcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGcpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYXBwZW5kQ2hpbGQoc3ZnKTtcblxuICAgICAgICB0aGlzLmhhbmQgPSBoYW5kO1xuICAgICAgICB0aGlzLmJnID0gYmc7XG4gICAgICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9idWlsZEhvdXJzVmlld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZEhvdXJzVmlldygpIHtcbiAgICAgICAgdmFyICR0aWNrID0gJCgnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItdGlja1wiPjwvZGl2PicpO1xuICAgICAgICAvLyBIb3VycyB2aWV3XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMTM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHRpY2sgPSAkdGljay5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHJhZGlhbiA9IGkgLyA2ICogTWF0aC5QSTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXM7XG4gICAgICAgICAgICB0aWNrLmNzcyh7XG4gICAgICAgICAgICAgIGxlZnQ6IHRoaXMub3B0aW9ucy5kaWFsUmFkaXVzICsgTWF0aC5zaW4ocmFkaWFuKSAqIHJhZGl1cyAtIHRoaXMub3B0aW9ucy50aWNrUmFkaXVzICsgJ3B4JyxcbiAgICAgICAgICAgICAgdG9wOiB0aGlzLm9wdGlvbnMuZGlhbFJhZGl1cyAtIE1hdGguY29zKHJhZGlhbikgKiByYWRpdXMgLSB0aGlzLm9wdGlvbnMudGlja1JhZGl1cyArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGljay5odG1sKGkgPT09IDAgPyAnMDAnIDogaSk7XG4gICAgICAgICAgICB0aGlzLmhvdXJzVmlldy5hcHBlbmRDaGlsZCh0aWNrWzBdKTtcbiAgICAgICAgICAgIC8vIHRpY2sub24obW91c2Vkb3duRXZlbnQsIG1vdXNlZG93bik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IDI0OyBfaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIF90aWNrID0gJHRpY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBfcmFkaWFuID0gX2kyIC8gNiAqIE1hdGguUEk7XG4gICAgICAgICAgICB2YXIgaW5uZXIgPSBfaTIgPiAwICYmIF9pMiA8IDEzO1xuICAgICAgICAgICAgdmFyIF9yYWRpdXMgPSBpbm5lciA/IHRoaXMub3B0aW9ucy5pbm5lclJhZGl1cyA6IHRoaXMub3B0aW9ucy5vdXRlclJhZGl1cztcbiAgICAgICAgICAgIF90aWNrLmNzcyh7XG4gICAgICAgICAgICAgIGxlZnQ6IHRoaXMub3B0aW9ucy5kaWFsUmFkaXVzICsgTWF0aC5zaW4oX3JhZGlhbikgKiBfcmFkaXVzIC0gdGhpcy5vcHRpb25zLnRpY2tSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgICB0b3A6IHRoaXMub3B0aW9ucy5kaWFsUmFkaXVzIC0gTWF0aC5jb3MoX3JhZGlhbikgKiBfcmFkaXVzIC0gdGhpcy5vcHRpb25zLnRpY2tSYWRpdXMgKyAncHgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aWNrLmh0bWwoX2kyID09PSAwID8gJzAwJyA6IF9pMik7XG4gICAgICAgICAgICB0aGlzLmhvdXJzVmlldy5hcHBlbmRDaGlsZChfdGlja1swXSk7XG4gICAgICAgICAgICAvLyB0aWNrLm9uKG1vdXNlZG93bkV2ZW50LCBtb3VzZWRvd24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYnVpbGRNaW51dGVzVmlld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZE1pbnV0ZXNWaWV3KCkge1xuICAgICAgICB2YXIgJHRpY2sgPSAkKCc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci10aWNrXCI+PC9kaXY+Jyk7XG4gICAgICAgIC8vIE1pbnV0ZXMgdmlld1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDYwOyBpICs9IDUpIHtcbiAgICAgICAgICB2YXIgdGljayA9ICR0aWNrLmNsb25lKCk7XG4gICAgICAgICAgdmFyIHJhZGlhbiA9IGkgLyAzMCAqIE1hdGguUEk7XG4gICAgICAgICAgdGljay5jc3Moe1xuICAgICAgICAgICAgbGVmdDogdGhpcy5vcHRpb25zLmRpYWxSYWRpdXMgKyBNYXRoLnNpbihyYWRpYW4pICogdGhpcy5vcHRpb25zLm91dGVyUmFkaXVzIC0gdGhpcy5vcHRpb25zLnRpY2tSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgdG9wOiB0aGlzLm9wdGlvbnMuZGlhbFJhZGl1cyAtIE1hdGguY29zKHJhZGlhbikgKiB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXMgLSB0aGlzLm9wdGlvbnMudGlja1JhZGl1cyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aWNrLmh0bWwoVGltZXBpY2tlci5fYWRkTGVhZGluZ1plcm8oaSkpO1xuICAgICAgICAgIHRoaXMubWludXRlc1ZpZXcuYXBwZW5kQ2hpbGQodGlja1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUFtUG1DbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVBbVBtQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGJ0bkNsaWNrZWQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5hbU9yUG0gPSAkYnRuQ2xpY2tlZC5oYXNDbGFzcygnYW0tYnRuJykgPyAnQU0nIDogJ1BNJztcbiAgICAgICAgdGhpcy5fdXBkYXRlQW1QbVZpZXcoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZUFtUG1WaWV3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFtUG1WaWV3KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR3ZWx2ZUhvdXIpIHtcbiAgICAgICAgICB0aGlzLiRhbUJ0bi50b2dnbGVDbGFzcygndGV4dC1wcmltYXJ5JywgdGhpcy5hbU9yUG0gPT09ICdBTScpO1xuICAgICAgICAgIHRoaXMuJHBtQnRuLnRvZ2dsZUNsYXNzKCd0ZXh0LXByaW1hcnknLCB0aGlzLmFtT3JQbSA9PT0gJ1BNJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZVRpbWVGcm9tSW5wdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlVGltZUZyb21JbnB1dCgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0aW1lXG4gICAgICAgIHZhciB2YWx1ZSA9ICgodGhpcy5lbC52YWx1ZSB8fCB0aGlzLm9wdGlvbnMuZGVmYXVsdFRpbWUgfHwgJycpICsgJycpLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91ciAmJiAhKHR5cGVvZiB2YWx1ZVsxXSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlWzFdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignQU0nKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYW1PclBtID0gJ0FNJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbU9yUG0gPSAnUE0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZVsxXSA9IHZhbHVlWzFdLnJlcGxhY2UoJ0FNJywgJycpLnJlcGxhY2UoJ1BNJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gJ25vdycpIHtcbiAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoK25ldyBEYXRlKCkgKyB0aGlzLm9wdGlvbnMuZnJvbU5vdyk7XG4gICAgICAgICAgdmFsdWUgPSBbbm93LmdldEhvdXJzKCksIG5vdy5nZXRNaW51dGVzKCldO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgICAgdGhpcy5hbU9yUG0gPSB2YWx1ZVswXSA+PSAxMiAmJiB2YWx1ZVswXSA8IDI0ID8gJ1BNJyA6ICdBTSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG91cnMgPSArdmFsdWVbMF0gfHwgMDtcbiAgICAgICAgdGhpcy5taW51dGVzID0gK3ZhbHVlWzFdIHx8IDA7XG4gICAgICAgIHRoaXMuc3BhbkhvdXJzLmlubmVySFRNTCA9IHRoaXMuaG91cnM7XG4gICAgICAgIHRoaXMuc3Bhbk1pbnV0ZXMuaW5uZXJIVE1MID0gVGltZXBpY2tlci5fYWRkTGVhZGluZ1plcm8odGhpcy5taW51dGVzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVBbVBtVmlldygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaG93Vmlld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dWaWV3KHZpZXcsIGRlbGF5KSB7XG4gICAgICAgIGlmICh2aWV3ID09PSAnbWludXRlcycgJiYgJCh0aGlzLmhvdXJzVmlldykuY3NzKCd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgIC8vIHJhaXNlQ2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUhvdXJTZWxlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0hvdXJzID0gdmlldyA9PT0gJ2hvdXJzJyxcbiAgICAgICAgICAgIG5leHRWaWV3ID0gaXNIb3VycyA/IHRoaXMuaG91cnNWaWV3IDogdGhpcy5taW51dGVzVmlldyxcbiAgICAgICAgICAgIGhpZGVWaWV3ID0gaXNIb3VycyA/IHRoaXMubWludXRlc1ZpZXcgOiB0aGlzLmhvdXJzVmlldztcbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHZpZXc7XG5cbiAgICAgICAgJCh0aGlzLnNwYW5Ib3VycykudG9nZ2xlQ2xhc3MoJ3RleHQtcHJpbWFyeScsIGlzSG91cnMpO1xuICAgICAgICAkKHRoaXMuc3Bhbk1pbnV0ZXMpLnRvZ2dsZUNsYXNzKCd0ZXh0LXByaW1hcnknLCAhaXNIb3Vycyk7XG5cbiAgICAgICAgLy8gVHJhbnNpdGlvbiB2aWV3XG4gICAgICAgIGhpZGVWaWV3LmNsYXNzTGlzdC5hZGQoJ3RpbWVwaWNrZXItZGlhbC1vdXQnKTtcbiAgICAgICAgJChuZXh0VmlldykuY3NzKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKS5yZW1vdmVDbGFzcygndGltZXBpY2tlci1kaWFsLW91dCcpO1xuXG4gICAgICAgIC8vIFJlc2V0IGNsb2NrIGhhbmRcbiAgICAgICAgdGhpcy5yZXNldENsb2NrKGRlbGF5KTtcblxuICAgICAgICAvLyBBZnRlciB0cmFuc2l0aW9ucyBlbmRlZFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b2dnbGVWaWV3VGltZXIpO1xuICAgICAgICB0aGlzLnRvZ2dsZVZpZXdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQoaGlkZVZpZXcpLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVzZXRDbG9ja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Q2xvY2soZGVsYXkpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmN1cnJlbnRWaWV3LFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzW3ZpZXddLFxuICAgICAgICAgICAgaXNIb3VycyA9IHZpZXcgPT09ICdob3VycycsXG4gICAgICAgICAgICB1bml0ID0gTWF0aC5QSSAvIChpc0hvdXJzID8gNiA6IDMwKSxcbiAgICAgICAgICAgIHJhZGlhbiA9IHZhbHVlICogdW5pdCxcbiAgICAgICAgICAgIHJhZGl1cyA9IGlzSG91cnMgJiYgdmFsdWUgPiAwICYmIHZhbHVlIDwgMTMgPyB0aGlzLm9wdGlvbnMuaW5uZXJSYWRpdXMgOiB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXMsXG4gICAgICAgICAgICB4ID0gTWF0aC5zaW4ocmFkaWFuKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHkgPSAtTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICQodGhpcy5jYW52YXMpLmFkZENsYXNzKCd0aW1lcGlja2VyLWNhbnZhcy1vdXQnKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoc2VsZi5jYW52YXMpLnJlbW92ZUNsYXNzKCd0aW1lcGlja2VyLWNhbnZhcy1vdXQnKTtcbiAgICAgICAgICAgIHNlbGYuc2V0SGFuZCh4LCB5KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRIYW5kKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEhhbmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIYW5kKHgsIHksIHJvdW5kQnk1KSB7XG4gICAgICAgIHZhciBfdGhpczYwID0gdGhpcztcblxuICAgICAgICB2YXIgcmFkaWFuID0gTWF0aC5hdGFuMih4LCAteSksXG4gICAgICAgICAgICBpc0hvdXJzID0gdGhpcy5jdXJyZW50VmlldyA9PT0gJ2hvdXJzJyxcbiAgICAgICAgICAgIHVuaXQgPSBNYXRoLlBJIC8gKGlzSG91cnMgfHwgcm91bmRCeTUgPyA2IDogMzApLFxuICAgICAgICAgICAgeiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KSxcbiAgICAgICAgICAgIGlubmVyID0gaXNIb3VycyAmJiB6IDwgKHRoaXMub3B0aW9ucy5vdXRlclJhZGl1cyArIHRoaXMub3B0aW9ucy5pbm5lclJhZGl1cykgLyAyLFxuICAgICAgICAgICAgcmFkaXVzID0gaW5uZXIgPyB0aGlzLm9wdGlvbnMuaW5uZXJSYWRpdXMgOiB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXM7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50d2VsdmVIb3VyKSB7XG4gICAgICAgICAgcmFkaXVzID0gdGhpcy5vcHRpb25zLm91dGVyUmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFkaWFuIHNob3VsZCBpbiByYW5nZSBbMCwgMlBJXVxuICAgICAgICBpZiAocmFkaWFuIDwgMCkge1xuICAgICAgICAgIHJhZGlhbiA9IE1hdGguUEkgKiAyICsgcmFkaWFuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSByb3VuZCB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnJvdW5kKHJhZGlhbiAvIHVuaXQpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgcm91bmQgcmFkaWFuXG4gICAgICAgIHJhZGlhbiA9IHZhbHVlICogdW5pdDtcblxuICAgICAgICAvLyBDb3JyZWN0IHRoZSBob3VycyBvciBtaW51dGVzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgIGlmIChpc0hvdXJzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHZhbHVlID0gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3VuZEJ5NSkgdmFsdWUgKj0gNTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gNjApIHZhbHVlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzSG91cnMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBpbm5lciA/IHZhbHVlID09PSAwID8gMTIgOiB2YWx1ZSA6IHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3VuZEJ5NSkge1xuICAgICAgICAgICAgICB2YWx1ZSAqPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSA2MCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25jZSBob3VycyBvciBtaW51dGVzIGNoYW5nZWQsIHZpYnJhdGUgdGhlIGRldmljZVxuICAgICAgICBpZiAodGhpc1t0aGlzLmN1cnJlbnRWaWV3XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhpcy52aWJyYXRlICYmIHRoaXMub3B0aW9ucy52aWJyYXRlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgdmlicmF0ZSB0b28gZnJlcXVlbnRseVxuICAgICAgICAgICAgaWYgKCF0aGlzLnZpYnJhdGVUaW1lcikge1xuICAgICAgICAgICAgICBuYXZpZ2F0b3JbdGhpcy52aWJyYXRlXSgxMCk7XG4gICAgICAgICAgICAgIHRoaXMudmlicmF0ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM2MC52aWJyYXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbdGhpcy5jdXJyZW50Vmlld10gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGlzSG91cnMpIHtcbiAgICAgICAgICB0aGlzWydzcGFuSG91cnMnXS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzWydzcGFuTWludXRlcyddLmlubmVySFRNTCA9IFRpbWVwaWNrZXIuX2FkZExlYWRpbmdaZXJvKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBjbG9jayBoYW5kIGFuZCBvdGhlcnMnIHBvc2l0aW9uXG4gICAgICAgIHZhciBjeDEgPSBNYXRoLnNpbihyYWRpYW4pICogKHJhZGl1cyAtIHRoaXMub3B0aW9ucy50aWNrUmFkaXVzKSxcbiAgICAgICAgICAgIGN5MSA9IC1NYXRoLmNvcyhyYWRpYW4pICogKHJhZGl1cyAtIHRoaXMub3B0aW9ucy50aWNrUmFkaXVzKSxcbiAgICAgICAgICAgIGN4MiA9IE1hdGguc2luKHJhZGlhbikgKiByYWRpdXMsXG4gICAgICAgICAgICBjeTIgPSAtTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cztcbiAgICAgICAgdGhpcy5oYW5kLnNldEF0dHJpYnV0ZSgneDInLCBjeDEpO1xuICAgICAgICB0aGlzLmhhbmQuc2V0QXR0cmlidXRlKCd5MicsIGN5MSk7XG4gICAgICAgIHRoaXMuYmcuc2V0QXR0cmlidXRlKCdjeCcsIGN4Mik7XG4gICAgICAgIHRoaXMuYmcuc2V0QXR0cmlidXRlKCdjeScsIGN5Mik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVGcm9tSW5wdXQoKTtcbiAgICAgICAgdGhpcy5zaG93VmlldygnaG91cnMnKTtcblxuICAgICAgICB0aGlzLm1vZGFsLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW9kYWwuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5pc2ggdGltZXBpY2tlciBzZWxlY3Rpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkb25lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZShlLCBjbGVhclZhbHVlKSB7XG4gICAgICAgIC8vIFNldCBpbnB1dCB2YWx1ZVxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZWwudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNsZWFyVmFsdWUgPyAnJyA6IFRpbWVwaWNrZXIuX2FkZExlYWRpbmdaZXJvKHRoaXMuaG91cnMpICsgJzonICsgVGltZXBpY2tlci5fYWRkTGVhZGluZ1plcm8odGhpcy5taW51dGVzKTtcbiAgICAgICAgdGhpcy50aW1lID0gdmFsdWU7XG4gICAgICAgIGlmICghY2xlYXJWYWx1ZSAmJiB0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyBcIiBcIiArIHRoaXMuYW1PclBtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBUcmlnZ2VyIGNoYW5nZSBldmVudFxuICAgICAgICBpZiAodmFsdWUgIT09IGxhc3QpIHtcbiAgICAgICAgICB0aGlzLiRlbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbC5mb2N1cygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmRvbmUobnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFRpbWVwaWNrZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lcGlja2VyKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FkZExlYWRpbmdaZXJvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZExlYWRpbmdaZXJvKG51bSkge1xuICAgICAgICByZXR1cm4gKG51bSA8IDEwID8gJzAnIDogJycpICsgbnVtO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlU1ZHRWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU1ZHRWwobmFtZSkge1xuICAgICAgICB2YXIgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIFggQ29vcmRpbmF0ZVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIFkgQ29vcmRpbmF0ZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHggcG9zaXRpb24gb2YgbW91c2Ugb3IgdG91Y2ggZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqIEByZXR1cm4ge1BvaW50fSB4IGFuZCB5IGxvY2F0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfUG9zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX1BvcyhlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHsgeDogZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsIHk6IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW91c2UgZXZlbnRcbiAgICAgICAgcmV0dXJuIHsgeDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fVGltZXBpY2tlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUaW1lcGlja2VyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgVGltZXBpY2tlci5fdGVtcGxhdGUgPSBbJzxkaXYgY2xhc3M9IFwibW9kYWwgdGltZXBpY2tlci1tb2RhbFwiPicsICc8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudCB0aW1lcGlja2VyLWNvbnRhaW5lclwiPicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1kaWdpdGFsLWRpc3BsYXlcIj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItdGV4dC1jb250YWluZXJcIj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItZGlzcGxheS1jb2x1bW5cIj4nLCAnPHNwYW4gY2xhc3M9XCJ0aW1lcGlja2VyLXNwYW4taG91cnMgdGV4dC1wcmltYXJ5XCI+PC9zcGFuPicsICc6JywgJzxzcGFuIGNsYXNzPVwidGltZXBpY2tlci1zcGFuLW1pbnV0ZXNcIj48L3NwYW4+JywgJzwvZGl2PicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1kaXNwbGF5LWNvbHVtbiB0aW1lcGlja2VyLWRpc3BsYXktYW0tcG1cIj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItc3Bhbi1hbS1wbVwiPjwvZGl2PicsICc8L2Rpdj4nLCAnPC9kaXY+JywgJzwvZGl2PicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1hbmFsb2ctZGlzcGxheVwiPicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1wbGF0ZVwiPicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1jYW52YXNcIj48L2Rpdj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItZGlhbCB0aW1lcGlja2VyLWhvdXJzXCI+PC9kaXY+JywgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLWRpYWwgdGltZXBpY2tlci1taW51dGVzIHRpbWVwaWNrZXItZGlhbC1vdXRcIj48L2Rpdj4nLCAnPC9kaXY+JywgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLWZvb3RlclwiPjwvZGl2PicsICc8L2Rpdj4nLCAnPC9kaXY+JywgJzwvZGl2PiddLmpvaW4oJycpO1xuXG4gIE0uVGltZXBpY2tlciA9IFRpbWVwaWNrZXI7XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihUaW1lcGlja2VyLCAndGltZXBpY2tlcicsICdNX1RpbWVwaWNrZXInKTtcbiAgfVxufSkoY2FzaCk7XG47KGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge307XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgQ2hhcmFjdGVyQ291bnRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50MTcpIHtcbiAgICBfaW5oZXJpdHMoQ2hhcmFjdGVyQ291bnRlciwgX0NvbXBvbmVudDE3KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBDaGFyYWN0ZXJDb3VudGVyIGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2hhcmFjdGVyQ291bnRlcihlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXJhY3RlckNvdW50ZXIpO1xuXG4gICAgICB2YXIgX3RoaXM2MSA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDaGFyYWN0ZXJDb3VudGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2hhcmFjdGVyQ291bnRlcikpLmNhbGwodGhpcywgQ2hhcmFjdGVyQ291bnRlciwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXM2MS5lbC5NX0NoYXJhY3RlckNvdW50ZXIgPSBfdGhpczYxO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBjaGFyYWN0ZXIgY291bnRlclxuICAgICAgICovXG4gICAgICBfdGhpczYxLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ2hhcmFjdGVyQ291bnRlci5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIF90aGlzNjEuaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICBfdGhpczYxLmlzVmFsaWRMZW5ndGggPSBmYWxzZTtcbiAgICAgIF90aGlzNjEuX3NldHVwQ291bnRlcigpO1xuICAgICAgX3RoaXM2MS5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXM2MTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2hhcmFjdGVyQ291bnRlciwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5lbC5DaGFyYWN0ZXJDb3VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZW1vdmVDb3VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVVcGRhdGVDb3VudGVyQm91bmQgPSB0aGlzLnVwZGF0ZUNvdW50ZXIuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlVXBkYXRlQ291bnRlckJvdW5kLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2hhbmRsZVVwZGF0ZUNvdW50ZXJCb3VuZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlVXBkYXRlQ291bnRlckJvdW5kLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2hhbmRsZVVwZGF0ZUNvdW50ZXJCb3VuZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgY291bnRlciBlbGVtZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBDb3VudGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwQ291bnRlcigpIHtcbiAgICAgICAgdGhpcy5jb3VudGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICQodGhpcy5jb3VudGVyRWwpLmFkZENsYXNzKCdjaGFyYWN0ZXItY291bnRlcicpLmNzcyh7XG4gICAgICAgICAgZmxvYXQ6ICdyaWdodCcsXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMnB4JyxcbiAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kZWwucGFyZW50KCkuYXBwZW5kKHRoaXMuY291bnRlckVsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgY291bnRlciBlbGVtZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlQ291bnRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVDb3VudGVyKCkge1xuICAgICAgICAkKHRoaXMuY291bnRlckVsKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgY291bnRlclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlQ291bnRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvdW50ZXIoKSB7XG4gICAgICAgIHZhciBtYXhMZW5ndGggPSArdGhpcy4kZWwuYXR0cignZGF0YS1sZW5ndGgnKSxcbiAgICAgICAgICAgIGFjdHVhbExlbmd0aCA9IHRoaXMuZWwudmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLmlzVmFsaWRMZW5ndGggPSBhY3R1YWxMZW5ndGggPD0gbWF4TGVuZ3RoO1xuICAgICAgICB2YXIgY291bnRlclN0cmluZyA9IGFjdHVhbExlbmd0aDtcblxuICAgICAgICBpZiAobWF4TGVuZ3RoKSB7XG4gICAgICAgICAgY291bnRlclN0cmluZyArPSAnLycgKyBtYXhMZW5ndGg7XG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGVJbnB1dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLmNvdW50ZXJFbCkuaHRtbChjb3VudGVyU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgdmFsaWRhdGlvbiBjbGFzc2VzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdmFsaWRhdGVJbnB1dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZUlucHV0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTGVuZ3RoICYmIHRoaXMuaXNJbnZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5pc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnaW52YWxpZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzVmFsaWRMZW5ndGggJiYgIXRoaXMuaXNJbnZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5pc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCd2YWxpZCcpO1xuICAgICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoQ2hhcmFjdGVyQ291bnRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENoYXJhY3RlckNvdW50ZXIpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9DaGFyYWN0ZXJDb3VudGVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENoYXJhY3RlckNvdW50ZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBNLkNoYXJhY3RlckNvdW50ZXIgPSBDaGFyYWN0ZXJDb3VudGVyO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoQ2hhcmFjdGVyQ291bnRlciwgJ2NoYXJhY3RlckNvdW50ZXInLCAnTV9DaGFyYWN0ZXJDb3VudGVyJyk7XG4gIH1cbn0pKGNhc2gpO1xuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBkdXJhdGlvbjogMjAwLCAvLyBtc1xuICAgIGRpc3Q6IC0xMDAsIC8vIHpvb20gc2NhbGUgVE9ETzogbWFrZSB0aGlzIG1vcmUgaW50dWl0aXZlIGFzIGFuIG9wdGlvblxuICAgIHNoaWZ0OiAwLCAvLyBzcGFjaW5nIGZvciBjZW50ZXIgaW1hZ2VcbiAgICBwYWRkaW5nOiAwLCAvLyBQYWRkaW5nIGJldHdlZW4gbm9uIGNlbnRlciBpdGVtc1xuICAgIG51bVZpc2libGU6IDUsIC8vIE51bWJlciBvZiB2aXNpYmxlIGl0ZW1zIGluIGNhcm91c2VsXG4gICAgZnVsbFdpZHRoOiBmYWxzZSwgLy8gQ2hhbmdlIHRvIGZ1bGwgd2lkdGggc3R5bGVzXG4gICAgaW5kaWNhdG9yczogZmFsc2UsIC8vIFRvZ2dsZSBpbmRpY2F0b3JzXG4gICAgbm9XcmFwOiBmYWxzZSwgLy8gRG9uJ3Qgd3JhcCBhcm91bmQgYW5kIGN5Y2xlIHRocm91Z2ggaXRlbXMuXG4gICAgb25DeWNsZVRvOiBudWxsIC8vIENhbGxiYWNrIGZvciB3aGVuIGEgbmV3IHNsaWRlIGlzIGN5Y2xlZCB0by5cbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50MTgpIHtcbiAgICBfaW5oZXJpdHMoQ2Fyb3VzZWwsIF9Db21wb25lbnQxOCk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgQ2Fyb3VzZWwgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcm91c2VsKTtcblxuICAgICAgdmFyIF90aGlzNjIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2Fyb3VzZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDYXJvdXNlbCkpLmNhbGwodGhpcywgQ2Fyb3VzZWwsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzNjIuZWwuTV9DYXJvdXNlbCA9IF90aGlzNjI7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIGNhcm91c2VsXG4gICAgICAgKiBAbWVtYmVyIENhcm91c2VsI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBkaXN0XG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBzaGlmdFxuICAgICAgICogQHByb3Age051bWJlcn0gcGFkZGluZ1xuICAgICAgICogQHByb3Age051bWJlcn0gbnVtVmlzaWJsZVxuICAgICAgICogQHByb3Age0Jvb2xlYW59IGZ1bGxXaWR0aFxuICAgICAgICogQHByb3Age0Jvb2xlYW59IGluZGljYXRvcnNcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBub1dyYXBcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25DeWNsZVRvXG4gICAgICAgKi9cbiAgICAgIF90aGlzNjIub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDYXJvdXNlbC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldHVwXG4gICAgICBfdGhpczYyLmhhc011bHRpcGxlU2xpZGVzID0gX3RoaXM2Mi4kZWwuZmluZCgnLmNhcm91c2VsLWl0ZW0nKS5sZW5ndGggPiAxO1xuICAgICAgX3RoaXM2Mi5zaG93SW5kaWNhdG9ycyA9IF90aGlzNjIub3B0aW9ucy5pbmRpY2F0b3JzICYmIF90aGlzNjIuaGFzTXVsdGlwbGVTbGlkZXM7XG4gICAgICBfdGhpczYyLm5vV3JhcCA9IF90aGlzNjIub3B0aW9ucy5ub1dyYXAgfHwgIV90aGlzNjIuaGFzTXVsdGlwbGVTbGlkZXM7XG4gICAgICBfdGhpczYyLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzNjIuZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgX3RoaXM2Mi5vZmZzZXQgPSBfdGhpczYyLnRhcmdldCA9IDA7XG4gICAgICBfdGhpczYyLmltYWdlcyA9IFtdO1xuICAgICAgX3RoaXM2Mi5pdGVtV2lkdGggPSBfdGhpczYyLiRlbC5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLmZpcnN0KCkuaW5uZXJXaWR0aCgpO1xuICAgICAgX3RoaXM2Mi5pdGVtSGVpZ2h0ID0gX3RoaXM2Mi4kZWwuZmluZCgnLmNhcm91c2VsLWl0ZW0nKS5maXJzdCgpLmlubmVySGVpZ2h0KCk7XG4gICAgICBfdGhpczYyLmRpbSA9IF90aGlzNjIuaXRlbVdpZHRoICogMiArIF90aGlzNjIub3B0aW9ucy5wYWRkaW5nIHx8IDE7IC8vIE1ha2Ugc3VyZSBkaW0gaXMgbm9uIHplcm8gZm9yIGRpdmlzaW9ucy5cbiAgICAgIF90aGlzNjIuX2F1dG9TY3JvbGxCb3VuZCA9IF90aGlzNjIuX2F1dG9TY3JvbGwuYmluZChfdGhpczYyKTtcbiAgICAgIF90aGlzNjIuX3RyYWNrQm91bmQgPSBfdGhpczYyLl90cmFjay5iaW5kKF90aGlzNjIpO1xuXG4gICAgICAvLyBGdWxsIFdpZHRoIGNhcm91c2VsIHNldHVwXG4gICAgICBpZiAoX3RoaXM2Mi5vcHRpb25zLmZ1bGxXaWR0aCkge1xuICAgICAgICBfdGhpczYyLm9wdGlvbnMuZGlzdCA9IDA7XG4gICAgICAgIF90aGlzNjIuX3NldENhcm91c2VsSGVpZ2h0KCk7XG5cbiAgICAgICAgLy8gT2Zmc2V0IGZpeGVkIGl0ZW1zIHdoZW4gaW5kaWNhdG9ycy5cbiAgICAgICAgaWYgKF90aGlzNjIuc2hvd0luZGljYXRvcnMpIHtcbiAgICAgICAgICBfdGhpczYyLiRlbC5maW5kKCcuY2Fyb3VzZWwtZml4ZWQtaXRlbScpLmFkZENsYXNzKCd3aXRoLWluZGljYXRvcnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggc2xpZGVzXG4gICAgICBfdGhpczYyLiRpbmRpY2F0b3JzID0gJCgnPHVsIGNsYXNzPVwiaW5kaWNhdG9yc1wiPjwvdWw+Jyk7XG4gICAgICBfdGhpczYyLiRlbC5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLmVhY2goZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgIF90aGlzNjIuaW1hZ2VzLnB1c2goZWwpO1xuICAgICAgICBpZiAoX3RoaXM2Mi5zaG93SW5kaWNhdG9ycykge1xuICAgICAgICAgIHZhciAkaW5kaWNhdG9yID0gJCgnPGxpIGNsYXNzPVwiaW5kaWNhdG9yLWl0ZW1cIj48L2xpPicpO1xuXG4gICAgICAgICAgLy8gQWRkIGFjdGl2ZSB0byBmaXJzdCBieSBkZWZhdWx0LlxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAkaW5kaWNhdG9yWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNjIuJGluZGljYXRvcnMuYXBwZW5kKCRpbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChfdGhpczYyLnNob3dJbmRpY2F0b3JzKSB7XG4gICAgICAgIF90aGlzNjIuJGVsLmFwcGVuZChfdGhpczYyLiRpbmRpY2F0b3JzKTtcbiAgICAgIH1cbiAgICAgIF90aGlzNjIuY291bnQgPSBfdGhpczYyLmltYWdlcy5sZW5ndGg7XG5cbiAgICAgIC8vIENhcCBudW1WaXNpYmxlIGF0IGNvdW50XG4gICAgICBfdGhpczYyLm9wdGlvbnMubnVtVmlzaWJsZSA9IE1hdGgubWluKF90aGlzNjIuY291bnQsIF90aGlzNjIub3B0aW9ucy5udW1WaXNpYmxlKTtcblxuICAgICAgLy8gU2V0dXAgY3Jvc3MgYnJvd3NlciBzdHJpbmdcbiAgICAgIF90aGlzNjIueGZvcm0gPSAndHJhbnNmb3JtJztcbiAgICAgIFsnd2Via2l0JywgJ01veicsICdPJywgJ21zJ10uZXZlcnkoZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICB2YXIgZSA9IHByZWZpeCArICdUcmFuc2Zvcm0nO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgX3RoaXM2Mi54Zm9ybSA9IGU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzNjIuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgX3RoaXM2Mi5fc2Nyb2xsKF90aGlzNjIub2Zmc2V0KTtcbiAgICAgIHJldHVybiBfdGhpczYyO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDYXJvdXNlbCwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5lbC5NX0Nhcm91c2VsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNjMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZUNhcm91c2VsVGFwQm91bmQgPSB0aGlzLl9oYW5kbGVDYXJvdXNlbFRhcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVDYXJvdXNlbERyYWdCb3VuZCA9IHRoaXMuX2hhbmRsZUNhcm91c2VsRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVDYXJvdXNlbFJlbGVhc2VCb3VuZCA9IHRoaXMuX2hhbmRsZUNhcm91c2VsUmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVDYXJvdXNlbENsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVDYXJvdXNlbENsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZUNhcm91c2VsVGFwQm91bmQpO1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlQ2Fyb3VzZWxEcmFnQm91bmQpO1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVDYXJvdXNlbFJlbGVhc2VCb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZUNhcm91c2VsVGFwQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUNhcm91c2VsRHJhZ0JvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlQ2Fyb3VzZWxSZWxlYXNlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9oYW5kbGVDYXJvdXNlbFJlbGVhc2VCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDYXJvdXNlbENsaWNrQm91bmQpO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3dJbmRpY2F0b3JzICYmIHRoaXMuJGluZGljYXRvcnMpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVJbmRpY2F0b3JDbGlja0JvdW5kID0gdGhpcy5faGFuZGxlSW5kaWNhdG9yQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLiRpbmRpY2F0b3JzLmZpbmQoJy5pbmRpY2F0b3ItaXRlbScpLmVhY2goZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzNjMuX2hhbmRsZUluZGljYXRvckNsaWNrQm91bmQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzaXplXG4gICAgICAgIHZhciB0aHJvdHRsZWRSZXNpemUgPSBNLnRocm90dGxlKHRoaXMuX2hhbmRsZVJlc2l6ZSwgMjAwKTtcbiAgICAgICAgdGhpcy5faGFuZGxlVGhyb3R0bGVkUmVzaXplQm91bmQgPSB0aHJvdHRsZWRSZXNpemUuYmluZCh0aGlzKTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5faGFuZGxlVGhyb3R0bGVkUmVzaXplQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNjQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVDYXJvdXNlbFRhcEJvdW5kKTtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUNhcm91c2VsRHJhZ0JvdW5kKTtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlQ2Fyb3VzZWxSZWxlYXNlQm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlQ2Fyb3VzZWxUYXBCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlQ2Fyb3VzZWxEcmFnQm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVDYXJvdXNlbFJlbGVhc2VCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZUNhcm91c2VsUmVsZWFzZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNhcm91c2VsQ2xpY2tCb3VuZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd0luZGljYXRvcnMgJiYgdGhpcy4kaW5kaWNhdG9ycykge1xuICAgICAgICAgIHRoaXMuJGluZGljYXRvcnMuZmluZCgnLmluZGljYXRvci1pdGVtJykuZWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXM2NC5faGFuZGxlSW5kaWNhdG9yQ2xpY2tCb3VuZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5faGFuZGxlVGhyb3R0bGVkUmVzaXplQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBDYXJvdXNlbCBUYXBcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDYXJvdXNlbFRhcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDYXJvdXNlbFRhcChlKSB7XG4gICAgICAgIC8vIEZpeGVzIGZpcmVmb3ggZHJhZ2dhYmxlIGltYWdlIGJ1Z1xuICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiAkKGUudGFyZ2V0KS5pcygnaW1nJykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmVydGljYWxEcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gdGhpcy5feHBvcyhlKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VZID0gdGhpcy5feXBvcyhlKTtcblxuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5hbXBsaXR1ZGUgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpY2tlcik7XG4gICAgICAgIHRoaXMudGlja2VyID0gc2V0SW50ZXJ2YWwodGhpcy5fdHJhY2tCb3VuZCwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgQ2Fyb3VzZWwgRHJhZ1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNhcm91c2VsRHJhZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDYXJvdXNlbERyYWcoZSkge1xuICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBkZWx0YSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGRlbHRhWSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICAgIHggPSB0aGlzLl94cG9zKGUpO1xuICAgICAgICAgIHkgPSB0aGlzLl95cG9zKGUpO1xuICAgICAgICAgIGRlbHRhID0gdGhpcy5yZWZlcmVuY2UgLSB4O1xuICAgICAgICAgIGRlbHRhWSA9IE1hdGguYWJzKHRoaXMucmVmZXJlbmNlWSAtIHkpO1xuICAgICAgICAgIGlmIChkZWx0YVkgPCAzMCAmJiAhdGhpcy52ZXJ0aWNhbERyYWdnZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHZlcnRpY2FsIHNjcm9sbGluZyBkb24ndCBhbGxvdyBkcmFnZ2luZy5cbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDIgfHwgZGVsdGEgPCAtMikge1xuICAgICAgICAgICAgICB0aGlzLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHg7XG4gICAgICAgICAgICAgIHRoaXMuX3Njcm9sbCh0aGlzLm9mZnNldCArIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZHJhZ2dlZCkge1xuICAgICAgICAgICAgLy8gSWYgZHJhZ2dpbmcgZG9uJ3QgYWxsb3cgdmVydGljYWwgc2Nyb2xsLlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVmVydGljYWwgc2Nyb2xsaW5nLlxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWQpIHtcbiAgICAgICAgICAvLyBJZiBkcmFnZ2luZyBkb24ndCBhbGxvdyB2ZXJ0aWNhbCBzY3JvbGwuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIENhcm91c2VsIFJlbGVhc2VcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDYXJvdXNlbFJlbGVhc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2Fyb3VzZWxSZWxlYXNlKGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aWNrZXIpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eSA+IDEwIHx8IHRoaXMudmVsb2NpdHkgPCAtMTApIHtcbiAgICAgICAgICB0aGlzLmFtcGxpdHVkZSA9IDAuOSAqIHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLm9mZnNldCArIHRoaXMuYW1wbGl0dWRlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gTWF0aC5yb3VuZCh0aGlzLnRhcmdldCAvIHRoaXMuZGltKSAqIHRoaXMuZGltO1xuXG4gICAgICAgIC8vIE5vIHdyYXAgb2YgaXRlbXMuXG4gICAgICAgIGlmICh0aGlzLm5vV3JhcCkge1xuICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA+PSB0aGlzLmRpbSAqICh0aGlzLmNvdW50IC0gMSkpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5kaW0gKiAodGhpcy5jb3VudCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW1wbGl0dWRlID0gdGhpcy50YXJnZXQgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYXV0b1Njcm9sbEJvdW5kKTtcblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBDYXJvdXNlbCBDTGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNhcm91c2VsQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2Fyb3VzZWxDbGljayhlKSB7XG4gICAgICAgIC8vIERpc2FibGUgY2xpY2tzIGlmIGNhcm91c2VsIHdhcyBkcmFnZ2VkLlxuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKSB7XG4gICAgICAgICAgdmFyIGNsaWNrZWRJbmRleCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jYXJvdXNlbC1pdGVtJykuaW5kZXgoKTtcbiAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMuX3dyYXAodGhpcy5jZW50ZXIpIC0gY2xpY2tlZEluZGV4O1xuXG4gICAgICAgICAgLy8gRGlzYWJsZSBjbGlja3MgaWYgY2Fyb3VzZWwgd2FzIHNoaWZ0ZWQgYnkgY2xpY2tcbiAgICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3ljbGVUbyhjbGlja2VkSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIEluZGljYXRvciBDTGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUluZGljYXRvckNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUluZGljYXRvckNsaWNrKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB2YXIgaW5kaWNhdG9yID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLmluZGljYXRvci1pdGVtJyk7XG4gICAgICAgIGlmIChpbmRpY2F0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fY3ljbGVUbyhpbmRpY2F0b3IuaW5kZXgoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgVGhyb3R0bGUgUmVzaXplXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlUmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJlc2l6ZShlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKSB7XG4gICAgICAgICAgdGhpcy5pdGVtV2lkdGggPSB0aGlzLiRlbC5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLmZpcnN0KCkuaW5uZXJXaWR0aCgpO1xuICAgICAgICAgIHRoaXMuaW1hZ2VIZWlnaHQgPSB0aGlzLiRlbC5maW5kKCcuY2Fyb3VzZWwtaXRlbS5hY3RpdmUnKS5oZWlnaHQoKTtcbiAgICAgICAgICB0aGlzLmRpbSA9IHRoaXMuaXRlbVdpZHRoICogMiArIHRoaXMub3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5jZW50ZXIgKiAyICogdGhpcy5pdGVtV2lkdGg7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICB0aGlzLl9zZXRDYXJvdXNlbEhlaWdodCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBjYXJvdXNlbCBoZWlnaHQgYmFzZWQgb24gZmlyc3Qgc2xpZGVcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbX0gaW1hZ2VPbmx5IC0gdHJ1ZSBmb3IgaW1hZ2Ugc2xpZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0Q2Fyb3VzZWxIZWlnaHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q2Fyb3VzZWxIZWlnaHQoaW1hZ2VPbmx5KSB7XG4gICAgICAgIHZhciBfdGhpczY1ID0gdGhpcztcblxuICAgICAgICB2YXIgZmlyc3RTbGlkZSA9IHRoaXMuJGVsLmZpbmQoJy5jYXJvdXNlbC1pdGVtLmFjdGl2ZScpLmxlbmd0aCA/IHRoaXMuJGVsLmZpbmQoJy5jYXJvdXNlbC1pdGVtLmFjdGl2ZScpLmZpcnN0KCkgOiB0aGlzLiRlbC5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLmZpcnN0KCk7XG4gICAgICAgIHZhciBmaXJzdEltYWdlID0gZmlyc3RTbGlkZS5maW5kKCdpbWcnKS5maXJzdCgpO1xuICAgICAgICBpZiAoZmlyc3RJbWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZmlyc3RJbWFnZVswXS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gSWYgaW1hZ2Ugd29uJ3QgdHJpZ2dlciB0aGUgbG9hZCBldmVudFxuICAgICAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gZmlyc3RJbWFnZS5oZWlnaHQoKTtcbiAgICAgICAgICAgIGlmIChpbWFnZUhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy4kZWwuY3NzKCdoZWlnaHQnLCBpbWFnZUhlaWdodCArICdweCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSWYgaW1hZ2Ugc3RpbGwgaGFzIG5vIGhlaWdodCwgdXNlIHRoZSBuYXR1cmFsIGRpbWVuc2lvbnMgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSBmaXJzdEltYWdlWzBdLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSBmaXJzdEltYWdlWzBdLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgIHZhciBhZGp1c3RlZEhlaWdodCA9IHRoaXMuJGVsLndpZHRoKCkgLyBuYXR1cmFsV2lkdGggKiBuYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICB0aGlzLiRlbC5jc3MoJ2hlaWdodCcsIGFkanVzdGVkSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdldCBoZWlnaHQgd2hlbiBpbWFnZSBpcyBsb2FkZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIGZpcnN0SW1hZ2Uub25lKCdsb2FkJywgZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgICAgIF90aGlzNjUuJGVsLmNzcygnaGVpZ2h0JywgZWwub2Zmc2V0SGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWltYWdlT25seSkge1xuICAgICAgICAgIHZhciBzbGlkZUhlaWdodCA9IGZpcnN0U2xpZGUuaGVpZ2h0KCk7XG4gICAgICAgICAgdGhpcy4kZWwuY3NzKCdoZWlnaHQnLCBzbGlkZUhlaWdodCArICdweCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHggcG9zaXRpb24gZnJvbSBldmVudFxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3hwb3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfeHBvcyhlKSB7XG4gICAgICAgIC8vIHRvdWNoIGV2ZW50XG4gICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgZXZlbnRcbiAgICAgICAgcmV0dXJuIGUuY2xpZW50WDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgeSBwb3NpdGlvbiBmcm9tIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfeXBvc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF95cG9zKGUpIHtcbiAgICAgICAgLy8gdG91Y2ggZXZlbnRcbiAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBldmVudFxuICAgICAgICByZXR1cm4gZS5jbGllbnRZO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgaW5kZXhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfd3JhcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93cmFwKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPj0gdGhpcy5jb3VudCA/IHggJSB0aGlzLmNvdW50IDogeCA8IDAgPyB0aGlzLl93cmFwKHRoaXMuY291bnQgKyB4ICUgdGhpcy5jb3VudCkgOiB4O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYWNrcyBzY3JvbGxpbmcgaW5mb3JtYXRpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl90cmFja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFjaygpIHtcbiAgICAgICAgdmFyIG5vdyA9IHZvaWQgMCxcbiAgICAgICAgICAgIGVsYXBzZWQgPSB2b2lkIDAsXG4gICAgICAgICAgICBkZWx0YSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHYgPSB2b2lkIDA7XG5cbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCA9IG5vdyAtIHRoaXMudGltZXN0YW1wO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgZGVsdGEgPSB0aGlzLm9mZnNldCAtIHRoaXMuZnJhbWU7XG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLm9mZnNldDtcblxuICAgICAgICB2ID0gMTAwMCAqIGRlbHRhIC8gKDEgKyBlbGFwc2VkKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDAuOCAqIHYgKyAwLjIgKiB0aGlzLnZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEF1dG8gc2Nyb2xscyB0byBuZWFyZXN0IGNhcm91c2VsIGl0ZW0uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYXV0b1Njcm9sbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hdXRvU2Nyb2xsKCkge1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGRlbHRhID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0aGlzLmFtcGxpdHVkZSkge1xuICAgICAgICAgIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXA7XG4gICAgICAgICAgZGVsdGEgPSB0aGlzLmFtcGxpdHVkZSAqIE1hdGguZXhwKC1lbGFwc2VkIC8gdGhpcy5vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgICBpZiAoZGVsdGEgPiAyIHx8IGRlbHRhIDwgLTIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbCh0aGlzLnRhcmdldCAtIGRlbHRhKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hdXRvU2Nyb2xsQm91bmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGwodGhpcy50YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCB0byB0YXJnZXRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2Nyb2xsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Njcm9sbCh4KSB7XG4gICAgICAgIHZhciBfdGhpczY2ID0gdGhpcztcblxuICAgICAgICAvLyBUcmFjayBzY3JvbGxpbmcgc3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLiRlbC5oYXNDbGFzcygnc2Nyb2xsaW5nJykpIHtcbiAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3Njcm9sbGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGluZ1RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zY3JvbGxpbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbGluZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2Ni4kZWwucmVtb3ZlQ2xhc3MoJ3Njcm9sbGluZycpO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pO1xuXG4gICAgICAgIC8vIFN0YXJ0IGFjdHVhbCBzY3JvbGxcbiAgICAgICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgICAgICBoYWxmID0gdm9pZCAwLFxuICAgICAgICAgICAgZGVsdGEgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaXIgPSB2b2lkIDAsXG4gICAgICAgICAgICB0d2VlbiA9IHZvaWQgMCxcbiAgICAgICAgICAgIGVsID0gdm9pZCAwLFxuICAgICAgICAgICAgYWxpZ25tZW50ID0gdm9pZCAwLFxuICAgICAgICAgICAgelRyYW5zbGF0aW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgdHdlZW5lZE9wYWNpdHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBjZW50ZXJUd2VlbmVkT3BhY2l0eSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxhc3RDZW50ZXIgPSB0aGlzLmNlbnRlcjtcbiAgICAgICAgdmFyIG51bVZpc2libGVPZmZzZXQgPSAxIC8gdGhpcy5vcHRpb25zLm51bVZpc2libGU7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0eXBlb2YgeCA9PT0gJ251bWJlcicgPyB4IDogdGhpcy5vZmZzZXQ7XG4gICAgICAgIHRoaXMuY2VudGVyID0gTWF0aC5mbG9vcigodGhpcy5vZmZzZXQgKyB0aGlzLmRpbSAvIDIpIC8gdGhpcy5kaW0pO1xuICAgICAgICBkZWx0YSA9IHRoaXMub2Zmc2V0IC0gdGhpcy5jZW50ZXIgKiB0aGlzLmRpbTtcbiAgICAgICAgZGlyID0gZGVsdGEgPCAwID8gMSA6IC0xO1xuICAgICAgICB0d2VlbiA9IC1kaXIgKiBkZWx0YSAqIDIgLyB0aGlzLmRpbTtcbiAgICAgICAgaGFsZiA9IHRoaXMuY291bnQgPj4gMTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxXaWR0aCkge1xuICAgICAgICAgIGFsaWdubWVudCA9ICd0cmFuc2xhdGVYKDApJztcbiAgICAgICAgICBjZW50ZXJUd2VlbmVkT3BhY2l0eSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxpZ25tZW50ID0gJ3RyYW5zbGF0ZVgoJyArICh0aGlzLmVsLmNsaWVudFdpZHRoIC0gdGhpcy5pdGVtV2lkdGgpIC8gMiArICdweCkgJztcbiAgICAgICAgICBhbGlnbm1lbnQgKz0gJ3RyYW5zbGF0ZVkoJyArICh0aGlzLmVsLmNsaWVudEhlaWdodCAtIHRoaXMuaXRlbUhlaWdodCkgLyAyICsgJ3B4KSc7XG4gICAgICAgICAgY2VudGVyVHdlZW5lZE9wYWNpdHkgPSAxIC0gbnVtVmlzaWJsZU9mZnNldCAqIHR3ZWVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGluZGljYXRvciBhY3RpdmVcbiAgICAgICAgaWYgKHRoaXMuc2hvd0luZGljYXRvcnMpIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMuY2VudGVyICUgdGhpcy5jb3VudDtcbiAgICAgICAgICB2YXIgYWN0aXZlSW5kaWNhdG9yID0gdGhpcy4kaW5kaWNhdG9ycy5maW5kKCcuaW5kaWNhdG9yLWl0ZW0uYWN0aXZlJyk7XG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGljYXRvci5pbmRleCgpICE9PSBkaWZmKSB7XG4gICAgICAgICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy4kaW5kaWNhdG9ycy5maW5kKCcuaW5kaWNhdG9yLWl0ZW0nKS5lcShkaWZmKVswXS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjZW50ZXJcbiAgICAgICAgLy8gRG9uJ3Qgc2hvdyB3cmFwcGVkIGl0ZW1zLlxuICAgICAgICBpZiAoIXRoaXMubm9XcmFwIHx8IHRoaXMuY2VudGVyID49IDAgJiYgdGhpcy5jZW50ZXIgPCB0aGlzLmNvdW50KSB7XG4gICAgICAgICAgZWwgPSB0aGlzLmltYWdlc1t0aGlzLl93cmFwKHRoaXMuY2VudGVyKV07XG5cbiAgICAgICAgICAvLyBBZGQgYWN0aXZlIGNsYXNzIHRvIGNlbnRlciBpdGVtLlxuICAgICAgICAgIGlmICghJChlbCkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhbnNmb3JtU3RyaW5nID0gYWxpZ25tZW50ICsgXCIgdHJhbnNsYXRlWChcIiArIC1kZWx0YSAvIDIgKyBcInB4KSB0cmFuc2xhdGVYKFwiICsgZGlyICogdGhpcy5vcHRpb25zLnNoaWZ0ICogdHdlZW4gKiBpICsgXCJweCkgdHJhbnNsYXRlWihcIiArIHRoaXMub3B0aW9ucy5kaXN0ICogdHdlZW4gKyBcInB4KVwiO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1TdHlsZShlbCwgY2VudGVyVHdlZW5lZE9wYWNpdHksIDAsIHRyYW5zZm9ybVN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGhhbGY7ICsraSkge1xuICAgICAgICAgIC8vIHJpZ2h0IHNpZGVcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxXaWR0aCkge1xuICAgICAgICAgICAgelRyYW5zbGF0aW9uID0gdGhpcy5vcHRpb25zLmRpc3Q7XG4gICAgICAgICAgICB0d2VlbmVkT3BhY2l0eSA9IGkgPT09IGhhbGYgJiYgZGVsdGEgPCAwID8gMSAtIHR3ZWVuIDogMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgelRyYW5zbGF0aW9uID0gdGhpcy5vcHRpb25zLmRpc3QgKiAoaSAqIDIgKyB0d2VlbiAqIGRpcik7XG4gICAgICAgICAgICB0d2VlbmVkT3BhY2l0eSA9IDEgLSBudW1WaXNpYmxlT2Zmc2V0ICogKGkgKiAyICsgdHdlZW4gKiBkaXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb24ndCBzaG93IHdyYXBwZWQgaXRlbXMuXG4gICAgICAgICAgaWYgKCF0aGlzLm5vV3JhcCB8fCB0aGlzLmNlbnRlciArIGkgPCB0aGlzLmNvdW50KSB7XG4gICAgICAgICAgICBlbCA9IHRoaXMuaW1hZ2VzW3RoaXMuX3dyYXAodGhpcy5jZW50ZXIgKyBpKV07XG4gICAgICAgICAgICB2YXIgX3RyYW5zZm9ybVN0cmluZyA9IGFsaWdubWVudCArIFwiIHRyYW5zbGF0ZVgoXCIgKyAodGhpcy5vcHRpb25zLnNoaWZ0ICsgKHRoaXMuZGltICogaSAtIGRlbHRhKSAvIDIpICsgXCJweCkgdHJhbnNsYXRlWihcIiArIHpUcmFuc2xhdGlvbiArIFwicHgpXCI7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJdGVtU3R5bGUoZWwsIHR3ZWVuZWRPcGFjaXR5LCAtaSwgX3RyYW5zZm9ybVN0cmluZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGVmdCBzaWRlXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsV2lkdGgpIHtcbiAgICAgICAgICAgIHpUcmFuc2xhdGlvbiA9IHRoaXMub3B0aW9ucy5kaXN0O1xuICAgICAgICAgICAgdHdlZW5lZE9wYWNpdHkgPSBpID09PSBoYWxmICYmIGRlbHRhID4gMCA/IDEgLSB0d2VlbiA6IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHpUcmFuc2xhdGlvbiA9IHRoaXMub3B0aW9ucy5kaXN0ICogKGkgKiAyIC0gdHdlZW4gKiBkaXIpO1xuICAgICAgICAgICAgdHdlZW5lZE9wYWNpdHkgPSAxIC0gbnVtVmlzaWJsZU9mZnNldCAqIChpICogMiAtIHR3ZWVuICogZGlyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRG9uJ3Qgc2hvdyB3cmFwcGVkIGl0ZW1zLlxuICAgICAgICAgIGlmICghdGhpcy5ub1dyYXAgfHwgdGhpcy5jZW50ZXIgLSBpID49IDApIHtcbiAgICAgICAgICAgIGVsID0gdGhpcy5pbWFnZXNbdGhpcy5fd3JhcCh0aGlzLmNlbnRlciAtIGkpXTtcbiAgICAgICAgICAgIHZhciBfdHJhbnNmb3JtU3RyaW5nMiA9IGFsaWdubWVudCArIFwiIHRyYW5zbGF0ZVgoXCIgKyAoLXRoaXMub3B0aW9ucy5zaGlmdCArICgtdGhpcy5kaW0gKiBpIC0gZGVsdGEpIC8gMikgKyBcInB4KSB0cmFuc2xhdGVaKFwiICsgelRyYW5zbGF0aW9uICsgXCJweClcIjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1TdHlsZShlbCwgdHdlZW5lZE9wYWNpdHksIC1pLCBfdHJhbnNmb3JtU3RyaW5nMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VudGVyXG4gICAgICAgIC8vIERvbid0IHNob3cgd3JhcHBlZCBpdGVtcy5cbiAgICAgICAgaWYgKCF0aGlzLm5vV3JhcCB8fCB0aGlzLmNlbnRlciA+PSAwICYmIHRoaXMuY2VudGVyIDwgdGhpcy5jb3VudCkge1xuICAgICAgICAgIGVsID0gdGhpcy5pbWFnZXNbdGhpcy5fd3JhcCh0aGlzLmNlbnRlcildO1xuICAgICAgICAgIHZhciBfdHJhbnNmb3JtU3RyaW5nMyA9IGFsaWdubWVudCArIFwiIHRyYW5zbGF0ZVgoXCIgKyAtZGVsdGEgLyAyICsgXCJweCkgdHJhbnNsYXRlWChcIiArIGRpciAqIHRoaXMub3B0aW9ucy5zaGlmdCAqIHR3ZWVuICsgXCJweCkgdHJhbnNsYXRlWihcIiArIHRoaXMub3B0aW9ucy5kaXN0ICogdHdlZW4gKyBcInB4KVwiO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1TdHlsZShlbCwgY2VudGVyVHdlZW5lZE9wYWNpdHksIDAsIF90cmFuc2Zvcm1TdHJpbmczKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uQ3ljbGVUbyBjYWxsYmFja1xuICAgICAgICB2YXIgJGN1cnJJdGVtID0gdGhpcy4kZWwuZmluZCgnLmNhcm91c2VsLWl0ZW0nKS5lcSh0aGlzLl93cmFwKHRoaXMuY2VudGVyKSk7XG4gICAgICAgIGlmIChsYXN0Q2VudGVyICE9PSB0aGlzLmNlbnRlciAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ3ljbGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkN5Y2xlVG8uY2FsbCh0aGlzLCAkY3Vyckl0ZW1bMF0sIHRoaXMuZHJhZ2dlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmUgdGltZSBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub25lVGltZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5vbmVUaW1lQ2FsbGJhY2suY2FsbCh0aGlzLCAkY3Vyckl0ZW1bMF0sIHRoaXMuZHJhZ2dlZCk7XG4gICAgICAgICAgdGhpcy5vbmVUaW1lQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3ljbGUgdG8gdGFyZ2V0XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHpJbmRleFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZUl0ZW1TdHlsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVJdGVtU3R5bGUoZWwsIG9wYWNpdHksIHpJbmRleCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGVsLnN0eWxlW3RoaXMueGZvcm1dID0gdHJhbnNmb3JtO1xuICAgICAgICBlbC5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG4gICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEN5Y2xlIHRvIHRhcmdldFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3ljbGVUb1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jeWNsZVRvKG4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkaWZmID0gdGhpcy5jZW50ZXIgJSB0aGlzLmNvdW50IC0gbjtcblxuICAgICAgICAvLyBBY2NvdW50IGZvciB3cmFwYXJvdW5kLlxuICAgICAgICBpZiAoIXRoaXMubm9XcmFwKSB7XG4gICAgICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZiArIHRoaXMuY291bnQpIDwgTWF0aC5hYnMoZGlmZikpIHtcbiAgICAgICAgICAgICAgZGlmZiArPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmIC0gdGhpcy5jb3VudCkgPCBkaWZmKSB7XG4gICAgICAgICAgICAgIGRpZmYgLT0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuZGltICogTWF0aC5yb3VuZCh0aGlzLm9mZnNldCAvIHRoaXMuZGltKTtcbiAgICAgICAgLy8gTmV4dFxuICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICB0aGlzLnRhcmdldCArPSB0aGlzLmRpbSAqIE1hdGguYWJzKGRpZmYpO1xuXG4gICAgICAgICAgLy8gUHJldlxuICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgdGhpcy50YXJnZXQgLT0gdGhpcy5kaW0gKiBkaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IG9uZSB0aW1lIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9uZVRpbWVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsXG4gICAgICAgIGlmICh0aGlzLm9mZnNldCAhPT0gdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLmFtcGxpdHVkZSA9IHRoaXMudGFyZ2V0IC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hdXRvU2Nyb2xsQm91bmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3ljbGUgdG8gbmV4dCBpdGVtXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gW25dXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dChuKSB7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgaXNOYU4obikpIHtcbiAgICAgICAgICBuID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2VudGVyICsgbjtcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9XcmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXggPSB0aGlzLl93cmFwKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jeWNsZVRvKGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDeWNsZSB0byBwcmV2aW91cyBpdGVtXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gW25dXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmV2XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJldihuKSB7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgaXNOYU4obikpIHtcbiAgICAgICAgICBuID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2VudGVyIC0gbjtcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9XcmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXggPSB0aGlzLl93cmFwKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N5Y2xlVG8oaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEN5Y2xlIHRvIG50aCBpdGVtXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gW25dXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgaXNOYU4obikpIHtcbiAgICAgICAgICBuID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuID4gdGhpcy5jb3VudCB8fCBuIDwgMCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vV3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4gPSB0aGlzLl93cmFwKG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3ljbGVUbyhuLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KENhcm91c2VsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2Fyb3VzZWwpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9DYXJvdXNlbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYXJvdXNlbDtcbiAgfShDb21wb25lbnQpO1xuXG4gIE0uQ2Fyb3VzZWwgPSBDYXJvdXNlbDtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKENhcm91c2VsLCAnY2Fyb3VzZWwnLCAnTV9DYXJvdXNlbCcpO1xuICB9XG59KShjYXNoKTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgb25PcGVuOiB1bmRlZmluZWQsXG4gICAgb25DbG9zZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgVGFwVGFyZ2V0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQxOSkge1xuICAgIF9pbmhlcml0cyhUYXBUYXJnZXQsIF9Db21wb25lbnQxOSk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgVGFwVGFyZ2V0IGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFwVGFyZ2V0KGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFwVGFyZ2V0KTtcblxuICAgICAgdmFyIF90aGlzNjcgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGFwVGFyZ2V0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGFwVGFyZ2V0KSkuY2FsbCh0aGlzLCBUYXBUYXJnZXQsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzNjcuZWwuTV9UYXBUYXJnZXQgPSBfdGhpczY3O1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBzZWxlY3RcbiAgICAgICAqIEBtZW1iZXIgVGFwVGFyZ2V0I29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25PcGVuIC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gZmVhdHVyZSBkaXNjb3ZlcnkgaXMgb3BlbmVkXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uQ2xvc2UgLSBDYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBmZWF0dXJlIGRpc2NvdmVyeSBpcyBjbG9zZWRcbiAgICAgICAqL1xuICAgICAgX3RoaXM2Ny5vcHRpb25zID0gJC5leHRlbmQoe30sIFRhcFRhcmdldC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIF90aGlzNjcuaXNPcGVuID0gZmFsc2U7XG5cbiAgICAgIC8vIHNldHVwXG4gICAgICBfdGhpczY3LiRvcmlnaW4gPSAkKCcjJyArIF90aGlzNjcuJGVsLmF0dHIoJ2RhdGEtdGFyZ2V0JykpO1xuICAgICAgX3RoaXM2Ny5fc2V0dXAoKTtcblxuICAgICAgX3RoaXM2Ny5fY2FsY3VsYXRlUG9zaXRpb25pbmcoKTtcbiAgICAgIF90aGlzNjcuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgcmV0dXJuIF90aGlzNjc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRhcFRhcmdldCwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5lbC5UYXBUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVRhcmdldENsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVUYXJnZXRDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVPcmlnaW5DbGlja0JvdW5kID0gdGhpcy5faGFuZGxlT3JpZ2luQ2xpY2suYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlVGFyZ2V0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMub3JpZ2luRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVPcmlnaW5DbGlja0JvdW5kKTtcblxuICAgICAgICAvLyBSZXNpemVcbiAgICAgICAgdmFyIHRocm90dGxlZFJlc2l6ZSA9IE0udGhyb3R0bGUodGhpcy5faGFuZGxlUmVzaXplLCAyMDApO1xuICAgICAgICB0aGlzLl9oYW5kbGVUaHJvdHRsZWRSZXNpemVCb3VuZCA9IHRocm90dGxlZFJlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVUaHJvdHRsZWRSZXNpemVCb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlVGFyZ2V0Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMub3JpZ2luRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVPcmlnaW5DbGlja0JvdW5kKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVRocm90dGxlZFJlc2l6ZUJvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgVGFyZ2V0IENsaWNrXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlVGFyZ2V0Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVGFyZ2V0Q2xpY2soZSkge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgT3JpZ2luIENsaWNrXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlT3JpZ2luQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlT3JpZ2luQ2xpY2soZSkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFJlc2l6ZVxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVJlc2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSZXNpemUoZSkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbmluZygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBSZXNpemVcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudENsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICBpZiAoISQoZS50YXJnZXQpLmNsb3Nlc3QoJy50YXAtdGFyZ2V0LXdyYXBwZXInKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBUYXAgVGFyZ2V0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICAgIC8vIENyZWF0aW5nIHRhcCB0YXJnZXRcbiAgICAgICAgdGhpcy53cmFwcGVyID0gdGhpcy4kZWwucGFyZW50KClbMF07XG4gICAgICAgIHRoaXMud2F2ZUVsID0gJCh0aGlzLndyYXBwZXIpLmZpbmQoJy50YXAtdGFyZ2V0LXdhdmUnKVswXTtcbiAgICAgICAgdGhpcy5vcmlnaW5FbCA9ICQodGhpcy53cmFwcGVyKS5maW5kKCcudGFwLXRhcmdldC1vcmlnaW4nKVswXTtcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSB0aGlzLiRlbC5maW5kKCcudGFwLXRhcmdldC1jb250ZW50JylbMF07XG5cbiAgICAgICAgLy8gQ3JlYXRpbmcgd3JhcHBlclxuICAgICAgICBpZiAoISQodGhpcy53cmFwcGVyKS5oYXNDbGFzcygnLnRhcC10YXJnZXQtd3JhcHBlcicpKSB7XG4gICAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ3RhcC10YXJnZXQtd3JhcHBlcicpO1xuICAgICAgICAgIHRoaXMuJGVsLmJlZm9yZSgkKHRoaXMud3JhcHBlcikpO1xuICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmQodGhpcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGluZyBjb250ZW50XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RWwpIHtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ3RhcC10YXJnZXQtY29udGVudCcpO1xuICAgICAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLmNvbnRlbnRFbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGluZyBmb3JlZ3JvdW5kIHdhdmVcbiAgICAgICAgaWYgKCF0aGlzLndhdmVFbCkge1xuICAgICAgICAgIHRoaXMud2F2ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy53YXZlRWwuY2xhc3NMaXN0LmFkZCgndGFwLXRhcmdldC13YXZlJyk7XG5cbiAgICAgICAgICAvLyBDcmVhdGluZyBvcmlnaW5cbiAgICAgICAgICBpZiAoIXRoaXMub3JpZ2luRWwpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luRWwgPSB0aGlzLiRvcmlnaW4uY2xvbmUodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbkVsLmFkZENsYXNzKCd0YXAtdGFyZ2V0LW9yaWdpbicpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5FbC5yZW1vdmVBdHRyKCdpZCcpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5FbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5FbCA9IHRoaXMub3JpZ2luRWxbMF07XG4gICAgICAgICAgICB0aGlzLndhdmVFbC5hcHBlbmQodGhpcy5vcmlnaW5FbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZCh0aGlzLndhdmVFbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgcG9zaXRpb25pbmdcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jYWxjdWxhdGVQb3NpdGlvbmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVQb3NpdGlvbmluZygpIHtcbiAgICAgICAgLy8gRWxlbWVudCBvciBwYXJlbnQgaXMgZml4ZWQgcG9zaXRpb24/XG4gICAgICAgIHZhciBpc0ZpeGVkID0gdGhpcy4kb3JpZ2luLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcbiAgICAgICAgaWYgKCFpc0ZpeGVkKSB7XG4gICAgICAgICAgdmFyIHBhcmVudHMgPSB0aGlzLiRvcmlnaW4ucGFyZW50cygpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXNGaXhlZCA9ICQocGFyZW50c1tpXSkuY3NzKCdwb3NpdGlvbicpID09ICdmaXhlZCc7XG4gICAgICAgICAgICBpZiAoaXNGaXhlZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGluZyBvcmlnaW5cbiAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gdGhpcy4kb3JpZ2luLm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHRoaXMuJG9yaWdpbi5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgb3JpZ2luVG9wID0gaXNGaXhlZCA/IHRoaXMuJG9yaWdpbi5vZmZzZXQoKS50b3AgLSBNLmdldERvY3VtZW50U2Nyb2xsVG9wKCkgOiB0aGlzLiRvcmlnaW4ub2Zmc2V0KCkudG9wO1xuICAgICAgICB2YXIgb3JpZ2luTGVmdCA9IGlzRml4ZWQgPyB0aGlzLiRvcmlnaW4ub2Zmc2V0KCkubGVmdCAtIE0uZ2V0RG9jdW1lbnRTY3JvbGxMZWZ0KCkgOiB0aGlzLiRvcmlnaW4ub2Zmc2V0KCkubGVmdDtcblxuICAgICAgICAvLyBDYWxjdWxhdGluZyBzY3JlZW5cbiAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBjZW50ZXJYID0gd2luZG93V2lkdGggLyAyO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHdpbmRvd0hlaWdodCAvIDI7XG4gICAgICAgIHZhciBpc0xlZnQgPSBvcmlnaW5MZWZ0IDw9IGNlbnRlclg7XG4gICAgICAgIHZhciBpc1JpZ2h0ID0gb3JpZ2luTGVmdCA+IGNlbnRlclg7XG4gICAgICAgIHZhciBpc1RvcCA9IG9yaWdpblRvcCA8PSBjZW50ZXJZO1xuICAgICAgICB2YXIgaXNCb3R0b20gPSBvcmlnaW5Ub3AgPiBjZW50ZXJZO1xuICAgICAgICB2YXIgaXNDZW50ZXJYID0gb3JpZ2luTGVmdCA+PSB3aW5kb3dXaWR0aCAqIDAuMjUgJiYgb3JpZ2luTGVmdCA8PSB3aW5kb3dXaWR0aCAqIDAuNzU7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRpbmcgdGFwIHRhcmdldFxuICAgICAgICB2YXIgdGFwVGFyZ2V0V2lkdGggPSB0aGlzLiRlbC5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciB0YXBUYXJnZXRIZWlnaHQgPSB0aGlzLiRlbC5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgdGFwVGFyZ2V0VG9wID0gb3JpZ2luVG9wICsgb3JpZ2luSGVpZ2h0IC8gMiAtIHRhcFRhcmdldEhlaWdodCAvIDI7XG4gICAgICAgIHZhciB0YXBUYXJnZXRMZWZ0ID0gb3JpZ2luTGVmdCArIG9yaWdpbldpZHRoIC8gMiAtIHRhcFRhcmdldFdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHRhcFRhcmdldFBvc2l0aW9uID0gaXNGaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gICAgICAgIC8vIENhbGN1bGF0aW5nIGNvbnRlbnRcbiAgICAgICAgdmFyIHRhcFRhcmdldFRleHRXaWR0aCA9IGlzQ2VudGVyWCA/IHRhcFRhcmdldFdpZHRoIDogdGFwVGFyZ2V0V2lkdGggLyAyICsgb3JpZ2luV2lkdGg7XG4gICAgICAgIHZhciB0YXBUYXJnZXRUZXh0SGVpZ2h0ID0gdGFwVGFyZ2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIHRhcFRhcmdldFRleHRUb3AgPSBpc1RvcCA/IHRhcFRhcmdldEhlaWdodCAvIDIgOiAwO1xuICAgICAgICB2YXIgdGFwVGFyZ2V0VGV4dEJvdHRvbSA9IDA7XG4gICAgICAgIHZhciB0YXBUYXJnZXRUZXh0TGVmdCA9IGlzTGVmdCAmJiAhaXNDZW50ZXJYID8gdGFwVGFyZ2V0V2lkdGggLyAyIC0gb3JpZ2luV2lkdGggOiAwO1xuICAgICAgICB2YXIgdGFwVGFyZ2V0VGV4dFJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIHRhcFRhcmdldFRleHRQYWRkaW5nID0gb3JpZ2luV2lkdGg7XG4gICAgICAgIHZhciB0YXBUYXJnZXRUZXh0QWxpZ24gPSBpc0JvdHRvbSA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRpbmcgd2F2ZVxuICAgICAgICB2YXIgdGFwVGFyZ2V0V2F2ZVdpZHRoID0gb3JpZ2luV2lkdGggPiBvcmlnaW5IZWlnaHQgPyBvcmlnaW5XaWR0aCAqIDIgOiBvcmlnaW5XaWR0aCAqIDI7XG4gICAgICAgIHZhciB0YXBUYXJnZXRXYXZlSGVpZ2h0ID0gdGFwVGFyZ2V0V2F2ZVdpZHRoO1xuICAgICAgICB2YXIgdGFwVGFyZ2V0V2F2ZVRvcCA9IHRhcFRhcmdldEhlaWdodCAvIDIgLSB0YXBUYXJnZXRXYXZlSGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIHRhcFRhcmdldFdhdmVMZWZ0ID0gdGFwVGFyZ2V0V2lkdGggLyAyIC0gdGFwVGFyZ2V0V2F2ZVdpZHRoIC8gMjtcblxuICAgICAgICAvLyBTZXR0aW5nIHRhcCB0YXJnZXRcbiAgICAgICAgdmFyIHRhcFRhcmdldFdyYXBwZXJDc3NPYmogPSB7fTtcbiAgICAgICAgdGFwVGFyZ2V0V3JhcHBlckNzc09iai50b3AgPSBpc1RvcCA/IHRhcFRhcmdldFRvcCArICdweCcgOiAnJztcbiAgICAgICAgdGFwVGFyZ2V0V3JhcHBlckNzc09iai5yaWdodCA9IGlzUmlnaHQgPyB3aW5kb3dXaWR0aCAtIHRhcFRhcmdldExlZnQgLSB0YXBUYXJnZXRXaWR0aCArICdweCcgOiAnJztcbiAgICAgICAgdGFwVGFyZ2V0V3JhcHBlckNzc09iai5ib3R0b20gPSBpc0JvdHRvbSA/IHdpbmRvd0hlaWdodCAtIHRhcFRhcmdldFRvcCAtIHRhcFRhcmdldEhlaWdodCArICdweCcgOiAnJztcbiAgICAgICAgdGFwVGFyZ2V0V3JhcHBlckNzc09iai5sZWZ0ID0gaXNMZWZ0ID8gdGFwVGFyZ2V0TGVmdCArICdweCcgOiAnJztcbiAgICAgICAgdGFwVGFyZ2V0V3JhcHBlckNzc09iai5wb3NpdGlvbiA9IHRhcFRhcmdldFBvc2l0aW9uO1xuICAgICAgICAkKHRoaXMud3JhcHBlcikuY3NzKHRhcFRhcmdldFdyYXBwZXJDc3NPYmopO1xuXG4gICAgICAgIC8vIFNldHRpbmcgY29udGVudFxuICAgICAgICAkKHRoaXMuY29udGVudEVsKS5jc3Moe1xuICAgICAgICAgIHdpZHRoOiB0YXBUYXJnZXRUZXh0V2lkdGggKyAncHgnLFxuICAgICAgICAgIGhlaWdodDogdGFwVGFyZ2V0VGV4dEhlaWdodCArICdweCcsXG4gICAgICAgICAgdG9wOiB0YXBUYXJnZXRUZXh0VG9wICsgJ3B4JyxcbiAgICAgICAgICByaWdodDogdGFwVGFyZ2V0VGV4dFJpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICBib3R0b206IHRhcFRhcmdldFRleHRCb3R0b20gKyAncHgnLFxuICAgICAgICAgIGxlZnQ6IHRhcFRhcmdldFRleHRMZWZ0ICsgJ3B4JyxcbiAgICAgICAgICBwYWRkaW5nOiB0YXBUYXJnZXRUZXh0UGFkZGluZyArICdweCcsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogdGFwVGFyZ2V0VGV4dEFsaWduXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldHRpbmcgd2F2ZVxuICAgICAgICAkKHRoaXMud2F2ZUVsKS5jc3Moe1xuICAgICAgICAgIHRvcDogdGFwVGFyZ2V0V2F2ZVRvcCArICdweCcsXG4gICAgICAgICAgbGVmdDogdGFwVGFyZ2V0V2F2ZUxlZnQgKyAncHgnLFxuICAgICAgICAgIHdpZHRoOiB0YXBUYXJnZXRXYXZlV2lkdGggKyAncHgnLFxuICAgICAgICAgIGhlaWdodDogdGFwVGFyZ2V0V2F2ZUhlaWdodCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbiBUYXBUYXJnZXRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbk9wZW4gY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9uT3Blbi5jYWxsKHRoaXMsIHRoaXMuJG9yaWdpblswXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKCdvcGVuJyk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tCb3VuZCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlIFRhcCBUYXJnZXRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbkNsb3NlIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbG9zZS5jYWxsKHRoaXMsIHRoaXMuJG9yaWdpblswXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0JvdW5kKTtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoVGFwVGFyZ2V0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGFwVGFyZ2V0KSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fVGFwVGFyZ2V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRhcFRhcmdldDtcbiAgfShDb21wb25lbnQpO1xuXG4gIE0uVGFwVGFyZ2V0ID0gVGFwVGFyZ2V0O1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoVGFwVGFyZ2V0LCAndGFwVGFyZ2V0JywgJ01fVGFwVGFyZ2V0Jyk7XG4gIH1cbn0pKGNhc2gpO1xuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBjbGFzc2VzOiAnJyxcbiAgICBkcm9wZG93bk9wdGlvbnM6IHt9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgRm9ybVNlbGVjdCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50MjApIHtcbiAgICBfaW5oZXJpdHMoRm9ybVNlbGVjdCwgX0NvbXBvbmVudDIwKTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBGb3JtU2VsZWN0IGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9ybVNlbGVjdChlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1TZWxlY3QpO1xuXG4gICAgICAvLyBEb24ndCBpbml0IGlmIGJyb3dzZXIgZGVmYXVsdCB2ZXJzaW9uXG4gICAgICB2YXIgX3RoaXM2OCA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JtU2VsZWN0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybVNlbGVjdCkpLmNhbGwodGhpcywgRm9ybVNlbGVjdCwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgaWYgKF90aGlzNjguJGVsLmhhc0NsYXNzKCdicm93c2VyLWRlZmF1bHQnKSkge1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXM2OCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzNjguZWwuTV9Gb3JtU2VsZWN0ID0gX3RoaXM2ODtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgc2VsZWN0XG4gICAgICAgKiBAbWVtYmVyIEZvcm1TZWxlY3Qjb3B0aW9uc1xuICAgICAgICovXG4gICAgICBfdGhpczY4Lm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRm9ybVNlbGVjdC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIF90aGlzNjguaXNNdWx0aXBsZSA9IF90aGlzNjguJGVsLnByb3AoJ211bHRpcGxlJyk7XG5cbiAgICAgIC8vIFNldHVwXG4gICAgICBfdGhpczY4LmVsLnRhYkluZGV4ID0gLTE7XG4gICAgICBfdGhpczY4Ll9rZXlzU2VsZWN0ZWQgPSB7fTtcbiAgICAgIF90aGlzNjguX3ZhbHVlRGljdCA9IHt9OyAvLyBNYXBzIGtleSB0byBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIG9wdGlvbiBlbGVtZW50LlxuICAgICAgX3RoaXM2OC5fc2V0dXBEcm9wZG93bigpO1xuXG4gICAgICBfdGhpczY4Ll9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczY4O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGb3JtU2VsZWN0LCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVEcm9wZG93bigpO1xuICAgICAgICB0aGlzLmVsLk1fRm9ybVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczY5ID0gdGhpcztcblxuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RDaGFuZ2VCb3VuZCA9IHRoaXMuX2hhbmRsZVNlbGVjdENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVPcHRpb25DbGlja0JvdW5kID0gdGhpcy5faGFuZGxlT3B0aW9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5wdXRDbGlja0JvdW5kID0gdGhpcy5faGFuZGxlSW5wdXRDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgICQodGhpcy5kcm9wZG93bk9wdGlvbnMpLmZpbmQoJ2xpOm5vdCgub3B0Z3JvdXApJykuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzNjkuX2hhbmRsZU9wdGlvbkNsaWNrQm91bmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVTZWxlY3RDaGFuZ2VCb3VuZCk7XG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNzAgPSB0aGlzO1xuXG4gICAgICAgICQodGhpcy5kcm9wZG93bk9wdGlvbnMpLmZpbmQoJ2xpOm5vdCgub3B0Z3JvdXApJykuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzNzAuX2hhbmRsZU9wdGlvbkNsaWNrQm91bmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVTZWxlY3RDaGFuZ2VCb3VuZCk7XG4gICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBTZWxlY3QgQ2hhbmdlXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlU2VsZWN0Q2hhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVNlbGVjdENoYW5nZShlKSB7XG4gICAgICAgIHRoaXMuX3NldFZhbHVlVG9JbnB1dCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBPcHRpb24gQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVPcHRpb25DbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPcHRpb25DbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIG9wdGlvbiA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2xpJylbMF07XG4gICAgICAgIHZhciBrZXkgPSBvcHRpb24uaWQ7XG4gICAgICAgIGlmICghJChvcHRpb24pLmhhc0NsYXNzKCdkaXNhYmxlZCcpICYmICEkKG9wdGlvbikuaGFzQ2xhc3MoJ29wdGdyb3VwJykgJiYga2V5Lmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAvLyBEZXNlbGVjdCBwbGFjZWhvbGRlciBvcHRpb24gaWYgc3RpbGwgc2VsZWN0ZWQuXG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJPcHRpb24gPSAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5maW5kKCdsaS5kaXNhYmxlZC5zZWxlY3RlZCcpO1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyT3B0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICBwbGFjZWhvbGRlck9wdGlvbi5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXJPcHRpb24uZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRW50cnlGcm9tQXJyYXkocGxhY2Vob2xkZXJPcHRpb25bMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLl90b2dnbGVFbnRyeUZyb21BcnJheShrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgJChvcHRpb24pLnRvZ2dsZUNsYXNzKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgc2VsZWN0ZWQgb24gb3JpZ2luYWwgc2VsZWN0IG9wdGlvblxuICAgICAgICAgIC8vIE9ubHkgdHJpZ2dlciBpZiBzZWxlY3RlZCBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgICAgdmFyIHByZXZTZWxlY3RlZCA9ICQodGhpcy5fdmFsdWVEaWN0W2tleV0uZWwpLnByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgaWYgKHByZXZTZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICQodGhpcy5fdmFsdWVEaWN0W2tleV0uZWwpLnByb3AoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy4kZWwudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgSW5wdXQgQ2xpY2tcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnB1dENsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUlucHV0Q2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3Bkb3duICYmIHRoaXMuZHJvcGRvd24uaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy5fc2V0VmFsdWVUb0lucHV0KCk7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRTdGF0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIGRyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cERyb3Bkb3duKCkge1xuICAgICAgICB2YXIgX3RoaXM3MSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICQodGhpcy53cmFwcGVyKS5hZGRDbGFzcygnc2VsZWN0LXdyYXBwZXIgJyArIHRoaXMub3B0aW9ucy5jbGFzc2VzKTtcbiAgICAgICAgdGhpcy4kZWwuYmVmb3JlKCQodGhpcy53cmFwcGVyKSk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcblxuICAgICAgICBpZiAodGhpcy5lbC5kaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGRyb3Bkb3duXG4gICAgICAgIHRoaXMuJHNlbGVjdE9wdGlvbnMgPSB0aGlzLiRlbC5jaGlsZHJlbignb3B0aW9uLCBvcHRncm91cCcpO1xuICAgICAgICB0aGlzLmRyb3Bkb3duT3B0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25PcHRpb25zLmlkID0gXCJzZWxlY3Qtb3B0aW9ucy1cIiArIE0uZ3VpZCgpO1xuICAgICAgICAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5hZGRDbGFzcygnZHJvcGRvd24tY29udGVudCBzZWxlY3QtZHJvcGRvd24gJyArICh0aGlzLmlzTXVsdGlwbGUgPyAnbXVsdGlwbGUtc2VsZWN0LWRyb3Bkb3duJyA6ICcnKSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGRyb3Bkb3duIHN0cnVjdHVyZS5cbiAgICAgICAgaWYgKHRoaXMuJHNlbGVjdE9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kc2VsZWN0T3B0aW9ucy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCQoZWwpLmlzKCdvcHRpb24nKSkge1xuICAgICAgICAgICAgICAvLyBEaXJlY3QgZGVzY2VuZGFudCBvcHRpb24uXG4gICAgICAgICAgICAgIHZhciBvcHRpb25FbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKF90aGlzNzEuaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbkVsID0gX3RoaXM3MS5fYXBwZW5kT3B0aW9uV2l0aEljb24oX3RoaXM3MS4kZWwsIGVsLCAnbXVsdGlwbGUnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25FbCA9IF90aGlzNzEuX2FwcGVuZE9wdGlvbldpdGhJY29uKF90aGlzNzEuJGVsLCBlbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfdGhpczcxLl9hZGRPcHRpb25Ub1ZhbHVlRGljdChlbCwgb3B0aW9uRWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkKGVsKS5pcygnb3B0Z3JvdXAnKSkge1xuICAgICAgICAgICAgICAvLyBPcHRncm91cC5cbiAgICAgICAgICAgICAgdmFyIHNlbGVjdE9wdGlvbnMgPSAkKGVsKS5jaGlsZHJlbignb3B0aW9uJyk7XG4gICAgICAgICAgICAgICQoX3RoaXM3MS5kcm9wZG93bk9wdGlvbnMpLmFwcGVuZCgkKCc8bGkgY2xhc3M9XCJvcHRncm91cFwiPjxzcGFuPicgKyBlbC5nZXRBdHRyaWJ1dGUoJ2xhYmVsJykgKyAnPC9zcGFuPjwvbGk+JylbMF0pO1xuXG4gICAgICAgICAgICAgIHNlbGVjdE9wdGlvbnMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uRWwgPSBfdGhpczcxLl9hcHBlbmRPcHRpb25XaXRoSWNvbihfdGhpczcxLiRlbCwgZWwsICdvcHRncm91cC1vcHRpb24nKTtcbiAgICAgICAgICAgICAgICBfdGhpczcxLl9hZGRPcHRpb25Ub1ZhbHVlRGljdChlbCwgb3B0aW9uRWwpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsLmFmdGVyKHRoaXMuZHJvcGRvd25PcHRpb25zKTtcblxuICAgICAgICAvLyBBZGQgaW5wdXQgZHJvcGRvd25cbiAgICAgICAgdGhpcy5pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICQodGhpcy5pbnB1dCkuYWRkQ2xhc3MoJ3NlbGVjdC1kcm9wZG93biBkcm9wZG93bi10cmlnZ2VyJyk7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JywgdGhpcy5kcm9wZG93bk9wdGlvbnMuaWQpO1xuICAgICAgICBpZiAodGhpcy5lbC5kaXNhYmxlZCkge1xuICAgICAgICAgICQodGhpcy5pbnB1dCkucHJvcCgnZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kZWwuYmVmb3JlKHRoaXMuaW5wdXQpO1xuICAgICAgICB0aGlzLl9zZXRWYWx1ZVRvSW5wdXQoKTtcblxuICAgICAgICAvLyBBZGQgY2FyZXRcbiAgICAgICAgdmFyIGRyb3Bkb3duSWNvbiA9ICQoJzxzdmcgY2xhc3M9XCJjYXJldFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk03IDEwbDUgNSA1LTV6XCIvPjxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PC9zdmc+Jyk7XG4gICAgICAgIHRoaXMuJGVsLmJlZm9yZShkcm9wZG93bkljb25bMF0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZHJvcGRvd25cbiAgICAgICAgaWYgKCF0aGlzLmVsLmRpc2FibGVkKSB7XG4gICAgICAgICAgdmFyIGRyb3Bkb3duT3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZHJvcGRvd25PcHRpb25zKTtcblxuICAgICAgICAgIC8vIEFkZCBjYWxsYmFjayBmb3IgY2VudGVyaW5nIHNlbGVjdGVkIG9wdGlvbiB3aGVuIGRyb3Bkb3duIGNvbnRlbnQgaXMgc2Nyb2xsYWJsZVxuICAgICAgICAgIGRyb3Bkb3duT3B0aW9ucy5vbk9wZW5FbmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE9wdGlvbiA9ICQoX3RoaXM3MS5kcm9wZG93bk9wdGlvbnMpLmZpbmQoJy5zZWxlY3RlZCcpLmZpcnN0KCk7XG4gICAgICAgICAgICBpZiAoX3RoaXM3MS5kcm9wZG93bi5pc1Njcm9sbGFibGUgJiYgc2VsZWN0ZWRPcHRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXQgPSBzZWxlY3RlZE9wdGlvblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBfdGhpczcxLmRyb3Bkb3duT3B0aW9ucy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7IC8vIHNjcm9sbCB0byBzZWxlY3RlZCBvcHRpb25cbiAgICAgICAgICAgICAgc2Nyb2xsT2Zmc2V0IC09IF90aGlzNzEuZHJvcGRvd25PcHRpb25zLmNsaWVudEhlaWdodCAvIDI7IC8vIGNlbnRlciBpbiBkcm9wZG93blxuICAgICAgICAgICAgICBfdGhpczcxLmRyb3Bkb3duT3B0aW9ucy5zY3JvbGxUb3AgPSBzY3JvbGxPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGRyb3Bkb3duT3B0aW9ucy5jbG9zZU9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kcm9wZG93biA9IE0uRHJvcGRvd24uaW5pdCh0aGlzLmlucHV0LCBkcm9wZG93bk9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGluaXRpYWwgc2VsZWN0aW9uc1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZFN0YXRlcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBvcHRpb24gdG8gdmFsdWUgZGljdFxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAgb3JpZ2luYWwgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9uRWwgIGdlbmVyYXRlZCBvcHRpb24gZWxlbWVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FkZE9wdGlvblRvVmFsdWVEaWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZE9wdGlvblRvVmFsdWVEaWN0KGVsLCBvcHRpb25FbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZURpY3QpLmxlbmd0aDtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZHJvcGRvd25PcHRpb25zLmlkICsgaW5kZXg7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb3B0aW9uRWwuaWQgPSBrZXk7XG5cbiAgICAgICAgb2JqLmVsID0gZWw7XG4gICAgICAgIG9iai5vcHRpb25FbCA9IG9wdGlvbkVsO1xuICAgICAgICB0aGlzLl92YWx1ZURpY3Rba2V5XSA9IG9iajtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVEcm9wZG93bigpIHtcbiAgICAgICAgJCh0aGlzLndyYXBwZXIpLmZpbmQoJy5jYXJldCcpLnJlbW92ZSgpO1xuICAgICAgICAkKHRoaXMuaW5wdXQpLnJlbW92ZSgpO1xuICAgICAgICAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5yZW1vdmUoKTtcbiAgICAgICAgJCh0aGlzLndyYXBwZXIpLmJlZm9yZSh0aGlzLiRlbCk7XG4gICAgICAgICQodGhpcy53cmFwcGVyKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBkcm9wZG93blxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBzZWxlY3QgIHNlbGVjdCBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbiAgb3B0aW9uIGVsZW1lbnQgZnJvbSBzZWxlY3RcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgb3B0aW9uIGVsZW1lbnQgYWRkZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hcHBlbmRPcHRpb25XaXRoSWNvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRPcHRpb25XaXRoSWNvbihzZWxlY3QsIG9wdGlvbiwgdHlwZSkge1xuICAgICAgICAvLyBBZGQgZGlzYWJsZWQgYXR0ciBpZiBkaXNhYmxlZFxuICAgICAgICB2YXIgZGlzYWJsZWRDbGFzcyA9IG9wdGlvbi5kaXNhYmxlZCA/ICdkaXNhYmxlZCAnIDogJyc7XG4gICAgICAgIHZhciBvcHRncm91cENsYXNzID0gdHlwZSA9PT0gJ29wdGdyb3VwLW9wdGlvbicgPyAnb3B0Z3JvdXAtb3B0aW9uICcgOiAnJztcbiAgICAgICAgdmFyIG11bHRpcGxlQ2hlY2tib3ggPSB0aGlzLmlzTXVsdGlwbGUgPyBcIjxsYWJlbD48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiXCIgKyBkaXNhYmxlZENsYXNzICsgXCJcXFwiLz48c3Bhbj5cIiArIG9wdGlvbi5pbm5lckhUTUwgKyBcIjwvc3Bhbj48L2xhYmVsPlwiIDogb3B0aW9uLmlubmVySFRNTDtcbiAgICAgICAgdmFyIGxpRWwgPSAkKCc8bGk+PC9saT4nKTtcbiAgICAgICAgdmFyIHNwYW5FbCA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgc3BhbkVsLmh0bWwobXVsdGlwbGVDaGVja2JveCk7XG4gICAgICAgIGxpRWwuYWRkQ2xhc3MoZGlzYWJsZWRDbGFzcyArIFwiIFwiICsgb3B0Z3JvdXBDbGFzcyk7XG4gICAgICAgIGxpRWwuYXBwZW5kKHNwYW5FbCk7XG5cbiAgICAgICAgLy8gYWRkIGljb25zXG4gICAgICAgIHZhciBpY29uVXJsID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1pY29uJyk7XG4gICAgICAgIGlmICghIWljb25VcmwpIHtcbiAgICAgICAgICB2YXIgaW1nRWwgPSAkKFwiPGltZyBhbHQ9XFxcIlxcXCIgc3JjPVxcXCJcIiArIGljb25VcmwgKyBcIlxcXCI+XCIpO1xuICAgICAgICAgIGxpRWwucHJlcGVuZChpbWdFbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgbXVsdGlwbGUgdHlwZS5cbiAgICAgICAgJCh0aGlzLmRyb3Bkb3duT3B0aW9ucykuYXBwZW5kKGxpRWxbMF0pO1xuICAgICAgICByZXR1cm4gbGlFbFswXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgZW50cnkgZnJvbSBvcHRpb25cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgIE9wdGlvbiBrZXlcbiAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICBpZiBlbnRyeSB3YXMgYWRkZWQgb3IgcmVtb3ZlZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3RvZ2dsZUVudHJ5RnJvbUFycmF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZUVudHJ5RnJvbUFycmF5KGtleSkge1xuICAgICAgICB2YXIgbm90QWRkZWQgPSAhdGhpcy5fa2V5c1NlbGVjdGVkLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIHZhciAkb3B0aW9uTGkgPSAkKHRoaXMuX3ZhbHVlRGljdFtrZXldLm9wdGlvbkVsKTtcblxuICAgICAgICBpZiAobm90QWRkZWQpIHtcbiAgICAgICAgICB0aGlzLl9rZXlzU2VsZWN0ZWRba2V5XSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2tleXNTZWxlY3RlZFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgJG9wdGlvbkxpLnRvZ2dsZUNsYXNzKCdzZWxlY3RlZCcsIG5vdEFkZGVkKTtcblxuICAgICAgICAvLyBTZXQgY2hlY2tib3ggY2hlY2tlZCB2YWx1ZVxuICAgICAgICAkb3B0aW9uTGkuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykucHJvcCgnY2hlY2tlZCcsIG5vdEFkZGVkKTtcblxuICAgICAgICAvLyB1c2Ugbm90QWRkZWQgaW5zdGVhZCBvZiB0cnVlICh0byBkZXRlY3QgaWYgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCBvciBub3QpXG4gICAgICAgICRvcHRpb25MaS5wcm9wKCdzZWxlY3RlZCcsIG5vdEFkZGVkKTtcblxuICAgICAgICByZXR1cm4gbm90QWRkZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRleHQgdmFsdWUgdG8gaW5wdXRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRWYWx1ZVRvSW5wdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVUb0lucHV0KCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kZWwuZmluZCgnb3B0aW9uJyk7XG5cbiAgICAgICAgb3B0aW9ucy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmICgkKGVsKS5wcm9wKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICQoZWwpLnRleHQoKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZpcnN0RGlzYWJsZWQgPSB0aGlzLiRlbC5maW5kKCdvcHRpb246ZGlzYWJsZWQnKS5lcSgwKTtcbiAgICAgICAgICBpZiAoZmlyc3REaXNhYmxlZC5sZW5ndGggJiYgZmlyc3REaXNhYmxlZFswXS52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGZpcnN0RGlzYWJsZWQudGV4dCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gdmFsdWVzLmpvaW4oJywgJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHNlbGVjdGVkIHN0YXRlIG9mIGRyb3Bkb3duIHRvIG1hdGNoIGFjdHVhbCBzZWxlY3QgZWxlbWVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFNlbGVjdGVkU3RhdGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNlbGVjdGVkU3RhdGVzKCkge1xuICAgICAgICB0aGlzLl9rZXlzU2VsZWN0ZWQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdmFsdWVEaWN0KSB7XG4gICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMuX3ZhbHVlRGljdFtrZXldO1xuICAgICAgICAgIHZhciBvcHRpb25Jc1NlbGVjdGVkID0gJChvcHRpb24uZWwpLnByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgJChvcHRpb24ub3B0aW9uRWwpLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLnByb3AoJ2NoZWNrZWQnLCBvcHRpb25Jc1NlbGVjdGVkKTtcbiAgICAgICAgICBpZiAob3B0aW9uSXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVPcHRpb24oJCh0aGlzLmRyb3Bkb3duT3B0aW9ucyksICQob3B0aW9uLm9wdGlvbkVsKSk7XG4gICAgICAgICAgICB0aGlzLl9rZXlzU2VsZWN0ZWRba2V5XSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQob3B0aW9uLm9wdGlvbkVsKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYWtlIG9wdGlvbiBhcyBzZWxlY3RlZCBhbmQgc2Nyb2xsIHRvIHNlbGVjdGVkIHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gY29sbGVjdGlvbiAgU2VsZWN0IG9wdGlvbnMgalF1ZXJ5IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbmV3T3B0aW9uICBlbGVtZW50IG9mIHRoZSBuZXcgb3B0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYWN0aXZhdGVPcHRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWN0aXZhdGVPcHRpb24oY29sbGVjdGlvbiwgbmV3T3B0aW9uKSB7XG4gICAgICAgIGlmIChuZXdPcHRpb24pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5maW5kKCdsaS5zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3B0aW9uID0gJChuZXdPcHRpb24pO1xuICAgICAgICAgIG9wdGlvbi5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBTZWxlY3RlZCBWYWx1ZXNcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSAgQXJyYXkgb2Ygc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTZWxlY3RlZFZhbHVlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkVmFsdWVzKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2tleXNTZWxlY3RlZCkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWVzLnB1c2godGhpcy5fdmFsdWVEaWN0W2tleV0uZWwudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFZhbHVlcztcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoRm9ybVNlbGVjdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm1TZWxlY3QpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9Gb3JtU2VsZWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZvcm1TZWxlY3Q7XG4gIH0oQ29tcG9uZW50KTtcblxuICBNLkZvcm1TZWxlY3QgPSBGb3JtU2VsZWN0O1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoRm9ybVNlbGVjdCwgJ2Zvcm1TZWxlY3QnLCAnTV9Gb3JtU2VsZWN0Jyk7XG4gIH1cbn0pKGNhc2gpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICovXG5cbiAgdmFyIFJhbmdlID0gZnVuY3Rpb24gKF9Db21wb25lbnQyMSkge1xuICAgIF9pbmhlcml0cyhSYW5nZSwgX0NvbXBvbmVudDIxKTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBSYW5nZSBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJhbmdlKGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UpO1xuXG4gICAgICB2YXIgX3RoaXM3MiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChSYW5nZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJhbmdlKSkuY2FsbCh0aGlzLCBSYW5nZSwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXM3Mi5lbC5NX1JhbmdlID0gX3RoaXM3MjtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgcmFuZ2VcbiAgICAgICAqIEBtZW1iZXIgUmFuZ2Ujb3B0aW9uc1xuICAgICAgICovXG4gICAgICBfdGhpczcyLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmFuZ2UuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICBfdGhpczcyLl9tb3VzZWRvd24gPSBmYWxzZTtcblxuICAgICAgLy8gU2V0dXBcbiAgICAgIF90aGlzNzIuX3NldHVwVGh1bWIoKTtcblxuICAgICAgX3RoaXM3Mi5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXM3MjtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUmFuZ2UsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVRodW1iKCk7XG4gICAgICAgIHRoaXMuZWwuTV9SYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVJhbmdlQ2hhbmdlQm91bmQgPSB0aGlzLl9oYW5kbGVSYW5nZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnRCb3VuZCA9IHRoaXMuX2hhbmRsZVJhbmdlTW91c2Vkb3duVG91Y2hzdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlQm91bmQgPSB0aGlzLl9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVJhbmdlTW91c2V1cFRvdWNoZW5kQm91bmQgPSB0aGlzLl9oYW5kbGVSYW5nZU1vdXNldXBUb3VjaGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCA9IHRoaXMuX2hhbmRsZVJhbmdlQmx1ck1vdXNlb3V0VG91Y2hsZWF2ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5faGFuZGxlUmFuZ2VDaGFuZ2VCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnRCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVJhbmdlTW91c2Vkb3duVG91Y2hzdGFydEJvdW5kKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVJhbmdlSW5wdXRNb3VzZW1vdmVUb3VjaG1vdmVCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZXVwVG91Y2hlbmRCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVSYW5nZU1vdXNldXBUb3VjaGVuZEJvdW5kKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIHRoaXMuX2hhbmRsZVJhbmdlQmx1ck1vdXNlb3V0VG91Y2hsZWF2ZUJvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5faGFuZGxlUmFuZ2VDaGFuZ2VCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnRCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVJhbmdlTW91c2Vkb3duVG91Y2hzdGFydEJvdW5kKTtcblxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVJhbmdlSW5wdXRNb3VzZW1vdmVUb3VjaG1vdmVCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZXVwVG91Y2hlbmRCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVSYW5nZU1vdXNldXBUb3VjaGVuZEJvdW5kKTtcblxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIHRoaXMuX2hhbmRsZVJhbmdlQmx1ck1vdXNlb3V0VG91Y2hsZWF2ZUJvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgUmFuZ2UgQ2hhbmdlXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlUmFuZ2VDaGFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUmFuZ2VDaGFuZ2UoKSB7XG4gICAgICAgICQodGhpcy52YWx1ZSkuaHRtbCh0aGlzLiRlbC52YWwoKSk7XG5cbiAgICAgICAgaWYgKCEkKHRoaXMudGh1bWIpLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHRoaXMuX3Nob3dSYW5nZUJ1YmJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSB0aGlzLl9jYWxjUmFuZ2VPZmZzZXQoKTtcbiAgICAgICAgJCh0aGlzLnRodW1iKS5hZGRDbGFzcygnYWN0aXZlJykuY3NzKCdsZWZ0Jywgb2Zmc2V0TGVmdCArICdweCcpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBSYW5nZSBNb3VzZWRvd24gYW5kIFRvdWNoc3RhcnRcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUmFuZ2VNb3VzZWRvd25Ub3VjaHN0YXJ0KGUpIHtcbiAgICAgICAgLy8gU2V0IGluZGljYXRvciB2YWx1ZVxuICAgICAgICAkKHRoaXMudmFsdWUpLmh0bWwodGhpcy4kZWwudmFsKCkpO1xuXG4gICAgICAgIHRoaXMuX21vdXNlZG93biA9IHRydWU7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdhY3RpdmUnKTtcblxuICAgICAgICBpZiAoISQodGhpcy50aHVtYikuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgdGhpcy5fc2hvd1JhbmdlQnViYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlICE9PSAnaW5wdXQnKSB7XG4gICAgICAgICAgdmFyIG9mZnNldExlZnQgPSB0aGlzLl9jYWxjUmFuZ2VPZmZzZXQoKTtcbiAgICAgICAgICAkKHRoaXMudGh1bWIpLmFkZENsYXNzKCdhY3RpdmUnKS5jc3MoJ2xlZnQnLCBvZmZzZXRMZWZ0ICsgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgUmFuZ2UgSW5wdXQsIE1vdXNlbW92ZSBhbmQgVG91Y2htb3ZlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5fbW91c2Vkb3duKSB7XG4gICAgICAgICAgaWYgKCEkKHRoaXMudGh1bWIpLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1JhbmdlQnViYmxlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9mZnNldExlZnQgPSB0aGlzLl9jYWxjUmFuZ2VPZmZzZXQoKTtcbiAgICAgICAgICAkKHRoaXMudGh1bWIpLmFkZENsYXNzKCdhY3RpdmUnKS5jc3MoJ2xlZnQnLCBvZmZzZXRMZWZ0ICsgJ3B4Jyk7XG4gICAgICAgICAgJCh0aGlzLnZhbHVlKS5odG1sKHRoaXMuJGVsLnZhbCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBSYW5nZSBNb3VzZXVwIGFuZCBUb3VjaGVuZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVJhbmdlTW91c2V1cFRvdWNoZW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJhbmdlTW91c2V1cFRvdWNoZW5kKCkge1xuICAgICAgICB0aGlzLl9tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBSYW5nZSBCbHVyLCBNb3VzZW91dCBhbmQgVG91Y2hsZWF2ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVJhbmdlQmx1ck1vdXNlb3V0VG91Y2hsZWF2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW91c2Vkb3duKSB7XG4gICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhpcy4kZWwuY3NzKCdwYWRkaW5nLWxlZnQnKSk7XG4gICAgICAgICAgdmFyIG1hcmdpbkxlZnQgPSA3ICsgcGFkZGluZ0xlZnQgKyAncHgnO1xuXG4gICAgICAgICAgaWYgKCQodGhpcy50aHVtYikuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICBhbmltLnJlbW92ZSh0aGlzLnRodW1iKTtcbiAgICAgICAgICAgIGFuaW0oe1xuICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLnRodW1iLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICB0b3A6IDEwLFxuICAgICAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkKHRoaXMudGh1bWIpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIGRyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBUaHVtYlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFRodW1iKCkge1xuICAgICAgICB0aGlzLnRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB0aGlzLnZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAkKHRoaXMudGh1bWIpLmFkZENsYXNzKCd0aHVtYicpO1xuICAgICAgICAkKHRoaXMudmFsdWUpLmFkZENsYXNzKCd2YWx1ZScpO1xuICAgICAgICAkKHRoaXMudGh1bWIpLmFwcGVuZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy4kZWwuYWZ0ZXIodGhpcy50aHVtYik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGRyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlVGh1bWJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlVGh1bWIoKSB7XG4gICAgICAgICQodGhpcy50aHVtYikucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbW9ycGggdGh1bWIgaW50byBidWJibGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zaG93UmFuZ2VCdWJibGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd1JhbmdlQnViYmxlKCkge1xuICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUludCgkKHRoaXMudGh1bWIpLnBhcmVudCgpLmNzcygncGFkZGluZy1sZWZ0JykpO1xuICAgICAgICB2YXIgbWFyZ2luTGVmdCA9IC03ICsgcGFkZGluZ0xlZnQgKyAncHgnOyAvLyBUT0RPOiBmaXggbWFnaWMgbnVtYmVyP1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLnRodW1iKTtcbiAgICAgICAgYW5pbSh7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy50aHVtYixcbiAgICAgICAgICBoZWlnaHQ6IDMwLFxuICAgICAgICAgIHdpZHRoOiAzMCxcbiAgICAgICAgICB0b3A6IC0zMCxcbiAgICAgICAgICBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1aW50J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIG9mZnNldCBvZiB0aGUgdGh1bWJcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gIG9mZnNldCBpbiBwaXhlbHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jYWxjUmFuZ2VPZmZzZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY1JhbmdlT2Zmc2V0KCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbC53aWR0aCgpIC0gMTU7XG4gICAgICAgIHZhciBtYXggPSBwYXJzZUZsb2F0KHRoaXMuJGVsLmF0dHIoJ21heCcpKSB8fCAxMDA7IC8vIFJhbmdlIGRlZmF1bHQgbWF4XG4gICAgICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KHRoaXMuJGVsLmF0dHIoJ21pbicpKSB8fCAwOyAvLyBSYW5nZSBkZWZhdWx0IG1pblxuICAgICAgICB2YXIgcGVyY2VudCA9IChwYXJzZUZsb2F0KHRoaXMuJGVsLnZhbCgpKSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQgKiB3aWR0aDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoUmFuZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSYW5nZSksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMsIGVscywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IEluc3RhbmNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJbnN0YW5jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlKGVsKSB7XG4gICAgICAgIHZhciBkb21FbGVtID0gISFlbC5qcXVlcnkgPyBlbFswXSA6IGVsO1xuICAgICAgICByZXR1cm4gZG9tRWxlbS5NX1JhbmdlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFJhbmdlO1xuICB9KENvbXBvbmVudCk7XG5cbiAgTS5SYW5nZSA9IFJhbmdlO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoUmFuZ2UsICdyYW5nZScsICdNX1JhbmdlJyk7XG4gIH1cblxuICBSYW5nZS5pbml0KCQoJ2lucHV0W3R5cGU9cmFuZ2VdJykpO1xufSkoY2FzaCwgTS5hbmltZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/materialize-css/dist/js/materialize.js\n");

/***/ }),

/***/ "./node_modules/photoswipe/dist/photoswipe-ui-default.js":
/*!***************************************************************!*\
  !*** ./node_modules/photoswipe/dist/photoswipe-ui-default.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! PhotoSwipe Default UI - 4.1.3 - 2019-01-08\n* http://photoswipe.com\n* Copyright (c) 2019 Dmitry Semenov; */\n/**\n*\n* UI on top of main sliding area (caption, arrows, close button, etc.).\n* Built just using public methods/properties of PhotoSwipe.\n* \n*/\n(function (root, factory) { \n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n})(this, function () {\n\n\t'use strict';\n\n\n\nvar PhotoSwipeUI_Default =\n function(pswp, framework) {\n\n\tvar ui = this;\n\tvar _overlayUIUpdated = false,\n\t\t_controlsVisible = true,\n\t\t_fullscrenAPI,\n\t\t_controls,\n\t\t_captionContainer,\n\t\t_fakeCaptionContainer,\n\t\t_indexIndicator,\n\t\t_shareButton,\n\t\t_shareModal,\n\t\t_shareModalHidden = true,\n\t\t_initalCloseOnScrollValue,\n\t\t_isIdle,\n\t\t_listen,\n\n\t\t_loadingIndicator,\n\t\t_loadingIndicatorHidden,\n\t\t_loadingIndicatorTimeout,\n\n\t\t_galleryHasOneSlide,\n\n\t\t_options,\n\t\t_defaultUIOptions = {\n\t\t\tbarsSize: {top:44, bottom:'auto'},\n\t\t\tcloseElClasses: ['item', 'caption', 'zoom-wrap', 'ui', 'top-bar'], \n\t\t\ttimeToIdle: 4000, \n\t\t\ttimeToIdleOutside: 1000,\n\t\t\tloadingIndicatorDelay: 1000, // 2s\n\t\t\t\n\t\t\taddCaptionHTMLFn: function(item, captionEl /*, isFake */) {\n\t\t\t\tif(!item.title) {\n\t\t\t\t\tcaptionEl.children[0].innerHTML = '';\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcaptionEl.children[0].innerHTML = item.title;\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\tcloseEl:true,\n\t\t\tcaptionEl: true,\n\t\t\tfullscreenEl: true,\n\t\t\tzoomEl: true,\n\t\t\tshareEl: true,\n\t\t\tcounterEl: true,\n\t\t\tarrowEl: true,\n\t\t\tpreloaderEl: true,\n\n\t\t\ttapToClose: false,\n\t\t\ttapToToggleControls: true,\n\n\t\t\tclickToCloseNonZoomable: true,\n\n\t\t\tshareButtons: [\n\t\t\t\t{id:'facebook', label:'Share on Facebook', url:'https://www.facebook.com/sharer/sharer.php?u={{url}}'},\n\t\t\t\t{id:'twitter', label:'Tweet', url:'https://twitter.com/intent/tweet?text={{text}}&url={{url}}'},\n\t\t\t\t{id:'pinterest', label:'Pin it', url:'http://www.pinterest.com/pin/create/button/'+\n\t\t\t\t\t\t\t\t\t\t\t\t\t'?url={{url}}&media={{image_url}}&description={{text}}'},\n\t\t\t\t{id:'download', label:'Download image', url:'{{raw_image_url}}', download:true}\n\t\t\t],\n\t\t\tgetImageURLForShare: function( /* shareButtonData */ ) {\n\t\t\t\treturn pswp.currItem.src || '';\n\t\t\t},\n\t\t\tgetPageURLForShare: function( /* shareButtonData */ ) {\n\t\t\t\treturn window.location.href;\n\t\t\t},\n\t\t\tgetTextForShare: function( /* shareButtonData */ ) {\n\t\t\t\treturn pswp.currItem.title || '';\n\t\t\t},\n\t\t\t\t\n\t\t\tindexIndicatorSep: ' / ',\n\t\t\tfitControlsWidth: 1200\n\n\t\t},\n\t\t_blockControlsTap,\n\t\t_blockControlsTapTimeout;\n\n\n\n\tvar _onControlsTap = function(e) {\n\t\t\tif(_blockControlsTap) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\n\t\t\te = e || window.event;\n\n\t\t\tif(_options.timeToIdle && _options.mouseUsed && !_isIdle) {\n\t\t\t\t// reset idle timer\n\t\t\t\t_onIdleMouseMove();\n\t\t\t}\n\n\n\t\t\tvar target = e.target || e.srcElement,\n\t\t\t\tuiElement,\n\t\t\t\tclickedClass = target.getAttribute('class') || '',\n\t\t\t\tfound;\n\n\t\t\tfor(var i = 0; i < _uiElements.length; i++) {\n\t\t\t\tuiElement = _uiElements[i];\n\t\t\t\tif(uiElement.onTap && clickedClass.indexOf('pswp__' + uiElement.name ) > -1 ) {\n\t\t\t\t\tuiElement.onTap();\n\t\t\t\t\tfound = true;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(found) {\n\t\t\t\tif(e.stopPropagation) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t}\n\t\t\t\t_blockControlsTap = true;\n\n\t\t\t\t// Some versions of Android don't prevent ghost click event \n\t\t\t\t// when preventDefault() was called on touchstart and/or touchend.\n\t\t\t\t// \n\t\t\t\t// This happens on v4.3, 4.2, 4.1, \n\t\t\t\t// older versions strangely work correctly, \n\t\t\t\t// but just in case we add delay on all of them)\t\n\t\t\t\tvar tapDelay = framework.features.isOldAndroid ? 600 : 30;\n\t\t\t\t_blockControlsTapTimeout = setTimeout(function() {\n\t\t\t\t\t_blockControlsTap = false;\n\t\t\t\t}, tapDelay);\n\t\t\t}\n\n\t\t},\n\t\t_fitControlsInViewport = function() {\n\t\t\treturn !pswp.likelyTouchDevice || _options.mouseUsed || screen.width > _options.fitControlsWidth;\n\t\t},\n\t\t_togglePswpClass = function(el, cName, add) {\n\t\t\tframework[ (add ? 'add' : 'remove') + 'Class' ](el, 'pswp__' + cName);\n\t\t},\n\n\t\t// add class when there is just one item in the gallery\n\t\t// (by default it hides left/right arrows and 1ofX counter)\n\t\t_countNumItems = function() {\n\t\t\tvar hasOneSlide = (_options.getNumItemsFn() === 1);\n\n\t\t\tif(hasOneSlide !== _galleryHasOneSlide) {\n\t\t\t\t_togglePswpClass(_controls, 'ui--one-slide', hasOneSlide);\n\t\t\t\t_galleryHasOneSlide = hasOneSlide;\n\t\t\t}\n\t\t},\n\t\t_toggleShareModalClass = function() {\n\t\t\t_togglePswpClass(_shareModal, 'share-modal--hidden', _shareModalHidden);\n\t\t},\n\t\t_toggleShareModal = function() {\n\n\t\t\t_shareModalHidden = !_shareModalHidden;\n\t\t\t\n\t\t\t\n\t\t\tif(!_shareModalHidden) {\n\t\t\t\t_toggleShareModalClass();\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif(!_shareModalHidden) {\n\t\t\t\t\t\tframework.addClass(_shareModal, 'pswp__share-modal--fade-in');\n\t\t\t\t\t}\n\t\t\t\t}, 30);\n\t\t\t} else {\n\t\t\t\tframework.removeClass(_shareModal, 'pswp__share-modal--fade-in');\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif(_shareModalHidden) {\n\t\t\t\t\t\t_toggleShareModalClass();\n\t\t\t\t\t}\n\t\t\t\t}, 300);\n\t\t\t}\n\t\t\t\n\t\t\tif(!_shareModalHidden) {\n\t\t\t\t_updateShareURLs();\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t_openWindowPopup = function(e) {\n\t\t\te = e || window.event;\n\t\t\tvar target = e.target || e.srcElement;\n\n\t\t\tpswp.shout('shareLinkClick', e, target);\n\n\t\t\tif(!target.href) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif( target.hasAttribute('download') ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\twindow.open(target.href, 'pswp_share', 'scrollbars=yes,resizable=yes,toolbar=no,'+\n\t\t\t\t\t\t\t\t\t\t'location=yes,width=550,height=420,top=100,left=' + \n\t\t\t\t\t\t\t\t\t\t(window.screen ? Math.round(screen.width / 2 - 275) : 100)  );\n\n\t\t\tif(!_shareModalHidden) {\n\t\t\t\t_toggleShareModal();\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t_updateShareURLs = function() {\n\t\t\tvar shareButtonOut = '',\n\t\t\t\tshareButtonData,\n\t\t\t\tshareURL,\n\t\t\t\timage_url,\n\t\t\t\tpage_url,\n\t\t\t\tshare_text;\n\n\t\t\tfor(var i = 0; i < _options.shareButtons.length; i++) {\n\t\t\t\tshareButtonData = _options.shareButtons[i];\n\n\t\t\t\timage_url = _options.getImageURLForShare(shareButtonData);\n\t\t\t\tpage_url = _options.getPageURLForShare(shareButtonData);\n\t\t\t\tshare_text = _options.getTextForShare(shareButtonData);\n\n\t\t\t\tshareURL = shareButtonData.url.replace('{{url}}', encodeURIComponent(page_url) )\n\t\t\t\t\t\t\t\t\t.replace('{{image_url}}', encodeURIComponent(image_url) )\n\t\t\t\t\t\t\t\t\t.replace('{{raw_image_url}}', image_url )\n\t\t\t\t\t\t\t\t\t.replace('{{text}}', encodeURIComponent(share_text) );\n\n\t\t\t\tshareButtonOut += '<a href=\"' + shareURL + '\" target=\"_blank\" '+\n\t\t\t\t\t\t\t\t\t'class=\"pswp__share--' + shareButtonData.id + '\"' +\n\t\t\t\t\t\t\t\t\t(shareButtonData.download ? 'download' : '') + '>' + \n\t\t\t\t\t\t\t\t\tshareButtonData.label + '</a>';\n\n\t\t\t\tif(_options.parseShareButtonOut) {\n\t\t\t\t\tshareButtonOut = _options.parseShareButtonOut(shareButtonData, shareButtonOut);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_shareModal.children[0].innerHTML = shareButtonOut;\n\t\t\t_shareModal.children[0].onclick = _openWindowPopup;\n\n\t\t},\n\t\t_hasCloseClass = function(target) {\n\t\t\tfor(var  i = 0; i < _options.closeElClasses.length; i++) {\n\t\t\t\tif( framework.hasClass(target, 'pswp__' + _options.closeElClasses[i]) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_idleInterval,\n\t\t_idleTimer,\n\t\t_idleIncrement = 0,\n\t\t_onIdleMouseMove = function() {\n\t\t\tclearTimeout(_idleTimer);\n\t\t\t_idleIncrement = 0;\n\t\t\tif(_isIdle) {\n\t\t\t\tui.setIdle(false);\n\t\t\t}\n\t\t},\n\t\t_onMouseLeaveWindow = function(e) {\n\t\t\te = e ? e : window.event;\n\t\t\tvar from = e.relatedTarget || e.toElement;\n\t\t\tif (!from || from.nodeName === 'HTML') {\n\t\t\t\tclearTimeout(_idleTimer);\n\t\t\t\t_idleTimer = setTimeout(function() {\n\t\t\t\t\tui.setIdle(true);\n\t\t\t\t}, _options.timeToIdleOutside);\n\t\t\t}\n\t\t},\n\t\t_setupFullscreenAPI = function() {\n\t\t\tif(_options.fullscreenEl && !framework.features.isOldAndroid) {\n\t\t\t\tif(!_fullscrenAPI) {\n\t\t\t\t\t_fullscrenAPI = ui.getFullscreenAPI();\n\t\t\t\t}\n\t\t\t\tif(_fullscrenAPI) {\n\t\t\t\t\tframework.bind(document, _fullscrenAPI.eventK, ui.updateFullscreen);\n\t\t\t\t\tui.updateFullscreen();\n\t\t\t\t\tframework.addClass(pswp.template, 'pswp--supports-fs');\n\t\t\t\t} else {\n\t\t\t\t\tframework.removeClass(pswp.template, 'pswp--supports-fs');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_setupLoadingIndicator = function() {\n\t\t\t// Setup loading indicator\n\t\t\tif(_options.preloaderEl) {\n\t\t\t\n\t\t\t\t_toggleLoadingIndicator(true);\n\n\t\t\t\t_listen('beforeChange', function() {\n\n\t\t\t\t\tclearTimeout(_loadingIndicatorTimeout);\n\n\t\t\t\t\t// display loading indicator with delay\n\t\t\t\t\t_loadingIndicatorTimeout = setTimeout(function() {\n\n\t\t\t\t\t\tif(pswp.currItem && pswp.currItem.loading) {\n\n\t\t\t\t\t\t\tif( !pswp.allowProgressiveImg() || (pswp.currItem.img && !pswp.currItem.img.naturalWidth)  ) {\n\t\t\t\t\t\t\t\t// show preloader if progressive loading is not enabled, \n\t\t\t\t\t\t\t\t// or image width is not defined yet (because of slow connection)\n\t\t\t\t\t\t\t\t_toggleLoadingIndicator(false); \n\t\t\t\t\t\t\t\t// items-controller.js function allowProgressiveImg\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_toggleLoadingIndicator(true); // hide preloader\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, _options.loadingIndicatorDelay);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t_listen('imageLoadComplete', function(index, item) {\n\t\t\t\t\tif(pswp.currItem === item) {\n\t\t\t\t\t\t_toggleLoadingIndicator(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\t\t},\n\t\t_toggleLoadingIndicator = function(hide) {\n\t\t\tif( _loadingIndicatorHidden !== hide ) {\n\t\t\t\t_togglePswpClass(_loadingIndicator, 'preloader--active', !hide);\n\t\t\t\t_loadingIndicatorHidden = hide;\n\t\t\t}\n\t\t},\n\t\t_applyNavBarGaps = function(item) {\n\t\t\tvar gap = item.vGap;\n\n\t\t\tif( _fitControlsInViewport() ) {\n\t\t\t\t\n\t\t\t\tvar bars = _options.barsSize; \n\t\t\t\tif(_options.captionEl && bars.bottom === 'auto') {\n\t\t\t\t\tif(!_fakeCaptionContainer) {\n\t\t\t\t\t\t_fakeCaptionContainer = framework.createEl('pswp__caption pswp__caption--fake');\n\t\t\t\t\t\t_fakeCaptionContainer.appendChild( framework.createEl('pswp__caption__center') );\n\t\t\t\t\t\t_controls.insertBefore(_fakeCaptionContainer, _captionContainer);\n\t\t\t\t\t\tframework.addClass(_controls, 'pswp__ui--fit');\n\t\t\t\t\t}\n\t\t\t\t\tif( _options.addCaptionHTMLFn(item, _fakeCaptionContainer, true) ) {\n\n\t\t\t\t\t\tvar captionSize = _fakeCaptionContainer.clientHeight;\n\t\t\t\t\t\tgap.bottom = parseInt(captionSize,10) || 44;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgap.bottom = bars.top; // if no caption, set size of bottom gap to size of top\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgap.bottom = bars.bottom === 'auto' ? 0 : bars.bottom;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// height of top bar is static, no need to calculate it\n\t\t\t\tgap.top = bars.top;\n\t\t\t} else {\n\t\t\t\tgap.top = gap.bottom = 0;\n\t\t\t}\n\t\t},\n\t\t_setupIdle = function() {\n\t\t\t// Hide controls when mouse is used\n\t\t\tif(_options.timeToIdle) {\n\t\t\t\t_listen('mouseUsed', function() {\n\t\t\t\t\t\n\t\t\t\t\tframework.bind(document, 'mousemove', _onIdleMouseMove);\n\t\t\t\t\tframework.bind(document, 'mouseout', _onMouseLeaveWindow);\n\n\t\t\t\t\t_idleInterval = setInterval(function() {\n\t\t\t\t\t\t_idleIncrement++;\n\t\t\t\t\t\tif(_idleIncrement === 2) {\n\t\t\t\t\t\t\tui.setIdle(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, _options.timeToIdle / 2);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t_setupHidingControlsDuringGestures = function() {\n\n\t\t\t// Hide controls on vertical drag\n\t\t\t_listen('onVerticalDrag', function(now) {\n\t\t\t\tif(_controlsVisible && now < 0.95) {\n\t\t\t\t\tui.hideControls();\n\t\t\t\t} else if(!_controlsVisible && now >= 0.95) {\n\t\t\t\t\tui.showControls();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Hide controls when pinching to close\n\t\t\tvar pinchControlsHidden;\n\t\t\t_listen('onPinchClose' , function(now) {\n\t\t\t\tif(_controlsVisible && now < 0.9) {\n\t\t\t\t\tui.hideControls();\n\t\t\t\t\tpinchControlsHidden = true;\n\t\t\t\t} else if(pinchControlsHidden && !_controlsVisible && now > 0.9) {\n\t\t\t\t\tui.showControls();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_listen('zoomGestureEnded', function() {\n\t\t\t\tpinchControlsHidden = false;\n\t\t\t\tif(pinchControlsHidden && !_controlsVisible) {\n\t\t\t\t\tui.showControls();\n\t\t\t\t}\n\t\t\t});\n\n\t\t};\n\n\n\n\tvar _uiElements = [\n\t\t{ \n\t\t\tname: 'caption', \n\t\t\toption: 'captionEl',\n\t\t\tonInit: function(el) {  \n\t\t\t\t_captionContainer = el; \n\t\t\t} \n\t\t},\n\t\t{ \n\t\t\tname: 'share-modal', \n\t\t\toption: 'shareEl',\n\t\t\tonInit: function(el) {  \n\t\t\t\t_shareModal = el;\n\t\t\t},\n\t\t\tonTap: function() {\n\t\t\t\t_toggleShareModal();\n\t\t\t} \n\t\t},\n\t\t{ \n\t\t\tname: 'button--share', \n\t\t\toption: 'shareEl',\n\t\t\tonInit: function(el) { \n\t\t\t\t_shareButton = el;\n\t\t\t},\n\t\t\tonTap: function() {\n\t\t\t\t_toggleShareModal();\n\t\t\t} \n\t\t},\n\t\t{ \n\t\t\tname: 'button--zoom', \n\t\t\toption: 'zoomEl',\n\t\t\tonTap: pswp.toggleDesktopZoom\n\t\t},\n\t\t{ \n\t\t\tname: 'counter', \n\t\t\toption: 'counterEl',\n\t\t\tonInit: function(el) {  \n\t\t\t\t_indexIndicator = el;\n\t\t\t} \n\t\t},\n\t\t{ \n\t\t\tname: 'button--close', \n\t\t\toption: 'closeEl',\n\t\t\tonTap: pswp.close\n\t\t},\n\t\t{ \n\t\t\tname: 'button--arrow--left', \n\t\t\toption: 'arrowEl',\n\t\t\tonTap: pswp.prev\n\t\t},\n\t\t{ \n\t\t\tname: 'button--arrow--right', \n\t\t\toption: 'arrowEl',\n\t\t\tonTap: pswp.next\n\t\t},\n\t\t{ \n\t\t\tname: 'button--fs', \n\t\t\toption: 'fullscreenEl',\n\t\t\tonTap: function() {  \n\t\t\t\tif(_fullscrenAPI.isFullscreen()) {\n\t\t\t\t\t_fullscrenAPI.exit();\n\t\t\t\t} else {\n\t\t\t\t\t_fullscrenAPI.enter();\n\t\t\t\t}\n\t\t\t} \n\t\t},\n\t\t{ \n\t\t\tname: 'preloader', \n\t\t\toption: 'preloaderEl',\n\t\t\tonInit: function(el) {  \n\t\t\t\t_loadingIndicator = el;\n\t\t\t} \n\t\t}\n\n\t];\n\n\tvar _setupUIElements = function() {\n\t\tvar item,\n\t\t\tclassAttr,\n\t\t\tuiElement;\n\n\t\tvar loopThroughChildElements = function(sChildren) {\n\t\t\tif(!sChildren) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar l = sChildren.length;\n\t\t\tfor(var i = 0; i < l; i++) {\n\t\t\t\titem = sChildren[i];\n\t\t\t\tclassAttr = item.className;\n\n\t\t\t\tfor(var a = 0; a < _uiElements.length; a++) {\n\t\t\t\t\tuiElement = _uiElements[a];\n\n\t\t\t\t\tif(classAttr.indexOf('pswp__' + uiElement.name) > -1  ) {\n\n\t\t\t\t\t\tif( _options[uiElement.option] ) { // if element is not disabled from options\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tframework.removeClass(item, 'pswp__element--disabled');\n\t\t\t\t\t\t\tif(uiElement.onInit) {\n\t\t\t\t\t\t\t\tuiElement.onInit(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//item.style.display = 'block';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tframework.addClass(item, 'pswp__element--disabled');\n\t\t\t\t\t\t\t//item.style.display = 'none';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tloopThroughChildElements(_controls.children);\n\n\t\tvar topBar =  framework.getChildByClass(_controls, 'pswp__top-bar');\n\t\tif(topBar) {\n\t\t\tloopThroughChildElements( topBar.children );\n\t\t}\n\t};\n\n\n\t\n\n\tui.init = function() {\n\n\t\t// extend options\n\t\tframework.extend(pswp.options, _defaultUIOptions, true);\n\n\t\t// create local link for fast access\n\t\t_options = pswp.options;\n\n\t\t// find pswp__ui element\n\t\t_controls = framework.getChildByClass(pswp.scrollWrap, 'pswp__ui');\n\n\t\t// create local link\n\t\t_listen = pswp.listen;\n\n\n\t\t_setupHidingControlsDuringGestures();\n\n\t\t// update controls when slides change\n\t\t_listen('beforeChange', ui.update);\n\n\t\t// toggle zoom on double-tap\n\t\t_listen('doubleTap', function(point) {\n\t\t\tvar initialZoomLevel = pswp.currItem.initialZoomLevel;\n\t\t\tif(pswp.getZoomLevel() !== initialZoomLevel) {\n\t\t\t\tpswp.zoomTo(initialZoomLevel, point, 333);\n\t\t\t} else {\n\t\t\t\tpswp.zoomTo(_options.getDoubleTapZoom(false, pswp.currItem), point, 333);\n\t\t\t}\n\t\t});\n\n\t\t// Allow text selection in caption\n\t\t_listen('preventDragEvent', function(e, isDown, preventObj) {\n\t\t\tvar t = e.target || e.srcElement;\n\t\t\tif(\n\t\t\t\tt && \n\t\t\t\tt.getAttribute('class') && e.type.indexOf('mouse') > -1 && \n\t\t\t\t( t.getAttribute('class').indexOf('__caption') > 0 || (/(SMALL|STRONG|EM)/i).test(t.tagName) ) \n\t\t\t) {\n\t\t\t\tpreventObj.prevent = false;\n\t\t\t}\n\t\t});\n\n\t\t// bind events for UI\n\t\t_listen('bindEvents', function() {\n\t\t\tframework.bind(_controls, 'pswpTap click', _onControlsTap);\n\t\t\tframework.bind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap);\n\n\t\t\tif(!pswp.likelyTouchDevice) {\n\t\t\t\tframework.bind(pswp.scrollWrap, 'mouseover', ui.onMouseOver);\n\t\t\t}\n\t\t});\n\n\t\t// unbind events for UI\n\t\t_listen('unbindEvents', function() {\n\t\t\tif(!_shareModalHidden) {\n\t\t\t\t_toggleShareModal();\n\t\t\t}\n\n\t\t\tif(_idleInterval) {\n\t\t\t\tclearInterval(_idleInterval);\n\t\t\t}\n\t\t\tframework.unbind(document, 'mouseout', _onMouseLeaveWindow);\n\t\t\tframework.unbind(document, 'mousemove', _onIdleMouseMove);\n\t\t\tframework.unbind(_controls, 'pswpTap click', _onControlsTap);\n\t\t\tframework.unbind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap);\n\t\t\tframework.unbind(pswp.scrollWrap, 'mouseover', ui.onMouseOver);\n\n\t\t\tif(_fullscrenAPI) {\n\t\t\t\tframework.unbind(document, _fullscrenAPI.eventK, ui.updateFullscreen);\n\t\t\t\tif(_fullscrenAPI.isFullscreen()) {\n\t\t\t\t\t_options.hideAnimationDuration = 0;\n\t\t\t\t\t_fullscrenAPI.exit();\n\t\t\t\t}\n\t\t\t\t_fullscrenAPI = null;\n\t\t\t}\n\t\t});\n\n\n\t\t// clean up things when gallery is destroyed\n\t\t_listen('destroy', function() {\n\t\t\tif(_options.captionEl) {\n\t\t\t\tif(_fakeCaptionContainer) {\n\t\t\t\t\t_controls.removeChild(_fakeCaptionContainer);\n\t\t\t\t}\n\t\t\t\tframework.removeClass(_captionContainer, 'pswp__caption--empty');\n\t\t\t}\n\n\t\t\tif(_shareModal) {\n\t\t\t\t_shareModal.children[0].onclick = null;\n\t\t\t}\n\t\t\tframework.removeClass(_controls, 'pswp__ui--over-close');\n\t\t\tframework.addClass( _controls, 'pswp__ui--hidden');\n\t\t\tui.setIdle(false);\n\t\t});\n\t\t\n\n\t\tif(!_options.showAnimationDuration) {\n\t\t\tframework.removeClass( _controls, 'pswp__ui--hidden');\n\t\t}\n\t\t_listen('initialZoomIn', function() {\n\t\t\tif(_options.showAnimationDuration) {\n\t\t\t\tframework.removeClass( _controls, 'pswp__ui--hidden');\n\t\t\t}\n\t\t});\n\t\t_listen('initialZoomOut', function() {\n\t\t\tframework.addClass( _controls, 'pswp__ui--hidden');\n\t\t});\n\n\t\t_listen('parseVerticalMargin', _applyNavBarGaps);\n\t\t\n\t\t_setupUIElements();\n\n\t\tif(_options.shareEl && _shareButton && _shareModal) {\n\t\t\t_shareModalHidden = true;\n\t\t}\n\n\t\t_countNumItems();\n\n\t\t_setupIdle();\n\n\t\t_setupFullscreenAPI();\n\n\t\t_setupLoadingIndicator();\n\t};\n\n\tui.setIdle = function(isIdle) {\n\t\t_isIdle = isIdle;\n\t\t_togglePswpClass(_controls, 'ui--idle', isIdle);\n\t};\n\n\tui.update = function() {\n\t\t// Don't update UI if it's hidden\n\t\tif(_controlsVisible && pswp.currItem) {\n\t\t\t\n\t\t\tui.updateIndexIndicator();\n\n\t\t\tif(_options.captionEl) {\n\t\t\t\t_options.addCaptionHTMLFn(pswp.currItem, _captionContainer);\n\n\t\t\t\t_togglePswpClass(_captionContainer, 'caption--empty', !pswp.currItem.title);\n\t\t\t}\n\n\t\t\t_overlayUIUpdated = true;\n\n\t\t} else {\n\t\t\t_overlayUIUpdated = false;\n\t\t}\n\n\t\tif(!_shareModalHidden) {\n\t\t\t_toggleShareModal();\n\t\t}\n\n\t\t_countNumItems();\n\t};\n\n\tui.updateFullscreen = function(e) {\n\n\t\tif(e) {\n\t\t\t// some browsers change window scroll position during the fullscreen\n\t\t\t// so PhotoSwipe updates it just in case\n\t\t\tsetTimeout(function() {\n\t\t\t\tpswp.setScrollOffset( 0, framework.getScrollY() );\n\t\t\t}, 50);\n\t\t}\n\t\t\n\t\t// toogle pswp--fs class on root element\n\t\tframework[ (_fullscrenAPI.isFullscreen() ? 'add' : 'remove') + 'Class' ](pswp.template, 'pswp--fs');\n\t};\n\n\tui.updateIndexIndicator = function() {\n\t\tif(_options.counterEl) {\n\t\t\t_indexIndicator.innerHTML = (pswp.getCurrentIndex()+1) + \n\t\t\t\t\t\t\t\t\t\t_options.indexIndicatorSep + \n\t\t\t\t\t\t\t\t\t\t_options.getNumItemsFn();\n\t\t}\n\t};\n\t\n\tui.onGlobalTap = function(e) {\n\t\te = e || window.event;\n\t\tvar target = e.target || e.srcElement;\n\n\t\tif(_blockControlsTap) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(e.detail && e.detail.pointerType === 'mouse') {\n\n\t\t\t// close gallery if clicked outside of the image\n\t\t\tif(_hasCloseClass(target)) {\n\t\t\t\tpswp.close();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(framework.hasClass(target, 'pswp__img')) {\n\t\t\t\tif(pswp.getZoomLevel() === 1 && pswp.getZoomLevel() <= pswp.currItem.fitRatio) {\n\t\t\t\t\tif(_options.clickToCloseNonZoomable) {\n\t\t\t\t\t\tpswp.close();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpswp.toggleDesktopZoom(e.detail.releasePoint);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else {\n\n\t\t\t// tap anywhere (except buttons) to toggle visibility of controls\n\t\t\tif(_options.tapToToggleControls) {\n\t\t\t\tif(_controlsVisible) {\n\t\t\t\t\tui.hideControls();\n\t\t\t\t} else {\n\t\t\t\t\tui.showControls();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// tap to close gallery\n\t\t\tif(_options.tapToClose && (framework.hasClass(target, 'pswp__img') || _hasCloseClass(target)) ) {\n\t\t\t\tpswp.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t}\n\t};\n\tui.onMouseOver = function(e) {\n\t\te = e || window.event;\n\t\tvar target = e.target || e.srcElement;\n\n\t\t// add class when mouse is over an element that should close the gallery\n\t\t_togglePswpClass(_controls, 'ui--over-close', _hasCloseClass(target));\n\t};\n\n\tui.hideControls = function() {\n\t\tframework.addClass(_controls,'pswp__ui--hidden');\n\t\t_controlsVisible = false;\n\t};\n\n\tui.showControls = function() {\n\t\t_controlsVisible = true;\n\t\tif(!_overlayUIUpdated) {\n\t\t\tui.update();\n\t\t}\n\t\tframework.removeClass(_controls,'pswp__ui--hidden');\n\t};\n\n\tui.supportsFullscreen = function() {\n\t\tvar d = document;\n\t\treturn !!(d.exitFullscreen || d.mozCancelFullScreen || d.webkitExitFullscreen || d.msExitFullscreen);\n\t};\n\n\tui.getFullscreenAPI = function() {\n\t\tvar dE = document.documentElement,\n\t\t\tapi,\n\t\t\ttF = 'fullscreenchange';\n\n\t\tif (dE.requestFullscreen) {\n\t\t\tapi = {\n\t\t\t\tenterK: 'requestFullscreen',\n\t\t\t\texitK: 'exitFullscreen',\n\t\t\t\telementK: 'fullscreenElement',\n\t\t\t\teventK: tF\n\t\t\t};\n\n\t\t} else if(dE.mozRequestFullScreen ) {\n\t\t\tapi = {\n\t\t\t\tenterK: 'mozRequestFullScreen',\n\t\t\t\texitK: 'mozCancelFullScreen',\n\t\t\t\telementK: 'mozFullScreenElement',\n\t\t\t\teventK: 'moz' + tF\n\t\t\t};\n\n\t\t\t\n\n\t\t} else if(dE.webkitRequestFullscreen) {\n\t\t\tapi = {\n\t\t\t\tenterK: 'webkitRequestFullscreen',\n\t\t\t\texitK: 'webkitExitFullscreen',\n\t\t\t\telementK: 'webkitFullscreenElement',\n\t\t\t\teventK: 'webkit' + tF\n\t\t\t};\n\n\t\t} else if(dE.msRequestFullscreen) {\n\t\t\tapi = {\n\t\t\t\tenterK: 'msRequestFullscreen',\n\t\t\t\texitK: 'msExitFullscreen',\n\t\t\t\telementK: 'msFullscreenElement',\n\t\t\t\teventK: 'MSFullscreenChange'\n\t\t\t};\n\t\t}\n\n\t\tif(api) {\n\t\t\tapi.enter = function() { \n\t\t\t\t// disable close-on-scroll in fullscreen\n\t\t\t\t_initalCloseOnScrollValue = _options.closeOnScroll; \n\t\t\t\t_options.closeOnScroll = false; \n\n\t\t\t\tif(this.enterK === 'webkitRequestFullscreen') {\n\t\t\t\t\tpswp.template[this.enterK]( Element.ALLOW_KEYBOARD_INPUT );\n\t\t\t\t} else {\n\t\t\t\t\treturn pswp.template[this.enterK](); \n\t\t\t\t}\n\t\t\t};\n\t\t\tapi.exit = function() { \n\t\t\t\t_options.closeOnScroll = _initalCloseOnScrollValue;\n\n\t\t\t\treturn document[this.exitK](); \n\n\t\t\t};\n\t\t\tapi.isFullscreen = function() { return document[this.elementK]; };\n\t\t}\n\n\t\treturn api;\n\t};\n\n\n\n};\nreturn PhotoSwipeUI_Default;\n\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhvdG9zd2lwZS9kaXN0L3Bob3Rvc3dpcGUtdWktZGVmYXVsdC5qcz8xNGZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7QUFDQSxLQUFLLElBQTBDO0FBQy9DLEVBQUUsb0NBQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ2pCLEVBQUUsTUFBTSxFQUlOO0FBQ0YsQ0FBQzs7QUFFRDs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLLDhGQUE4RixLQUFLLEVBQUU7QUFDMUcsS0FBSywwRUFBMEUsTUFBTSxPQUFPLEtBQUssRUFBRTtBQUNuRyxLQUFLO0FBQ0wscUJBQXFCLEtBQUssU0FBUyxXQUFXLGVBQWUsTUFBTSxFQUFFO0FBQ3JFLEtBQUssOENBQThDLGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFD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Rzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQjtBQUNBO0FBQ0EsdUQ7QUFDQSxtQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDO0FBQ0E7QUFDQTtBQUNBLDBCO0FBQ0E7O0FBRUEsa0M7O0FBRUE7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bob3Rvc3dpcGUvZGlzdC9waG90b3N3aXBlLXVpLWRlZmF1bHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgUGhvdG9Td2lwZSBEZWZhdWx0IFVJIC0gNC4xLjMgLSAyMDE5LTAxLTA4XG4qIGh0dHA6Ly9waG90b3N3aXBlLmNvbVxuKiBDb3B5cmlnaHQgKGMpIDIwMTkgRG1pdHJ5IFNlbWVub3Y7ICovXG4vKipcbipcbiogVUkgb24gdG9wIG9mIG1haW4gc2xpZGluZyBhcmVhIChjYXB0aW9uLCBhcnJvd3MsIGNsb3NlIGJ1dHRvbiwgZXRjLikuXG4qIEJ1aWx0IGp1c3QgdXNpbmcgcHVibGljIG1ldGhvZHMvcHJvcGVydGllcyBvZiBQaG90b1N3aXBlLlxuKiBcbiovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHsgXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdC5QaG90b1N3aXBlVUlfRGVmYXVsdCA9IGZhY3RvcnkoKTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBQaG90b1N3aXBlVUlfRGVmYXVsdCA9XG4gZnVuY3Rpb24ocHN3cCwgZnJhbWV3b3JrKSB7XG5cblx0dmFyIHVpID0gdGhpcztcblx0dmFyIF9vdmVybGF5VUlVcGRhdGVkID0gZmFsc2UsXG5cdFx0X2NvbnRyb2xzVmlzaWJsZSA9IHRydWUsXG5cdFx0X2Z1bGxzY3JlbkFQSSxcblx0XHRfY29udHJvbHMsXG5cdFx0X2NhcHRpb25Db250YWluZXIsXG5cdFx0X2Zha2VDYXB0aW9uQ29udGFpbmVyLFxuXHRcdF9pbmRleEluZGljYXRvcixcblx0XHRfc2hhcmVCdXR0b24sXG5cdFx0X3NoYXJlTW9kYWwsXG5cdFx0X3NoYXJlTW9kYWxIaWRkZW4gPSB0cnVlLFxuXHRcdF9pbml0YWxDbG9zZU9uU2Nyb2xsVmFsdWUsXG5cdFx0X2lzSWRsZSxcblx0XHRfbGlzdGVuLFxuXG5cdFx0X2xvYWRpbmdJbmRpY2F0b3IsXG5cdFx0X2xvYWRpbmdJbmRpY2F0b3JIaWRkZW4sXG5cdFx0X2xvYWRpbmdJbmRpY2F0b3JUaW1lb3V0LFxuXG5cdFx0X2dhbGxlcnlIYXNPbmVTbGlkZSxcblxuXHRcdF9vcHRpb25zLFxuXHRcdF9kZWZhdWx0VUlPcHRpb25zID0ge1xuXHRcdFx0YmFyc1NpemU6IHt0b3A6NDQsIGJvdHRvbTonYXV0byd9LFxuXHRcdFx0Y2xvc2VFbENsYXNzZXM6IFsnaXRlbScsICdjYXB0aW9uJywgJ3pvb20td3JhcCcsICd1aScsICd0b3AtYmFyJ10sIFxuXHRcdFx0dGltZVRvSWRsZTogNDAwMCwgXG5cdFx0XHR0aW1lVG9JZGxlT3V0c2lkZTogMTAwMCxcblx0XHRcdGxvYWRpbmdJbmRpY2F0b3JEZWxheTogMTAwMCwgLy8gMnNcblx0XHRcdFxuXHRcdFx0YWRkQ2FwdGlvbkhUTUxGbjogZnVuY3Rpb24oaXRlbSwgY2FwdGlvbkVsIC8qLCBpc0Zha2UgKi8pIHtcblx0XHRcdFx0aWYoIWl0ZW0udGl0bGUpIHtcblx0XHRcdFx0XHRjYXB0aW9uRWwuY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhcHRpb25FbC5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBpdGVtLnRpdGxlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdGNsb3NlRWw6dHJ1ZSxcblx0XHRcdGNhcHRpb25FbDogdHJ1ZSxcblx0XHRcdGZ1bGxzY3JlZW5FbDogdHJ1ZSxcblx0XHRcdHpvb21FbDogdHJ1ZSxcblx0XHRcdHNoYXJlRWw6IHRydWUsXG5cdFx0XHRjb3VudGVyRWw6IHRydWUsXG5cdFx0XHRhcnJvd0VsOiB0cnVlLFxuXHRcdFx0cHJlbG9hZGVyRWw6IHRydWUsXG5cblx0XHRcdHRhcFRvQ2xvc2U6IGZhbHNlLFxuXHRcdFx0dGFwVG9Ub2dnbGVDb250cm9sczogdHJ1ZSxcblxuXHRcdFx0Y2xpY2tUb0Nsb3NlTm9uWm9vbWFibGU6IHRydWUsXG5cblx0XHRcdHNoYXJlQnV0dG9uczogW1xuXHRcdFx0XHR7aWQ6J2ZhY2Vib29rJywgbGFiZWw6J1NoYXJlIG9uIEZhY2Vib29rJywgdXJsOidodHRwczovL3d3dy5mYWNlYm9vay5jb20vc2hhcmVyL3NoYXJlci5waHA/dT17e3VybH19J30sXG5cdFx0XHRcdHtpZDondHdpdHRlcicsIGxhYmVsOidUd2VldCcsIHVybDonaHR0cHM6Ly90d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQ/dGV4dD17e3RleHR9fSZ1cmw9e3t1cmx9fSd9LFxuXHRcdFx0XHR7aWQ6J3BpbnRlcmVzdCcsIGxhYmVsOidQaW4gaXQnLCB1cmw6J2h0dHA6Ly93d3cucGludGVyZXN0LmNvbS9waW4vY3JlYXRlL2J1dHRvbi8nK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnP3VybD17e3VybH19Jm1lZGlhPXt7aW1hZ2VfdXJsfX0mZGVzY3JpcHRpb249e3t0ZXh0fX0nfSxcblx0XHRcdFx0e2lkOidkb3dubG9hZCcsIGxhYmVsOidEb3dubG9hZCBpbWFnZScsIHVybDone3tyYXdfaW1hZ2VfdXJsfX0nLCBkb3dubG9hZDp0cnVlfVxuXHRcdFx0XSxcblx0XHRcdGdldEltYWdlVVJMRm9yU2hhcmU6IGZ1bmN0aW9uKCAvKiBzaGFyZUJ1dHRvbkRhdGEgKi8gKSB7XG5cdFx0XHRcdHJldHVybiBwc3dwLmN1cnJJdGVtLnNyYyB8fCAnJztcblx0XHRcdH0sXG5cdFx0XHRnZXRQYWdlVVJMRm9yU2hhcmU6IGZ1bmN0aW9uKCAvKiBzaGFyZUJ1dHRvbkRhdGEgKi8gKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZjtcblx0XHRcdH0sXG5cdFx0XHRnZXRUZXh0Rm9yU2hhcmU6IGZ1bmN0aW9uKCAvKiBzaGFyZUJ1dHRvbkRhdGEgKi8gKSB7XG5cdFx0XHRcdHJldHVybiBwc3dwLmN1cnJJdGVtLnRpdGxlIHx8ICcnO1xuXHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRpbmRleEluZGljYXRvclNlcDogJyAvICcsXG5cdFx0XHRmaXRDb250cm9sc1dpZHRoOiAxMjAwXG5cblx0XHR9LFxuXHRcdF9ibG9ja0NvbnRyb2xzVGFwLFxuXHRcdF9ibG9ja0NvbnRyb2xzVGFwVGltZW91dDtcblxuXG5cblx0dmFyIF9vbkNvbnRyb2xzVGFwID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYoX2Jsb2NrQ29udHJvbHNUYXApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblxuXHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG5cdFx0XHRpZihfb3B0aW9ucy50aW1lVG9JZGxlICYmIF9vcHRpb25zLm1vdXNlVXNlZCAmJiAhX2lzSWRsZSkge1xuXHRcdFx0XHQvLyByZXNldCBpZGxlIHRpbWVyXG5cdFx0XHRcdF9vbklkbGVNb3VzZU1vdmUoKTtcblx0XHRcdH1cblxuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuXHRcdFx0XHR1aUVsZW1lbnQsXG5cdFx0XHRcdGNsaWNrZWRDbGFzcyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycsXG5cdFx0XHRcdGZvdW5kO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgX3VpRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dWlFbGVtZW50ID0gX3VpRWxlbWVudHNbaV07XG5cdFx0XHRcdGlmKHVpRWxlbWVudC5vblRhcCAmJiBjbGlja2VkQ2xhc3MuaW5kZXhPZigncHN3cF9fJyArIHVpRWxlbWVudC5uYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHR1aUVsZW1lbnQub25UYXAoKTtcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihmb3VuZCkge1xuXHRcdFx0XHRpZihlLnN0b3BQcm9wYWdhdGlvbikge1xuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2Jsb2NrQ29udHJvbHNUYXAgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIFNvbWUgdmVyc2lvbnMgb2YgQW5kcm9pZCBkb24ndCBwcmV2ZW50IGdob3N0IGNsaWNrIGV2ZW50IFxuXHRcdFx0XHQvLyB3aGVuIHByZXZlbnREZWZhdWx0KCkgd2FzIGNhbGxlZCBvbiB0b3VjaHN0YXJ0IGFuZC9vciB0b3VjaGVuZC5cblx0XHRcdFx0Ly8gXG5cdFx0XHRcdC8vIFRoaXMgaGFwcGVucyBvbiB2NC4zLCA0LjIsIDQuMSwgXG5cdFx0XHRcdC8vIG9sZGVyIHZlcnNpb25zIHN0cmFuZ2VseSB3b3JrIGNvcnJlY3RseSwgXG5cdFx0XHRcdC8vIGJ1dCBqdXN0IGluIGNhc2Ugd2UgYWRkIGRlbGF5IG9uIGFsbCBvZiB0aGVtKVx0XG5cdFx0XHRcdHZhciB0YXBEZWxheSA9IGZyYW1ld29yay5mZWF0dXJlcy5pc09sZEFuZHJvaWQgPyA2MDAgOiAzMDtcblx0XHRcdFx0X2Jsb2NrQ29udHJvbHNUYXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfYmxvY2tDb250cm9sc1RhcCA9IGZhbHNlO1xuXHRcdFx0XHR9LCB0YXBEZWxheSk7XG5cdFx0XHR9XG5cblx0XHR9LFxuXHRcdF9maXRDb250cm9sc0luVmlld3BvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhcHN3cC5saWtlbHlUb3VjaERldmljZSB8fCBfb3B0aW9ucy5tb3VzZVVzZWQgfHwgc2NyZWVuLndpZHRoID4gX29wdGlvbnMuZml0Q29udHJvbHNXaWR0aDtcblx0XHR9LFxuXHRcdF90b2dnbGVQc3dwQ2xhc3MgPSBmdW5jdGlvbihlbCwgY05hbWUsIGFkZCkge1xuXHRcdFx0ZnJhbWV3b3JrWyAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnQ2xhc3MnIF0oZWwsICdwc3dwX18nICsgY05hbWUpO1xuXHRcdH0sXG5cblx0XHQvLyBhZGQgY2xhc3Mgd2hlbiB0aGVyZSBpcyBqdXN0IG9uZSBpdGVtIGluIHRoZSBnYWxsZXJ5XG5cdFx0Ly8gKGJ5IGRlZmF1bHQgaXQgaGlkZXMgbGVmdC9yaWdodCBhcnJvd3MgYW5kIDFvZlggY291bnRlcilcblx0XHRfY291bnROdW1JdGVtcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhc09uZVNsaWRlID0gKF9vcHRpb25zLmdldE51bUl0ZW1zRm4oKSA9PT0gMSk7XG5cblx0XHRcdGlmKGhhc09uZVNsaWRlICE9PSBfZ2FsbGVyeUhhc09uZVNsaWRlKSB7XG5cdFx0XHRcdF90b2dnbGVQc3dwQ2xhc3MoX2NvbnRyb2xzLCAndWktLW9uZS1zbGlkZScsIGhhc09uZVNsaWRlKTtcblx0XHRcdFx0X2dhbGxlcnlIYXNPbmVTbGlkZSA9IGhhc09uZVNsaWRlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3RvZ2dsZVNoYXJlTW9kYWxDbGFzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RvZ2dsZVBzd3BDbGFzcyhfc2hhcmVNb2RhbCwgJ3NoYXJlLW1vZGFsLS1oaWRkZW4nLCBfc2hhcmVNb2RhbEhpZGRlbik7XG5cdFx0fSxcblx0XHRfdG9nZ2xlU2hhcmVNb2RhbCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRfc2hhcmVNb2RhbEhpZGRlbiA9ICFfc2hhcmVNb2RhbEhpZGRlbjtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRpZighX3NoYXJlTW9kYWxIaWRkZW4pIHtcblx0XHRcdFx0X3RvZ2dsZVNoYXJlTW9kYWxDbGFzcygpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmKCFfc2hhcmVNb2RhbEhpZGRlbikge1xuXHRcdFx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKF9zaGFyZU1vZGFsLCAncHN3cF9fc2hhcmUtbW9kYWwtLWZhZGUtaW4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDMwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyhfc2hhcmVNb2RhbCwgJ3Bzd3BfX3NoYXJlLW1vZGFsLS1mYWRlLWluJyk7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoX3NoYXJlTW9kYWxIaWRkZW4pIHtcblx0XHRcdFx0XHRcdF90b2dnbGVTaGFyZU1vZGFsQ2xhc3MoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDMwMCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKCFfc2hhcmVNb2RhbEhpZGRlbikge1xuXHRcdFx0XHRfdXBkYXRlU2hhcmVVUkxzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdF9vcGVuV2luZG93UG9wdXAgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdFx0XHRwc3dwLnNob3V0KCdzaGFyZUxpbmtDbGljaycsIGUsIHRhcmdldCk7XG5cblx0XHRcdGlmKCF0YXJnZXQuaHJlZikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCB0YXJnZXQuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0d2luZG93Lm9wZW4odGFyZ2V0LmhyZWYsICdwc3dwX3NoYXJlJywgJ3Njcm9sbGJhcnM9eWVzLHJlc2l6YWJsZT15ZXMsdG9vbGJhcj1ubywnK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnbG9jYXRpb249eWVzLHdpZHRoPTU1MCxoZWlnaHQ9NDIwLHRvcD0xMDAsbGVmdD0nICsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCh3aW5kb3cuc2NyZWVuID8gTWF0aC5yb3VuZChzY3JlZW4ud2lkdGggLyAyIC0gMjc1KSA6IDEwMCkgICk7XG5cblx0XHRcdGlmKCFfc2hhcmVNb2RhbEhpZGRlbikge1xuXHRcdFx0XHRfdG9nZ2xlU2hhcmVNb2RhbCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRfdXBkYXRlU2hhcmVVUkxzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2hhcmVCdXR0b25PdXQgPSAnJyxcblx0XHRcdFx0c2hhcmVCdXR0b25EYXRhLFxuXHRcdFx0XHRzaGFyZVVSTCxcblx0XHRcdFx0aW1hZ2VfdXJsLFxuXHRcdFx0XHRwYWdlX3VybCxcblx0XHRcdFx0c2hhcmVfdGV4dDtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IF9vcHRpb25zLnNoYXJlQnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzaGFyZUJ1dHRvbkRhdGEgPSBfb3B0aW9ucy5zaGFyZUJ1dHRvbnNbaV07XG5cblx0XHRcdFx0aW1hZ2VfdXJsID0gX29wdGlvbnMuZ2V0SW1hZ2VVUkxGb3JTaGFyZShzaGFyZUJ1dHRvbkRhdGEpO1xuXHRcdFx0XHRwYWdlX3VybCA9IF9vcHRpb25zLmdldFBhZ2VVUkxGb3JTaGFyZShzaGFyZUJ1dHRvbkRhdGEpO1xuXHRcdFx0XHRzaGFyZV90ZXh0ID0gX29wdGlvbnMuZ2V0VGV4dEZvclNoYXJlKHNoYXJlQnV0dG9uRGF0YSk7XG5cblx0XHRcdFx0c2hhcmVVUkwgPSBzaGFyZUJ1dHRvbkRhdGEudXJsLnJlcGxhY2UoJ3t7dXJsfX0nLCBlbmNvZGVVUklDb21wb25lbnQocGFnZV91cmwpIClcblx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCd7e2ltYWdlX3VybH19JywgZW5jb2RlVVJJQ29tcG9uZW50KGltYWdlX3VybCkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoJ3t7cmF3X2ltYWdlX3VybH19JywgaW1hZ2VfdXJsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCd7e3RleHR9fScsIGVuY29kZVVSSUNvbXBvbmVudChzaGFyZV90ZXh0KSApO1xuXG5cdFx0XHRcdHNoYXJlQnV0dG9uT3V0ICs9ICc8YSBocmVmPVwiJyArIHNoYXJlVVJMICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiICcrXG5cdFx0XHRcdFx0XHRcdFx0XHQnY2xhc3M9XCJwc3dwX19zaGFyZS0tJyArIHNoYXJlQnV0dG9uRGF0YS5pZCArICdcIicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0KHNoYXJlQnV0dG9uRGF0YS5kb3dubG9hZCA/ICdkb3dubG9hZCcgOiAnJykgKyAnPicgKyBcblx0XHRcdFx0XHRcdFx0XHRcdHNoYXJlQnV0dG9uRGF0YS5sYWJlbCArICc8L2E+JztcblxuXHRcdFx0XHRpZihfb3B0aW9ucy5wYXJzZVNoYXJlQnV0dG9uT3V0KSB7XG5cdFx0XHRcdFx0c2hhcmVCdXR0b25PdXQgPSBfb3B0aW9ucy5wYXJzZVNoYXJlQnV0dG9uT3V0KHNoYXJlQnV0dG9uRGF0YSwgc2hhcmVCdXR0b25PdXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRfc2hhcmVNb2RhbC5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBzaGFyZUJ1dHRvbk91dDtcblx0XHRcdF9zaGFyZU1vZGFsLmNoaWxkcmVuWzBdLm9uY2xpY2sgPSBfb3BlbldpbmRvd1BvcHVwO1xuXG5cdFx0fSxcblx0XHRfaGFzQ2xvc2VDbGFzcyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0Zm9yKHZhciAgaSA9IDA7IGkgPCBfb3B0aW9ucy5jbG9zZUVsQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiggZnJhbWV3b3JrLmhhc0NsYXNzKHRhcmdldCwgJ3Bzd3BfXycgKyBfb3B0aW9ucy5jbG9zZUVsQ2xhc3Nlc1tpXSkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdF9pZGxlSW50ZXJ2YWwsXG5cdFx0X2lkbGVUaW1lcixcblx0XHRfaWRsZUluY3JlbWVudCA9IDAsXG5cdFx0X29uSWRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KF9pZGxlVGltZXIpO1xuXHRcdFx0X2lkbGVJbmNyZW1lbnQgPSAwO1xuXHRcdFx0aWYoX2lzSWRsZSkge1xuXHRcdFx0XHR1aS5zZXRJZGxlKGZhbHNlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9vbk1vdXNlTGVhdmVXaW5kb3cgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRlID0gZSA/IGUgOiB3aW5kb3cuZXZlbnQ7XG5cdFx0XHR2YXIgZnJvbSA9IGUucmVsYXRlZFRhcmdldCB8fCBlLnRvRWxlbWVudDtcblx0XHRcdGlmICghZnJvbSB8fCBmcm9tLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9pZGxlVGltZXIpO1xuXHRcdFx0XHRfaWRsZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR1aS5zZXRJZGxlKHRydWUpO1xuXHRcdFx0XHR9LCBfb3B0aW9ucy50aW1lVG9JZGxlT3V0c2lkZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfc2V0dXBGdWxsc2NyZWVuQVBJID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihfb3B0aW9ucy5mdWxsc2NyZWVuRWwgJiYgIWZyYW1ld29yay5mZWF0dXJlcy5pc09sZEFuZHJvaWQpIHtcblx0XHRcdFx0aWYoIV9mdWxsc2NyZW5BUEkpIHtcblx0XHRcdFx0XHRfZnVsbHNjcmVuQVBJID0gdWkuZ2V0RnVsbHNjcmVlbkFQSSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKF9mdWxsc2NyZW5BUEkpIHtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgX2Z1bGxzY3JlbkFQSS5ldmVudEssIHVpLnVwZGF0ZUZ1bGxzY3JlZW4pO1xuXHRcdFx0XHRcdHVpLnVwZGF0ZUZ1bGxzY3JlZW4oKTtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYWRkQ2xhc3MocHN3cC50ZW1wbGF0ZSwgJ3Bzd3AtLXN1cHBvcnRzLWZzJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHBzd3AudGVtcGxhdGUsICdwc3dwLS1zdXBwb3J0cy1mcycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfc2V0dXBMb2FkaW5nSW5kaWNhdG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBTZXR1cCBsb2FkaW5nIGluZGljYXRvclxuXHRcdFx0aWYoX29wdGlvbnMucHJlbG9hZGVyRWwpIHtcblx0XHRcdFxuXHRcdFx0XHRfdG9nZ2xlTG9hZGluZ0luZGljYXRvcih0cnVlKTtcblxuXHRcdFx0XHRfbGlzdGVuKCdiZWZvcmVDaGFuZ2UnLCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfbG9hZGluZ0luZGljYXRvclRpbWVvdXQpO1xuXG5cdFx0XHRcdFx0Ly8gZGlzcGxheSBsb2FkaW5nIGluZGljYXRvciB3aXRoIGRlbGF5XG5cdFx0XHRcdFx0X2xvYWRpbmdJbmRpY2F0b3JUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0aWYocHN3cC5jdXJySXRlbSAmJiBwc3dwLmN1cnJJdGVtLmxvYWRpbmcpIHtcblxuXHRcdFx0XHRcdFx0XHRpZiggIXBzd3AuYWxsb3dQcm9ncmVzc2l2ZUltZygpIHx8IChwc3dwLmN1cnJJdGVtLmltZyAmJiAhcHN3cC5jdXJySXRlbS5pbWcubmF0dXJhbFdpZHRoKSAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2hvdyBwcmVsb2FkZXIgaWYgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpcyBub3QgZW5hYmxlZCwgXG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3IgaW1hZ2Ugd2lkdGggaXMgbm90IGRlZmluZWQgeWV0IChiZWNhdXNlIG9mIHNsb3cgY29ubmVjdGlvbilcblx0XHRcdFx0XHRcdFx0XHRfdG9nZ2xlTG9hZGluZ0luZGljYXRvcihmYWxzZSk7IFxuXHRcdFx0XHRcdFx0XHRcdC8vIGl0ZW1zLWNvbnRyb2xsZXIuanMgZnVuY3Rpb24gYWxsb3dQcm9ncmVzc2l2ZUltZ1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0X3RvZ2dsZUxvYWRpbmdJbmRpY2F0b3IodHJ1ZSk7IC8vIGhpZGUgcHJlbG9hZGVyXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9LCBfb3B0aW9ucy5sb2FkaW5nSW5kaWNhdG9yRGVsYXkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0X2xpc3RlbignaW1hZ2VMb2FkQ29tcGxldGUnLCBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuXHRcdFx0XHRcdGlmKHBzd3AuY3Vyckl0ZW0gPT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdF90b2dnbGVMb2FkaW5nSW5kaWNhdG9yKHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdF90b2dnbGVMb2FkaW5nSW5kaWNhdG9yID0gZnVuY3Rpb24oaGlkZSkge1xuXHRcdFx0aWYoIF9sb2FkaW5nSW5kaWNhdG9ySGlkZGVuICE9PSBoaWRlICkge1xuXHRcdFx0XHRfdG9nZ2xlUHN3cENsYXNzKF9sb2FkaW5nSW5kaWNhdG9yLCAncHJlbG9hZGVyLS1hY3RpdmUnLCAhaGlkZSk7XG5cdFx0XHRcdF9sb2FkaW5nSW5kaWNhdG9ySGlkZGVuID0gaGlkZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9hcHBseU5hdkJhckdhcHMgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgZ2FwID0gaXRlbS52R2FwO1xuXG5cdFx0XHRpZiggX2ZpdENvbnRyb2xzSW5WaWV3cG9ydCgpICkge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGJhcnMgPSBfb3B0aW9ucy5iYXJzU2l6ZTsgXG5cdFx0XHRcdGlmKF9vcHRpb25zLmNhcHRpb25FbCAmJiBiYXJzLmJvdHRvbSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0aWYoIV9mYWtlQ2FwdGlvbkNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0X2Zha2VDYXB0aW9uQ29udGFpbmVyID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19jYXB0aW9uIHBzd3BfX2NhcHRpb24tLWZha2UnKTtcblx0XHRcdFx0XHRcdF9mYWtlQ2FwdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCggZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19jYXB0aW9uX19jZW50ZXInKSApO1xuXHRcdFx0XHRcdFx0X2NvbnRyb2xzLmluc2VydEJlZm9yZShfZmFrZUNhcHRpb25Db250YWluZXIsIF9jYXB0aW9uQ29udGFpbmVyKTtcblx0XHRcdFx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyhfY29udHJvbHMsICdwc3dwX191aS0tZml0Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCBfb3B0aW9ucy5hZGRDYXB0aW9uSFRNTEZuKGl0ZW0sIF9mYWtlQ2FwdGlvbkNvbnRhaW5lciwgdHJ1ZSkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjYXB0aW9uU2l6ZSA9IF9mYWtlQ2FwdGlvbkNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRcdFx0XHRnYXAuYm90dG9tID0gcGFyc2VJbnQoY2FwdGlvblNpemUsMTApIHx8IDQ0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRnYXAuYm90dG9tID0gYmFycy50b3A7IC8vIGlmIG5vIGNhcHRpb24sIHNldCBzaXplIG9mIGJvdHRvbSBnYXAgdG8gc2l6ZSBvZiB0b3Bcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2FwLmJvdHRvbSA9IGJhcnMuYm90dG9tID09PSAnYXV0bycgPyAwIDogYmFycy5ib3R0b207XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIGhlaWdodCBvZiB0b3AgYmFyIGlzIHN0YXRpYywgbm8gbmVlZCB0byBjYWxjdWxhdGUgaXRcblx0XHRcdFx0Z2FwLnRvcCA9IGJhcnMudG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2FwLnRvcCA9IGdhcC5ib3R0b20gPSAwO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3NldHVwSWRsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSGlkZSBjb250cm9scyB3aGVuIG1vdXNlIGlzIHVzZWRcblx0XHRcdGlmKF9vcHRpb25zLnRpbWVUb0lkbGUpIHtcblx0XHRcdFx0X2xpc3RlbignbW91c2VVc2VkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZnJhbWV3b3JrLmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfb25JZGxlTW91c2VNb3ZlKTtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgJ21vdXNlb3V0JywgX29uTW91c2VMZWF2ZVdpbmRvdyk7XG5cblx0XHRcdFx0XHRfaWRsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRfaWRsZUluY3JlbWVudCsrO1xuXHRcdFx0XHRcdFx0aWYoX2lkbGVJbmNyZW1lbnQgPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0dWkuc2V0SWRsZSh0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBfb3B0aW9ucy50aW1lVG9JZGxlIC8gMik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3NldHVwSGlkaW5nQ29udHJvbHNEdXJpbmdHZXN0dXJlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBIaWRlIGNvbnRyb2xzIG9uIHZlcnRpY2FsIGRyYWdcblx0XHRcdF9saXN0ZW4oJ29uVmVydGljYWxEcmFnJywgZnVuY3Rpb24obm93KSB7XG5cdFx0XHRcdGlmKF9jb250cm9sc1Zpc2libGUgJiYgbm93IDwgMC45NSkge1xuXHRcdFx0XHRcdHVpLmhpZGVDb250cm9scygpO1xuXHRcdFx0XHR9IGVsc2UgaWYoIV9jb250cm9sc1Zpc2libGUgJiYgbm93ID49IDAuOTUpIHtcblx0XHRcdFx0XHR1aS5zaG93Q29udHJvbHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEhpZGUgY29udHJvbHMgd2hlbiBwaW5jaGluZyB0byBjbG9zZVxuXHRcdFx0dmFyIHBpbmNoQ29udHJvbHNIaWRkZW47XG5cdFx0XHRfbGlzdGVuKCdvblBpbmNoQ2xvc2UnICwgZnVuY3Rpb24obm93KSB7XG5cdFx0XHRcdGlmKF9jb250cm9sc1Zpc2libGUgJiYgbm93IDwgMC45KSB7XG5cdFx0XHRcdFx0dWkuaGlkZUNvbnRyb2xzKCk7XG5cdFx0XHRcdFx0cGluY2hDb250cm9sc0hpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZihwaW5jaENvbnRyb2xzSGlkZGVuICYmICFfY29udHJvbHNWaXNpYmxlICYmIG5vdyA+IDAuOSkge1xuXHRcdFx0XHRcdHVpLnNob3dDb250cm9scygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0X2xpc3Rlbignem9vbUdlc3R1cmVFbmRlZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwaW5jaENvbnRyb2xzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdGlmKHBpbmNoQ29udHJvbHNIaWRkZW4gJiYgIV9jb250cm9sc1Zpc2libGUpIHtcblx0XHRcdFx0XHR1aS5zaG93Q29udHJvbHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9O1xuXG5cblxuXHR2YXIgX3VpRWxlbWVudHMgPSBbXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdjYXB0aW9uJywgXG5cdFx0XHRvcHRpb246ICdjYXB0aW9uRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9jYXB0aW9uQ29udGFpbmVyID0gZWw7IFxuXHRcdFx0fSBcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnc2hhcmUtbW9kYWwnLCBcblx0XHRcdG9wdGlvbjogJ3NoYXJlRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9zaGFyZU1vZGFsID0gZWw7XG5cdFx0XHR9LFxuXHRcdFx0b25UYXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdG9nZ2xlU2hhcmVNb2RhbCgpO1xuXHRcdFx0fSBcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnYnV0dG9uLS1zaGFyZScsIFxuXHRcdFx0b3B0aW9uOiAnc2hhcmVFbCcsXG5cdFx0XHRvbkluaXQ6IGZ1bmN0aW9uKGVsKSB7IFxuXHRcdFx0XHRfc2hhcmVCdXR0b24gPSBlbDtcblx0XHRcdH0sXG5cdFx0XHRvblRhcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90b2dnbGVTaGFyZU1vZGFsKCk7XG5cdFx0XHR9IFxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdidXR0b24tLXpvb20nLCBcblx0XHRcdG9wdGlvbjogJ3pvb21FbCcsXG5cdFx0XHRvblRhcDogcHN3cC50b2dnbGVEZXNrdG9wWm9vbVxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdjb3VudGVyJywgXG5cdFx0XHRvcHRpb246ICdjb3VudGVyRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9pbmRleEluZGljYXRvciA9IGVsO1xuXHRcdFx0fSBcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnYnV0dG9uLS1jbG9zZScsIFxuXHRcdFx0b3B0aW9uOiAnY2xvc2VFbCcsXG5cdFx0XHRvblRhcDogcHN3cC5jbG9zZVxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdidXR0b24tLWFycm93LS1sZWZ0JywgXG5cdFx0XHRvcHRpb246ICdhcnJvd0VsJyxcblx0XHRcdG9uVGFwOiBwc3dwLnByZXZcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnYnV0dG9uLS1hcnJvdy0tcmlnaHQnLCBcblx0XHRcdG9wdGlvbjogJ2Fycm93RWwnLFxuXHRcdFx0b25UYXA6IHBzd3AubmV4dFxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdidXR0b24tLWZzJywgXG5cdFx0XHRvcHRpb246ICdmdWxsc2NyZWVuRWwnLFxuXHRcdFx0b25UYXA6IGZ1bmN0aW9uKCkgeyAgXG5cdFx0XHRcdGlmKF9mdWxsc2NyZW5BUEkuaXNGdWxsc2NyZWVuKCkpIHtcblx0XHRcdFx0XHRfZnVsbHNjcmVuQVBJLmV4aXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZnVsbHNjcmVuQVBJLmVudGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gXG5cdFx0fSxcblx0XHR7IFxuXHRcdFx0bmFtZTogJ3ByZWxvYWRlcicsIFxuXHRcdFx0b3B0aW9uOiAncHJlbG9hZGVyRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9sb2FkaW5nSW5kaWNhdG9yID0gZWw7XG5cdFx0XHR9IFxuXHRcdH1cblxuXHRdO1xuXG5cdHZhciBfc2V0dXBVSUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0sXG5cdFx0XHRjbGFzc0F0dHIsXG5cdFx0XHR1aUVsZW1lbnQ7XG5cblx0XHR2YXIgbG9vcFRocm91Z2hDaGlsZEVsZW1lbnRzID0gZnVuY3Rpb24oc0NoaWxkcmVuKSB7XG5cdFx0XHRpZighc0NoaWxkcmVuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGwgPSBzQ2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpdGVtID0gc0NoaWxkcmVuW2ldO1xuXHRcdFx0XHRjbGFzc0F0dHIgPSBpdGVtLmNsYXNzTmFtZTtcblxuXHRcdFx0XHRmb3IodmFyIGEgPSAwOyBhIDwgX3VpRWxlbWVudHMubGVuZ3RoOyBhKyspIHtcblx0XHRcdFx0XHR1aUVsZW1lbnQgPSBfdWlFbGVtZW50c1thXTtcblxuXHRcdFx0XHRcdGlmKGNsYXNzQXR0ci5pbmRleE9mKCdwc3dwX18nICsgdWlFbGVtZW50Lm5hbWUpID4gLTEgICkge1xuXG5cdFx0XHRcdFx0XHRpZiggX29wdGlvbnNbdWlFbGVtZW50Lm9wdGlvbl0gKSB7IC8vIGlmIGVsZW1lbnQgaXMgbm90IGRpc2FibGVkIGZyb20gb3B0aW9uc1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKGl0ZW0sICdwc3dwX19lbGVtZW50LS1kaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0XHRpZih1aUVsZW1lbnQub25Jbml0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dWlFbGVtZW50Lm9uSW5pdChpdGVtKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly9pdGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKGl0ZW0sICdwc3dwX19lbGVtZW50LS1kaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0XHQvL2l0ZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGxvb3BUaHJvdWdoQ2hpbGRFbGVtZW50cyhfY29udHJvbHMuY2hpbGRyZW4pO1xuXG5cdFx0dmFyIHRvcEJhciA9ICBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKF9jb250cm9scywgJ3Bzd3BfX3RvcC1iYXInKTtcblx0XHRpZih0b3BCYXIpIHtcblx0XHRcdGxvb3BUaHJvdWdoQ2hpbGRFbGVtZW50cyggdG9wQmFyLmNoaWxkcmVuICk7XG5cdFx0fVxuXHR9O1xuXG5cblx0XG5cblx0dWkuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gZXh0ZW5kIG9wdGlvbnNcblx0XHRmcmFtZXdvcmsuZXh0ZW5kKHBzd3Aub3B0aW9ucywgX2RlZmF1bHRVSU9wdGlvbnMsIHRydWUpO1xuXG5cdFx0Ly8gY3JlYXRlIGxvY2FsIGxpbmsgZm9yIGZhc3QgYWNjZXNzXG5cdFx0X29wdGlvbnMgPSBwc3dwLm9wdGlvbnM7XG5cblx0XHQvLyBmaW5kIHBzd3BfX3VpIGVsZW1lbnRcblx0XHRfY29udHJvbHMgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHBzd3Auc2Nyb2xsV3JhcCwgJ3Bzd3BfX3VpJyk7XG5cblx0XHQvLyBjcmVhdGUgbG9jYWwgbGlua1xuXHRcdF9saXN0ZW4gPSBwc3dwLmxpc3RlbjtcblxuXG5cdFx0X3NldHVwSGlkaW5nQ29udHJvbHNEdXJpbmdHZXN0dXJlcygpO1xuXG5cdFx0Ly8gdXBkYXRlIGNvbnRyb2xzIHdoZW4gc2xpZGVzIGNoYW5nZVxuXHRcdF9saXN0ZW4oJ2JlZm9yZUNoYW5nZScsIHVpLnVwZGF0ZSk7XG5cblx0XHQvLyB0b2dnbGUgem9vbSBvbiBkb3VibGUtdGFwXG5cdFx0X2xpc3RlbignZG91YmxlVGFwJywgZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHZhciBpbml0aWFsWm9vbUxldmVsID0gcHN3cC5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsO1xuXHRcdFx0aWYocHN3cC5nZXRab29tTGV2ZWwoKSAhPT0gaW5pdGlhbFpvb21MZXZlbCkge1xuXHRcdFx0XHRwc3dwLnpvb21Ubyhpbml0aWFsWm9vbUxldmVsLCBwb2ludCwgMzMzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBzd3Auem9vbVRvKF9vcHRpb25zLmdldERvdWJsZVRhcFpvb20oZmFsc2UsIHBzd3AuY3Vyckl0ZW0pLCBwb2ludCwgMzMzKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEFsbG93IHRleHQgc2VsZWN0aW9uIGluIGNhcHRpb25cblx0XHRfbGlzdGVuKCdwcmV2ZW50RHJhZ0V2ZW50JywgZnVuY3Rpb24oZSwgaXNEb3duLCBwcmV2ZW50T2JqKSB7XG5cdFx0XHR2YXIgdCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0XHRcdGlmKFxuXHRcdFx0XHR0ICYmIFxuXHRcdFx0XHR0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAmJiBlLnR5cGUuaW5kZXhPZignbW91c2UnKSA+IC0xICYmIFxuXHRcdFx0XHQoIHQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLmluZGV4T2YoJ19fY2FwdGlvbicpID4gMCB8fCAoLyhTTUFMTHxTVFJPTkd8RU0pL2kpLnRlc3QodC50YWdOYW1lKSApIFxuXHRcdFx0KSB7XG5cdFx0XHRcdHByZXZlbnRPYmoucHJldmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gYmluZCBldmVudHMgZm9yIFVJXG5cdFx0X2xpc3RlbignYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnJhbWV3b3JrLmJpbmQoX2NvbnRyb2xzLCAncHN3cFRhcCBjbGljaycsIF9vbkNvbnRyb2xzVGFwKTtcblx0XHRcdGZyYW1ld29yay5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ3Bzd3BUYXAnLCB1aS5vbkdsb2JhbFRhcCk7XG5cblx0XHRcdGlmKCFwc3dwLmxpa2VseVRvdWNoRGV2aWNlKSB7XG5cdFx0XHRcdGZyYW1ld29yay5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ21vdXNlb3ZlcicsIHVpLm9uTW91c2VPdmVyKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHVuYmluZCBldmVudHMgZm9yIFVJXG5cdFx0X2xpc3RlbigndW5iaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighX3NoYXJlTW9kYWxIaWRkZW4pIHtcblx0XHRcdFx0X3RvZ2dsZVNoYXJlTW9kYWwoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoX2lkbGVJbnRlcnZhbCkge1xuXHRcdFx0XHRjbGVhckludGVydmFsKF9pZGxlSW50ZXJ2YWwpO1xuXHRcdFx0fVxuXHRcdFx0ZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ21vdXNlb3V0JywgX29uTW91c2VMZWF2ZVdpbmRvdyk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX29uSWRsZU1vdXNlTW92ZSk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKF9jb250cm9scywgJ3Bzd3BUYXAgY2xpY2snLCBfb25Db250cm9sc1RhcCk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ3Bzd3BUYXAnLCB1aS5vbkdsb2JhbFRhcCk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ21vdXNlb3ZlcicsIHVpLm9uTW91c2VPdmVyKTtcblxuXHRcdFx0aWYoX2Z1bGxzY3JlbkFQSSkge1xuXHRcdFx0XHRmcmFtZXdvcmsudW5iaW5kKGRvY3VtZW50LCBfZnVsbHNjcmVuQVBJLmV2ZW50SywgdWkudXBkYXRlRnVsbHNjcmVlbik7XG5cdFx0XHRcdGlmKF9mdWxsc2NyZW5BUEkuaXNGdWxsc2NyZWVuKCkpIHtcblx0XHRcdFx0XHRfb3B0aW9ucy5oaWRlQW5pbWF0aW9uRHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdF9mdWxsc2NyZW5BUEkuZXhpdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mdWxsc2NyZW5BUEkgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHQvLyBjbGVhbiB1cCB0aGluZ3Mgd2hlbiBnYWxsZXJ5IGlzIGRlc3Ryb3llZFxuXHRcdF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmKF9vcHRpb25zLmNhcHRpb25FbCkge1xuXHRcdFx0XHRpZihfZmFrZUNhcHRpb25Db250YWluZXIpIHtcblx0XHRcdFx0XHRfY29udHJvbHMucmVtb3ZlQ2hpbGQoX2Zha2VDYXB0aW9uQ29udGFpbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcmFtZXdvcmsucmVtb3ZlQ2xhc3MoX2NhcHRpb25Db250YWluZXIsICdwc3dwX19jYXB0aW9uLS1lbXB0eScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihfc2hhcmVNb2RhbCkge1xuXHRcdFx0XHRfc2hhcmVNb2RhbC5jaGlsZHJlblswXS5vbmNsaWNrID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyhfY29udHJvbHMsICdwc3dwX191aS0tb3Zlci1jbG9zZScpO1xuXHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKCBfY29udHJvbHMsICdwc3dwX191aS0taGlkZGVuJyk7XG5cdFx0XHR1aS5zZXRJZGxlKGZhbHNlKTtcblx0XHR9KTtcblx0XHRcblxuXHRcdGlmKCFfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb24pIHtcblx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyggX2NvbnRyb2xzLCAncHN3cF9fdWktLWhpZGRlbicpO1xuXHRcdH1cblx0XHRfbGlzdGVuKCdpbml0aWFsWm9vbUluJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb24pIHtcblx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKCBfY29udHJvbHMsICdwc3dwX191aS0taGlkZGVuJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0X2xpc3RlbignaW5pdGlhbFpvb21PdXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyggX2NvbnRyb2xzLCAncHN3cF9fdWktLWhpZGRlbicpO1xuXHRcdH0pO1xuXG5cdFx0X2xpc3RlbigncGFyc2VWZXJ0aWNhbE1hcmdpbicsIF9hcHBseU5hdkJhckdhcHMpO1xuXHRcdFxuXHRcdF9zZXR1cFVJRWxlbWVudHMoKTtcblxuXHRcdGlmKF9vcHRpb25zLnNoYXJlRWwgJiYgX3NoYXJlQnV0dG9uICYmIF9zaGFyZU1vZGFsKSB7XG5cdFx0XHRfc2hhcmVNb2RhbEhpZGRlbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X2NvdW50TnVtSXRlbXMoKTtcblxuXHRcdF9zZXR1cElkbGUoKTtcblxuXHRcdF9zZXR1cEZ1bGxzY3JlZW5BUEkoKTtcblxuXHRcdF9zZXR1cExvYWRpbmdJbmRpY2F0b3IoKTtcblx0fTtcblxuXHR1aS5zZXRJZGxlID0gZnVuY3Rpb24oaXNJZGxlKSB7XG5cdFx0X2lzSWRsZSA9IGlzSWRsZTtcblx0XHRfdG9nZ2xlUHN3cENsYXNzKF9jb250cm9scywgJ3VpLS1pZGxlJywgaXNJZGxlKTtcblx0fTtcblxuXHR1aS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBEb24ndCB1cGRhdGUgVUkgaWYgaXQncyBoaWRkZW5cblx0XHRpZihfY29udHJvbHNWaXNpYmxlICYmIHBzd3AuY3Vyckl0ZW0pIHtcblx0XHRcdFxuXHRcdFx0dWkudXBkYXRlSW5kZXhJbmRpY2F0b3IoKTtcblxuXHRcdFx0aWYoX29wdGlvbnMuY2FwdGlvbkVsKSB7XG5cdFx0XHRcdF9vcHRpb25zLmFkZENhcHRpb25IVE1MRm4ocHN3cC5jdXJySXRlbSwgX2NhcHRpb25Db250YWluZXIpO1xuXG5cdFx0XHRcdF90b2dnbGVQc3dwQ2xhc3MoX2NhcHRpb25Db250YWluZXIsICdjYXB0aW9uLS1lbXB0eScsICFwc3dwLmN1cnJJdGVtLnRpdGxlKTtcblx0XHRcdH1cblxuXHRcdFx0X292ZXJsYXlVSVVwZGF0ZWQgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdF9vdmVybGF5VUlVcGRhdGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoIV9zaGFyZU1vZGFsSGlkZGVuKSB7XG5cdFx0XHRfdG9nZ2xlU2hhcmVNb2RhbCgpO1xuXHRcdH1cblxuXHRcdF9jb3VudE51bUl0ZW1zKCk7XG5cdH07XG5cblx0dWkudXBkYXRlRnVsbHNjcmVlbiA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdGlmKGUpIHtcblx0XHRcdC8vIHNvbWUgYnJvd3NlcnMgY2hhbmdlIHdpbmRvdyBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIHRoZSBmdWxsc2NyZWVuXG5cdFx0XHQvLyBzbyBQaG90b1N3aXBlIHVwZGF0ZXMgaXQganVzdCBpbiBjYXNlXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwc3dwLnNldFNjcm9sbE9mZnNldCggMCwgZnJhbWV3b3JrLmdldFNjcm9sbFkoKSApO1xuXHRcdFx0fSwgNTApO1xuXHRcdH1cblx0XHRcblx0XHQvLyB0b29nbGUgcHN3cC0tZnMgY2xhc3Mgb24gcm9vdCBlbGVtZW50XG5cdFx0ZnJhbWV3b3JrWyAoX2Z1bGxzY3JlbkFQSS5pc0Z1bGxzY3JlZW4oKSA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0NsYXNzJyBdKHBzd3AudGVtcGxhdGUsICdwc3dwLS1mcycpO1xuXHR9O1xuXG5cdHVpLnVwZGF0ZUluZGV4SW5kaWNhdG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoX29wdGlvbnMuY291bnRlckVsKSB7XG5cdFx0XHRfaW5kZXhJbmRpY2F0b3IuaW5uZXJIVE1MID0gKHBzd3AuZ2V0Q3VycmVudEluZGV4KCkrMSkgKyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0X29wdGlvbnMuaW5kZXhJbmRpY2F0b3JTZXAgKyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0X29wdGlvbnMuZ2V0TnVtSXRlbXNGbigpO1xuXHRcdH1cblx0fTtcblx0XG5cdHVpLm9uR2xvYmFsVGFwID0gZnVuY3Rpb24oZSkge1xuXHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdFx0aWYoX2Jsb2NrQ29udHJvbHNUYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihlLmRldGFpbCAmJiBlLmRldGFpbC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXG5cdFx0XHQvLyBjbG9zZSBnYWxsZXJ5IGlmIGNsaWNrZWQgb3V0c2lkZSBvZiB0aGUgaW1hZ2Vcblx0XHRcdGlmKF9oYXNDbG9zZUNsYXNzKHRhcmdldCkpIHtcblx0XHRcdFx0cHN3cC5jbG9zZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKGZyYW1ld29yay5oYXNDbGFzcyh0YXJnZXQsICdwc3dwX19pbWcnKSkge1xuXHRcdFx0XHRpZihwc3dwLmdldFpvb21MZXZlbCgpID09PSAxICYmIHBzd3AuZ2V0Wm9vbUxldmVsKCkgPD0gcHN3cC5jdXJySXRlbS5maXRSYXRpbykge1xuXHRcdFx0XHRcdGlmKF9vcHRpb25zLmNsaWNrVG9DbG9zZU5vblpvb21hYmxlKSB7XG5cdFx0XHRcdFx0XHRwc3dwLmNsb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBzd3AudG9nZ2xlRGVza3RvcFpvb20oZS5kZXRhaWwucmVsZWFzZVBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gdGFwIGFueXdoZXJlIChleGNlcHQgYnV0dG9ucykgdG8gdG9nZ2xlIHZpc2liaWxpdHkgb2YgY29udHJvbHNcblx0XHRcdGlmKF9vcHRpb25zLnRhcFRvVG9nZ2xlQ29udHJvbHMpIHtcblx0XHRcdFx0aWYoX2NvbnRyb2xzVmlzaWJsZSkge1xuXHRcdFx0XHRcdHVpLmhpZGVDb250cm9scygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVpLnNob3dDb250cm9scygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRhcCB0byBjbG9zZSBnYWxsZXJ5XG5cdFx0XHRpZihfb3B0aW9ucy50YXBUb0Nsb3NlICYmIChmcmFtZXdvcmsuaGFzQ2xhc3ModGFyZ2V0LCAncHN3cF9faW1nJykgfHwgX2hhc0Nsb3NlQ2xhc3ModGFyZ2V0KSkgKSB7XG5cdFx0XHRcdHBzd3AuY2xvc2UoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHR9O1xuXHR1aS5vbk1vdXNlT3ZlciA9IGZ1bmN0aW9uKGUpIHtcblx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuXHRcdC8vIGFkZCBjbGFzcyB3aGVuIG1vdXNlIGlzIG92ZXIgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBjbG9zZSB0aGUgZ2FsbGVyeVxuXHRcdF90b2dnbGVQc3dwQ2xhc3MoX2NvbnRyb2xzLCAndWktLW92ZXItY2xvc2UnLCBfaGFzQ2xvc2VDbGFzcyh0YXJnZXQpKTtcblx0fTtcblxuXHR1aS5oaWRlQ29udHJvbHMgPSBmdW5jdGlvbigpIHtcblx0XHRmcmFtZXdvcmsuYWRkQ2xhc3MoX2NvbnRyb2xzLCdwc3dwX191aS0taGlkZGVuJyk7XG5cdFx0X2NvbnRyb2xzVmlzaWJsZSA9IGZhbHNlO1xuXHR9O1xuXG5cdHVpLnNob3dDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuXHRcdF9jb250cm9sc1Zpc2libGUgPSB0cnVlO1xuXHRcdGlmKCFfb3ZlcmxheVVJVXBkYXRlZCkge1xuXHRcdFx0dWkudXBkYXRlKCk7XG5cdFx0fVxuXHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyhfY29udHJvbHMsJ3Bzd3BfX3VpLS1oaWRkZW4nKTtcblx0fTtcblxuXHR1aS5zdXBwb3J0c0Z1bGxzY3JlZW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZCA9IGRvY3VtZW50O1xuXHRcdHJldHVybiAhIShkLmV4aXRGdWxsc2NyZWVuIHx8IGQubW96Q2FuY2VsRnVsbFNjcmVlbiB8fCBkLndlYmtpdEV4aXRGdWxsc2NyZWVuIHx8IGQubXNFeGl0RnVsbHNjcmVlbik7XG5cdH07XG5cblx0dWkuZ2V0RnVsbHNjcmVlbkFQSSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkRSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRcdGFwaSxcblx0XHRcdHRGID0gJ2Z1bGxzY3JlZW5jaGFuZ2UnO1xuXG5cdFx0aWYgKGRFLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0XHRhcGkgPSB7XG5cdFx0XHRcdGVudGVySzogJ3JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZXhpdEs6ICdleGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdGVsZW1lbnRLOiAnZnVsbHNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHRldmVudEs6IHRGXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIGlmKGRFLm1velJlcXVlc3RGdWxsU2NyZWVuICkge1xuXHRcdFx0YXBpID0ge1xuXHRcdFx0XHRlbnRlcks6ICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG5cdFx0XHRcdGV4aXRLOiAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXG5cdFx0XHRcdGVsZW1lbnRLOiAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHRldmVudEs6ICdtb3onICsgdEZcblx0XHRcdH07XG5cblx0XHRcdFxuXG5cdFx0fSBlbHNlIGlmKGRFLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0XHRhcGkgPSB7XG5cdFx0XHRcdGVudGVySzogJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZXhpdEs6ICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdGVsZW1lbnRLOiAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHRldmVudEs6ICd3ZWJraXQnICsgdEZcblx0XHRcdH07XG5cblx0XHR9IGVsc2UgaWYoZEUubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuXHRcdFx0YXBpID0ge1xuXHRcdFx0XHRlbnRlcks6ICdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZXhpdEs6ICdtc0V4aXRGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZWxlbWVudEs6ICdtc0Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0ZXZlbnRLOiAnTVNGdWxsc2NyZWVuQ2hhbmdlJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZihhcGkpIHtcblx0XHRcdGFwaS5lbnRlciA9IGZ1bmN0aW9uKCkgeyBcblx0XHRcdFx0Ly8gZGlzYWJsZSBjbG9zZS1vbi1zY3JvbGwgaW4gZnVsbHNjcmVlblxuXHRcdFx0XHRfaW5pdGFsQ2xvc2VPblNjcm9sbFZhbHVlID0gX29wdGlvbnMuY2xvc2VPblNjcm9sbDsgXG5cdFx0XHRcdF9vcHRpb25zLmNsb3NlT25TY3JvbGwgPSBmYWxzZTsgXG5cblx0XHRcdFx0aWYodGhpcy5lbnRlcksgPT09ICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicpIHtcblx0XHRcdFx0XHRwc3dwLnRlbXBsYXRlW3RoaXMuZW50ZXJLXSggRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBwc3dwLnRlbXBsYXRlW3RoaXMuZW50ZXJLXSgpOyBcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGFwaS5leGl0ID0gZnVuY3Rpb24oKSB7IFxuXHRcdFx0XHRfb3B0aW9ucy5jbG9zZU9uU2Nyb2xsID0gX2luaXRhbENsb3NlT25TY3JvbGxWYWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnRbdGhpcy5leGl0S10oKTsgXG5cblx0XHRcdH07XG5cdFx0XHRhcGkuaXNGdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7IHJldHVybiBkb2N1bWVudFt0aGlzLmVsZW1lbnRLXTsgfTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXBpO1xuXHR9O1xuXG5cblxufTtcbnJldHVybiBQaG90b1N3aXBlVUlfRGVmYXVsdDtcblxuXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/photoswipe/dist/photoswipe-ui-default.js\n");

/***/ }),

/***/ "./node_modules/photoswipe/dist/photoswipe.js":
/*!****************************************************!*\
  !*** ./node_modules/photoswipe/dist/photoswipe.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! PhotoSwipe - v4.1.3 - 2019-01-08\n* http://photoswipe.com\n* Copyright (c) 2019 Dmitry Semenov; */\n(function (root, factory) { \n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n})(this, function () {\n\n\t'use strict';\n\tvar PhotoSwipe = function(template, UiClass, items, options){\n\n/*>>framework-bridge*/\n/**\n *\n * Set of generic functions used by gallery.\n * \n * You're free to modify anything here as long as functionality is kept.\n * \n */\nvar framework = {\n\tfeatures: null,\n\tbind: function(target, type, listener, unbind) {\n\t\tvar methodName = (unbind ? 'remove' : 'add') + 'EventListener';\n\t\ttype = type.split(' ');\n\t\tfor(var i = 0; i < type.length; i++) {\n\t\t\tif(type[i]) {\n\t\t\t\ttarget[methodName]( type[i], listener, false);\n\t\t\t}\n\t\t}\n\t},\n\tisArray: function(obj) {\n\t\treturn (obj instanceof Array);\n\t},\n\tcreateEl: function(classes, tag) {\n\t\tvar el = document.createElement(tag || 'div');\n\t\tif(classes) {\n\t\t\tel.className = classes;\n\t\t}\n\t\treturn el;\n\t},\n\tgetScrollY: function() {\n\t\tvar yOffset = window.pageYOffset;\n\t\treturn yOffset !== undefined ? yOffset : document.documentElement.scrollTop;\n\t},\n\tunbind: function(target, type, listener) {\n\t\tframework.bind(target,type,listener,true);\n\t},\n\tremoveClass: function(el, className) {\n\t\tvar reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n\t\tel.className = el.className.replace(reg, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); \n\t},\n\taddClass: function(el, className) {\n\t\tif( !framework.hasClass(el,className) ) {\n\t\t\tel.className += (el.className ? ' ' : '') + className;\n\t\t}\n\t},\n\thasClass: function(el, className) {\n\t\treturn el.className && new RegExp('(^|\\\\s)' + className + '(\\\\s|$)').test(el.className);\n\t},\n\tgetChildByClass: function(parentEl, childClassName) {\n\t\tvar node = parentEl.firstChild;\n\t\twhile(node) {\n\t\t\tif( framework.hasClass(node, childClassName) ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tnode = node.nextSibling;\n\t\t}\n\t},\n\tarraySearch: function(array, value, key) {\n\t\tvar i = array.length;\n\t\twhile(i--) {\n\t\t\tif(array[i][key] === value) {\n\t\t\t\treturn i;\n\t\t\t} \n\t\t}\n\t\treturn -1;\n\t},\n\textend: function(o1, o2, preventOverwrite) {\n\t\tfor (var prop in o2) {\n\t\t\tif (o2.hasOwnProperty(prop)) {\n\t\t\t\tif(preventOverwrite && o1.hasOwnProperty(prop)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\to1[prop] = o2[prop];\n\t\t\t}\n\t\t}\n\t},\n\teasing: {\n\t\tsine: {\n\t\t\tout: function(k) {\n\t\t\t\treturn Math.sin(k * (Math.PI / 2));\n\t\t\t},\n\t\t\tinOut: function(k) {\n\t\t\t\treturn - (Math.cos(Math.PI * k) - 1) / 2;\n\t\t\t}\n\t\t},\n\t\tcubic: {\n\t\t\tout: function(k) {\n\t\t\t\treturn --k * k * k + 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\telastic: {\n\t\t\t\tout: function ( k ) {\n\n\t\t\t\t\tvar s, a = 0.1, p = 0.4;\n\t\t\t\t\tif ( k === 0 ) return 0;\n\t\t\t\t\tif ( k === 1 ) return 1;\n\t\t\t\t\tif ( !a || a < 1 ) { a = 1; s = p / 4; }\n\t\t\t\t\telse s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n\t\t\t\t\treturn ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );\n\n\t\t\t\t},\n\t\t\t},\n\t\t\tback: {\n\t\t\t\tout: function ( k ) {\n\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\treturn --k * k * ( ( s + 1 ) * k + s ) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t*/\n\t},\n\n\t/**\n\t * \n\t * @return {object}\n\t * \n\t * {\n\t *  raf : request animation frame function\n\t *  caf : cancel animation frame function\n\t *  transfrom : transform property key (with vendor), or null if not supported\n\t *  oldIE : IE8 or below\n\t * }\n\t * \n\t */\n\tdetectFeatures: function() {\n\t\tif(framework.features) {\n\t\t\treturn framework.features;\n\t\t}\n\t\tvar helperEl = framework.createEl(),\n\t\t\thelperStyle = helperEl.style,\n\t\t\tvendor = '',\n\t\t\tfeatures = {};\n\n\t\t// IE8 and below\n\t\tfeatures.oldIE = document.all && !document.addEventListener;\n\n\t\tfeatures.touch = 'ontouchstart' in window;\n\n\t\tif(window.requestAnimationFrame) {\n\t\t\tfeatures.raf = window.requestAnimationFrame;\n\t\t\tfeatures.caf = window.cancelAnimationFrame;\n\t\t}\n\n\t\tfeatures.pointerEvent = !!(window.PointerEvent) || navigator.msPointerEnabled;\n\n\t\t// fix false-positive detection of old Android in new IE\n\t\t// (IE11 ua string contains \"Android 4.0\")\n\t\t\n\t\tif(!features.pointerEvent) { \n\n\t\t\tvar ua = navigator.userAgent;\n\n\t\t\t// Detect if device is iPhone or iPod and if it's older than iOS 8\n\t\t\t// http://stackoverflow.com/a/14223920\n\t\t\t// \n\t\t\t// This detection is made because of buggy top/bottom toolbars\n\t\t\t// that don't trigger window.resize event.\n\t\t\t// For more info refer to _isFixedPosition variable in core.js\n\n\t\t\tif (/iP(hone|od)/.test(navigator.platform)) {\n\t\t\t\tvar v = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\t\t\t\tif(v && v.length > 0) {\n\t\t\t\t\tv = parseInt(v[1], 10);\n\t\t\t\t\tif(v >= 1 && v < 8 ) {\n\t\t\t\t\t\tfeatures.isOldIOSPhone = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Detect old Android (before KitKat)\n\t\t\t// due to bugs related to position:fixed\n\t\t\t// http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript\n\t\t\t\n\t\t\tvar match = ua.match(/Android\\s([0-9\\.]*)/);\n\t\t\tvar androidversion =  match ? match[1] : 0;\n\t\t\tandroidversion = parseFloat(androidversion);\n\t\t\tif(androidversion >= 1 ) {\n\t\t\t\tif(androidversion < 4.4) {\n\t\t\t\t\tfeatures.isOldAndroid = true; // for fixed position bug & performance\n\t\t\t\t}\n\t\t\t\tfeatures.androidVersion = androidversion; // for touchend bug\n\t\t\t}\t\n\t\t\tfeatures.isMobileOpera = /opera mini|opera mobi/i.test(ua);\n\n\t\t\t// p.s. yes, yes, UA sniffing is bad, propose your solution for above bugs.\n\t\t}\n\t\t\n\t\tvar styleChecks = ['transform', 'perspective', 'animationName'],\n\t\t\tvendors = ['', 'webkit','Moz','ms','O'],\n\t\t\tstyleCheckItem,\n\t\t\tstyleName;\n\n\t\tfor(var i = 0; i < 4; i++) {\n\t\t\tvendor = vendors[i];\n\n\t\t\tfor(var a = 0; a < 3; a++) {\n\t\t\t\tstyleCheckItem = styleChecks[a];\n\n\t\t\t\t// uppercase first letter of property name, if vendor is present\n\t\t\t\tstyleName = vendor + (vendor ? \n\t\t\t\t\t\t\t\t\t\tstyleCheckItem.charAt(0).toUpperCase() + styleCheckItem.slice(1) : \n\t\t\t\t\t\t\t\t\t\tstyleCheckItem);\n\t\t\t\n\t\t\t\tif(!features[styleCheckItem] && styleName in helperStyle ) {\n\t\t\t\t\tfeatures[styleCheckItem] = styleName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(vendor && !features.raf) {\n\t\t\t\tvendor = vendor.toLowerCase();\n\t\t\t\tfeatures.raf = window[vendor+'RequestAnimationFrame'];\n\t\t\t\tif(features.raf) {\n\t\t\t\t\tfeatures.caf = window[vendor+'CancelAnimationFrame'] || \n\t\t\t\t\t\t\t\t\twindow[vendor+'CancelRequestAnimationFrame'];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif(!features.raf) {\n\t\t\tvar lastTime = 0;\n\t\t\tfeatures.raf = function(fn) {\n\t\t\t\tvar currTime = new Date().getTime();\n\t\t\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\t\tvar id = window.setTimeout(function() { fn(currTime + timeToCall); }, timeToCall);\n\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\treturn id;\n\t\t\t};\n\t\t\tfeatures.caf = function(id) { clearTimeout(id); };\n\t\t}\n\n\t\t// Detect SVG support\n\t\tfeatures.svg = !!document.createElementNS && \n\t\t\t\t\t\t!!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;\n\n\t\tframework.features = features;\n\n\t\treturn features;\n\t}\n};\n\nframework.detectFeatures();\n\n// Override addEventListener for old versions of IE\nif(framework.features.oldIE) {\n\n\tframework.bind = function(target, type, listener, unbind) {\n\t\t\n\t\ttype = type.split(' ');\n\n\t\tvar methodName = (unbind ? 'detach' : 'attach') + 'Event',\n\t\t\tevName,\n\t\t\t_handleEv = function() {\n\t\t\t\tlistener.handleEvent.call(listener);\n\t\t\t};\n\n\t\tfor(var i = 0; i < type.length; i++) {\n\t\t\tevName = type[i];\n\t\t\tif(evName) {\n\n\t\t\t\tif(typeof listener === 'object' && listener.handleEvent) {\n\t\t\t\t\tif(!unbind) {\n\t\t\t\t\t\tlistener['oldIE' + evName] = _handleEv;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(!listener['oldIE' + evName]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[methodName]( 'on' + evName, listener['oldIE' + evName]);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[methodName]( 'on' + evName, listener);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t};\n\t\n}\n\n/*>>framework-bridge*/\n\n/*>>core*/\n//function(template, UiClass, items, options)\n\nvar self = this;\n\n/**\n * Static vars, don't change unless you know what you're doing.\n */\nvar DOUBLE_TAP_RADIUS = 25, \n\tNUM_HOLDERS = 3;\n\n/**\n * Options\n */\nvar _options = {\n\tallowPanToNext:true,\n\tspacing: 0.12,\n\tbgOpacity: 1,\n\tmouseUsed: false,\n\tloop: true,\n\tpinchToClose: true,\n\tcloseOnScroll: true,\n\tcloseOnVerticalDrag: true,\n\tverticalDragRange: 0.75,\n\thideAnimationDuration: 333,\n\tshowAnimationDuration: 333,\n\tshowHideOpacity: false,\n\tfocus: true,\n\tescKey: true,\n\tarrowKeys: true,\n\tmainScrollEndFriction: 0.35,\n\tpanEndFriction: 0.35,\n\tisClickableElement: function(el) {\n        return el.tagName === 'A';\n    },\n    getDoubleTapZoom: function(isMouseClick, item) {\n    \tif(isMouseClick) {\n    \t\treturn 1;\n    \t} else {\n    \t\treturn item.initialZoomLevel < 0.7 ? 1 : 1.33;\n    \t}\n    },\n    maxSpreadZoom: 1.33,\n\tmodal: true,\n\n\t// not fully implemented yet\n\tscaleMode: 'fit' // TODO\n};\nframework.extend(_options, options);\n\n\n/**\n * Private helper variables & functions\n */\n\nvar _getEmptyPoint = function() { \n\t\treturn {x:0,y:0}; \n\t};\n\nvar _isOpen,\n\t_isDestroying,\n\t_closedByScroll,\n\t_currentItemIndex,\n\t_containerStyle,\n\t_containerShiftIndex,\n\t_currPanDist = _getEmptyPoint(),\n\t_startPanOffset = _getEmptyPoint(),\n\t_panOffset = _getEmptyPoint(),\n\t_upMoveEvents, // drag move, drag end & drag cancel events array\n\t_downEvents, // drag start events array\n\t_globalEventHandlers,\n\t_viewportSize = {},\n\t_currZoomLevel,\n\t_startZoomLevel,\n\t_translatePrefix,\n\t_translateSufix,\n\t_updateSizeInterval,\n\t_itemsNeedUpdate,\n\t_currPositionIndex = 0,\n\t_offset = {},\n\t_slideSize = _getEmptyPoint(), // size of slide area, including spacing\n\t_itemHolders,\n\t_prevItemIndex,\n\t_indexDiff = 0, // difference of indexes since last content update\n\t_dragStartEvent,\n\t_dragMoveEvent,\n\t_dragEndEvent,\n\t_dragCancelEvent,\n\t_transformKey,\n\t_pointerEventEnabled,\n\t_isFixedPosition = true,\n\t_likelyTouchDevice,\n\t_modules = [],\n\t_requestAF,\n\t_cancelAF,\n\t_initalClassName,\n\t_initalWindowScrollY,\n\t_oldIE,\n\t_currentWindowScrollY,\n\t_features,\n\t_windowVisibleSize = {},\n\t_renderMaxResolution = false,\n\t_orientationChangeTimeout,\n\n\n\t// Registers PhotoSWipe module (History, Controller ...)\n\t_registerModule = function(name, module) {\n\t\tframework.extend(self, module.publicMethods);\n\t\t_modules.push(name);\n\t},\n\n\t_getLoopedId = function(index) {\n\t\tvar numSlides = _getNumItems();\n\t\tif(index > numSlides - 1) {\n\t\t\treturn index - numSlides;\n\t\t} else  if(index < 0) {\n\t\t\treturn numSlides + index;\n\t\t}\n\t\treturn index;\n\t},\n\t\n\t// Micro bind/trigger\n\t_listeners = {},\n\t_listen = function(name, fn) {\n\t\tif(!_listeners[name]) {\n\t\t\t_listeners[name] = [];\n\t\t}\n\t\treturn _listeners[name].push(fn);\n\t},\n\t_shout = function(name) {\n\t\tvar listeners = _listeners[name];\n\n\t\tif(listeners) {\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\targs.shift();\n\n\t\t\tfor(var i = 0; i < listeners.length; i++) {\n\t\t\t\tlisteners[i].apply(self, args);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getCurrentTime = function() {\n\t\treturn new Date().getTime();\n\t},\n\t_applyBgOpacity = function(opacity) {\n\t\t_bgOpacity = opacity;\n\t\tself.bg.style.opacity = opacity * _options.bgOpacity;\n\t},\n\n\t_applyZoomTransform = function(styleObj,x,y,zoom,item) {\n\t\tif(!_renderMaxResolution || (item && item !== self.currItem) ) {\n\t\t\tzoom = zoom / (item ? item.fitRatio : self.currItem.fitRatio);\t\n\t\t}\n\t\t\t\n\t\tstyleObj[_transformKey] = _translatePrefix + x + 'px, ' + y + 'px' + _translateSufix + ' scale(' + zoom + ')';\n\t},\n\t_applyCurrentZoomPan = function( allowRenderResolution ) {\n\t\tif(_currZoomElementStyle) {\n\n\t\t\tif(allowRenderResolution) {\n\t\t\t\tif(_currZoomLevel > self.currItem.fitRatio) {\n\t\t\t\t\tif(!_renderMaxResolution) {\n\t\t\t\t\t\t_setImageSize(self.currItem, false, true);\n\t\t\t\t\t\t_renderMaxResolution = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(_renderMaxResolution) {\n\t\t\t\t\t\t_setImageSize(self.currItem);\n\t\t\t\t\t\t_renderMaxResolution = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\t_applyZoomTransform(_currZoomElementStyle, _panOffset.x, _panOffset.y, _currZoomLevel);\n\t\t}\n\t},\n\t_applyZoomPanToItem = function(item) {\n\t\tif(item.container) {\n\n\t\t\t_applyZoomTransform(item.container.style, \n\t\t\t\t\t\t\t\titem.initialPosition.x, \n\t\t\t\t\t\t\t\titem.initialPosition.y, \n\t\t\t\t\t\t\t\titem.initialZoomLevel,\n\t\t\t\t\t\t\t\titem);\n\t\t}\n\t},\n\t_setTranslateX = function(x, elStyle) {\n\t\telStyle[_transformKey] = _translatePrefix + x + 'px, 0px' + _translateSufix;\n\t},\n\t_moveMainScroll = function(x, dragging) {\n\n\t\tif(!_options.loop && dragging) {\n\t\t\tvar newSlideIndexOffset = _currentItemIndex + (_slideSize.x * _currPositionIndex - x) / _slideSize.x,\n\t\t\t\tdelta = Math.round(x - _mainScrollPos.x);\n\n\t\t\tif( (newSlideIndexOffset < 0 && delta > 0) || \n\t\t\t\t(newSlideIndexOffset >= _getNumItems() - 1 && delta < 0) ) {\n\t\t\t\tx = _mainScrollPos.x + delta * _options.mainScrollEndFriction;\n\t\t\t} \n\t\t}\n\t\t\n\t\t_mainScrollPos.x = x;\n\t\t_setTranslateX(x, _containerStyle);\n\t},\n\t_calculatePanOffset = function(axis, zoomLevel) {\n\t\tvar m = _midZoomPoint[axis] - _offset[axis];\n\t\treturn _startPanOffset[axis] + _currPanDist[axis] + m - m * ( zoomLevel / _startZoomLevel );\n\t},\n\t\n\t_equalizePoints = function(p1, p2) {\n\t\tp1.x = p2.x;\n\t\tp1.y = p2.y;\n\t\tif(p2.id) {\n\t\t\tp1.id = p2.id;\n\t\t}\n\t},\n\t_roundPoint = function(p) {\n\t\tp.x = Math.round(p.x);\n\t\tp.y = Math.round(p.y);\n\t},\n\n\t_mouseMoveTimeout = null,\n\t_onFirstMouseMove = function() {\n\t\t// Wait until mouse move event is fired at least twice during 100ms\n\t\t// We do this, because some mobile browsers trigger it on touchstart\n\t\tif(_mouseMoveTimeout ) { \n\t\t\tframework.unbind(document, 'mousemove', _onFirstMouseMove);\n\t\t\tframework.addClass(template, 'pswp--has_mouse');\n\t\t\t_options.mouseUsed = true;\n\t\t\t_shout('mouseUsed');\n\t\t}\n\t\t_mouseMoveTimeout = setTimeout(function() {\n\t\t\t_mouseMoveTimeout = null;\n\t\t}, 100);\n\t},\n\n\t_bindEvents = function() {\n\t\tframework.bind(document, 'keydown', self);\n\n\t\tif(_features.transform) {\n\t\t\t// don't bind click event in browsers that don't support transform (mostly IE8)\n\t\t\tframework.bind(self.scrollWrap, 'click', self);\n\t\t}\n\t\t\n\n\t\tif(!_options.mouseUsed) {\n\t\t\tframework.bind(document, 'mousemove', _onFirstMouseMove);\n\t\t}\n\n\t\tframework.bind(window, 'resize scroll orientationchange', self);\n\n\t\t_shout('bindEvents');\n\t},\n\n\t_unbindEvents = function() {\n\t\tframework.unbind(window, 'resize scroll orientationchange', self);\n\t\tframework.unbind(window, 'scroll', _globalEventHandlers.scroll);\n\t\tframework.unbind(document, 'keydown', self);\n\t\tframework.unbind(document, 'mousemove', _onFirstMouseMove);\n\n\t\tif(_features.transform) {\n\t\t\tframework.unbind(self.scrollWrap, 'click', self);\n\t\t}\n\n\t\tif(_isDragging) {\n\t\t\tframework.unbind(window, _upMoveEvents, self);\n\t\t}\n\n\t\tclearTimeout(_orientationChangeTimeout);\n\n\t\t_shout('unbindEvents');\n\t},\n\t\n\t_calculatePanBounds = function(zoomLevel, update) {\n\t\tvar bounds = _calculateItemSize( self.currItem, _viewportSize, zoomLevel );\n\t\tif(update) {\n\t\t\t_currPanBounds = bounds;\n\t\t}\n\t\treturn bounds;\n\t},\n\t\n\t_getMinZoomLevel = function(item) {\n\t\tif(!item) {\n\t\t\titem = self.currItem;\n\t\t}\n\t\treturn item.initialZoomLevel;\n\t},\n\t_getMaxZoomLevel = function(item) {\n\t\tif(!item) {\n\t\t\titem = self.currItem;\n\t\t}\n\t\treturn item.w > 0 ? _options.maxSpreadZoom : 1;\n\t},\n\n\t// Return true if offset is out of the bounds\n\t_modifyDestPanOffset = function(axis, destPanBounds, destPanOffset, destZoomLevel) {\n\t\tif(destZoomLevel === self.currItem.initialZoomLevel) {\n\t\t\tdestPanOffset[axis] = self.currItem.initialPosition[axis];\n\t\t\treturn true;\n\t\t} else {\n\t\t\tdestPanOffset[axis] = _calculatePanOffset(axis, destZoomLevel); \n\n\t\t\tif(destPanOffset[axis] > destPanBounds.min[axis]) {\n\t\t\t\tdestPanOffset[axis] = destPanBounds.min[axis];\n\t\t\t\treturn true;\n\t\t\t} else if(destPanOffset[axis] < destPanBounds.max[axis] ) {\n\t\t\t\tdestPanOffset[axis] = destPanBounds.max[axis];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t_setupTransforms = function() {\n\n\t\tif(_transformKey) {\n\t\t\t// setup 3d transforms\n\t\t\tvar allow3dTransform = _features.perspective && !_likelyTouchDevice;\n\t\t\t_translatePrefix = 'translate' + (allow3dTransform ? '3d(' : '(');\n\t\t\t_translateSufix = _features.perspective ? ', 0px)' : ')';\t\n\t\t\treturn;\n\t\t}\n\n\t\t// Override zoom/pan/move functions in case old browser is used (most likely IE)\n\t\t// (so they use left/top/width/height, instead of CSS transform)\n\t\n\t\t_transformKey = 'left';\n\t\tframework.addClass(template, 'pswp--ie');\n\n\t\t_setTranslateX = function(x, elStyle) {\n\t\t\telStyle.left = x + 'px';\n\t\t};\n\t\t_applyZoomPanToItem = function(item) {\n\n\t\t\tvar zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,\n\t\t\t\ts = item.container.style,\n\t\t\t\tw = zoomRatio * item.w,\n\t\t\t\th = zoomRatio * item.h;\n\n\t\t\ts.width = w + 'px';\n\t\t\ts.height = h + 'px';\n\t\t\ts.left = item.initialPosition.x + 'px';\n\t\t\ts.top = item.initialPosition.y + 'px';\n\n\t\t};\n\t\t_applyCurrentZoomPan = function() {\n\t\t\tif(_currZoomElementStyle) {\n\n\t\t\t\tvar s = _currZoomElementStyle,\n\t\t\t\t\titem = self.currItem,\n\t\t\t\t\tzoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,\n\t\t\t\t\tw = zoomRatio * item.w,\n\t\t\t\t\th = zoomRatio * item.h;\n\n\t\t\t\ts.width = w + 'px';\n\t\t\t\ts.height = h + 'px';\n\n\n\t\t\t\ts.left = _panOffset.x + 'px';\n\t\t\t\ts.top = _panOffset.y + 'px';\n\t\t\t}\n\t\t\t\n\t\t};\n\t},\n\n\t_onKeyDown = function(e) {\n\t\tvar keydownAction = '';\n\t\tif(_options.escKey && e.keyCode === 27) { \n\t\t\tkeydownAction = 'close';\n\t\t} else if(_options.arrowKeys) {\n\t\t\tif(e.keyCode === 37) {\n\t\t\t\tkeydownAction = 'prev';\n\t\t\t} else if(e.keyCode === 39) { \n\t\t\t\tkeydownAction = 'next';\n\t\t\t}\n\t\t}\n\n\t\tif(keydownAction) {\n\t\t\t// don't do anything if special key pressed to prevent from overriding default browser actions\n\t\t\t// e.g. in Chrome on Mac cmd+arrow-left returns to previous page\n\t\t\tif( !e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey ) {\n\t\t\t\tif(e.preventDefault) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t} else {\n\t\t\t\t\te.returnValue = false;\n\t\t\t\t} \n\t\t\t\tself[keydownAction]();\n\t\t\t}\n\t\t}\n\t},\n\n\t_onGlobalClick = function(e) {\n\t\tif(!e) {\n\t\t\treturn;\n\t\t}\n\n\t\t// don't allow click event to pass through when triggering after drag or some other gesture\n\t\tif(_moved || _zoomStarted || _mainScrollAnimating || _verticalDragInitiated) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\n\t_updatePageScrollOffset = function() {\n\t\tself.setScrollOffset(0, framework.getScrollY());\t\t\n\t};\n\t\n\n\n\t\n\n\n\n// Micro animation engine\nvar _animations = {},\n\t_numAnimations = 0,\n\t_stopAnimation = function(name) {\n\t\tif(_animations[name]) {\n\t\t\tif(_animations[name].raf) {\n\t\t\t\t_cancelAF( _animations[name].raf );\n\t\t\t}\n\t\t\t_numAnimations--;\n\t\t\tdelete _animations[name];\n\t\t}\n\t},\n\t_registerStartAnimation = function(name) {\n\t\tif(_animations[name]) {\n\t\t\t_stopAnimation(name);\n\t\t}\n\t\tif(!_animations[name]) {\n\t\t\t_numAnimations++;\n\t\t\t_animations[name] = {};\n\t\t}\n\t},\n\t_stopAllAnimations = function() {\n\t\tfor (var prop in _animations) {\n\n\t\t\tif( _animations.hasOwnProperty( prop ) ) {\n\t\t\t\t_stopAnimation(prop);\n\t\t\t} \n\t\t\t\n\t\t}\n\t},\n\t_animateProp = function(name, b, endProp, d, easingFn, onUpdate, onComplete) {\n\t\tvar startAnimTime = _getCurrentTime(), t;\n\t\t_registerStartAnimation(name);\n\n\t\tvar animloop = function(){\n\t\t\tif ( _animations[name] ) {\n\t\t\t\t\n\t\t\t\tt = _getCurrentTime() - startAnimTime; // time diff\n\t\t\t\t//b - beginning (start prop)\n\t\t\t\t//d - anim duration\n\n\t\t\t\tif ( t >= d ) {\n\t\t\t\t\t_stopAnimation(name);\n\t\t\t\t\tonUpdate(endProp);\n\t\t\t\t\tif(onComplete) {\n\t\t\t\t\t\tonComplete();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonUpdate( (endProp - b) * easingFn(t/d) + b );\n\n\t\t\t\t_animations[name].raf = _requestAF(animloop);\n\t\t\t}\n\t\t};\n\t\tanimloop();\n\t};\n\t\n\n\nvar publicMethods = {\n\n\t// make a few local variables and functions public\n\tshout: _shout,\n\tlisten: _listen,\n\tviewportSize: _viewportSize,\n\toptions: _options,\n\n\tisMainScrollAnimating: function() {\n\t\treturn _mainScrollAnimating;\n\t},\n\tgetZoomLevel: function() {\n\t\treturn _currZoomLevel;\n\t},\n\tgetCurrentIndex: function() {\n\t\treturn _currentItemIndex;\n\t},\n\tisDragging: function() {\n\t\treturn _isDragging;\n\t},\t\n\tisZooming: function() {\n\t\treturn _isZooming;\n\t},\n\tsetScrollOffset: function(x,y) {\n\t\t_offset.x = x;\n\t\t_currentWindowScrollY = _offset.y = y;\n\t\t_shout('updateScrollOffset', _offset);\n\t},\n\tapplyZoomPan: function(zoomLevel,panX,panY,allowRenderResolution) {\n\t\t_panOffset.x = panX;\n\t\t_panOffset.y = panY;\n\t\t_currZoomLevel = zoomLevel;\n\t\t_applyCurrentZoomPan( allowRenderResolution );\n\t},\n\n\tinit: function() {\n\n\t\tif(_isOpen || _isDestroying) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar i;\n\n\t\tself.framework = framework; // basic functionality\n\t\tself.template = template; // root DOM element of PhotoSwipe\n\t\tself.bg = framework.getChildByClass(template, 'pswp__bg');\n\n\t\t_initalClassName = template.className;\n\t\t_isOpen = true;\n\t\t\t\t\n\t\t_features = framework.detectFeatures();\n\t\t_requestAF = _features.raf;\n\t\t_cancelAF = _features.caf;\n\t\t_transformKey = _features.transform;\n\t\t_oldIE = _features.oldIE;\n\t\t\n\t\tself.scrollWrap = framework.getChildByClass(template, 'pswp__scroll-wrap');\n\t\tself.container = framework.getChildByClass(self.scrollWrap, 'pswp__container');\n\n\t\t_containerStyle = self.container.style; // for fast access\n\n\t\t// Objects that hold slides (there are only 3 in DOM)\n\t\tself.itemHolders = _itemHolders = [\n\t\t\t{el:self.container.children[0] , wrap:0, index: -1},\n\t\t\t{el:self.container.children[1] , wrap:0, index: -1},\n\t\t\t{el:self.container.children[2] , wrap:0, index: -1}\n\t\t];\n\n\t\t// hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)\n\t\t_itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'none';\n\n\t\t_setupTransforms();\n\n\t\t// Setup global events\n\t\t_globalEventHandlers = {\n\t\t\tresize: self.updateSize,\n\n\t\t\t// Fixes: iOS 10.3 resize event\n\t\t\t// does not update scrollWrap.clientWidth instantly after resize\n\t\t\t// https://github.com/dimsemenov/PhotoSwipe/issues/1315\n\t\t\torientationchange: function() {\n\t\t\t\tclearTimeout(_orientationChangeTimeout);\n\t\t\t\t_orientationChangeTimeout = setTimeout(function() {\n\t\t\t\t\tif(_viewportSize.x !== self.scrollWrap.clientWidth) {\n\t\t\t\t\t\tself.updateSize();\n\t\t\t\t\t}\n\t\t\t\t}, 500);\n\t\t\t},\n\t\t\tscroll: _updatePageScrollOffset,\n\t\t\tkeydown: _onKeyDown,\n\t\t\tclick: _onGlobalClick\n\t\t};\n\n\t\t// disable show/hide effects on old browsers that don't support CSS animations or transforms, \n\t\t// old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models.\n\t\tvar oldPhone = _features.isOldIOSPhone || _features.isOldAndroid || _features.isMobileOpera;\n\t\tif(!_features.animationName || !_features.transform || oldPhone) {\n\t\t\t_options.showAnimationDuration = _options.hideAnimationDuration = 0;\n\t\t}\n\n\t\t// init modules\n\t\tfor(i = 0; i < _modules.length; i++) {\n\t\t\tself['init' + _modules[i]]();\n\t\t}\n\t\t\n\t\t// init\n\t\tif(UiClass) {\n\t\t\tvar ui = self.ui = new UiClass(self, framework);\n\t\t\tui.init();\n\t\t}\n\n\t\t_shout('firstUpdate');\n\t\t_currentItemIndex = _currentItemIndex || _options.index || 0;\n\t\t// validate index\n\t\tif( isNaN(_currentItemIndex) || _currentItemIndex < 0 || _currentItemIndex >= _getNumItems() ) {\n\t\t\t_currentItemIndex = 0;\n\t\t}\n\t\tself.currItem = _getItemAt( _currentItemIndex );\n\n\t\t\n\t\tif(_features.isOldIOSPhone || _features.isOldAndroid) {\n\t\t\t_isFixedPosition = false;\n\t\t}\n\t\t\n\t\ttemplate.setAttribute('aria-hidden', 'false');\n\t\tif(_options.modal) {\n\t\t\tif(!_isFixedPosition) {\n\t\t\t\ttemplate.style.position = 'absolute';\n\t\t\t\ttemplate.style.top = framework.getScrollY() + 'px';\n\t\t\t} else {\n\t\t\t\ttemplate.style.position = 'fixed';\n\t\t\t}\n\t\t}\n\n\t\tif(_currentWindowScrollY === undefined) {\n\t\t\t_shout('initialLayout');\n\t\t\t_currentWindowScrollY = _initalWindowScrollY = framework.getScrollY();\n\t\t}\n\t\t\n\t\t// add classes to root element of PhotoSwipe\n\t\tvar rootClasses = 'pswp--open ';\n\t\tif(_options.mainClass) {\n\t\t\trootClasses += _options.mainClass + ' ';\n\t\t}\n\t\tif(_options.showHideOpacity) {\n\t\t\trootClasses += 'pswp--animate_opacity ';\n\t\t}\n\t\trootClasses += _likelyTouchDevice ? 'pswp--touch' : 'pswp--notouch';\n\t\trootClasses += _features.animationName ? ' pswp--css_animation' : '';\n\t\trootClasses += _features.svg ? ' pswp--svg' : '';\n\t\tframework.addClass(template, rootClasses);\n\n\t\tself.updateSize();\n\n\t\t// initial update\n\t\t_containerShiftIndex = -1;\n\t\t_indexDiff = null;\n\t\tfor(i = 0; i < NUM_HOLDERS; i++) {\n\t\t\t_setTranslateX( (i+_containerShiftIndex) * _slideSize.x, _itemHolders[i].el.style);\n\t\t}\n\n\t\tif(!_oldIE) {\n\t\t\tframework.bind(self.scrollWrap, _downEvents, self); // no dragging for old IE\n\t\t}\t\n\n\t\t_listen('initialZoomInEnd', function() {\n\t\t\tself.setContent(_itemHolders[0], _currentItemIndex-1);\n\t\t\tself.setContent(_itemHolders[2], _currentItemIndex+1);\n\n\t\t\t_itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'block';\n\n\t\t\tif(_options.focus) {\n\t\t\t\t// focus causes layout, \n\t\t\t\t// which causes lag during the animation, \n\t\t\t\t// that's why we delay it untill the initial zoom transition ends\n\t\t\t\ttemplate.focus();\n\t\t\t}\n\t\t\t \n\n\t\t\t_bindEvents();\n\t\t});\n\n\t\t// set content for center slide (first time)\n\t\tself.setContent(_itemHolders[1], _currentItemIndex);\n\t\t\n\t\tself.updateCurrItem();\n\n\t\t_shout('afterInit');\n\n\t\tif(!_isFixedPosition) {\n\n\t\t\t// On all versions of iOS lower than 8.0, we check size of viewport every second.\n\t\t\t// \n\t\t\t// This is done to detect when Safari top & bottom bars appear, \n\t\t\t// as this action doesn't trigger any events (like resize). \n\t\t\t// \n\t\t\t// On iOS8 they fixed this.\n\t\t\t// \n\t\t\t// 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%.\n\t\t\t\n\t\t\t_updateSizeInterval = setInterval(function() {\n\t\t\t\tif(!_numAnimations && !_isDragging && !_isZooming && (_currZoomLevel === self.currItem.initialZoomLevel)  ) {\n\t\t\t\t\tself.updateSize();\n\t\t\t\t}\n\t\t\t}, 1000);\n\t\t}\n\n\t\tframework.addClass(template, 'pswp--visible');\n\t},\n\n\t// Close the gallery, then destroy it\n\tclose: function() {\n\t\tif(!_isOpen) {\n\t\t\treturn;\n\t\t}\n\n\t\t_isOpen = false;\n\t\t_isDestroying = true;\n\t\t_shout('close');\n\t\t_unbindEvents();\n\n\t\t_showOrHide(self.currItem, null, true, self.destroy);\n\t},\n\n\t// destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks)\n\tdestroy: function() {\n\t\t_shout('destroy');\n\n\t\tif(_showOrHideTimeout) {\n\t\t\tclearTimeout(_showOrHideTimeout);\n\t\t}\n\t\t\n\t\ttemplate.setAttribute('aria-hidden', 'true');\n\t\ttemplate.className = _initalClassName;\n\n\t\tif(_updateSizeInterval) {\n\t\t\tclearInterval(_updateSizeInterval);\n\t\t}\n\n\t\tframework.unbind(self.scrollWrap, _downEvents, self);\n\n\t\t// we unbind scroll event at the end, as closing animation may depend on it\n\t\tframework.unbind(window, 'scroll', self);\n\n\t\t_stopDragUpdateLoop();\n\n\t\t_stopAllAnimations();\n\n\t\t_listeners = null;\n\t},\n\n\t/**\n\t * Pan image to position\n\t * @param {Number} x     \n\t * @param {Number} y     \n\t * @param {Boolean} force Will ignore bounds if set to true.\n\t */\n\tpanTo: function(x,y,force) {\n\t\tif(!force) {\n\t\t\tif(x > _currPanBounds.min.x) {\n\t\t\t\tx = _currPanBounds.min.x;\n\t\t\t} else if(x < _currPanBounds.max.x) {\n\t\t\t\tx = _currPanBounds.max.x;\n\t\t\t}\n\n\t\t\tif(y > _currPanBounds.min.y) {\n\t\t\t\ty = _currPanBounds.min.y;\n\t\t\t} else if(y < _currPanBounds.max.y) {\n\t\t\t\ty = _currPanBounds.max.y;\n\t\t\t}\n\t\t}\n\t\t\n\t\t_panOffset.x = x;\n\t\t_panOffset.y = y;\n\t\t_applyCurrentZoomPan();\n\t},\n\t\n\thandleEvent: function (e) {\n\t\te = e || window.event;\n\t\tif(_globalEventHandlers[e.type]) {\n\t\t\t_globalEventHandlers[e.type](e);\n\t\t}\n\t},\n\n\n\tgoTo: function(index) {\n\n\t\tindex = _getLoopedId(index);\n\n\t\tvar diff = index - _currentItemIndex;\n\t\t_indexDiff = diff;\n\n\t\t_currentItemIndex = index;\n\t\tself.currItem = _getItemAt( _currentItemIndex );\n\t\t_currPositionIndex -= diff;\n\t\t\n\t\t_moveMainScroll(_slideSize.x * _currPositionIndex);\n\t\t\n\n\t\t_stopAllAnimations();\n\t\t_mainScrollAnimating = false;\n\n\t\tself.updateCurrItem();\n\t},\n\tnext: function() {\n\t\tself.goTo( _currentItemIndex + 1);\n\t},\n\tprev: function() {\n\t\tself.goTo( _currentItemIndex - 1);\n\t},\n\n\t// update current zoom/pan objects\n\tupdateCurrZoomItem: function(emulateSetContent) {\n\t\tif(emulateSetContent) {\n\t\t\t_shout('beforeChange', 0);\n\t\t}\n\n\t\t// itemHolder[1] is middle (current) item\n\t\tif(_itemHolders[1].el.children.length) {\n\t\t\tvar zoomElement = _itemHolders[1].el.children[0];\n\t\t\tif( framework.hasClass(zoomElement, 'pswp__zoom-wrap') ) {\n\t\t\t\t_currZoomElementStyle = zoomElement.style;\n\t\t\t} else {\n\t\t\t\t_currZoomElementStyle = null;\n\t\t\t}\n\t\t} else {\n\t\t\t_currZoomElementStyle = null;\n\t\t}\n\t\t\n\t\t_currPanBounds = self.currItem.bounds;\t\n\t\t_startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;\n\n\t\t_panOffset.x = _currPanBounds.center.x;\n\t\t_panOffset.y = _currPanBounds.center.y;\n\n\t\tif(emulateSetContent) {\n\t\t\t_shout('afterChange');\n\t\t}\n\t},\n\n\n\tinvalidateCurrItems: function() {\n\t\t_itemsNeedUpdate = true;\n\t\tfor(var i = 0; i < NUM_HOLDERS; i++) {\n\t\t\tif( _itemHolders[i].item ) {\n\t\t\t\t_itemHolders[i].item.needsUpdate = true;\n\t\t\t}\n\t\t}\n\t},\n\n\tupdateCurrItem: function(beforeAnimation) {\n\n\t\tif(_indexDiff === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar diffAbs = Math.abs(_indexDiff),\n\t\t\ttempHolder;\n\n\t\tif(beforeAnimation && diffAbs < 2) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tself.currItem = _getItemAt( _currentItemIndex );\n\t\t_renderMaxResolution = false;\n\t\t\n\t\t_shout('beforeChange', _indexDiff);\n\n\t\tif(diffAbs >= NUM_HOLDERS) {\n\t\t\t_containerShiftIndex += _indexDiff + (_indexDiff > 0 ? -NUM_HOLDERS : NUM_HOLDERS);\n\t\t\tdiffAbs = NUM_HOLDERS;\n\t\t}\n\t\tfor(var i = 0; i < diffAbs; i++) {\n\t\t\tif(_indexDiff > 0) {\n\t\t\t\ttempHolder = _itemHolders.shift();\n\t\t\t\t_itemHolders[NUM_HOLDERS-1] = tempHolder; // move first to last\n\n\t\t\t\t_containerShiftIndex++;\n\t\t\t\t_setTranslateX( (_containerShiftIndex+2) * _slideSize.x, tempHolder.el.style);\n\t\t\t\tself.setContent(tempHolder, _currentItemIndex - diffAbs + i + 1 + 1);\n\t\t\t} else {\n\t\t\t\ttempHolder = _itemHolders.pop();\n\t\t\t\t_itemHolders.unshift( tempHolder ); // move last to first\n\n\t\t\t\t_containerShiftIndex--;\n\t\t\t\t_setTranslateX( _containerShiftIndex * _slideSize.x, tempHolder.el.style);\n\t\t\t\tself.setContent(tempHolder, _currentItemIndex + diffAbs - i - 1 - 1);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t// reset zoom/pan on previous item\n\t\tif(_currZoomElementStyle && Math.abs(_indexDiff) === 1) {\n\n\t\t\tvar prevItem = _getItemAt(_prevItemIndex);\n\t\t\tif(prevItem.initialZoomLevel !== _currZoomLevel) {\n\t\t\t\t_calculateItemSize(prevItem , _viewportSize );\n\t\t\t\t_setImageSize(prevItem);\n\t\t\t\t_applyZoomPanToItem( prevItem ); \t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t\t// reset diff after update\n\t\t_indexDiff = 0;\n\n\t\tself.updateCurrZoomItem();\n\n\t\t_prevItemIndex = _currentItemIndex;\n\n\t\t_shout('afterChange');\n\t\t\n\t},\n\n\n\n\tupdateSize: function(force) {\n\t\t\n\t\tif(!_isFixedPosition && _options.modal) {\n\t\t\tvar windowScrollY = framework.getScrollY();\n\t\t\tif(_currentWindowScrollY !== windowScrollY) {\n\t\t\t\ttemplate.style.top = windowScrollY + 'px';\n\t\t\t\t_currentWindowScrollY = windowScrollY;\n\t\t\t}\n\t\t\tif(!force && _windowVisibleSize.x === window.innerWidth && _windowVisibleSize.y === window.innerHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_windowVisibleSize.x = window.innerWidth;\n\t\t\t_windowVisibleSize.y = window.innerHeight;\n\n\t\t\t//template.style.width = _windowVisibleSize.x + 'px';\n\t\t\ttemplate.style.height = _windowVisibleSize.y + 'px';\n\t\t}\n\n\n\n\t\t_viewportSize.x = self.scrollWrap.clientWidth;\n\t\t_viewportSize.y = self.scrollWrap.clientHeight;\n\n\t\t_updatePageScrollOffset();\n\n\t\t_slideSize.x = _viewportSize.x + Math.round(_viewportSize.x * _options.spacing);\n\t\t_slideSize.y = _viewportSize.y;\n\n\t\t_moveMainScroll(_slideSize.x * _currPositionIndex);\n\n\t\t_shout('beforeResize'); // even may be used for example to switch image sources\n\n\n\t\t// don't re-calculate size on inital size update\n\t\tif(_containerShiftIndex !== undefined) {\n\n\t\t\tvar holder,\n\t\t\t\titem,\n\t\t\t\thIndex;\n\n\t\t\tfor(var i = 0; i < NUM_HOLDERS; i++) {\n\t\t\t\tholder = _itemHolders[i];\n\t\t\t\t_setTranslateX( (i+_containerShiftIndex) * _slideSize.x, holder.el.style);\n\n\t\t\t\thIndex = _currentItemIndex+i-1;\n\n\t\t\t\tif(_options.loop && _getNumItems() > 2) {\n\t\t\t\t\thIndex = _getLoopedId(hIndex);\n\t\t\t\t}\n\n\t\t\t\t// update zoom level on items and refresh source (if needsUpdate)\n\t\t\t\titem = _getItemAt( hIndex );\n\n\t\t\t\t// re-render gallery item if `needsUpdate`,\n\t\t\t\t// or doesn't have `bounds` (entirely new slide object)\n\t\t\t\tif( item && (_itemsNeedUpdate || item.needsUpdate || !item.bounds) ) {\n\n\t\t\t\t\tself.cleanSlide( item );\n\t\t\t\t\t\n\t\t\t\t\tself.setContent( holder, hIndex );\n\n\t\t\t\t\t// if \"center\" slide\n\t\t\t\t\tif(i === 1) {\n\t\t\t\t\t\tself.currItem = item;\n\t\t\t\t\t\tself.updateCurrZoomItem(true);\n\t\t\t\t\t}\n\n\t\t\t\t\titem.needsUpdate = false;\n\n\t\t\t\t} else if(holder.index === -1 && hIndex >= 0) {\n\t\t\t\t\t// add content first time\n\t\t\t\t\tself.setContent( holder, hIndex );\n\t\t\t\t}\n\t\t\t\tif(item && item.container) {\n\t\t\t\t\t_calculateItemSize(item, _viewportSize);\n\t\t\t\t\t_setImageSize(item);\n\t\t\t\t\t_applyZoomPanToItem( item );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t_itemsNeedUpdate = false;\n\t\t}\t\n\n\t\t_startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;\n\t\t_currPanBounds = self.currItem.bounds;\n\n\t\tif(_currPanBounds) {\n\t\t\t_panOffset.x = _currPanBounds.center.x;\n\t\t\t_panOffset.y = _currPanBounds.center.y;\n\t\t\t_applyCurrentZoomPan( true );\n\t\t}\n\t\t\n\t\t_shout('resize');\n\t},\n\t\n\t// Zoom current item to\n\tzoomTo: function(destZoomLevel, centerPoint, speed, easingFn, updateFn) {\n\t\t/*\n\t\t\tif(destZoomLevel === 'fit') {\n\t\t\t\tdestZoomLevel = self.currItem.fitRatio;\n\t\t\t} else if(destZoomLevel === 'fill') {\n\t\t\t\tdestZoomLevel = self.currItem.fillRatio;\n\t\t\t}\n\t\t*/\n\n\t\tif(centerPoint) {\n\t\t\t_startZoomLevel = _currZoomLevel;\n\t\t\t_midZoomPoint.x = Math.abs(centerPoint.x) - _panOffset.x ;\n\t\t\t_midZoomPoint.y = Math.abs(centerPoint.y) - _panOffset.y ;\n\t\t\t_equalizePoints(_startPanOffset, _panOffset);\n\t\t}\n\n\t\tvar destPanBounds = _calculatePanBounds(destZoomLevel, false),\n\t\t\tdestPanOffset = {};\n\n\t\t_modifyDestPanOffset('x', destPanBounds, destPanOffset, destZoomLevel);\n\t\t_modifyDestPanOffset('y', destPanBounds, destPanOffset, destZoomLevel);\n\n\t\tvar initialZoomLevel = _currZoomLevel;\n\t\tvar initialPanOffset = {\n\t\t\tx: _panOffset.x,\n\t\t\ty: _panOffset.y\n\t\t};\n\n\t\t_roundPoint(destPanOffset);\n\n\t\tvar onUpdate = function(now) {\n\t\t\tif(now === 1) {\n\t\t\t\t_currZoomLevel = destZoomLevel;\n\t\t\t\t_panOffset.x = destPanOffset.x;\n\t\t\t\t_panOffset.y = destPanOffset.y;\n\t\t\t} else {\n\t\t\t\t_currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;\n\t\t\t\t_panOffset.x = (destPanOffset.x - initialPanOffset.x) * now + initialPanOffset.x;\n\t\t\t\t_panOffset.y = (destPanOffset.y - initialPanOffset.y) * now + initialPanOffset.y;\n\t\t\t}\n\n\t\t\tif(updateFn) {\n\t\t\t\tupdateFn(now);\n\t\t\t}\n\n\t\t\t_applyCurrentZoomPan( now === 1 );\n\t\t};\n\n\t\tif(speed) {\n\t\t\t_animateProp('customZoomTo', 0, 1, speed, easingFn || framework.easing.sine.inOut, onUpdate);\n\t\t} else {\n\t\t\tonUpdate(1);\n\t\t}\n\t}\n\n\n};\n\n\n/*>>core*/\n\n/*>>gestures*/\n/**\n * Mouse/touch/pointer event handlers.\n * \n * separated from @core.js for readability\n */\n\nvar MIN_SWIPE_DISTANCE = 30,\n\tDIRECTION_CHECK_OFFSET = 10; // amount of pixels to drag to determine direction of swipe\n\nvar _gestureStartTime,\n\t_gestureCheckSpeedTime,\n\n\t// pool of objects that are used during dragging of zooming\n\tp = {}, // first point\n\tp2 = {}, // second point (for zoom gesture)\n\tdelta = {},\n\t_currPoint = {},\n\t_startPoint = {},\n\t_currPointers = [],\n\t_startMainScrollPos = {},\n\t_releaseAnimData,\n\t_posPoints = [], // array of points during dragging, used to determine type of gesture\n\t_tempPoint = {},\n\n\t_isZoomingIn,\n\t_verticalDragInitiated,\n\t_oldAndroidTouchEndTimeout,\n\t_currZoomedItemIndex = 0,\n\t_centerPoint = _getEmptyPoint(),\n\t_lastReleaseTime = 0,\n\t_isDragging, // at least one pointer is down\n\t_isMultitouch, // at least two _pointers are down\n\t_zoomStarted, // zoom level changed during zoom gesture\n\t_moved,\n\t_dragAnimFrame,\n\t_mainScrollShifted,\n\t_currentPoints, // array of current touch points\n\t_isZooming,\n\t_currPointsDistance,\n\t_startPointsDistance,\n\t_currPanBounds,\n\t_mainScrollPos = _getEmptyPoint(),\n\t_currZoomElementStyle,\n\t_mainScrollAnimating, // true, if animation after swipe gesture is running\n\t_midZoomPoint = _getEmptyPoint(),\n\t_currCenterPoint = _getEmptyPoint(),\n\t_direction,\n\t_isFirstMove,\n\t_opacityChanged,\n\t_bgOpacity,\n\t_wasOverInitialZoom,\n\n\t_isEqualPoints = function(p1, p2) {\n\t\treturn p1.x === p2.x && p1.y === p2.y;\n\t},\n\t_isNearbyPoints = function(touch0, touch1) {\n\t\treturn Math.abs(touch0.x - touch1.x) < DOUBLE_TAP_RADIUS && Math.abs(touch0.y - touch1.y) < DOUBLE_TAP_RADIUS;\n\t},\n\t_calculatePointsDistance = function(p1, p2) {\n\t\t_tempPoint.x = Math.abs( p1.x - p2.x );\n\t\t_tempPoint.y = Math.abs( p1.y - p2.y );\n\t\treturn Math.sqrt(_tempPoint.x * _tempPoint.x + _tempPoint.y * _tempPoint.y);\n\t},\n\t_stopDragUpdateLoop = function() {\n\t\tif(_dragAnimFrame) {\n\t\t\t_cancelAF(_dragAnimFrame);\n\t\t\t_dragAnimFrame = null;\n\t\t}\n\t},\n\t_dragUpdateLoop = function() {\n\t\tif(_isDragging) {\n\t\t\t_dragAnimFrame = _requestAF(_dragUpdateLoop);\n\t\t\t_renderMovement();\n\t\t}\n\t},\n\t_canPan = function() {\n\t\treturn !(_options.scaleMode === 'fit' && _currZoomLevel ===  self.currItem.initialZoomLevel);\n\t},\n\t\n\t// find the closest parent DOM element\n\t_closestElement = function(el, fn) {\n\t  \tif(!el || el === document) {\n\t  \t\treturn false;\n\t  \t}\n\n\t  \t// don't search elements above pswp__scroll-wrap\n\t  \tif(el.getAttribute('class') && el.getAttribute('class').indexOf('pswp__scroll-wrap') > -1 ) {\n\t  \t\treturn false;\n\t  \t}\n\n\t  \tif( fn(el) ) {\n\t  \t\treturn el;\n\t  \t}\n\n\t  \treturn _closestElement(el.parentNode, fn);\n\t},\n\n\t_preventObj = {},\n\t_preventDefaultEventBehaviour = function(e, isDown) {\n\t    _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement);\n\n\t\t_shout('preventDragEvent', e, isDown, _preventObj);\n\t\treturn _preventObj.prevent;\n\n\t},\n\t_convertTouchToPoint = function(touch, p) {\n\t\tp.x = touch.pageX;\n\t\tp.y = touch.pageY;\n\t\tp.id = touch.identifier;\n\t\treturn p;\n\t},\n\t_findCenterOfPoints = function(p1, p2, pCenter) {\n\t\tpCenter.x = (p1.x + p2.x) * 0.5;\n\t\tpCenter.y = (p1.y + p2.y) * 0.5;\n\t},\n\t_pushPosPoint = function(time, x, y) {\n\t\tif(time - _gestureCheckSpeedTime > 50) {\n\t\t\tvar o = _posPoints.length > 2 ? _posPoints.shift() : {};\n\t\t\to.x = x;\n\t\t\to.y = y; \n\t\t\t_posPoints.push(o);\n\t\t\t_gestureCheckSpeedTime = time;\n\t\t}\n\t},\n\n\t_calculateVerticalDragOpacityRatio = function() {\n\t\tvar yOffset = _panOffset.y - self.currItem.initialPosition.y; // difference between initial and current position\n\t\treturn 1 -  Math.abs( yOffset / (_viewportSize.y / 2)  );\n\t},\n\n\t\n\t// points pool, reused during touch events\n\t_ePoint1 = {},\n\t_ePoint2 = {},\n\t_tempPointsArr = [],\n\t_tempCounter,\n\t_getTouchPoints = function(e) {\n\t\t// clean up previous points, without recreating array\n\t\twhile(_tempPointsArr.length > 0) {\n\t\t\t_tempPointsArr.pop();\n\t\t}\n\n\t\tif(!_pointerEventEnabled) {\n\t\t\tif(e.type.indexOf('touch') > -1) {\n\n\t\t\t\tif(e.touches && e.touches.length > 0) {\n\t\t\t\t\t_tempPointsArr[0] = _convertTouchToPoint(e.touches[0], _ePoint1);\n\t\t\t\t\tif(e.touches.length > 1) {\n\t\t\t\t\t\t_tempPointsArr[1] = _convertTouchToPoint(e.touches[1], _ePoint2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t_ePoint1.x = e.pageX;\n\t\t\t\t_ePoint1.y = e.pageY;\n\t\t\t\t_ePoint1.id = '';\n\t\t\t\t_tempPointsArr[0] = _ePoint1;//_ePoint1;\n\t\t\t}\n\t\t} else {\n\t\t\t_tempCounter = 0;\n\t\t\t// we can use forEach, as pointer events are supported only in modern browsers\n\t\t\t_currPointers.forEach(function(p) {\n\t\t\t\tif(_tempCounter === 0) {\n\t\t\t\t\t_tempPointsArr[0] = p;\n\t\t\t\t} else if(_tempCounter === 1) {\n\t\t\t\t\t_tempPointsArr[1] = p;\n\t\t\t\t}\n\t\t\t\t_tempCounter++;\n\n\t\t\t});\n\t\t}\n\t\treturn _tempPointsArr;\n\t},\n\n\t_panOrMoveMainScroll = function(axis, delta) {\n\n\t\tvar panFriction,\n\t\t\toverDiff = 0,\n\t\t\tnewOffset = _panOffset[axis] + delta[axis],\n\t\t\tstartOverDiff,\n\t\t\tdir = delta[axis] > 0,\n\t\t\tnewMainScrollPosition = _mainScrollPos.x + delta.x,\n\t\t\tmainScrollDiff = _mainScrollPos.x - _startMainScrollPos.x,\n\t\t\tnewPanPos,\n\t\t\tnewMainScrollPos;\n\n\t\t// calculate fdistance over the bounds and friction\n\t\tif(newOffset > _currPanBounds.min[axis] || newOffset < _currPanBounds.max[axis]) {\n\t\t\tpanFriction = _options.panEndFriction;\n\t\t\t// Linear increasing of friction, so at 1/4 of viewport it's at max value. \n\t\t\t// Looks not as nice as was expected. Left for history.\n\t\t\t// panFriction = (1 - (_panOffset[axis] + delta[axis] + panBounds.min[axis]) / (_viewportSize[axis] / 4) );\n\t\t} else {\n\t\t\tpanFriction = 1;\n\t\t}\n\t\t\n\t\tnewOffset = _panOffset[axis] + delta[axis] * panFriction;\n\n\t\t// move main scroll or start panning\n\t\tif(_options.allowPanToNext || _currZoomLevel === self.currItem.initialZoomLevel) {\n\n\n\t\t\tif(!_currZoomElementStyle) {\n\t\t\t\t\n\t\t\t\tnewMainScrollPos = newMainScrollPosition;\n\n\t\t\t} else if(_direction === 'h' && axis === 'x' && !_zoomStarted ) {\n\t\t\t\t\n\t\t\t\tif(dir) {\n\t\t\t\t\tif(newOffset > _currPanBounds.min[axis]) {\n\t\t\t\t\t\tpanFriction = _options.panEndFriction;\n\t\t\t\t\t\toverDiff = _currPanBounds.min[axis] - newOffset;\n\t\t\t\t\t\tstartOverDiff = _currPanBounds.min[axis] - _startPanOffset[axis];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// drag right\n\t\t\t\t\tif( (startOverDiff <= 0 || mainScrollDiff < 0) && _getNumItems() > 1 ) {\n\t\t\t\t\t\tnewMainScrollPos = newMainScrollPosition;\n\t\t\t\t\t\tif(mainScrollDiff < 0 && newMainScrollPosition > _startMainScrollPos.x) {\n\t\t\t\t\t\t\tnewMainScrollPos = _startMainScrollPos.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(_currPanBounds.min.x !== _currPanBounds.max.x) {\n\t\t\t\t\t\t\tnewPanPos = newOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif(newOffset < _currPanBounds.max[axis] ) {\n\t\t\t\t\t\tpanFriction =_options.panEndFriction;\n\t\t\t\t\t\toverDiff = newOffset - _currPanBounds.max[axis];\n\t\t\t\t\t\tstartOverDiff = _startPanOffset[axis] - _currPanBounds.max[axis];\n\t\t\t\t\t}\n\n\t\t\t\t\tif( (startOverDiff <= 0 || mainScrollDiff > 0) && _getNumItems() > 1 ) {\n\t\t\t\t\t\tnewMainScrollPos = newMainScrollPosition;\n\n\t\t\t\t\t\tif(mainScrollDiff > 0 && newMainScrollPosition < _startMainScrollPos.x) {\n\t\t\t\t\t\t\tnewMainScrollPos = _startMainScrollPos.x;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(_currPanBounds.min.x !== _currPanBounds.max.x) {\n\t\t\t\t\t\t\tnewPanPos = newOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t//\n\t\t\t}\n\n\t\t\tif(axis === 'x') {\n\n\t\t\t\tif(newMainScrollPos !== undefined) {\n\t\t\t\t\t_moveMainScroll(newMainScrollPos, true);\n\t\t\t\t\tif(newMainScrollPos === _startMainScrollPos.x) {\n\t\t\t\t\t\t_mainScrollShifted = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_mainScrollShifted = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(_currPanBounds.min.x !== _currPanBounds.max.x) {\n\t\t\t\t\tif(newPanPos !== undefined) {\n\t\t\t\t\t\t_panOffset.x = newPanPos;\n\t\t\t\t\t} else if(!_mainScrollShifted) {\n\t\t\t\t\t\t_panOffset.x += delta.x * panFriction;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn newMainScrollPos !== undefined;\n\t\t\t}\n\n\t\t}\n\n\t\tif(!_mainScrollAnimating) {\n\t\t\t\n\t\t\tif(!_mainScrollShifted) {\n\t\t\t\tif(_currZoomLevel > self.currItem.fitRatio) {\n\t\t\t\t\t_panOffset[axis] += delta[axis] * panFriction;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t\t\n\t},\n\n\t// Pointerdown/touchstart/mousedown handler\n\t_onDragStart = function(e) {\n\n\t\t// Allow dragging only via left mouse button.\n\t\t// As this handler is not added in IE8 - we ignore e.which\n\t\t// \n\t\t// http://www.quirksmode.org/js/events_properties.html\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/event.button\n\t\tif(e.type === 'mousedown' && e.button > 0  ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(_initialZoomRunning) {\n\t\t\te.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tif(_oldAndroidTouchEndTimeout && e.type === 'mousedown') {\n\t\t\treturn;\n\t\t}\n\n\t\tif(_preventDefaultEventBehaviour(e, true)) {\n\t\t\te.preventDefault();\n\t\t}\n\n\n\n\t\t_shout('pointerDown');\n\n\t\tif(_pointerEventEnabled) {\n\t\t\tvar pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\n\t\t\tif(pointerIndex < 0) {\n\t\t\t\tpointerIndex = _currPointers.length;\n\t\t\t}\n\t\t\t_currPointers[pointerIndex] = {x:e.pageX, y:e.pageY, id: e.pointerId};\n\t\t}\n\t\t\n\n\n\t\tvar startPointsList = _getTouchPoints(e),\n\t\t\tnumPoints = startPointsList.length;\n\n\t\t_currentPoints = null;\n\n\t\t_stopAllAnimations();\n\n\t\t// init drag\n\t\tif(!_isDragging || numPoints === 1) {\n\n\t\t\t\n\n\t\t\t_isDragging = _isFirstMove = true;\n\t\t\tframework.bind(window, _upMoveEvents, self);\n\n\t\t\t_isZoomingIn = \n\t\t\t\t_wasOverInitialZoom = \n\t\t\t\t_opacityChanged = \n\t\t\t\t_verticalDragInitiated = \n\t\t\t\t_mainScrollShifted = \n\t\t\t\t_moved = \n\t\t\t\t_isMultitouch = \n\t\t\t\t_zoomStarted = false;\n\n\t\t\t_direction = null;\n\n\t\t\t_shout('firstTouchStart', startPointsList);\n\n\t\t\t_equalizePoints(_startPanOffset, _panOffset);\n\n\t\t\t_currPanDist.x = _currPanDist.y = 0;\n\t\t\t_equalizePoints(_currPoint, startPointsList[0]);\n\t\t\t_equalizePoints(_startPoint, _currPoint);\n\n\t\t\t//_equalizePoints(_startMainScrollPos, _mainScrollPos);\n\t\t\t_startMainScrollPos.x = _slideSize.x * _currPositionIndex;\n\n\t\t\t_posPoints = [{\n\t\t\t\tx: _currPoint.x,\n\t\t\t\ty: _currPoint.y\n\t\t\t}];\n\n\t\t\t_gestureCheckSpeedTime = _gestureStartTime = _getCurrentTime();\n\n\t\t\t//_mainScrollAnimationEnd(true);\n\t\t\t_calculatePanBounds( _currZoomLevel, true );\n\t\t\t\n\t\t\t// Start rendering\n\t\t\t_stopDragUpdateLoop();\n\t\t\t_dragUpdateLoop();\n\t\t\t\n\t\t}\n\n\t\t// init zoom\n\t\tif(!_isZooming && numPoints > 1 && !_mainScrollAnimating && !_mainScrollShifted) {\n\t\t\t_startZoomLevel = _currZoomLevel;\n\t\t\t_zoomStarted = false; // true if zoom changed at least once\n\n\t\t\t_isZooming = _isMultitouch = true;\n\t\t\t_currPanDist.y = _currPanDist.x = 0;\n\n\t\t\t_equalizePoints(_startPanOffset, _panOffset);\n\n\t\t\t_equalizePoints(p, startPointsList[0]);\n\t\t\t_equalizePoints(p2, startPointsList[1]);\n\n\t\t\t_findCenterOfPoints(p, p2, _currCenterPoint);\n\n\t\t\t_midZoomPoint.x = Math.abs(_currCenterPoint.x) - _panOffset.x;\n\t\t\t_midZoomPoint.y = Math.abs(_currCenterPoint.y) - _panOffset.y;\n\t\t\t_currPointsDistance = _startPointsDistance = _calculatePointsDistance(p, p2);\n\t\t}\n\n\n\t},\n\n\t// Pointermove/touchmove/mousemove handler\n\t_onDragMove = function(e) {\n\n\t\te.preventDefault();\n\n\t\tif(_pointerEventEnabled) {\n\t\t\tvar pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\n\t\t\tif(pointerIndex > -1) {\n\t\t\t\tvar p = _currPointers[pointerIndex];\n\t\t\t\tp.x = e.pageX;\n\t\t\t\tp.y = e.pageY; \n\t\t\t}\n\t\t}\n\n\t\tif(_isDragging) {\n\t\t\tvar touchesList = _getTouchPoints(e);\n\t\t\tif(!_direction && !_moved && !_isZooming) {\n\n\t\t\t\tif(_mainScrollPos.x !== _slideSize.x * _currPositionIndex) {\n\t\t\t\t\t// if main scroll position is shifted – direction is always horizontal\n\t\t\t\t\t_direction = 'h';\n\t\t\t\t} else {\n\t\t\t\t\tvar diff = Math.abs(touchesList[0].x - _currPoint.x) - Math.abs(touchesList[0].y - _currPoint.y);\n\t\t\t\t\t// check the direction of movement\n\t\t\t\t\tif(Math.abs(diff) >= DIRECTION_CHECK_OFFSET) {\n\t\t\t\t\t\t_direction = diff > 0 ? 'h' : 'v';\n\t\t\t\t\t\t_currentPoints = touchesList;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t_currentPoints = touchesList;\n\t\t\t}\n\t\t}\t\n\t},\n\t// \n\t_renderMovement =  function() {\n\n\t\tif(!_currentPoints) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar numPoints = _currentPoints.length;\n\n\t\tif(numPoints === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t_equalizePoints(p, _currentPoints[0]);\n\n\t\tdelta.x = p.x - _currPoint.x;\n\t\tdelta.y = p.y - _currPoint.y;\n\n\t\tif(_isZooming && numPoints > 1) {\n\t\t\t// Handle behaviour for more than 1 point\n\n\t\t\t_currPoint.x = p.x;\n\t\t\t_currPoint.y = p.y;\n\t\t\n\t\t\t// check if one of two points changed\n\t\t\tif( !delta.x && !delta.y && _isEqualPoints(_currentPoints[1], p2) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_equalizePoints(p2, _currentPoints[1]);\n\n\n\t\t\tif(!_zoomStarted) {\n\t\t\t\t_zoomStarted = true;\n\t\t\t\t_shout('zoomGestureStarted');\n\t\t\t}\n\t\t\t\n\t\t\t// Distance between two points\n\t\t\tvar pointsDistance = _calculatePointsDistance(p,p2);\n\n\t\t\tvar zoomLevel = _calculateZoomLevel(pointsDistance);\n\n\t\t\t// slightly over the of initial zoom level\n\t\t\tif(zoomLevel > self.currItem.initialZoomLevel + self.currItem.initialZoomLevel / 15) {\n\t\t\t\t_wasOverInitialZoom = true;\n\t\t\t}\n\n\t\t\t// Apply the friction if zoom level is out of the bounds\n\t\t\tvar zoomFriction = 1,\n\t\t\t\tminZoomLevel = _getMinZoomLevel(),\n\t\t\t\tmaxZoomLevel = _getMaxZoomLevel();\n\n\t\t\tif ( zoomLevel < minZoomLevel ) {\n\t\t\t\t\n\t\t\t\tif(_options.pinchToClose && !_wasOverInitialZoom && _startZoomLevel <= self.currItem.initialZoomLevel) {\n\t\t\t\t\t// fade out background if zooming out\n\t\t\t\t\tvar minusDiff = minZoomLevel - zoomLevel;\n\t\t\t\t\tvar percent = 1 - minusDiff / (minZoomLevel / 1.2);\n\n\t\t\t\t\t_applyBgOpacity(percent);\n\t\t\t\t\t_shout('onPinchClose', percent);\n\t\t\t\t\t_opacityChanged = true;\n\t\t\t\t} else {\n\t\t\t\t\tzoomFriction = (minZoomLevel - zoomLevel) / minZoomLevel;\n\t\t\t\t\tif(zoomFriction > 1) {\n\t\t\t\t\t\tzoomFriction = 1;\n\t\t\t\t\t}\n\t\t\t\t\tzoomLevel = minZoomLevel - zoomFriction * (minZoomLevel / 3);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( zoomLevel > maxZoomLevel ) {\n\t\t\t\t// 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5\n\t\t\t\tzoomFriction = (zoomLevel - maxZoomLevel) / ( minZoomLevel * 6 );\n\t\t\t\tif(zoomFriction > 1) {\n\t\t\t\t\tzoomFriction = 1;\n\t\t\t\t}\n\t\t\t\tzoomLevel = maxZoomLevel + zoomFriction * minZoomLevel;\n\t\t\t}\n\n\t\t\tif(zoomFriction < 0) {\n\t\t\t\tzoomFriction = 0;\n\t\t\t}\n\n\t\t\t// distance between touch points after friction is applied\n\t\t\t_currPointsDistance = pointsDistance;\n\n\t\t\t// _centerPoint - The point in the middle of two pointers\n\t\t\t_findCenterOfPoints(p, p2, _centerPoint);\n\t\t\n\t\t\t// paning with two pointers pressed\n\t\t\t_currPanDist.x += _centerPoint.x - _currCenterPoint.x;\n\t\t\t_currPanDist.y += _centerPoint.y - _currCenterPoint.y;\n\t\t\t_equalizePoints(_currCenterPoint, _centerPoint);\n\n\t\t\t_panOffset.x = _calculatePanOffset('x', zoomLevel);\n\t\t\t_panOffset.y = _calculatePanOffset('y', zoomLevel);\n\n\t\t\t_isZoomingIn = zoomLevel > _currZoomLevel;\n\t\t\t_currZoomLevel = zoomLevel;\n\t\t\t_applyCurrentZoomPan();\n\n\t\t} else {\n\n\t\t\t// handle behaviour for one point (dragging or panning)\n\n\t\t\tif(!_direction) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(_isFirstMove) {\n\t\t\t\t_isFirstMove = false;\n\n\t\t\t\t// subtract drag distance that was used during the detection direction  \n\n\t\t\t\tif( Math.abs(delta.x) >= DIRECTION_CHECK_OFFSET) {\n\t\t\t\t\tdelta.x -= _currentPoints[0].x - _startPoint.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( Math.abs(delta.y) >= DIRECTION_CHECK_OFFSET) {\n\t\t\t\t\tdelta.y -= _currentPoints[0].y - _startPoint.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_currPoint.x = p.x;\n\t\t\t_currPoint.y = p.y;\n\n\t\t\t// do nothing if pointers position hasn't changed\n\t\t\tif(delta.x === 0 && delta.y === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(_direction === 'v' && _options.closeOnVerticalDrag) {\n\t\t\t\tif(!_canPan()) {\n\t\t\t\t\t_currPanDist.y += delta.y;\n\t\t\t\t\t_panOffset.y += delta.y;\n\n\t\t\t\t\tvar opacityRatio = _calculateVerticalDragOpacityRatio();\n\n\t\t\t\t\t_verticalDragInitiated = true;\n\t\t\t\t\t_shout('onVerticalDrag', opacityRatio);\n\n\t\t\t\t\t_applyBgOpacity(opacityRatio);\n\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_pushPosPoint(_getCurrentTime(), p.x, p.y);\n\n\t\t\t_moved = true;\n\t\t\t_currPanBounds = self.currItem.bounds;\n\t\t\t\n\t\t\tvar mainScrollChanged = _panOrMoveMainScroll('x', delta);\n\t\t\tif(!mainScrollChanged) {\n\t\t\t\t_panOrMoveMainScroll('y', delta);\n\n\t\t\t\t_roundPoint(_panOffset);\n\t\t\t\t_applyCurrentZoomPan();\n\t\t\t}\n\n\t\t}\n\n\t},\n\t\n\t// Pointerup/pointercancel/touchend/touchcancel/mouseup event handler\n\t_onDragRelease = function(e) {\n\n\t\tif(_features.isOldAndroid ) {\n\n\t\t\tif(_oldAndroidTouchEndTimeout && e.type === 'mouseup') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// on Android (v4.1, 4.2, 4.3 & possibly older) \n\t\t\t// ghost mousedown/up event isn't preventable via e.preventDefault,\n\t\t\t// which causes fake mousedown event\n\t\t\t// so we block mousedown/up for 600ms\n\t\t\tif( e.type.indexOf('touch') > -1 ) {\n\t\t\t\tclearTimeout(_oldAndroidTouchEndTimeout);\n\t\t\t\t_oldAndroidTouchEndTimeout = setTimeout(function() {\n\t\t\t\t\t_oldAndroidTouchEndTimeout = 0;\n\t\t\t\t}, 600);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t_shout('pointerUp');\n\n\t\tif(_preventDefaultEventBehaviour(e, false)) {\n\t\t\te.preventDefault();\n\t\t}\n\n\t\tvar releasePoint;\n\n\t\tif(_pointerEventEnabled) {\n\t\t\tvar pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\n\t\t\t\n\t\t\tif(pointerIndex > -1) {\n\t\t\t\treleasePoint = _currPointers.splice(pointerIndex, 1)[0];\n\n\t\t\t\tif(navigator.msPointerEnabled) {\n\t\t\t\t\tvar MSPOINTER_TYPES = {\n\t\t\t\t\t\t4: 'mouse', // event.MSPOINTER_TYPE_MOUSE\n\t\t\t\t\t\t2: 'touch', // event.MSPOINTER_TYPE_TOUCH \n\t\t\t\t\t\t3: 'pen' // event.MSPOINTER_TYPE_PEN\n\t\t\t\t\t};\n\t\t\t\t\treleasePoint.type = MSPOINTER_TYPES[e.pointerType];\n\n\t\t\t\t\tif(!releasePoint.type) {\n\t\t\t\t\t\treleasePoint.type = e.pointerType || 'mouse';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treleasePoint.type = e.pointerType || 'mouse';\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tvar touchList = _getTouchPoints(e),\n\t\t\tgestureType,\n\t\t\tnumPoints = touchList.length;\n\n\t\tif(e.type === 'mouseup') {\n\t\t\tnumPoints = 0;\n\t\t}\n\n\t\t// Do nothing if there were 3 touch points or more\n\t\tif(numPoints === 2) {\n\t\t\t_currentPoints = null;\n\t\t\treturn true;\n\t\t}\n\n\t\t// if second pointer released\n\t\tif(numPoints === 1) {\n\t\t\t_equalizePoints(_startPoint, touchList[0]);\n\t\t}\t\t\t\t\n\n\n\t\t// pointer hasn't moved, send \"tap release\" point\n\t\tif(numPoints === 0 && !_direction && !_mainScrollAnimating) {\n\t\t\tif(!releasePoint) {\n\t\t\t\tif(e.type === 'mouseup') {\n\t\t\t\t\treleasePoint = {x: e.pageX, y: e.pageY, type:'mouse'};\n\t\t\t\t} else if(e.changedTouches && e.changedTouches[0]) {\n\t\t\t\t\treleasePoint = {x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY, type:'touch'};\n\t\t\t\t}\t\t\n\t\t\t}\n\n\t\t\t_shout('touchRelease', e, releasePoint);\n\t\t}\n\n\t\t// Difference in time between releasing of two last touch points (zoom gesture)\n\t\tvar releaseTimeDiff = -1;\n\n\t\t// Gesture completed, no pointers left\n\t\tif(numPoints === 0) {\n\t\t\t_isDragging = false;\n\t\t\tframework.unbind(window, _upMoveEvents, self);\n\n\t\t\t_stopDragUpdateLoop();\n\n\t\t\tif(_isZooming) {\n\t\t\t\t// Two points released at the same time\n\t\t\t\treleaseTimeDiff = 0;\n\t\t\t} else if(_lastReleaseTime !== -1) {\n\t\t\t\treleaseTimeDiff = _getCurrentTime() - _lastReleaseTime;\n\t\t\t}\n\t\t}\n\t\t_lastReleaseTime = numPoints === 1 ? _getCurrentTime() : -1;\n\t\t\n\t\tif(releaseTimeDiff !== -1 && releaseTimeDiff < 150) {\n\t\t\tgestureType = 'zoom';\n\t\t} else {\n\t\t\tgestureType = 'swipe';\n\t\t}\n\n\t\tif(_isZooming && numPoints < 2) {\n\t\t\t_isZooming = false;\n\n\t\t\t// Only second point released\n\t\t\tif(numPoints === 1) {\n\t\t\t\tgestureType = 'zoomPointerUp';\n\t\t\t}\n\t\t\t_shout('zoomGestureEnded');\n\t\t}\n\n\t\t_currentPoints = null;\n\t\tif(!_moved && !_zoomStarted && !_mainScrollAnimating && !_verticalDragInitiated) {\n\t\t\t// nothing to animate\n\t\t\treturn;\n\t\t}\n\t\n\t\t_stopAllAnimations();\n\n\t\t\n\t\tif(!_releaseAnimData) {\n\t\t\t_releaseAnimData = _initDragReleaseAnimationData();\n\t\t}\n\t\t\n\t\t_releaseAnimData.calculateSwipeSpeed('x');\n\n\n\t\tif(_verticalDragInitiated) {\n\n\t\t\tvar opacityRatio = _calculateVerticalDragOpacityRatio();\n\n\t\t\tif(opacityRatio < _options.verticalDragRange) {\n\t\t\t\tself.close();\n\t\t\t} else {\n\t\t\t\tvar initalPanY = _panOffset.y,\n\t\t\t\t\tinitialBgOpacity = _bgOpacity;\n\n\t\t\t\t_animateProp('verticalDrag', 0, 1, 300, framework.easing.cubic.out, function(now) {\n\t\t\t\t\t\n\t\t\t\t\t_panOffset.y = (self.currItem.initialPosition.y - initalPanY) * now + initalPanY;\n\n\t\t\t\t\t_applyBgOpacity(  (1 - initialBgOpacity) * now + initialBgOpacity );\n\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t});\n\n\t\t\t\t_shout('onVerticalDrag', 1);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\n\t\t// main scroll \n\t\tif(  (_mainScrollShifted || _mainScrollAnimating) && numPoints === 0) {\n\t\t\tvar itemChanged = _finishSwipeMainScrollGesture(gestureType, _releaseAnimData);\n\t\t\tif(itemChanged) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgestureType = 'zoomPointerUp';\n\t\t}\n\n\t\t// prevent zoom/pan animation when main scroll animation runs\n\t\tif(_mainScrollAnimating) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Complete simple zoom gesture (reset zoom level if it's out of the bounds)  \n\t\tif(gestureType !== 'swipe') {\n\t\t\t_completeZoomGesture();\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Complete pan gesture if main scroll is not shifted, and it's possible to pan current image\n\t\tif(!_mainScrollShifted && _currZoomLevel > self.currItem.fitRatio) {\n\t\t\t_completePanGesture(_releaseAnimData);\n\t\t}\n\t},\n\n\n\t// Returns object with data about gesture\n\t// It's created only once and then reused\n\t_initDragReleaseAnimationData  = function() {\n\t\t// temp local vars\n\t\tvar lastFlickDuration,\n\t\t\ttempReleasePos;\n\n\t\t// s = this\n\t\tvar s = {\n\t\t\tlastFlickOffset: {},\n\t\t\tlastFlickDist: {},\n\t\t\tlastFlickSpeed: {},\n\t\t\tslowDownRatio:  {},\n\t\t\tslowDownRatioReverse:  {},\n\t\t\tspeedDecelerationRatio:  {},\n\t\t\tspeedDecelerationRatioAbs:  {},\n\t\t\tdistanceOffset:  {},\n\t\t\tbackAnimDestination: {},\n\t\t\tbackAnimStarted: {},\n\t\t\tcalculateSwipeSpeed: function(axis) {\n\t\t\t\t\n\n\t\t\t\tif( _posPoints.length > 1) {\n\t\t\t\t\tlastFlickDuration = _getCurrentTime() - _gestureCheckSpeedTime + 50;\n\t\t\t\t\ttempReleasePos = _posPoints[_posPoints.length-2][axis];\n\t\t\t\t} else {\n\t\t\t\t\tlastFlickDuration = _getCurrentTime() - _gestureStartTime; // total gesture duration\n\t\t\t\t\ttempReleasePos = _startPoint[axis];\n\t\t\t\t}\n\t\t\t\ts.lastFlickOffset[axis] = _currPoint[axis] - tempReleasePos;\n\t\t\t\ts.lastFlickDist[axis] = Math.abs(s.lastFlickOffset[axis]);\n\t\t\t\tif(s.lastFlickDist[axis] > 20) {\n\t\t\t\t\ts.lastFlickSpeed[axis] = s.lastFlickOffset[axis] / lastFlickDuration;\n\t\t\t\t} else {\n\t\t\t\t\ts.lastFlickSpeed[axis] = 0;\n\t\t\t\t}\n\t\t\t\tif( Math.abs(s.lastFlickSpeed[axis]) < 0.1 ) {\n\t\t\t\t\ts.lastFlickSpeed[axis] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts.slowDownRatio[axis] = 0.95;\n\t\t\t\ts.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];\n\t\t\t\ts.speedDecelerationRatio[axis] = 1;\n\t\t\t},\n\n\t\t\tcalculateOverBoundsAnimOffset: function(axis, speed) {\n\t\t\t\tif(!s.backAnimStarted[axis]) {\n\n\t\t\t\t\tif(_panOffset[axis] > _currPanBounds.min[axis]) {\n\t\t\t\t\t\ts.backAnimDestination[axis] = _currPanBounds.min[axis];\n\t\t\t\t\t\t\n\t\t\t\t\t} else if(_panOffset[axis] < _currPanBounds.max[axis]) {\n\t\t\t\t\t\ts.backAnimDestination[axis] = _currPanBounds.max[axis];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(s.backAnimDestination[axis] !== undefined) {\n\t\t\t\t\t\ts.slowDownRatio[axis] = 0.7;\n\t\t\t\t\t\ts.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];\n\t\t\t\t\t\tif(s.speedDecelerationRatioAbs[axis] < 0.05) {\n\n\t\t\t\t\t\t\ts.lastFlickSpeed[axis] = 0;\n\t\t\t\t\t\t\ts.backAnimStarted[axis] = true;\n\n\t\t\t\t\t\t\t_animateProp('bounceZoomPan'+axis,_panOffset[axis], \n\t\t\t\t\t\t\t\ts.backAnimDestination[axis], \n\t\t\t\t\t\t\t\tspeed || 300, \n\t\t\t\t\t\t\t\tframework.easing.sine.out, \n\t\t\t\t\t\t\t\tfunction(pos) {\n\t\t\t\t\t\t\t\t\t_panOffset[axis] = pos;\n\t\t\t\t\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Reduces the speed by slowDownRatio (per 10ms)\n\t\t\tcalculateAnimOffset: function(axis) {\n\t\t\t\tif(!s.backAnimStarted[axis]) {\n\t\t\t\t\ts.speedDecelerationRatio[axis] = s.speedDecelerationRatio[axis] * (s.slowDownRatio[axis] + \n\t\t\t\t\t\t\t\t\t\t\t\ts.slowDownRatioReverse[axis] - \n\t\t\t\t\t\t\t\t\t\t\t\ts.slowDownRatioReverse[axis] * s.timeDiff / 10);\n\n\t\t\t\t\ts.speedDecelerationRatioAbs[axis] = Math.abs(s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis]);\n\t\t\t\t\ts.distanceOffset[axis] = s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis] * s.timeDiff;\n\t\t\t\t\t_panOffset[axis] += s.distanceOffset[axis];\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tpanAnimLoop: function() {\n\t\t\t\tif ( _animations.zoomPan ) {\n\t\t\t\t\t_animations.zoomPan.raf = _requestAF(s.panAnimLoop);\n\n\t\t\t\t\ts.now = _getCurrentTime();\n\t\t\t\t\ts.timeDiff = s.now - s.lastNow;\n\t\t\t\t\ts.lastNow = s.now;\n\t\t\t\t\t\n\t\t\t\t\ts.calculateAnimOffset('x');\n\t\t\t\t\ts.calculateAnimOffset('y');\n\n\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t\t\n\t\t\t\t\ts.calculateOverBoundsAnimOffset('x');\n\t\t\t\t\ts.calculateOverBoundsAnimOffset('y');\n\n\n\t\t\t\t\tif (s.speedDecelerationRatioAbs.x < 0.05 && s.speedDecelerationRatioAbs.y < 0.05) {\n\n\t\t\t\t\t\t// round pan position\n\t\t\t\t\t\t_panOffset.x = Math.round(_panOffset.x);\n\t\t\t\t\t\t_panOffset.y = Math.round(_panOffset.y);\n\t\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t\t\t\n\t\t\t\t\t\t_stopAnimation('zoomPan');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t};\n\t\treturn s;\n\t},\n\n\t_completePanGesture = function(animData) {\n\t\t// calculate swipe speed for Y axis (paanning)\n\t\tanimData.calculateSwipeSpeed('y');\n\n\t\t_currPanBounds = self.currItem.bounds;\n\t\t\n\t\tanimData.backAnimDestination = {};\n\t\tanimData.backAnimStarted = {};\n\n\t\t// Avoid acceleration animation if speed is too low\n\t\tif(Math.abs(animData.lastFlickSpeed.x) <= 0.05 && Math.abs(animData.lastFlickSpeed.y) <= 0.05 ) {\n\t\t\tanimData.speedDecelerationRatioAbs.x = animData.speedDecelerationRatioAbs.y = 0;\n\n\t\t\t// Run pan drag release animation. E.g. if you drag image and release finger without momentum.\n\t\t\tanimData.calculateOverBoundsAnimOffset('x');\n\t\t\tanimData.calculateOverBoundsAnimOffset('y');\n\t\t\treturn true;\n\t\t}\n\n\t\t// Animation loop that controls the acceleration after pan gesture ends\n\t\t_registerStartAnimation('zoomPan');\n\t\tanimData.lastNow = _getCurrentTime();\n\t\tanimData.panAnimLoop();\n\t},\n\n\n\t_finishSwipeMainScrollGesture = function(gestureType, _releaseAnimData) {\n\t\tvar itemChanged;\n\t\tif(!_mainScrollAnimating) {\n\t\t\t_currZoomedItemIndex = _currentItemIndex;\n\t\t}\n\n\n\t\t\n\t\tvar itemsDiff;\n\n\t\tif(gestureType === 'swipe') {\n\t\t\tvar totalShiftDist = _currPoint.x - _startPoint.x,\n\t\t\t\tisFastLastFlick = _releaseAnimData.lastFlickDist.x < 10;\n\n\t\t\t// if container is shifted for more than MIN_SWIPE_DISTANCE, \n\t\t\t// and last flick gesture was in right direction\n\t\t\tif(totalShiftDist > MIN_SWIPE_DISTANCE && \n\t\t\t\t(isFastLastFlick || _releaseAnimData.lastFlickOffset.x > 20) ) {\n\t\t\t\t// go to prev item\n\t\t\t\titemsDiff = -1;\n\t\t\t} else if(totalShiftDist < -MIN_SWIPE_DISTANCE && \n\t\t\t\t(isFastLastFlick || _releaseAnimData.lastFlickOffset.x < -20) ) {\n\t\t\t\t// go to next item\n\t\t\t\titemsDiff = 1;\n\t\t\t}\n\t\t}\n\n\t\tvar nextCircle;\n\n\t\tif(itemsDiff) {\n\t\t\t\n\t\t\t_currentItemIndex += itemsDiff;\n\n\t\t\tif(_currentItemIndex < 0) {\n\t\t\t\t_currentItemIndex = _options.loop ? _getNumItems()-1 : 0;\n\t\t\t\tnextCircle = true;\n\t\t\t} else if(_currentItemIndex >= _getNumItems()) {\n\t\t\t\t_currentItemIndex = _options.loop ? 0 : _getNumItems()-1;\n\t\t\t\tnextCircle = true;\n\t\t\t}\n\n\t\t\tif(!nextCircle || _options.loop) {\n\t\t\t\t_indexDiff += itemsDiff;\n\t\t\t\t_currPositionIndex -= itemsDiff;\n\t\t\t\titemChanged = true;\n\t\t\t}\n\t\t\t\n\n\t\t\t\n\t\t}\n\n\t\tvar animateToX = _slideSize.x * _currPositionIndex;\n\t\tvar animateToDist = Math.abs( animateToX - _mainScrollPos.x );\n\t\tvar finishAnimDuration;\n\n\n\t\tif(!itemChanged && animateToX > _mainScrollPos.x !== _releaseAnimData.lastFlickSpeed.x > 0) {\n\t\t\t// \"return to current\" duration, e.g. when dragging from slide 0 to -1\n\t\t\tfinishAnimDuration = 333; \n\t\t} else {\n\t\t\tfinishAnimDuration = Math.abs(_releaseAnimData.lastFlickSpeed.x) > 0 ? \n\t\t\t\t\t\t\t\t\tanimateToDist / Math.abs(_releaseAnimData.lastFlickSpeed.x) : \n\t\t\t\t\t\t\t\t\t333;\n\n\t\t\tfinishAnimDuration = Math.min(finishAnimDuration, 400);\n\t\t\tfinishAnimDuration = Math.max(finishAnimDuration, 250);\n\t\t}\n\n\t\tif(_currZoomedItemIndex === _currentItemIndex) {\n\t\t\titemChanged = false;\n\t\t}\n\t\t\n\t\t_mainScrollAnimating = true;\n\t\t\n\t\t_shout('mainScrollAnimStart');\n\n\t\t_animateProp('mainScroll', _mainScrollPos.x, animateToX, finishAnimDuration, framework.easing.cubic.out, \n\t\t\t_moveMainScroll,\n\t\t\tfunction() {\n\t\t\t\t_stopAllAnimations();\n\t\t\t\t_mainScrollAnimating = false;\n\t\t\t\t_currZoomedItemIndex = -1;\n\t\t\t\t\n\t\t\t\tif(itemChanged || _currZoomedItemIndex !== _currentItemIndex) {\n\t\t\t\t\tself.updateCurrItem();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t_shout('mainScrollAnimComplete');\n\t\t\t}\n\t\t);\n\n\t\tif(itemChanged) {\n\t\t\tself.updateCurrItem(true);\n\t\t}\n\n\t\treturn itemChanged;\n\t},\n\n\t_calculateZoomLevel = function(touchesDistance) {\n\t\treturn  1 / _startPointsDistance * touchesDistance * _startZoomLevel;\n\t},\n\n\t// Resets zoom if it's out of bounds\n\t_completeZoomGesture = function() {\n\t\tvar destZoomLevel = _currZoomLevel,\n\t\t\tminZoomLevel = _getMinZoomLevel(),\n\t\t\tmaxZoomLevel = _getMaxZoomLevel();\n\n\t\tif ( _currZoomLevel < minZoomLevel ) {\n\t\t\tdestZoomLevel = minZoomLevel;\n\t\t} else if ( _currZoomLevel > maxZoomLevel ) {\n\t\t\tdestZoomLevel = maxZoomLevel;\n\t\t}\n\n\t\tvar destOpacity = 1,\n\t\t\tonUpdate,\n\t\t\tinitialOpacity = _bgOpacity;\n\n\t\tif(_opacityChanged && !_isZoomingIn && !_wasOverInitialZoom && _currZoomLevel < minZoomLevel) {\n\t\t\t//_closedByScroll = true;\n\t\t\tself.close();\n\t\t\treturn true;\n\t\t}\n\n\t\tif(_opacityChanged) {\n\t\t\tonUpdate = function(now) {\n\t\t\t\t_applyBgOpacity(  (destOpacity - initialOpacity) * now + initialOpacity );\n\t\t\t};\n\t\t}\n\n\t\tself.zoomTo(destZoomLevel, 0, 200,  framework.easing.cubic.out, onUpdate);\n\t\treturn true;\n\t};\n\n\n_registerModule('Gestures', {\n\tpublicMethods: {\n\n\t\tinitGestures: function() {\n\n\t\t\t// helper function that builds touch/pointer/mouse events\n\t\t\tvar addEventNames = function(pref, down, move, up, cancel) {\n\t\t\t\t_dragStartEvent = pref + down;\n\t\t\t\t_dragMoveEvent = pref + move;\n\t\t\t\t_dragEndEvent = pref + up;\n\t\t\t\tif(cancel) {\n\t\t\t\t\t_dragCancelEvent = pref + cancel;\n\t\t\t\t} else {\n\t\t\t\t\t_dragCancelEvent = '';\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t_pointerEventEnabled = _features.pointerEvent;\n\t\t\tif(_pointerEventEnabled && _features.touch) {\n\t\t\t\t// we don't need touch events, if browser supports pointer events\n\t\t\t\t_features.touch = false;\n\t\t\t}\n\n\t\t\tif(_pointerEventEnabled) {\n\t\t\t\tif(navigator.msPointerEnabled) {\n\t\t\t\t\t// IE10 pointer events are case-sensitive\n\t\t\t\t\taddEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');\n\t\t\t\t} else {\n\t\t\t\t\taddEventNames('pointer', 'down', 'move', 'up', 'cancel');\n\t\t\t\t}\n\t\t\t} else if(_features.touch) {\n\t\t\t\taddEventNames('touch', 'start', 'move', 'end', 'cancel');\n\t\t\t\t_likelyTouchDevice = true;\n\t\t\t} else {\n\t\t\t\taddEventNames('mouse', 'down', 'move', 'up');\t\n\t\t\t}\n\n\t\t\t_upMoveEvents = _dragMoveEvent + ' ' + _dragEndEvent  + ' ' +  _dragCancelEvent;\n\t\t\t_downEvents = _dragStartEvent;\n\n\t\t\tif(_pointerEventEnabled && !_likelyTouchDevice) {\n\t\t\t\t_likelyTouchDevice = (navigator.maxTouchPoints > 1) || (navigator.msMaxTouchPoints > 1);\n\t\t\t}\n\t\t\t// make variable public\n\t\t\tself.likelyTouchDevice = _likelyTouchDevice; \n\t\t\t\n\t\t\t_globalEventHandlers[_dragStartEvent] = _onDragStart;\n\t\t\t_globalEventHandlers[_dragMoveEvent] = _onDragMove;\n\t\t\t_globalEventHandlers[_dragEndEvent] = _onDragRelease; // the Kraken\n\n\t\t\tif(_dragCancelEvent) {\n\t\t\t\t_globalEventHandlers[_dragCancelEvent] = _globalEventHandlers[_dragEndEvent];\n\t\t\t}\n\n\t\t\t// Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input.\n\t\t\tif(_features.touch) {\n\t\t\t\t_downEvents += ' mousedown';\n\t\t\t\t_upMoveEvents += ' mousemove mouseup';\n\t\t\t\t_globalEventHandlers.mousedown = _globalEventHandlers[_dragStartEvent];\n\t\t\t\t_globalEventHandlers.mousemove = _globalEventHandlers[_dragMoveEvent];\n\t\t\t\t_globalEventHandlers.mouseup = _globalEventHandlers[_dragEndEvent];\n\t\t\t}\n\n\t\t\tif(!_likelyTouchDevice) {\n\t\t\t\t// don't allow pan to next slide from zoomed state on Desktop\n\t\t\t\t_options.allowPanToNext = false;\n\t\t\t}\n\t\t}\n\n\t}\n});\n\n\n/*>>gestures*/\n\n/*>>show-hide-transition*/\n/**\n * show-hide-transition.js:\n *\n * Manages initial opening or closing transition.\n *\n * If you're not planning to use transition for gallery at all,\n * you may set options hideAnimationDuration and showAnimationDuration to 0,\n * and just delete startAnimation function.\n * \n */\n\n\nvar _showOrHideTimeout,\n\t_showOrHide = function(item, img, out, completeFn) {\n\n\t\tif(_showOrHideTimeout) {\n\t\t\tclearTimeout(_showOrHideTimeout);\n\t\t}\n\n\t\t_initialZoomRunning = true;\n\t\t_initialContentSet = true;\n\t\t\n\t\t// dimensions of small thumbnail {x:,y:,w:}.\n\t\t// Height is optional, as calculated based on large image.\n\t\tvar thumbBounds; \n\t\tif(item.initialLayout) {\n\t\t\tthumbBounds = item.initialLayout;\n\t\t\titem.initialLayout = null;\n\t\t} else {\n\t\t\tthumbBounds = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);\n\t\t}\n\n\t\tvar duration = out ? _options.hideAnimationDuration : _options.showAnimationDuration;\n\n\t\tvar onComplete = function() {\n\t\t\t_stopAnimation('initialZoom');\n\t\t\tif(!out) {\n\t\t\t\t_applyBgOpacity(1);\n\t\t\t\tif(img) {\n\t\t\t\t\timg.style.display = 'block';\n\t\t\t\t}\n\t\t\t\tframework.addClass(template, 'pswp--animated-in');\n\t\t\t\t_shout('initialZoom' + (out ? 'OutEnd' : 'InEnd'));\n\t\t\t} else {\n\t\t\t\tself.template.removeAttribute('style');\n\t\t\t\tself.bg.removeAttribute('style');\n\t\t\t}\n\n\t\t\tif(completeFn) {\n\t\t\t\tcompleteFn();\n\t\t\t}\n\t\t\t_initialZoomRunning = false;\n\t\t};\n\n\t\t// if bounds aren't provided, just open gallery without animation\n\t\tif(!duration || !thumbBounds || thumbBounds.x === undefined) {\n\n\t\t\t_shout('initialZoom' + (out ? 'Out' : 'In') );\n\n\t\t\t_currZoomLevel = item.initialZoomLevel;\n\t\t\t_equalizePoints(_panOffset,  item.initialPosition );\n\t\t\t_applyCurrentZoomPan();\n\n\t\t\ttemplate.style.opacity = out ? 0 : 1;\n\t\t\t_applyBgOpacity(1);\n\n\t\t\tif(duration) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tonComplete();\n\t\t\t\t}, duration);\n\t\t\t} else {\n\t\t\t\tonComplete();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar startAnimation = function() {\n\t\t\tvar closeWithRaf = _closedByScroll,\n\t\t\t\tfadeEverything = !self.currItem.src || self.currItem.loadError || _options.showHideOpacity;\n\t\t\t\n\t\t\t// apply hw-acceleration to image\n\t\t\tif(item.miniImg) {\n\t\t\t\titem.miniImg.style.webkitBackfaceVisibility = 'hidden';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\t_currZoomLevel = thumbBounds.w / item.w;\n\t\t\t\t_panOffset.x = thumbBounds.x;\n\t\t\t\t_panOffset.y = thumbBounds.y - _initalWindowScrollY;\n\n\t\t\t\tself[fadeEverything ? 'template' : 'bg'].style.opacity = 0.001;\n\t\t\t\t_applyCurrentZoomPan();\n\t\t\t}\n\n\t\t\t_registerStartAnimation('initialZoom');\n\t\t\t\n\t\t\tif(out && !closeWithRaf) {\n\t\t\t\tframework.removeClass(template, 'pswp--animated-in');\n\t\t\t}\n\n\t\t\tif(fadeEverything) {\n\t\t\t\tif(out) {\n\t\t\t\t\tframework[ (closeWithRaf ? 'remove' : 'add') + 'Class' ](template, 'pswp--animate_opacity');\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tframework.addClass(template, 'pswp--animate_opacity');\n\t\t\t\t\t}, 30);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_showOrHideTimeout = setTimeout(function() {\n\n\t\t\t\t_shout('initialZoom' + (out ? 'Out' : 'In') );\n\t\t\t\t\n\n\t\t\t\tif(!out) {\n\n\t\t\t\t\t// \"in\" animation always uses CSS transitions (instead of rAF).\n\t\t\t\t\t// CSS transition work faster here, \n\t\t\t\t\t// as developer may also want to animate other things, \n\t\t\t\t\t// like ui on top of sliding area, which can be animated just via CSS\n\t\t\t\t\t\n\t\t\t\t\t_currZoomLevel = item.initialZoomLevel;\n\t\t\t\t\t_equalizePoints(_panOffset,  item.initialPosition );\n\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t\t_applyBgOpacity(1);\n\n\t\t\t\t\tif(fadeEverything) {\n\t\t\t\t\t\ttemplate.style.opacity = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_applyBgOpacity(1);\n\t\t\t\t\t}\n\n\t\t\t\t\t_showOrHideTimeout = setTimeout(onComplete, duration + 20);\n\t\t\t\t} else {\n\n\t\t\t\t\t// \"out\" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position\n\t\t\t\t\tvar destZoomLevel = thumbBounds.w / item.w,\n\t\t\t\t\t\tinitialPanOffset = {\n\t\t\t\t\t\t\tx: _panOffset.x,\n\t\t\t\t\t\t\ty: _panOffset.y\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitialZoomLevel = _currZoomLevel,\n\t\t\t\t\t\tinitalBgOpacity = _bgOpacity,\n\t\t\t\t\t\tonUpdate = function(now) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(now === 1) {\n\t\t\t\t\t\t\t\t_currZoomLevel = destZoomLevel;\n\t\t\t\t\t\t\t\t_panOffset.x = thumbBounds.x;\n\t\t\t\t\t\t\t\t_panOffset.y = thumbBounds.y  - _currentWindowScrollY;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;\n\t\t\t\t\t\t\t\t_panOffset.x = (thumbBounds.x - initialPanOffset.x) * now + initialPanOffset.x;\n\t\t\t\t\t\t\t\t_panOffset.y = (thumbBounds.y - _currentWindowScrollY - initialPanOffset.y) * now + initialPanOffset.y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t_applyCurrentZoomPan();\n\t\t\t\t\t\t\tif(fadeEverything) {\n\t\t\t\t\t\t\t\ttemplate.style.opacity = 1 - now;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_applyBgOpacity( initalBgOpacity - now * initalBgOpacity );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\tif(closeWithRaf) {\n\t\t\t\t\t\t_animateProp('initialZoom', 0, 1, duration, framework.easing.cubic.out, onUpdate, onComplete);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonUpdate(1);\n\t\t\t\t\t\t_showOrHideTimeout = setTimeout(onComplete, duration + 20);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}, out ? 25 : 90); // Main purpose of this delay is to give browser time to paint and\n\t\t\t\t\t// create composite layers of PhotoSwipe UI parts (background, controls, caption, arrows).\n\t\t\t\t\t// Which avoids lag at the beginning of scale transition.\n\t\t};\n\t\tstartAnimation();\n\n\t\t\n\t};\n\n/*>>show-hide-transition*/\n\n/*>>items-controller*/\n/**\n*\n* Controller manages gallery items, their dimensions, and their content.\n* \n*/\n\nvar _items,\n\t_tempPanAreaSize = {},\n\t_imagesToAppendPool = [],\n\t_initialContentSet,\n\t_initialZoomRunning,\n\t_controllerDefaultOptions = {\n\t\tindex: 0,\n\t\terrorMsg: '<div class=\"pswp__error-msg\"><a href=\"%url%\" target=\"_blank\">The image</a> could not be loaded.</div>',\n\t\tforceProgressiveLoading: false, // TODO\n\t\tpreload: [1,1],\n\t\tgetNumItemsFn: function() {\n\t\t\treturn _items.length;\n\t\t}\n\t};\n\n\nvar _getItemAt,\n\t_getNumItems,\n\t_initialIsLoop,\n\t_getZeroBounds = function() {\n\t\treturn {\n\t\t\tcenter:{x:0,y:0}, \n\t\t\tmax:{x:0,y:0}, \n\t\t\tmin:{x:0,y:0}\n\t\t};\n\t},\n\t_calculateSingleItemPanBounds = function(item, realPanElementW, realPanElementH ) {\n\t\tvar bounds = item.bounds;\n\n\t\t// position of element when it's centered\n\t\tbounds.center.x = Math.round((_tempPanAreaSize.x - realPanElementW) / 2);\n\t\tbounds.center.y = Math.round((_tempPanAreaSize.y - realPanElementH) / 2) + item.vGap.top;\n\n\t\t// maximum pan position\n\t\tbounds.max.x = (realPanElementW > _tempPanAreaSize.x) ? \n\t\t\t\t\t\t\tMath.round(_tempPanAreaSize.x - realPanElementW) : \n\t\t\t\t\t\t\tbounds.center.x;\n\t\t\n\t\tbounds.max.y = (realPanElementH > _tempPanAreaSize.y) ? \n\t\t\t\t\t\t\tMath.round(_tempPanAreaSize.y - realPanElementH) + item.vGap.top : \n\t\t\t\t\t\t\tbounds.center.y;\n\t\t\n\t\t// minimum pan position\n\t\tbounds.min.x = (realPanElementW > _tempPanAreaSize.x) ? 0 : bounds.center.x;\n\t\tbounds.min.y = (realPanElementH > _tempPanAreaSize.y) ? item.vGap.top : bounds.center.y;\n\t},\n\t_calculateItemSize = function(item, viewportSize, zoomLevel) {\n\n\t\tif (item.src && !item.loadError) {\n\t\t\tvar isInitial = !zoomLevel;\n\t\t\t\n\t\t\tif(isInitial) {\n\t\t\t\tif(!item.vGap) {\n\t\t\t\t\titem.vGap = {top:0,bottom:0};\n\t\t\t\t}\n\t\t\t\t// allows overriding vertical margin for individual items\n\t\t\t\t_shout('parseVerticalMargin', item);\n\t\t\t}\n\n\n\t\t\t_tempPanAreaSize.x = viewportSize.x;\n\t\t\t_tempPanAreaSize.y = viewportSize.y - item.vGap.top - item.vGap.bottom;\n\n\t\t\tif (isInitial) {\n\t\t\t\tvar hRatio = _tempPanAreaSize.x / item.w;\n\t\t\t\tvar vRatio = _tempPanAreaSize.y / item.h;\n\n\t\t\t\titem.fitRatio = hRatio < vRatio ? hRatio : vRatio;\n\t\t\t\t//item.fillRatio = hRatio > vRatio ? hRatio : vRatio;\n\n\t\t\t\tvar scaleMode = _options.scaleMode;\n\n\t\t\t\tif (scaleMode === 'orig') {\n\t\t\t\t\tzoomLevel = 1;\n\t\t\t\t} else if (scaleMode === 'fit') {\n\t\t\t\t\tzoomLevel = item.fitRatio;\n\t\t\t\t}\n\n\t\t\t\tif (zoomLevel > 1) {\n\t\t\t\t\tzoomLevel = 1;\n\t\t\t\t}\n\n\t\t\t\titem.initialZoomLevel = zoomLevel;\n\t\t\t\t\n\t\t\t\tif(!item.bounds) {\n\t\t\t\t\t// reuse bounds object\n\t\t\t\t\titem.bounds = _getZeroBounds(); \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!zoomLevel) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_calculateSingleItemPanBounds(item, item.w * zoomLevel, item.h * zoomLevel);\n\n\t\t\tif (isInitial && zoomLevel === item.initialZoomLevel) {\n\t\t\t\titem.initialPosition = item.bounds.center;\n\t\t\t}\n\n\t\t\treturn item.bounds;\n\t\t} else {\n\t\t\titem.w = item.h = 0;\n\t\t\titem.initialZoomLevel = item.fitRatio = 1;\n\t\t\titem.bounds = _getZeroBounds();\n\t\t\titem.initialPosition = item.bounds.center;\n\n\t\t\t// if it's not image, we return zero bounds (content is not zoomable)\n\t\t\treturn item.bounds;\n\t\t}\n\t\t\n\t},\n\n\t\n\n\n\t_appendImage = function(index, item, baseDiv, img, preventAnimation, keepPlaceholder) {\n\t\t\n\n\t\tif(item.loadError) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(img) {\n\n\t\t\titem.imageAppended = true;\n\t\t\t_setImageSize(item, img, (item === self.currItem && _renderMaxResolution) );\n\t\t\t\n\t\t\tbaseDiv.appendChild(img);\n\n\t\t\tif(keepPlaceholder) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif(item && item.loaded && item.placeholder) {\n\t\t\t\t\t\titem.placeholder.style.display = 'none';\n\t\t\t\t\t\titem.placeholder = null;\n\t\t\t\t\t}\n\t\t\t\t}, 500);\n\t\t\t}\n\t\t}\n\t},\n\t\n\n\n\t_preloadImage = function(item) {\n\t\titem.loading = true;\n\t\titem.loaded = false;\n\t\tvar img = item.img = framework.createEl('pswp__img', 'img');\n\t\tvar onComplete = function() {\n\t\t\titem.loading = false;\n\t\t\titem.loaded = true;\n\n\t\t\tif(item.loadComplete) {\n\t\t\t\titem.loadComplete(item);\n\t\t\t} else {\n\t\t\t\titem.img = null; // no need to store image object\n\t\t\t}\n\t\t\timg.onload = img.onerror = null;\n\t\t\timg = null;\n\t\t};\n\t\timg.onload = onComplete;\n\t\timg.onerror = function() {\n\t\t\titem.loadError = true;\n\t\t\tonComplete();\n\t\t};\t\t\n\n\t\timg.src = item.src;// + '?a=' + Math.random();\n\n\t\treturn img;\n\t},\n\t_checkForError = function(item, cleanUp) {\n\t\tif(item.src && item.loadError && item.container) {\n\n\t\t\tif(cleanUp) {\n\t\t\t\titem.container.innerHTML = '';\n\t\t\t}\n\n\t\t\titem.container.innerHTML = _options.errorMsg.replace('%url%',  item.src );\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t},\n\t_setImageSize = function(item, img, maxRes) {\n\t\tif(!item.src) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(!img) {\n\t\t\timg = item.container.lastChild;\n\t\t}\n\n\t\tvar w = maxRes ? item.w : Math.round(item.w * item.fitRatio),\n\t\t\th = maxRes ? item.h : Math.round(item.h * item.fitRatio);\n\t\t\n\t\tif(item.placeholder && !item.loaded) {\n\t\t\titem.placeholder.style.width = w + 'px';\n\t\t\titem.placeholder.style.height = h + 'px';\n\t\t}\n\n\t\timg.style.width = w + 'px';\n\t\timg.style.height = h + 'px';\n\t},\n\t_appendImagesPool = function() {\n\n\t\tif(_imagesToAppendPool.length) {\n\t\t\tvar poolItem;\n\n\t\t\tfor(var i = 0; i < _imagesToAppendPool.length; i++) {\n\t\t\t\tpoolItem = _imagesToAppendPool[i];\n\t\t\t\tif( poolItem.holder.index === poolItem.index ) {\n\t\t\t\t\t_appendImage(poolItem.index, poolItem.item, poolItem.baseDiv, poolItem.img, false, poolItem.clearPlaceholder);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_imagesToAppendPool = [];\n\t\t}\n\t};\n\t\n\n\n_registerModule('Controller', {\n\n\tpublicMethods: {\n\n\t\tlazyLoadItem: function(index) {\n\t\t\tindex = _getLoopedId(index);\n\t\t\tvar item = _getItemAt(index);\n\n\t\t\tif(!item || ((item.loaded || item.loading) && !_itemsNeedUpdate)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_shout('gettingData', index, item);\n\n\t\t\tif (!item.src) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_preloadImage(item);\n\t\t},\n\t\tinitController: function() {\n\t\t\tframework.extend(_options, _controllerDefaultOptions, true);\n\t\t\tself.items = _items = items;\n\t\t\t_getItemAt = self.getItemAt;\n\t\t\t_getNumItems = _options.getNumItemsFn; //self.getNumItems;\n\n\n\n\t\t\t_initialIsLoop = _options.loop;\n\t\t\tif(_getNumItems() < 3) {\n\t\t\t\t_options.loop = false; // disable loop if less then 3 items\n\t\t\t}\n\n\t\t\t_listen('beforeChange', function(diff) {\n\n\t\t\t\tvar p = _options.preload,\n\t\t\t\t\tisNext = diff === null ? true : (diff >= 0),\n\t\t\t\t\tpreloadBefore = Math.min(p[0], _getNumItems() ),\n\t\t\t\t\tpreloadAfter = Math.min(p[1], _getNumItems() ),\n\t\t\t\t\ti;\n\n\n\t\t\t\tfor(i = 1; i <= (isNext ? preloadAfter : preloadBefore); i++) {\n\t\t\t\t\tself.lazyLoadItem(_currentItemIndex+i);\n\t\t\t\t}\n\t\t\t\tfor(i = 1; i <= (isNext ? preloadBefore : preloadAfter); i++) {\n\t\t\t\t\tself.lazyLoadItem(_currentItemIndex-i);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_listen('initialLayout', function() {\n\t\t\t\tself.currItem.initialLayout = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);\n\t\t\t});\n\n\t\t\t_listen('mainScrollAnimComplete', _appendImagesPool);\n\t\t\t_listen('initialZoomInEnd', _appendImagesPool);\n\n\n\n\t\t\t_listen('destroy', function() {\n\t\t\t\tvar item;\n\t\t\t\tfor(var i = 0; i < _items.length; i++) {\n\t\t\t\t\titem = _items[i];\n\t\t\t\t\t// remove reference to DOM elements, for GC\n\t\t\t\t\tif(item.container) {\n\t\t\t\t\t\titem.container = null; \n\t\t\t\t\t}\n\t\t\t\t\tif(item.placeholder) {\n\t\t\t\t\t\titem.placeholder = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(item.img) {\n\t\t\t\t\t\titem.img = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(item.preloader) {\n\t\t\t\t\t\titem.preloader = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(item.loadError) {\n\t\t\t\t\t\titem.loaded = item.loadError = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_imagesToAppendPool = null;\n\t\t\t});\n\t\t},\n\n\n\t\tgetItemAt: function(index) {\n\t\t\tif (index >= 0) {\n\t\t\t\treturn _items[index] !== undefined ? _items[index] : false;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tallowProgressiveImg: function() {\n\t\t\t// 1. Progressive image loading isn't working on webkit/blink \n\t\t\t//    when hw-acceleration (e.g. translateZ) is applied to IMG element.\n\t\t\t//    That's why in PhotoSwipe parent element gets zoom transform, not image itself.\n\t\t\t//    \n\t\t\t// 2. Progressive image loading sometimes blinks in webkit/blink when applying animation to parent element.\n\t\t\t//    That's why it's disabled on touch devices (mainly because of swipe transition)\n\t\t\t//    \n\t\t\t// 3. Progressive image loading sometimes doesn't work in IE (up to 11).\n\n\t\t\t// Don't allow progressive loading on non-large touch devices\n\t\t\treturn _options.forceProgressiveLoading || !_likelyTouchDevice || _options.mouseUsed || screen.width > 1200; \n\t\t\t// 1200 - to eliminate touch devices with large screen (like Chromebook Pixel)\n\t\t},\n\n\t\tsetContent: function(holder, index) {\n\n\t\t\tif(_options.loop) {\n\t\t\t\tindex = _getLoopedId(index);\n\t\t\t}\n\n\t\t\tvar prevItem = self.getItemAt(holder.index);\n\t\t\tif(prevItem) {\n\t\t\t\tprevItem.container = null;\n\t\t\t}\n\t\n\t\t\tvar item = self.getItemAt(index),\n\t\t\t\timg;\n\t\t\t\n\t\t\tif(!item) {\n\t\t\t\tholder.el.innerHTML = '';\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// allow to override data\n\t\t\t_shout('gettingData', index, item);\n\n\t\t\tholder.index = index;\n\t\t\tholder.item = item;\n\n\t\t\t// base container DIV is created only once for each of 3 holders\n\t\t\tvar baseDiv = item.container = framework.createEl('pswp__zoom-wrap'); \n\n\t\t\t\n\n\t\t\tif(!item.src && item.html) {\n\t\t\t\tif(item.html.tagName) {\n\t\t\t\t\tbaseDiv.appendChild(item.html);\n\t\t\t\t} else {\n\t\t\t\t\tbaseDiv.innerHTML = item.html;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkForError(item);\n\n\t\t\t_calculateItemSize(item, _viewportSize);\n\t\t\t\n\t\t\tif(item.src && !item.loadError && !item.loaded) {\n\n\t\t\t\titem.loadComplete = function(item) {\n\n\t\t\t\t\t// gallery closed before image finished loading\n\t\t\t\t\tif(!_isOpen) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if holder hasn't changed while image was loading\n\t\t\t\t\tif(holder && holder.index === index ) {\n\t\t\t\t\t\tif( _checkForError(item, true) ) {\n\t\t\t\t\t\t\titem.loadComplete = item.img = null;\n\t\t\t\t\t\t\t_calculateItemSize(item, _viewportSize);\n\t\t\t\t\t\t\t_applyZoomPanToItem(item);\n\n\t\t\t\t\t\t\tif(holder.index === _currentItemIndex) {\n\t\t\t\t\t\t\t\t// recalculate dimensions\n\t\t\t\t\t\t\t\tself.updateCurrZoomItem();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( !item.imageAppended ) {\n\t\t\t\t\t\t\tif(_features.transform && (_mainScrollAnimating || _initialZoomRunning) ) {\n\t\t\t\t\t\t\t\t_imagesToAppendPool.push({\n\t\t\t\t\t\t\t\t\titem:item,\n\t\t\t\t\t\t\t\t\tbaseDiv:baseDiv,\n\t\t\t\t\t\t\t\t\timg:item.img,\n\t\t\t\t\t\t\t\t\tindex:index,\n\t\t\t\t\t\t\t\t\tholder:holder,\n\t\t\t\t\t\t\t\t\tclearPlaceholder:true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_appendImage(index, item, baseDiv, item.img, _mainScrollAnimating || _initialZoomRunning, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// remove preloader & mini-img\n\t\t\t\t\t\t\tif(!_initialZoomRunning && item.placeholder) {\n\t\t\t\t\t\t\t\titem.placeholder.style.display = 'none';\n\t\t\t\t\t\t\t\titem.placeholder = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\titem.loadComplete = null;\n\t\t\t\t\titem.img = null; // no need to store image element after it's added\n\n\t\t\t\t\t_shout('imageLoadComplete', index, item);\n\t\t\t\t};\n\n\t\t\t\tif(framework.features.transform) {\n\t\t\t\t\t\n\t\t\t\t\tvar placeholderClassName = 'pswp__img pswp__img--placeholder'; \n\t\t\t\t\tplaceholderClassName += (item.msrc ? '' : ' pswp__img--placeholder--blank');\n\n\t\t\t\t\tvar placeholder = framework.createEl(placeholderClassName, item.msrc ? 'img' : '');\n\t\t\t\t\tif(item.msrc) {\n\t\t\t\t\t\tplaceholder.src = item.msrc;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_setImageSize(item, placeholder);\n\n\t\t\t\t\tbaseDiv.appendChild(placeholder);\n\t\t\t\t\titem.placeholder = placeholder;\n\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t\n\n\t\t\t\tif(!item.loading) {\n\t\t\t\t\t_preloadImage(item);\n\t\t\t\t}\n\n\n\t\t\t\tif( self.allowProgressiveImg() ) {\n\t\t\t\t\t// just append image\n\t\t\t\t\tif(!_initialContentSet && _features.transform) {\n\t\t\t\t\t\t_imagesToAppendPool.push({\n\t\t\t\t\t\t\titem:item, \n\t\t\t\t\t\t\tbaseDiv:baseDiv, \n\t\t\t\t\t\t\timg:item.img, \n\t\t\t\t\t\t\tindex:index, \n\t\t\t\t\t\t\tholder:holder\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_appendImage(index, item, baseDiv, item.img, true, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(item.src && !item.loadError) {\n\t\t\t\t// image object is created every time, due to bugs of image loading & delay when switching images\n\t\t\t\timg = framework.createEl('pswp__img', 'img');\n\t\t\t\timg.style.opacity = 1;\n\t\t\t\timg.src = item.src;\n\t\t\t\t_setImageSize(item, img);\n\t\t\t\t_appendImage(index, item, baseDiv, img, true);\n\t\t\t}\n\t\t\t\n\n\t\t\tif(!_initialContentSet && index === _currentItemIndex) {\n\t\t\t\t_currZoomElementStyle = baseDiv.style;\n\t\t\t\t_showOrHide(item, (img ||item.img) );\n\t\t\t} else {\n\t\t\t\t_applyZoomPanToItem(item);\n\t\t\t}\n\n\t\t\tholder.el.innerHTML = '';\n\t\t\tholder.el.appendChild(baseDiv);\n\t\t},\n\n\t\tcleanSlide: function( item ) {\n\t\t\tif(item.img ) {\n\t\t\t\titem.img.onload = item.img.onerror = null;\n\t\t\t}\n\t\t\titem.loaded = item.loading = item.img = item.imageAppended = false;\n\t\t}\n\n\t}\n});\n\n/*>>items-controller*/\n\n/*>>tap*/\n/**\n * tap.js:\n *\n * Displatches tap and double-tap events.\n * \n */\n\nvar tapTimer,\n\ttapReleasePoint = {},\n\t_dispatchTapEvent = function(origEvent, releasePoint, pointerType) {\t\t\n\t\tvar e = document.createEvent( 'CustomEvent' ),\n\t\t\teDetail = {\n\t\t\t\torigEvent:origEvent, \n\t\t\t\ttarget:origEvent.target, \n\t\t\t\treleasePoint: releasePoint, \n\t\t\t\tpointerType:pointerType || 'touch'\n\t\t\t};\n\n\t\te.initCustomEvent( 'pswpTap', true, true, eDetail );\n\t\torigEvent.target.dispatchEvent(e);\n\t};\n\n_registerModule('Tap', {\n\tpublicMethods: {\n\t\tinitTap: function() {\n\t\t\t_listen('firstTouchStart', self.onTapStart);\n\t\t\t_listen('touchRelease', self.onTapRelease);\n\t\t\t_listen('destroy', function() {\n\t\t\t\ttapReleasePoint = {};\n\t\t\t\ttapTimer = null;\n\t\t\t});\n\t\t},\n\t\tonTapStart: function(touchList) {\n\t\t\tif(touchList.length > 1) {\n\t\t\t\tclearTimeout(tapTimer);\n\t\t\t\ttapTimer = null;\n\t\t\t}\n\t\t},\n\t\tonTapRelease: function(e, releasePoint) {\n\t\t\tif(!releasePoint) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(!_moved && !_isMultitouch && !_numAnimations) {\n\t\t\t\tvar p0 = releasePoint;\n\t\t\t\tif(tapTimer) {\n\t\t\t\t\tclearTimeout(tapTimer);\n\t\t\t\t\ttapTimer = null;\n\n\t\t\t\t\t// Check if taped on the same place\n\t\t\t\t\tif ( _isNearbyPoints(p0, tapReleasePoint) ) {\n\t\t\t\t\t\t_shout('doubleTap', p0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(releasePoint.type === 'mouse') {\n\t\t\t\t\t_dispatchTapEvent(e, releasePoint, 'mouse');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar clickedTagName = e.target.tagName.toUpperCase();\n\t\t\t\t// avoid double tap delay on buttons and elements that have class pswp__single-tap\n\t\t\t\tif(clickedTagName === 'BUTTON' || framework.hasClass(e.target, 'pswp__single-tap') ) {\n\t\t\t\t\t_dispatchTapEvent(e, releasePoint);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_equalizePoints(tapReleasePoint, p0);\n\n\t\t\t\ttapTimer = setTimeout(function() {\n\t\t\t\t\t_dispatchTapEvent(e, releasePoint);\n\t\t\t\t\ttapTimer = null;\n\t\t\t\t}, 300);\n\t\t\t}\n\t\t}\n\t}\n});\n\n/*>>tap*/\n\n/*>>desktop-zoom*/\n/**\n *\n * desktop-zoom.js:\n *\n * - Binds mousewheel event for paning zoomed image.\n * - Manages \"dragging\", \"zoomed-in\", \"zoom-out\" classes.\n *   (which are used for cursors and zoom icon)\n * - Adds toggleDesktopZoom function.\n * \n */\n\nvar _wheelDelta;\n\t\n_registerModule('DesktopZoom', {\n\n\tpublicMethods: {\n\n\t\tinitDesktopZoom: function() {\n\n\t\t\tif(_oldIE) {\n\t\t\t\t// no zoom for old IE (<=8)\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(_likelyTouchDevice) {\n\t\t\t\t// if detected hardware touch support, we wait until mouse is used,\n\t\t\t\t// and only then apply desktop-zoom features\n\t\t\t\t_listen('mouseUsed', function() {\n\t\t\t\t\tself.setupDesktopZoom();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tself.setupDesktopZoom(true);\n\t\t\t}\n\n\t\t},\n\n\t\tsetupDesktopZoom: function(onInit) {\n\n\t\t\t_wheelDelta = {};\n\n\t\t\tvar events = 'wheel mousewheel DOMMouseScroll';\n\t\t\t\n\t\t\t_listen('bindEvents', function() {\n\t\t\t\tframework.bind(template, events,  self.handleMouseWheel);\n\t\t\t});\n\n\t\t\t_listen('unbindEvents', function() {\n\t\t\t\tif(_wheelDelta) {\n\t\t\t\t\tframework.unbind(template, events, self.handleMouseWheel);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tself.mouseZoomedIn = false;\n\n\t\t\tvar hasDraggingClass,\n\t\t\t\tupdateZoomable = function() {\n\t\t\t\t\tif(self.mouseZoomedIn) {\n\t\t\t\t\t\tframework.removeClass(template, 'pswp--zoomed-in');\n\t\t\t\t\t\tself.mouseZoomedIn = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(_currZoomLevel < 1) {\n\t\t\t\t\t\tframework.addClass(template, 'pswp--zoom-allowed');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tframework.removeClass(template, 'pswp--zoom-allowed');\n\t\t\t\t\t}\n\t\t\t\t\tremoveDraggingClass();\n\t\t\t\t},\n\t\t\t\tremoveDraggingClass = function() {\n\t\t\t\t\tif(hasDraggingClass) {\n\t\t\t\t\t\tframework.removeClass(template, 'pswp--dragging');\n\t\t\t\t\t\thasDraggingClass = false;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t_listen('resize' , updateZoomable);\n\t\t\t_listen('afterChange' , updateZoomable);\n\t\t\t_listen('pointerDown', function() {\n\t\t\t\tif(self.mouseZoomedIn) {\n\t\t\t\t\thasDraggingClass = true;\n\t\t\t\t\tframework.addClass(template, 'pswp--dragging');\n\t\t\t\t}\n\t\t\t});\n\t\t\t_listen('pointerUp', removeDraggingClass);\n\n\t\t\tif(!onInit) {\n\t\t\t\tupdateZoomable();\n\t\t\t}\n\t\t\t\n\t\t},\n\n\t\thandleMouseWheel: function(e) {\n\n\t\t\tif(_currZoomLevel <= self.currItem.fitRatio) {\n\t\t\t\tif( _options.modal ) {\n\n\t\t\t\t\tif (!_options.closeOnScroll || _numAnimations || _isDragging) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t} else if(_transformKey && Math.abs(e.deltaY) > 2) {\n\t\t\t\t\t\t// close PhotoSwipe\n\t\t\t\t\t\t// if browser supports transforms & scroll changed enough\n\t\t\t\t\t\t_closedByScroll = true;\n\t\t\t\t\t\tself.close();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// allow just one event to fire\n\t\t\te.stopPropagation();\n\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n\t\t\t_wheelDelta.x = 0;\n\n\t\t\tif('deltaX' in e) {\n\t\t\t\tif(e.deltaMode === 1 /* DOM_DELTA_LINE */) {\n\t\t\t\t\t// 18 - average line height\n\t\t\t\t\t_wheelDelta.x = e.deltaX * 18;\n\t\t\t\t\t_wheelDelta.y = e.deltaY * 18;\n\t\t\t\t} else {\n\t\t\t\t\t_wheelDelta.x = e.deltaX;\n\t\t\t\t\t_wheelDelta.y = e.deltaY;\n\t\t\t\t}\n\t\t\t} else if('wheelDelta' in e) {\n\t\t\t\tif(e.wheelDeltaX) {\n\t\t\t\t\t_wheelDelta.x = -0.16 * e.wheelDeltaX;\n\t\t\t\t}\n\t\t\t\tif(e.wheelDeltaY) {\n\t\t\t\t\t_wheelDelta.y = -0.16 * e.wheelDeltaY;\n\t\t\t\t} else {\n\t\t\t\t\t_wheelDelta.y = -0.16 * e.wheelDelta;\n\t\t\t\t}\n\t\t\t} else if('detail' in e) {\n\t\t\t\t_wheelDelta.y = e.detail;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_calculatePanBounds(_currZoomLevel, true);\n\n\t\t\tvar newPanX = _panOffset.x - _wheelDelta.x,\n\t\t\t\tnewPanY = _panOffset.y - _wheelDelta.y;\n\n\t\t\t// only prevent scrolling in nonmodal mode when not at edges\n\t\t\tif (_options.modal ||\n\t\t\t\t(\n\t\t\t\tnewPanX <= _currPanBounds.min.x && newPanX >= _currPanBounds.max.x &&\n\t\t\t\tnewPanY <= _currPanBounds.min.y && newPanY >= _currPanBounds.max.y\n\t\t\t\t) ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\n\t\t\t// TODO: use rAF instead of mousewheel?\n\t\t\tself.panTo(newPanX, newPanY);\n\t\t},\n\n\t\ttoggleDesktopZoom: function(centerPoint) {\n\t\t\tcenterPoint = centerPoint || {x:_viewportSize.x/2 + _offset.x, y:_viewportSize.y/2 + _offset.y };\n\n\t\t\tvar doubleTapZoomLevel = _options.getDoubleTapZoom(true, self.currItem);\n\t\t\tvar zoomOut = _currZoomLevel === doubleTapZoomLevel;\n\t\t\t\n\t\t\tself.mouseZoomedIn = !zoomOut;\n\n\t\t\tself.zoomTo(zoomOut ? self.currItem.initialZoomLevel : doubleTapZoomLevel, centerPoint, 333);\n\t\t\tframework[ (!zoomOut ? 'add' : 'remove') + 'Class'](template, 'pswp--zoomed-in');\n\t\t}\n\n\t}\n});\n\n\n/*>>desktop-zoom*/\n\n/*>>history*/\n/**\n *\n * history.js:\n *\n * - Back button to close gallery.\n * \n * - Unique URL for each slide: example.com/&pid=1&gid=3\n *   (where PID is picture index, and GID and gallery index)\n *   \n * - Switch URL when slides change.\n * \n */\n\n\nvar _historyDefaultOptions = {\n\thistory: true,\n\tgalleryUID: 1\n};\n\nvar _historyUpdateTimeout,\n\t_hashChangeTimeout,\n\t_hashAnimCheckTimeout,\n\t_hashChangedByScript,\n\t_hashChangedByHistory,\n\t_hashReseted,\n\t_initialHash,\n\t_historyChanged,\n\t_closedFromURL,\n\t_urlChangedOnce,\n\t_windowLoc,\n\n\t_supportsPushState,\n\n\t_getHash = function() {\n\t\treturn _windowLoc.hash.substring(1);\n\t},\n\t_cleanHistoryTimeouts = function() {\n\n\t\tif(_historyUpdateTimeout) {\n\t\t\tclearTimeout(_historyUpdateTimeout);\n\t\t}\n\n\t\tif(_hashAnimCheckTimeout) {\n\t\t\tclearTimeout(_hashAnimCheckTimeout);\n\t\t}\n\t},\n\n\t// pid - Picture index\n\t// gid - Gallery index\n\t_parseItemIndexFromURL = function() {\n\t\tvar hash = _getHash(),\n\t\t\tparams = {};\n\n\t\tif(hash.length < 5) { // pid=1\n\t\t\treturn params;\n\t\t}\n\n\t\tvar i, vars = hash.split('&');\n\t\tfor (i = 0; i < vars.length; i++) {\n\t\t\tif(!vars[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar pair = vars[i].split('=');\t\n\t\t\tif(pair.length < 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparams[pair[0]] = pair[1];\n\t\t}\n\t\tif(_options.galleryPIDs) {\n\t\t\t// detect custom pid in hash and search for it among the items collection\n\t\t\tvar searchfor = params.pid;\n\t\t\tparams.pid = 0; // if custom pid cannot be found, fallback to the first item\n\t\t\tfor(i = 0; i < _items.length; i++) {\n\t\t\t\tif(_items[i].pid === searchfor) {\n\t\t\t\t\tparams.pid = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tparams.pid = parseInt(params.pid,10)-1;\n\t\t}\n\t\tif( params.pid < 0 ) {\n\t\t\tparams.pid = 0;\n\t\t}\n\t\treturn params;\n\t},\n\t_updateHash = function() {\n\n\t\tif(_hashAnimCheckTimeout) {\n\t\t\tclearTimeout(_hashAnimCheckTimeout);\n\t\t}\n\n\n\t\tif(_numAnimations || _isDragging) {\n\t\t\t// changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation\n\t\t\t// that's why we update hash only when no animations running\n\t\t\t_hashAnimCheckTimeout = setTimeout(_updateHash, 500);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(_hashChangedByScript) {\n\t\t\tclearTimeout(_hashChangeTimeout);\n\t\t} else {\n\t\t\t_hashChangedByScript = true;\n\t\t}\n\n\n\t\tvar pid = (_currentItemIndex + 1);\n\t\tvar item = _getItemAt( _currentItemIndex );\n\t\tif(item.hasOwnProperty('pid')) {\n\t\t\t// carry forward any custom pid assigned to the item\n\t\t\tpid = item.pid;\n\t\t}\n\t\tvar newHash = _initialHash + '&'  +  'gid=' + _options.galleryUID + '&' + 'pid=' + pid;\n\n\t\tif(!_historyChanged) {\n\t\t\tif(_windowLoc.hash.indexOf(newHash) === -1) {\n\t\t\t\t_urlChangedOnce = true;\n\t\t\t}\n\t\t\t// first time - add new hisory record, then just replace\n\t\t}\n\n\t\tvar newURL = _windowLoc.href.split('#')[0] + '#' +  newHash;\n\n\t\tif( _supportsPushState ) {\n\n\t\t\tif('#' + newHash !== window.location.hash) {\n\t\t\t\thistory[_historyChanged ? 'replaceState' : 'pushState']('', document.title, newURL);\n\t\t\t}\n\n\t\t} else {\n\t\t\tif(_historyChanged) {\n\t\t\t\t_windowLoc.replace( newURL );\n\t\t\t} else {\n\t\t\t\t_windowLoc.hash = newHash;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t\t_historyChanged = true;\n\t\t_hashChangeTimeout = setTimeout(function() {\n\t\t\t_hashChangedByScript = false;\n\t\t}, 60);\n\t};\n\n\n\n\t\n\n_registerModule('History', {\n\n\t\n\n\tpublicMethods: {\n\t\tinitHistory: function() {\n\n\t\t\tframework.extend(_options, _historyDefaultOptions, true);\n\n\t\t\tif( !_options.history ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\t_windowLoc = window.location;\n\t\t\t_urlChangedOnce = false;\n\t\t\t_closedFromURL = false;\n\t\t\t_historyChanged = false;\n\t\t\t_initialHash = _getHash();\n\t\t\t_supportsPushState = ('pushState' in history);\n\n\n\t\t\tif(_initialHash.indexOf('gid=') > -1) {\n\t\t\t\t_initialHash = _initialHash.split('&gid=')[0];\n\t\t\t\t_initialHash = _initialHash.split('?gid=')[0];\n\t\t\t}\n\t\t\t\n\n\t\t\t_listen('afterChange', self.updateURL);\n\t\t\t_listen('unbindEvents', function() {\n\t\t\t\tframework.unbind(window, 'hashchange', self.onHashChange);\n\t\t\t});\n\n\n\t\t\tvar returnToOriginal = function() {\n\t\t\t\t_hashReseted = true;\n\t\t\t\tif(!_closedFromURL) {\n\n\t\t\t\t\tif(_urlChangedOnce) {\n\t\t\t\t\t\thistory.back();\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif(_initialHash) {\n\t\t\t\t\t\t\t_windowLoc.hash = _initialHash;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (_supportsPushState) {\n\n\t\t\t\t\t\t\t\t// remove hash from url without refreshing it or scrolling to top\n\t\t\t\t\t\t\t\thistory.pushState('', document.title,  _windowLoc.pathname + _windowLoc.search );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_windowLoc.hash = '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t_cleanHistoryTimeouts();\n\t\t\t};\n\n\n\t\t\t_listen('unbindEvents', function() {\n\t\t\t\tif(_closedByScroll) {\n\t\t\t\t\t// if PhotoSwipe is closed by scroll, we go \"back\" before the closing animation starts\n\t\t\t\t\t// this is done to keep the scroll position\n\t\t\t\t\treturnToOriginal();\n\t\t\t\t}\n\t\t\t});\n\t\t\t_listen('destroy', function() {\n\t\t\t\tif(!_hashReseted) {\n\t\t\t\t\treturnToOriginal();\n\t\t\t\t}\n\t\t\t});\n\t\t\t_listen('firstUpdate', function() {\n\t\t\t\t_currentItemIndex = _parseItemIndexFromURL().pid;\n\t\t\t});\n\n\t\t\t\n\n\t\t\t\n\t\t\tvar index = _initialHash.indexOf('pid=');\n\t\t\tif(index > -1) {\n\t\t\t\t_initialHash = _initialHash.substring(0, index);\n\t\t\t\tif(_initialHash.slice(-1) === '&') {\n\t\t\t\t\t_initialHash = _initialHash.slice(0, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\tsetTimeout(function() {\n\t\t\t\tif(_isOpen) { // hasn't destroyed yet\n\t\t\t\t\tframework.bind(window, 'hashchange', self.onHashChange);\n\t\t\t\t}\n\t\t\t}, 40);\n\t\t\t\n\t\t},\n\t\tonHashChange: function() {\n\n\t\t\tif(_getHash() === _initialHash) {\n\n\t\t\t\t_closedFromURL = true;\n\t\t\t\tself.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!_hashChangedByScript) {\n\n\t\t\t\t_hashChangedByHistory = true;\n\t\t\t\tself.goTo( _parseItemIndexFromURL().pid );\n\t\t\t\t_hashChangedByHistory = false;\n\t\t\t}\n\t\t\t\n\t\t},\n\t\tupdateURL: function() {\n\n\t\t\t// Delay the update of URL, to avoid lag during transition, \n\t\t\t// and to not to trigger actions like \"refresh page sound\" or \"blinking favicon\" to often\n\t\t\t\n\t\t\t_cleanHistoryTimeouts();\n\t\t\t\n\n\t\t\tif(_hashChangedByHistory) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(!_historyChanged) {\n\t\t\t\t_updateHash(); // first time\n\t\t\t} else {\n\t\t\t\t_historyUpdateTimeout = setTimeout(_updateHash, 800);\n\t\t\t}\n\t\t}\n\t\n\t}\n});\n\n\n/*>>history*/\n\tframework.extend(self, publicMethods); };\n\treturn PhotoSwipe;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhvdG9zd2lwZS9kaXN0L3Bob3Rvc3dpcGUuanM/YjI0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDJCO0FBQ0EsS0FBSyxJQUEwQztBQUMvQyxFQUFFLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNqQixFQUFFLE1BQU0sRUFJTjtBQUNGLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLDRGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFdBQVc7QUFDM0M7QUFDQTs7QUFFQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSw2Q0FBNkM7QUFDN0MsSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxpQztBQUNBLFVBQVUsUztBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsaUU7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSwyQztBQUNBO0FBQ0EsR0FB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O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRztBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsS0FBSztBQUNMLHFCQUFxQjtBQUNyQixLO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSixpRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBLGtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsUUFBUSxRQUFRO0FBQ2hCLFFBQVE7QUFDUjtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7Ozs7QUFLRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEk7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7OztBQUl6QztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGNBQWMsOENBQThDO0FBQzVEO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsNEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0c7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0U7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7O0FBRUEsbUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLHFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7OztBQU1BOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOzs7OztBQUtKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsSUFBSTs7QUFFSixHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGhvdG9zd2lwZS9kaXN0L3Bob3Rvc3dpcGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgUGhvdG9Td2lwZSAtIHY0LjEuMyAtIDIwMTktMDEtMDhcbiogaHR0cDovL3Bob3Rvc3dpcGUuY29tXG4qIENvcHlyaWdodCAoYykgMjAxOSBEbWl0cnkgU2VtZW5vdjsgKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkgeyBcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHRyb290LlBob3RvU3dpcGUgPSBmYWN0b3J5KCk7XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciBQaG90b1N3aXBlID0gZnVuY3Rpb24odGVtcGxhdGUsIFVpQ2xhc3MsIGl0ZW1zLCBvcHRpb25zKXtcblxuLyo+PmZyYW1ld29yay1icmlkZ2UqL1xuLyoqXG4gKlxuICogU2V0IG9mIGdlbmVyaWMgZnVuY3Rpb25zIHVzZWQgYnkgZ2FsbGVyeS5cbiAqIFxuICogWW91J3JlIGZyZWUgdG8gbW9kaWZ5IGFueXRoaW5nIGhlcmUgYXMgbG9uZyBhcyBmdW5jdGlvbmFsaXR5IGlzIGtlcHQuXG4gKiBcbiAqL1xudmFyIGZyYW1ld29yayA9IHtcblx0ZmVhdHVyZXM6IG51bGwsXG5cdGJpbmQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHVuYmluZCkge1xuXHRcdHZhciBtZXRob2ROYW1lID0gKHVuYmluZCA/ICdyZW1vdmUnIDogJ2FkZCcpICsgJ0V2ZW50TGlzdGVuZXInO1xuXHRcdHR5cGUgPSB0eXBlLnNwbGl0KCcgJyk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmKHR5cGVbaV0pIHtcblx0XHRcdFx0dGFyZ2V0W21ldGhvZE5hbWVdKCB0eXBlW2ldLCBsaXN0ZW5lciwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aXNBcnJheTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0cmV0dXJuIChvYmogaW5zdGFuY2VvZiBBcnJheSk7XG5cdH0sXG5cdGNyZWF0ZUVsOiBmdW5jdGlvbihjbGFzc2VzLCB0YWcpIHtcblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyB8fCAnZGl2Jyk7XG5cdFx0aWYoY2xhc3Nlcykge1xuXHRcdFx0ZWwuY2xhc3NOYW1lID0gY2xhc3Nlcztcblx0XHR9XG5cdFx0cmV0dXJuIGVsO1xuXHR9LFxuXHRnZXRTY3JvbGxZOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgeU9mZnNldCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcblx0XHRyZXR1cm4geU9mZnNldCAhPT0gdW5kZWZpbmVkID8geU9mZnNldCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdGZyYW1ld29yay5iaW5kKHRhcmdldCx0eXBlLGxpc3RlbmVyLHRydWUpO1xuXHR9LFxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xuXHRcdHZhciByZWcgPSBuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpO1xuXHRcdGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKS5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTsgXG5cdH0sXG5cdGFkZENsYXNzOiBmdW5jdGlvbihlbCwgY2xhc3NOYW1lKSB7XG5cdFx0aWYoICFmcmFtZXdvcmsuaGFzQ2xhc3MoZWwsY2xhc3NOYW1lKSApIHtcblx0XHRcdGVsLmNsYXNzTmFtZSArPSAoZWwuY2xhc3NOYW1lID8gJyAnIDogJycpICsgY2xhc3NOYW1lO1xuXHRcdH1cblx0fSxcblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcblx0XHRyZXR1cm4gZWwuY2xhc3NOYW1lICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKFxcXFxzfCQpJykudGVzdChlbC5jbGFzc05hbWUpO1xuXHR9LFxuXHRnZXRDaGlsZEJ5Q2xhc3M6IGZ1bmN0aW9uKHBhcmVudEVsLCBjaGlsZENsYXNzTmFtZSkge1xuXHRcdHZhciBub2RlID0gcGFyZW50RWwuZmlyc3RDaGlsZDtcblx0XHR3aGlsZShub2RlKSB7XG5cdFx0XHRpZiggZnJhbWV3b3JrLmhhc0NsYXNzKG5vZGUsIGNoaWxkQ2xhc3NOYW1lKSApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gbm9kZS5uZXh0U2libGluZztcblx0XHR9XG5cdH0sXG5cdGFycmF5U2VhcmNoOiBmdW5jdGlvbihhcnJheSwgdmFsdWUsIGtleSkge1xuXHRcdHZhciBpID0gYXJyYXkubGVuZ3RoO1xuXHRcdHdoaWxlKGktLSkge1xuXHRcdFx0aWYoYXJyYXlbaV1ba2V5XSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9IFxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cdGV4dGVuZDogZnVuY3Rpb24obzEsIG8yLCBwcmV2ZW50T3ZlcndyaXRlKSB7XG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBvMikge1xuXHRcdFx0aWYgKG8yLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdGlmKHByZXZlbnRPdmVyd3JpdGUgJiYgbzEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvMVtwcm9wXSA9IG8yW3Byb3BdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZWFzaW5nOiB7XG5cdFx0c2luZToge1xuXHRcdFx0b3V0OiBmdW5jdGlvbihrKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNpbihrICogKE1hdGguUEkgLyAyKSk7XG5cdFx0XHR9LFxuXHRcdFx0aW5PdXQ6IGZ1bmN0aW9uKGspIHtcblx0XHRcdFx0cmV0dXJuIC0gKE1hdGguY29zKE1hdGguUEkgKiBrKSAtIDEpIC8gMjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGN1YmljOiB7XG5cdFx0XHRvdXQ6IGZ1bmN0aW9uKGspIHtcblx0XHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Lypcblx0XHRcdGVsYXN0aWM6IHtcblx0XHRcdFx0b3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdFx0XHR2YXIgcywgYSA9IDAuMSwgcCA9IDAuNDtcblx0XHRcdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdFx0XHRpZiAoICFhIHx8IGEgPCAxICkgeyBhID0gMTsgcyA9IHAgLyA0OyB9XG5cdFx0XHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdFx0XHRyZXR1cm4gKCBhICogTWF0aC5wb3coIDIsIC0gMTAgKiBrKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKyAxICk7XG5cblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0XHRiYWNrOiB7XG5cdFx0XHRcdG91dDogZnVuY3Rpb24gKCBrICkge1xuXHRcdFx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdFx0XHRyZXR1cm4gLS1rICogayAqICggKCBzICsgMSApICogayArIHMgKSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQqL1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBcblx0ICoge1xuXHQgKiAgcmFmIDogcmVxdWVzdCBhbmltYXRpb24gZnJhbWUgZnVuY3Rpb25cblx0ICogIGNhZiA6IGNhbmNlbCBhbmltYXRpb24gZnJhbWUgZnVuY3Rpb25cblx0ICogIHRyYW5zZnJvbSA6IHRyYW5zZm9ybSBwcm9wZXJ0eSBrZXkgKHdpdGggdmVuZG9yKSwgb3IgbnVsbCBpZiBub3Qgc3VwcG9ydGVkXG5cdCAqICBvbGRJRSA6IElFOCBvciBiZWxvd1xuXHQgKiB9XG5cdCAqIFxuXHQgKi9cblx0ZGV0ZWN0RmVhdHVyZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmKGZyYW1ld29yay5mZWF0dXJlcykge1xuXHRcdFx0cmV0dXJuIGZyYW1ld29yay5mZWF0dXJlcztcblx0XHR9XG5cdFx0dmFyIGhlbHBlckVsID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCksXG5cdFx0XHRoZWxwZXJTdHlsZSA9IGhlbHBlckVsLnN0eWxlLFxuXHRcdFx0dmVuZG9yID0gJycsXG5cdFx0XHRmZWF0dXJlcyA9IHt9O1xuXG5cdFx0Ly8gSUU4IGFuZCBiZWxvd1xuXHRcdGZlYXR1cmVzLm9sZElFID0gZG9jdW1lbnQuYWxsICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xuXG5cdFx0ZmVhdHVyZXMudG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG5cblx0XHRpZih3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRmZWF0dXJlcy5yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0ZmVhdHVyZXMuY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXHRcdH1cblxuXHRcdGZlYXR1cmVzLnBvaW50ZXJFdmVudCA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG5cdFx0Ly8gZml4IGZhbHNlLXBvc2l0aXZlIGRldGVjdGlvbiBvZiBvbGQgQW5kcm9pZCBpbiBuZXcgSUVcblx0XHQvLyAoSUUxMSB1YSBzdHJpbmcgY29udGFpbnMgXCJBbmRyb2lkIDQuMFwiKVxuXHRcdFxuXHRcdGlmKCFmZWF0dXJlcy5wb2ludGVyRXZlbnQpIHsgXG5cblx0XHRcdHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cblx0XHRcdC8vIERldGVjdCBpZiBkZXZpY2UgaXMgaVBob25lIG9yIGlQb2QgYW5kIGlmIGl0J3Mgb2xkZXIgdGhhbiBpT1MgOFxuXHRcdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQyMjM5MjBcblx0XHRcdC8vIFxuXHRcdFx0Ly8gVGhpcyBkZXRlY3Rpb24gaXMgbWFkZSBiZWNhdXNlIG9mIGJ1Z2d5IHRvcC9ib3R0b20gdG9vbGJhcnNcblx0XHRcdC8vIHRoYXQgZG9uJ3QgdHJpZ2dlciB3aW5kb3cucmVzaXplIGV2ZW50LlxuXHRcdFx0Ly8gRm9yIG1vcmUgaW5mbyByZWZlciB0byBfaXNGaXhlZFBvc2l0aW9uIHZhcmlhYmxlIGluIGNvcmUuanNcblxuXHRcdFx0aWYgKC9pUChob25lfG9kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pKSB7XG5cdFx0XHRcdHZhciB2ID0gKG5hdmlnYXRvci5hcHBWZXJzaW9uKS5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKV8/KFxcZCspPy8pO1xuXHRcdFx0XHRpZih2ICYmIHYubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHYgPSBwYXJzZUludCh2WzFdLCAxMCk7XG5cdFx0XHRcdFx0aWYodiA+PSAxICYmIHYgPCA4ICkge1xuXHRcdFx0XHRcdFx0ZmVhdHVyZXMuaXNPbGRJT1NQaG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVjdCBvbGQgQW5kcm9pZCAoYmVmb3JlIEtpdEthdClcblx0XHRcdC8vIGR1ZSB0byBidWdzIHJlbGF0ZWQgdG8gcG9zaXRpb246Zml4ZWRcblx0XHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzE4NDU3My9waWNrLXVwLXRoZS1hbmRyb2lkLXZlcnNpb24taW4tdGhlLWJyb3dzZXItYnktamF2YXNjcmlwdFxuXHRcdFx0XG5cdFx0XHR2YXIgbWF0Y2ggPSB1YS5tYXRjaCgvQW5kcm9pZFxccyhbMC05XFwuXSopLyk7XG5cdFx0XHR2YXIgYW5kcm9pZHZlcnNpb24gPSAgbWF0Y2ggPyBtYXRjaFsxXSA6IDA7XG5cdFx0XHRhbmRyb2lkdmVyc2lvbiA9IHBhcnNlRmxvYXQoYW5kcm9pZHZlcnNpb24pO1xuXHRcdFx0aWYoYW5kcm9pZHZlcnNpb24gPj0gMSApIHtcblx0XHRcdFx0aWYoYW5kcm9pZHZlcnNpb24gPCA0LjQpIHtcblx0XHRcdFx0XHRmZWF0dXJlcy5pc09sZEFuZHJvaWQgPSB0cnVlOyAvLyBmb3IgZml4ZWQgcG9zaXRpb24gYnVnICYgcGVyZm9ybWFuY2Vcblx0XHRcdFx0fVxuXHRcdFx0XHRmZWF0dXJlcy5hbmRyb2lkVmVyc2lvbiA9IGFuZHJvaWR2ZXJzaW9uOyAvLyBmb3IgdG91Y2hlbmQgYnVnXG5cdFx0XHR9XHRcblx0XHRcdGZlYXR1cmVzLmlzTW9iaWxlT3BlcmEgPSAvb3BlcmEgbWluaXxvcGVyYSBtb2JpL2kudGVzdCh1YSk7XG5cblx0XHRcdC8vIHAucy4geWVzLCB5ZXMsIFVBIHNuaWZmaW5nIGlzIGJhZCwgcHJvcG9zZSB5b3VyIHNvbHV0aW9uIGZvciBhYm92ZSBidWdzLlxuXHRcdH1cblx0XHRcblx0XHR2YXIgc3R5bGVDaGVja3MgPSBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdhbmltYXRpb25OYW1lJ10sXG5cdFx0XHR2ZW5kb3JzID0gWycnLCAnd2Via2l0JywnTW96JywnbXMnLCdPJ10sXG5cdFx0XHRzdHlsZUNoZWNrSXRlbSxcblx0XHRcdHN0eWxlTmFtZTtcblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZlbmRvciA9IHZlbmRvcnNbaV07XG5cblx0XHRcdGZvcih2YXIgYSA9IDA7IGEgPCAzOyBhKyspIHtcblx0XHRcdFx0c3R5bGVDaGVja0l0ZW0gPSBzdHlsZUNoZWNrc1thXTtcblxuXHRcdFx0XHQvLyB1cHBlcmNhc2UgZmlyc3QgbGV0dGVyIG9mIHByb3BlcnR5IG5hbWUsIGlmIHZlbmRvciBpcyBwcmVzZW50XG5cdFx0XHRcdHN0eWxlTmFtZSA9IHZlbmRvciArICh2ZW5kb3IgPyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGVDaGVja0l0ZW0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZUNoZWNrSXRlbS5zbGljZSgxKSA6IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZUNoZWNrSXRlbSk7XG5cdFx0XHRcblx0XHRcdFx0aWYoIWZlYXR1cmVzW3N0eWxlQ2hlY2tJdGVtXSAmJiBzdHlsZU5hbWUgaW4gaGVscGVyU3R5bGUgKSB7XG5cdFx0XHRcdFx0ZmVhdHVyZXNbc3R5bGVDaGVja0l0ZW1dID0gc3R5bGVOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKHZlbmRvciAmJiAhZmVhdHVyZXMucmFmKSB7XG5cdFx0XHRcdHZlbmRvciA9IHZlbmRvci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRmZWF0dXJlcy5yYWYgPSB3aW5kb3dbdmVuZG9yKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcblx0XHRcdFx0aWYoZmVhdHVyZXMucmFmKSB7XG5cdFx0XHRcdFx0ZmVhdHVyZXMuY2FmID0gd2luZG93W3ZlbmRvcisnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCBcblx0XHRcdFx0XHRcdFx0XHRcdHdpbmRvd1t2ZW5kb3IrJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFx0XG5cdFx0aWYoIWZlYXR1cmVzLnJhZikge1xuXHRcdFx0dmFyIGxhc3RUaW1lID0gMDtcblx0XHRcdGZlYXR1cmVzLnJhZiA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRcdHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0XHR2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcblx0XHRcdFx0dmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZuKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7IH0sIHRpbWVUb0NhbGwpO1xuXHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcblx0XHRcdFx0cmV0dXJuIGlkO1xuXHRcdFx0fTtcblx0XHRcdGZlYXR1cmVzLmNhZiA9IGZ1bmN0aW9uKGlkKSB7IGNsZWFyVGltZW91dChpZCk7IH07XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IFNWRyBzdXBwb3J0XG5cdFx0ZmVhdHVyZXMuc3ZnID0gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgXG5cdFx0XHRcdFx0XHQhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdDtcblxuXHRcdGZyYW1ld29yay5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG5cdFx0cmV0dXJuIGZlYXR1cmVzO1xuXHR9XG59O1xuXG5mcmFtZXdvcmsuZGV0ZWN0RmVhdHVyZXMoKTtcblxuLy8gT3ZlcnJpZGUgYWRkRXZlbnRMaXN0ZW5lciBmb3Igb2xkIHZlcnNpb25zIG9mIElFXG5pZihmcmFtZXdvcmsuZmVhdHVyZXMub2xkSUUpIHtcblxuXHRmcmFtZXdvcmsuYmluZCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHVuYmluZCkge1xuXHRcdFxuXHRcdHR5cGUgPSB0eXBlLnNwbGl0KCcgJyk7XG5cblx0XHR2YXIgbWV0aG9kTmFtZSA9ICh1bmJpbmQgPyAnZGV0YWNoJyA6ICdhdHRhY2gnKSArICdFdmVudCcsXG5cdFx0XHRldk5hbWUsXG5cdFx0XHRfaGFuZGxlRXYgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbChsaXN0ZW5lcik7XG5cdFx0XHR9O1xuXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGV2TmFtZSA9IHR5cGVbaV07XG5cdFx0XHRpZihldk5hbWUpIHtcblxuXHRcdFx0XHRpZih0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnICYmIGxpc3RlbmVyLmhhbmRsZUV2ZW50KSB7XG5cdFx0XHRcdFx0aWYoIXVuYmluZCkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXJbJ29sZElFJyArIGV2TmFtZV0gPSBfaGFuZGxlRXY7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmKCFsaXN0ZW5lclsnb2xkSUUnICsgZXZOYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0W21ldGhvZE5hbWVdKCAnb24nICsgZXZOYW1lLCBsaXN0ZW5lclsnb2xkSUUnICsgZXZOYW1lXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W21ldGhvZE5hbWVdKCAnb24nICsgZXZOYW1lLCBsaXN0ZW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG59XG5cbi8qPj5mcmFtZXdvcmstYnJpZGdlKi9cblxuLyo+PmNvcmUqL1xuLy9mdW5jdGlvbih0ZW1wbGF0ZSwgVWlDbGFzcywgaXRlbXMsIG9wdGlvbnMpXG5cbnZhciBzZWxmID0gdGhpcztcblxuLyoqXG4gKiBTdGF0aWMgdmFycywgZG9uJ3QgY2hhbmdlIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqL1xudmFyIERPVUJMRV9UQVBfUkFESVVTID0gMjUsIFxuXHROVU1fSE9MREVSUyA9IDM7XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG52YXIgX29wdGlvbnMgPSB7XG5cdGFsbG93UGFuVG9OZXh0OnRydWUsXG5cdHNwYWNpbmc6IDAuMTIsXG5cdGJnT3BhY2l0eTogMSxcblx0bW91c2VVc2VkOiBmYWxzZSxcblx0bG9vcDogdHJ1ZSxcblx0cGluY2hUb0Nsb3NlOiB0cnVlLFxuXHRjbG9zZU9uU2Nyb2xsOiB0cnVlLFxuXHRjbG9zZU9uVmVydGljYWxEcmFnOiB0cnVlLFxuXHR2ZXJ0aWNhbERyYWdSYW5nZTogMC43NSxcblx0aGlkZUFuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXG5cdHNob3dBbmltYXRpb25EdXJhdGlvbjogMzMzLFxuXHRzaG93SGlkZU9wYWNpdHk6IGZhbHNlLFxuXHRmb2N1czogdHJ1ZSxcblx0ZXNjS2V5OiB0cnVlLFxuXHRhcnJvd0tleXM6IHRydWUsXG5cdG1haW5TY3JvbGxFbmRGcmljdGlvbjogMC4zNSxcblx0cGFuRW5kRnJpY3Rpb246IDAuMzUsXG5cdGlzQ2xpY2thYmxlRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnRhZ05hbWUgPT09ICdBJztcbiAgICB9LFxuICAgIGdldERvdWJsZVRhcFpvb206IGZ1bmN0aW9uKGlzTW91c2VDbGljaywgaXRlbSkge1xuICAgIFx0aWYoaXNNb3VzZUNsaWNrKSB7XG4gICAgXHRcdHJldHVybiAxO1xuICAgIFx0fSBlbHNlIHtcbiAgICBcdFx0cmV0dXJuIGl0ZW0uaW5pdGlhbFpvb21MZXZlbCA8IDAuNyA/IDEgOiAxLjMzO1xuICAgIFx0fVxuICAgIH0sXG4gICAgbWF4U3ByZWFkWm9vbTogMS4zMyxcblx0bW9kYWw6IHRydWUsXG5cblx0Ly8gbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldFxuXHRzY2FsZU1vZGU6ICdmaXQnIC8vIFRPRE9cbn07XG5mcmFtZXdvcmsuZXh0ZW5kKF9vcHRpb25zLCBvcHRpb25zKTtcblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHZhcmlhYmxlcyAmIGZ1bmN0aW9uc1xuICovXG5cbnZhciBfZ2V0RW1wdHlQb2ludCA9IGZ1bmN0aW9uKCkgeyBcblx0XHRyZXR1cm4ge3g6MCx5OjB9OyBcblx0fTtcblxudmFyIF9pc09wZW4sXG5cdF9pc0Rlc3Ryb3lpbmcsXG5cdF9jbG9zZWRCeVNjcm9sbCxcblx0X2N1cnJlbnRJdGVtSW5kZXgsXG5cdF9jb250YWluZXJTdHlsZSxcblx0X2NvbnRhaW5lclNoaWZ0SW5kZXgsXG5cdF9jdXJyUGFuRGlzdCA9IF9nZXRFbXB0eVBvaW50KCksXG5cdF9zdGFydFBhbk9mZnNldCA9IF9nZXRFbXB0eVBvaW50KCksXG5cdF9wYW5PZmZzZXQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuXHRfdXBNb3ZlRXZlbnRzLCAvLyBkcmFnIG1vdmUsIGRyYWcgZW5kICYgZHJhZyBjYW5jZWwgZXZlbnRzIGFycmF5XG5cdF9kb3duRXZlbnRzLCAvLyBkcmFnIHN0YXJ0IGV2ZW50cyBhcnJheVxuXHRfZ2xvYmFsRXZlbnRIYW5kbGVycyxcblx0X3ZpZXdwb3J0U2l6ZSA9IHt9LFxuXHRfY3Vyclpvb21MZXZlbCxcblx0X3N0YXJ0Wm9vbUxldmVsLFxuXHRfdHJhbnNsYXRlUHJlZml4LFxuXHRfdHJhbnNsYXRlU3VmaXgsXG5cdF91cGRhdGVTaXplSW50ZXJ2YWwsXG5cdF9pdGVtc05lZWRVcGRhdGUsXG5cdF9jdXJyUG9zaXRpb25JbmRleCA9IDAsXG5cdF9vZmZzZXQgPSB7fSxcblx0X3NsaWRlU2l6ZSA9IF9nZXRFbXB0eVBvaW50KCksIC8vIHNpemUgb2Ygc2xpZGUgYXJlYSwgaW5jbHVkaW5nIHNwYWNpbmdcblx0X2l0ZW1Ib2xkZXJzLFxuXHRfcHJldkl0ZW1JbmRleCxcblx0X2luZGV4RGlmZiA9IDAsIC8vIGRpZmZlcmVuY2Ugb2YgaW5kZXhlcyBzaW5jZSBsYXN0IGNvbnRlbnQgdXBkYXRlXG5cdF9kcmFnU3RhcnRFdmVudCxcblx0X2RyYWdNb3ZlRXZlbnQsXG5cdF9kcmFnRW5kRXZlbnQsXG5cdF9kcmFnQ2FuY2VsRXZlbnQsXG5cdF90cmFuc2Zvcm1LZXksXG5cdF9wb2ludGVyRXZlbnRFbmFibGVkLFxuXHRfaXNGaXhlZFBvc2l0aW9uID0gdHJ1ZSxcblx0X2xpa2VseVRvdWNoRGV2aWNlLFxuXHRfbW9kdWxlcyA9IFtdLFxuXHRfcmVxdWVzdEFGLFxuXHRfY2FuY2VsQUYsXG5cdF9pbml0YWxDbGFzc05hbWUsXG5cdF9pbml0YWxXaW5kb3dTY3JvbGxZLFxuXHRfb2xkSUUsXG5cdF9jdXJyZW50V2luZG93U2Nyb2xsWSxcblx0X2ZlYXR1cmVzLFxuXHRfd2luZG93VmlzaWJsZVNpemUgPSB7fSxcblx0X3JlbmRlck1heFJlc29sdXRpb24gPSBmYWxzZSxcblx0X29yaWVudGF0aW9uQ2hhbmdlVGltZW91dCxcblxuXG5cdC8vIFJlZ2lzdGVycyBQaG90b1NXaXBlIG1vZHVsZSAoSGlzdG9yeSwgQ29udHJvbGxlciAuLi4pXG5cdF9yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUsIG1vZHVsZSkge1xuXHRcdGZyYW1ld29yay5leHRlbmQoc2VsZiwgbW9kdWxlLnB1YmxpY01ldGhvZHMpO1xuXHRcdF9tb2R1bGVzLnB1c2gobmFtZSk7XG5cdH0sXG5cblx0X2dldExvb3BlZElkID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbnVtU2xpZGVzID0gX2dldE51bUl0ZW1zKCk7XG5cdFx0aWYoaW5kZXggPiBudW1TbGlkZXMgLSAxKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggLSBudW1TbGlkZXM7XG5cdFx0fSBlbHNlICBpZihpbmRleCA8IDApIHtcblx0XHRcdHJldHVybiBudW1TbGlkZXMgKyBpbmRleDtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXHRcblx0Ly8gTWljcm8gYmluZC90cmlnZ2VyXG5cdF9saXN0ZW5lcnMgPSB7fSxcblx0X2xpc3RlbiA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG5cdFx0aWYoIV9saXN0ZW5lcnNbbmFtZV0pIHtcblx0XHRcdF9saXN0ZW5lcnNbbmFtZV0gPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9saXN0ZW5lcnNbbmFtZV0ucHVzaChmbik7XG5cdH0sXG5cdF9zaG91dCA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gX2xpc3RlbmVyc1tuYW1lXTtcblxuXHRcdGlmKGxpc3RlbmVycykge1xuXHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0YXJncy5zaGlmdCgpO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9LFxuXHRfYXBwbHlCZ09wYWNpdHkgPSBmdW5jdGlvbihvcGFjaXR5KSB7XG5cdFx0X2JnT3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0c2VsZi5iZy5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eSAqIF9vcHRpb25zLmJnT3BhY2l0eTtcblx0fSxcblxuXHRfYXBwbHlab29tVHJhbnNmb3JtID0gZnVuY3Rpb24oc3R5bGVPYmoseCx5LHpvb20saXRlbSkge1xuXHRcdGlmKCFfcmVuZGVyTWF4UmVzb2x1dGlvbiB8fCAoaXRlbSAmJiBpdGVtICE9PSBzZWxmLmN1cnJJdGVtKSApIHtcblx0XHRcdHpvb20gPSB6b29tIC8gKGl0ZW0gPyBpdGVtLmZpdFJhdGlvIDogc2VsZi5jdXJySXRlbS5maXRSYXRpbyk7XHRcblx0XHR9XG5cdFx0XHRcblx0XHRzdHlsZU9ialtfdHJhbnNmb3JtS2V5XSA9IF90cmFuc2xhdGVQcmVmaXggKyB4ICsgJ3B4LCAnICsgeSArICdweCcgKyBfdHJhbnNsYXRlU3VmaXggKyAnIHNjYWxlKCcgKyB6b29tICsgJyknO1xuXHR9LFxuXHRfYXBwbHlDdXJyZW50Wm9vbVBhbiA9IGZ1bmN0aW9uKCBhbGxvd1JlbmRlclJlc29sdXRpb24gKSB7XG5cdFx0aWYoX2N1cnJab29tRWxlbWVudFN0eWxlKSB7XG5cblx0XHRcdGlmKGFsbG93UmVuZGVyUmVzb2x1dGlvbikge1xuXHRcdFx0XHRpZihfY3Vyclpvb21MZXZlbCA+IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pIHtcblx0XHRcdFx0XHRpZighX3JlbmRlck1heFJlc29sdXRpb24pIHtcblx0XHRcdFx0XHRcdF9zZXRJbWFnZVNpemUoc2VsZi5jdXJySXRlbSwgZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdFx0X3JlbmRlck1heFJlc29sdXRpb24gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZihfcmVuZGVyTWF4UmVzb2x1dGlvbikge1xuXHRcdFx0XHRcdFx0X3NldEltYWdlU2l6ZShzZWxmLmN1cnJJdGVtKTtcblx0XHRcdFx0XHRcdF9yZW5kZXJNYXhSZXNvbHV0aW9uID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblxuXHRcdFx0X2FwcGx5Wm9vbVRyYW5zZm9ybShfY3Vyclpvb21FbGVtZW50U3R5bGUsIF9wYW5PZmZzZXQueCwgX3Bhbk9mZnNldC55LCBfY3Vyclpvb21MZXZlbCk7XG5cdFx0fVxuXHR9LFxuXHRfYXBwbHlab29tUGFuVG9JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmKGl0ZW0uY29udGFpbmVyKSB7XG5cblx0XHRcdF9hcHBseVpvb21UcmFuc2Zvcm0oaXRlbS5jb250YWluZXIuc3R5bGUsIFxuXHRcdFx0XHRcdFx0XHRcdGl0ZW0uaW5pdGlhbFBvc2l0aW9uLngsIFxuXHRcdFx0XHRcdFx0XHRcdGl0ZW0uaW5pdGlhbFBvc2l0aW9uLnksIFxuXHRcdFx0XHRcdFx0XHRcdGl0ZW0uaW5pdGlhbFpvb21MZXZlbCxcblx0XHRcdFx0XHRcdFx0XHRpdGVtKTtcblx0XHR9XG5cdH0sXG5cdF9zZXRUcmFuc2xhdGVYID0gZnVuY3Rpb24oeCwgZWxTdHlsZSkge1xuXHRcdGVsU3R5bGVbX3RyYW5zZm9ybUtleV0gPSBfdHJhbnNsYXRlUHJlZml4ICsgeCArICdweCwgMHB4JyArIF90cmFuc2xhdGVTdWZpeDtcblx0fSxcblx0X21vdmVNYWluU2Nyb2xsID0gZnVuY3Rpb24oeCwgZHJhZ2dpbmcpIHtcblxuXHRcdGlmKCFfb3B0aW9ucy5sb29wICYmIGRyYWdnaW5nKSB7XG5cdFx0XHR2YXIgbmV3U2xpZGVJbmRleE9mZnNldCA9IF9jdXJyZW50SXRlbUluZGV4ICsgKF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleCAtIHgpIC8gX3NsaWRlU2l6ZS54LFxuXHRcdFx0XHRkZWx0YSA9IE1hdGgucm91bmQoeCAtIF9tYWluU2Nyb2xsUG9zLngpO1xuXG5cdFx0XHRpZiggKG5ld1NsaWRlSW5kZXhPZmZzZXQgPCAwICYmIGRlbHRhID4gMCkgfHwgXG5cdFx0XHRcdChuZXdTbGlkZUluZGV4T2Zmc2V0ID49IF9nZXROdW1JdGVtcygpIC0gMSAmJiBkZWx0YSA8IDApICkge1xuXHRcdFx0XHR4ID0gX21haW5TY3JvbGxQb3MueCArIGRlbHRhICogX29wdGlvbnMubWFpblNjcm9sbEVuZEZyaWN0aW9uO1xuXHRcdFx0fSBcblx0XHR9XG5cdFx0XG5cdFx0X21haW5TY3JvbGxQb3MueCA9IHg7XG5cdFx0X3NldFRyYW5zbGF0ZVgoeCwgX2NvbnRhaW5lclN0eWxlKTtcblx0fSxcblx0X2NhbGN1bGF0ZVBhbk9mZnNldCA9IGZ1bmN0aW9uKGF4aXMsIHpvb21MZXZlbCkge1xuXHRcdHZhciBtID0gX21pZFpvb21Qb2ludFtheGlzXSAtIF9vZmZzZXRbYXhpc107XG5cdFx0cmV0dXJuIF9zdGFydFBhbk9mZnNldFtheGlzXSArIF9jdXJyUGFuRGlzdFtheGlzXSArIG0gLSBtICogKCB6b29tTGV2ZWwgLyBfc3RhcnRab29tTGV2ZWwgKTtcblx0fSxcblx0XG5cdF9lcXVhbGl6ZVBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xuXHRcdHAxLnggPSBwMi54O1xuXHRcdHAxLnkgPSBwMi55O1xuXHRcdGlmKHAyLmlkKSB7XG5cdFx0XHRwMS5pZCA9IHAyLmlkO1xuXHRcdH1cblx0fSxcblx0X3JvdW5kUG9pbnQgPSBmdW5jdGlvbihwKSB7XG5cdFx0cC54ID0gTWF0aC5yb3VuZChwLngpO1xuXHRcdHAueSA9IE1hdGgucm91bmQocC55KTtcblx0fSxcblxuXHRfbW91c2VNb3ZlVGltZW91dCA9IG51bGwsXG5cdF9vbkZpcnN0TW91c2VNb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gV2FpdCB1bnRpbCBtb3VzZSBtb3ZlIGV2ZW50IGlzIGZpcmVkIGF0IGxlYXN0IHR3aWNlIGR1cmluZyAxMDBtc1xuXHRcdC8vIFdlIGRvIHRoaXMsIGJlY2F1c2Ugc29tZSBtb2JpbGUgYnJvd3NlcnMgdHJpZ2dlciBpdCBvbiB0b3VjaHN0YXJ0XG5cdFx0aWYoX21vdXNlTW92ZVRpbWVvdXQgKSB7IFxuXHRcdFx0ZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIF9vbkZpcnN0TW91c2VNb3ZlKTtcblx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWhhc19tb3VzZScpO1xuXHRcdFx0X29wdGlvbnMubW91c2VVc2VkID0gdHJ1ZTtcblx0XHRcdF9zaG91dCgnbW91c2VVc2VkJyk7XG5cdFx0fVxuXHRcdF9tb3VzZU1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdF9tb3VzZU1vdmVUaW1lb3V0ID0gbnVsbDtcblx0XHR9LCAxMDApO1xuXHR9LFxuXG5cdF9iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0ZnJhbWV3b3JrLmJpbmQoZG9jdW1lbnQsICdrZXlkb3duJywgc2VsZik7XG5cblx0XHRpZihfZmVhdHVyZXMudHJhbnNmb3JtKSB7XG5cdFx0XHQvLyBkb24ndCBiaW5kIGNsaWNrIGV2ZW50IGluIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0cmFuc2Zvcm0gKG1vc3RseSBJRTgpXG5cdFx0XHRmcmFtZXdvcmsuYmluZChzZWxmLnNjcm9sbFdyYXAsICdjbGljaycsIHNlbGYpO1xuXHRcdH1cblx0XHRcblxuXHRcdGlmKCFfb3B0aW9ucy5tb3VzZVVzZWQpIHtcblx0XHRcdGZyYW1ld29yay5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX29uRmlyc3RNb3VzZU1vdmUpO1xuXHRcdH1cblxuXHRcdGZyYW1ld29yay5iaW5kKHdpbmRvdywgJ3Jlc2l6ZSBzY3JvbGwgb3JpZW50YXRpb25jaGFuZ2UnLCBzZWxmKTtcblxuXHRcdF9zaG91dCgnYmluZEV2ZW50cycpO1xuXHR9LFxuXG5cdF91bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcblx0XHRmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ3Jlc2l6ZSBzY3JvbGwgb3JpZW50YXRpb25jaGFuZ2UnLCBzZWxmKTtcblx0XHRmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ3Njcm9sbCcsIF9nbG9iYWxFdmVudEhhbmRsZXJzLnNjcm9sbCk7XG5cdFx0ZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ2tleWRvd24nLCBzZWxmKTtcblx0XHRmcmFtZXdvcmsudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX29uRmlyc3RNb3VzZU1vdmUpO1xuXG5cdFx0aWYoX2ZlYXR1cmVzLnRyYW5zZm9ybSkge1xuXHRcdFx0ZnJhbWV3b3JrLnVuYmluZChzZWxmLnNjcm9sbFdyYXAsICdjbGljaycsIHNlbGYpO1xuXHRcdH1cblxuXHRcdGlmKF9pc0RyYWdnaW5nKSB7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgX3VwTW92ZUV2ZW50cywgc2VsZik7XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KF9vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQpO1xuXG5cdFx0X3Nob3V0KCd1bmJpbmRFdmVudHMnKTtcblx0fSxcblx0XG5cdF9jYWxjdWxhdGVQYW5Cb3VuZHMgPSBmdW5jdGlvbih6b29tTGV2ZWwsIHVwZGF0ZSkge1xuXHRcdHZhciBib3VuZHMgPSBfY2FsY3VsYXRlSXRlbVNpemUoIHNlbGYuY3Vyckl0ZW0sIF92aWV3cG9ydFNpemUsIHpvb21MZXZlbCApO1xuXHRcdGlmKHVwZGF0ZSkge1xuXHRcdFx0X2N1cnJQYW5Cb3VuZHMgPSBib3VuZHM7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cdFxuXHRfZ2V0TWluWm9vbUxldmVsID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmKCFpdGVtKSB7XG5cdFx0XHRpdGVtID0gc2VsZi5jdXJySXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW0uaW5pdGlhbFpvb21MZXZlbDtcblx0fSxcblx0X2dldE1heFpvb21MZXZlbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZighaXRlbSkge1xuXHRcdFx0aXRlbSA9IHNlbGYuY3Vyckl0ZW07XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtLncgPiAwID8gX29wdGlvbnMubWF4U3ByZWFkWm9vbSA6IDE7XG5cdH0sXG5cblx0Ly8gUmV0dXJuIHRydWUgaWYgb2Zmc2V0IGlzIG91dCBvZiB0aGUgYm91bmRzXG5cdF9tb2RpZnlEZXN0UGFuT2Zmc2V0ID0gZnVuY3Rpb24oYXhpcywgZGVzdFBhbkJvdW5kcywgZGVzdFBhbk9mZnNldCwgZGVzdFpvb21MZXZlbCkge1xuXHRcdGlmKGRlc3Rab29tTGV2ZWwgPT09IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkge1xuXHRcdFx0ZGVzdFBhbk9mZnNldFtheGlzXSA9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFBvc2l0aW9uW2F4aXNdO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RQYW5PZmZzZXRbYXhpc10gPSBfY2FsY3VsYXRlUGFuT2Zmc2V0KGF4aXMsIGRlc3Rab29tTGV2ZWwpOyBcblxuXHRcdFx0aWYoZGVzdFBhbk9mZnNldFtheGlzXSA+IGRlc3RQYW5Cb3VuZHMubWluW2F4aXNdKSB7XG5cdFx0XHRcdGRlc3RQYW5PZmZzZXRbYXhpc10gPSBkZXN0UGFuQm91bmRzLm1pbltheGlzXTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2UgaWYoZGVzdFBhbk9mZnNldFtheGlzXSA8IGRlc3RQYW5Cb3VuZHMubWF4W2F4aXNdICkge1xuXHRcdFx0XHRkZXN0UGFuT2Zmc2V0W2F4aXNdID0gZGVzdFBhbkJvdW5kcy5tYXhbYXhpc107XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3NldHVwVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYoX3RyYW5zZm9ybUtleSkge1xuXHRcdFx0Ly8gc2V0dXAgM2QgdHJhbnNmb3Jtc1xuXHRcdFx0dmFyIGFsbG93M2RUcmFuc2Zvcm0gPSBfZmVhdHVyZXMucGVyc3BlY3RpdmUgJiYgIV9saWtlbHlUb3VjaERldmljZTtcblx0XHRcdF90cmFuc2xhdGVQcmVmaXggPSAndHJhbnNsYXRlJyArIChhbGxvdzNkVHJhbnNmb3JtID8gJzNkKCcgOiAnKCcpO1xuXHRcdFx0X3RyYW5zbGF0ZVN1Zml4ID0gX2ZlYXR1cmVzLnBlcnNwZWN0aXZlID8gJywgMHB4KScgOiAnKSc7XHRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPdmVycmlkZSB6b29tL3Bhbi9tb3ZlIGZ1bmN0aW9ucyBpbiBjYXNlIG9sZCBicm93c2VyIGlzIHVzZWQgKG1vc3QgbGlrZWx5IElFKVxuXHRcdC8vIChzbyB0aGV5IHVzZSBsZWZ0L3RvcC93aWR0aC9oZWlnaHQsIGluc3RlYWQgb2YgQ1NTIHRyYW5zZm9ybSlcblx0XG5cdFx0X3RyYW5zZm9ybUtleSA9ICdsZWZ0Jztcblx0XHRmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1pZScpO1xuXG5cdFx0X3NldFRyYW5zbGF0ZVggPSBmdW5jdGlvbih4LCBlbFN0eWxlKSB7XG5cdFx0XHRlbFN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHR9O1xuXHRcdF9hcHBseVpvb21QYW5Ub0l0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHRcdHZhciB6b29tUmF0aW8gPSBpdGVtLmZpdFJhdGlvID4gMSA/IDEgOiBpdGVtLmZpdFJhdGlvLFxuXHRcdFx0XHRzID0gaXRlbS5jb250YWluZXIuc3R5bGUsXG5cdFx0XHRcdHcgPSB6b29tUmF0aW8gKiBpdGVtLncsXG5cdFx0XHRcdGggPSB6b29tUmF0aW8gKiBpdGVtLmg7XG5cblx0XHRcdHMud2lkdGggPSB3ICsgJ3B4Jztcblx0XHRcdHMuaGVpZ2h0ID0gaCArICdweCc7XG5cdFx0XHRzLmxlZnQgPSBpdGVtLmluaXRpYWxQb3NpdGlvbi54ICsgJ3B4Jztcblx0XHRcdHMudG9wID0gaXRlbS5pbml0aWFsUG9zaXRpb24ueSArICdweCc7XG5cblx0XHR9O1xuXHRcdF9hcHBseUN1cnJlbnRab29tUGFuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihfY3Vyclpvb21FbGVtZW50U3R5bGUpIHtcblxuXHRcdFx0XHR2YXIgcyA9IF9jdXJyWm9vbUVsZW1lbnRTdHlsZSxcblx0XHRcdFx0XHRpdGVtID0gc2VsZi5jdXJySXRlbSxcblx0XHRcdFx0XHR6b29tUmF0aW8gPSBpdGVtLmZpdFJhdGlvID4gMSA/IDEgOiBpdGVtLmZpdFJhdGlvLFxuXHRcdFx0XHRcdHcgPSB6b29tUmF0aW8gKiBpdGVtLncsXG5cdFx0XHRcdFx0aCA9IHpvb21SYXRpbyAqIGl0ZW0uaDtcblxuXHRcdFx0XHRzLndpZHRoID0gdyArICdweCc7XG5cdFx0XHRcdHMuaGVpZ2h0ID0gaCArICdweCc7XG5cblxuXHRcdFx0XHRzLmxlZnQgPSBfcGFuT2Zmc2V0LnggKyAncHgnO1xuXHRcdFx0XHRzLnRvcCA9IF9wYW5PZmZzZXQueSArICdweCc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9O1xuXHR9LFxuXG5cdF9vbktleURvd24gPSBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIGtleWRvd25BY3Rpb24gPSAnJztcblx0XHRpZihfb3B0aW9ucy5lc2NLZXkgJiYgZS5rZXlDb2RlID09PSAyNykgeyBcblx0XHRcdGtleWRvd25BY3Rpb24gPSAnY2xvc2UnO1xuXHRcdH0gZWxzZSBpZihfb3B0aW9ucy5hcnJvd0tleXMpIHtcblx0XHRcdGlmKGUua2V5Q29kZSA9PT0gMzcpIHtcblx0XHRcdFx0a2V5ZG93bkFjdGlvbiA9ICdwcmV2Jztcblx0XHRcdH0gZWxzZSBpZihlLmtleUNvZGUgPT09IDM5KSB7IFxuXHRcdFx0XHRrZXlkb3duQWN0aW9uID0gJ25leHQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKGtleWRvd25BY3Rpb24pIHtcblx0XHRcdC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHNwZWNpYWwga2V5IHByZXNzZWQgdG8gcHJldmVudCBmcm9tIG92ZXJyaWRpbmcgZGVmYXVsdCBicm93c2VyIGFjdGlvbnNcblx0XHRcdC8vIGUuZy4gaW4gQ2hyb21lIG9uIE1hYyBjbWQrYXJyb3ctbGVmdCByZXR1cm5zIHRvIHByZXZpb3VzIHBhZ2Vcblx0XHRcdGlmKCAhZS5jdHJsS2V5ICYmICFlLmFsdEtleSAmJiAhZS5zaGlmdEtleSAmJiAhZS5tZXRhS2V5ICkge1xuXHRcdFx0XHRpZihlLnByZXZlbnREZWZhdWx0KSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0XHRcdFx0fSBcblx0XHRcdFx0c2VsZltrZXlkb3duQWN0aW9uXSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfb25HbG9iYWxDbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZighZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IGFsbG93IGNsaWNrIGV2ZW50IHRvIHBhc3MgdGhyb3VnaCB3aGVuIHRyaWdnZXJpbmcgYWZ0ZXIgZHJhZyBvciBzb21lIG90aGVyIGdlc3R1cmVcblx0XHRpZihfbW92ZWQgfHwgX3pvb21TdGFydGVkIHx8IF9tYWluU2Nyb2xsQW5pbWF0aW5nIHx8IF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYWdlU2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi5zZXRTY3JvbGxPZmZzZXQoMCwgZnJhbWV3b3JrLmdldFNjcm9sbFkoKSk7XHRcdFxuXHR9O1xuXHRcblxuXG5cdFxuXG5cblxuLy8gTWljcm8gYW5pbWF0aW9uIGVuZ2luZVxudmFyIF9hbmltYXRpb25zID0ge30sXG5cdF9udW1BbmltYXRpb25zID0gMCxcblx0X3N0b3BBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0aWYoX2FuaW1hdGlvbnNbbmFtZV0pIHtcblx0XHRcdGlmKF9hbmltYXRpb25zW25hbWVdLnJhZikge1xuXHRcdFx0XHRfY2FuY2VsQUYoIF9hbmltYXRpb25zW25hbWVdLnJhZiApO1xuXHRcdFx0fVxuXHRcdFx0X251bUFuaW1hdGlvbnMtLTtcblx0XHRcdGRlbGV0ZSBfYW5pbWF0aW9uc1tuYW1lXTtcblx0XHR9XG5cdH0sXG5cdF9yZWdpc3RlclN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmKF9hbmltYXRpb25zW25hbWVdKSB7XG5cdFx0XHRfc3RvcEFuaW1hdGlvbihuYW1lKTtcblx0XHR9XG5cdFx0aWYoIV9hbmltYXRpb25zW25hbWVdKSB7XG5cdFx0XHRfbnVtQW5pbWF0aW9ucysrO1xuXHRcdFx0X2FuaW1hdGlvbnNbbmFtZV0gPSB7fTtcblx0XHR9XG5cdH0sXG5cdF9zdG9wQWxsQW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIHByb3AgaW4gX2FuaW1hdGlvbnMpIHtcblxuXHRcdFx0aWYoIF9hbmltYXRpb25zLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdF9zdG9wQW5pbWF0aW9uKHByb3ApO1xuXHRcdFx0fSBcblx0XHRcdFxuXHRcdH1cblx0fSxcblx0X2FuaW1hdGVQcm9wID0gZnVuY3Rpb24obmFtZSwgYiwgZW5kUHJvcCwgZCwgZWFzaW5nRm4sIG9uVXBkYXRlLCBvbkNvbXBsZXRlKSB7XG5cdFx0dmFyIHN0YXJ0QW5pbVRpbWUgPSBfZ2V0Q3VycmVudFRpbWUoKSwgdDtcblx0XHRfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbihuYW1lKTtcblxuXHRcdHZhciBhbmltbG9vcCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIF9hbmltYXRpb25zW25hbWVdICkge1xuXHRcdFx0XHRcblx0XHRcdFx0dCA9IF9nZXRDdXJyZW50VGltZSgpIC0gc3RhcnRBbmltVGltZTsgLy8gdGltZSBkaWZmXG5cdFx0XHRcdC8vYiAtIGJlZ2lubmluZyAoc3RhcnQgcHJvcClcblx0XHRcdFx0Ly9kIC0gYW5pbSBkdXJhdGlvblxuXG5cdFx0XHRcdGlmICggdCA+PSBkICkge1xuXHRcdFx0XHRcdF9zdG9wQW5pbWF0aW9uKG5hbWUpO1xuXHRcdFx0XHRcdG9uVXBkYXRlKGVuZFByb3ApO1xuXHRcdFx0XHRcdGlmKG9uQ29tcGxldGUpIHtcblx0XHRcdFx0XHRcdG9uQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9uVXBkYXRlKCAoZW5kUHJvcCAtIGIpICogZWFzaW5nRm4odC9kKSArIGIgKTtcblxuXHRcdFx0XHRfYW5pbWF0aW9uc1tuYW1lXS5yYWYgPSBfcmVxdWVzdEFGKGFuaW1sb29wKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGFuaW1sb29wKCk7XG5cdH07XG5cdFxuXG5cbnZhciBwdWJsaWNNZXRob2RzID0ge1xuXG5cdC8vIG1ha2UgYSBmZXcgbG9jYWwgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnMgcHVibGljXG5cdHNob3V0OiBfc2hvdXQsXG5cdGxpc3RlbjogX2xpc3Rlbixcblx0dmlld3BvcnRTaXplOiBfdmlld3BvcnRTaXplLFxuXHRvcHRpb25zOiBfb3B0aW9ucyxcblxuXHRpc01haW5TY3JvbGxBbmltYXRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfbWFpblNjcm9sbEFuaW1hdGluZztcblx0fSxcblx0Z2V0Wm9vbUxldmVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX2N1cnJab29tTGV2ZWw7XG5cdH0sXG5cdGdldEN1cnJlbnRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9jdXJyZW50SXRlbUluZGV4O1xuXHR9LFxuXHRpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX2lzRHJhZ2dpbmc7XG5cdH0sXHRcblx0aXNab29taW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX2lzWm9vbWluZztcblx0fSxcblx0c2V0U2Nyb2xsT2Zmc2V0OiBmdW5jdGlvbih4LHkpIHtcblx0XHRfb2Zmc2V0LnggPSB4O1xuXHRcdF9jdXJyZW50V2luZG93U2Nyb2xsWSA9IF9vZmZzZXQueSA9IHk7XG5cdFx0X3Nob3V0KCd1cGRhdGVTY3JvbGxPZmZzZXQnLCBfb2Zmc2V0KTtcblx0fSxcblx0YXBwbHlab29tUGFuOiBmdW5jdGlvbih6b29tTGV2ZWwscGFuWCxwYW5ZLGFsbG93UmVuZGVyUmVzb2x1dGlvbikge1xuXHRcdF9wYW5PZmZzZXQueCA9IHBhblg7XG5cdFx0X3Bhbk9mZnNldC55ID0gcGFuWTtcblx0XHRfY3Vyclpvb21MZXZlbCA9IHpvb21MZXZlbDtcblx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbiggYWxsb3dSZW5kZXJSZXNvbHV0aW9uICk7XG5cdH0sXG5cblx0aW5pdDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZihfaXNPcGVuIHx8IF9pc0Rlc3Ryb3lpbmcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaTtcblxuXHRcdHNlbGYuZnJhbWV3b3JrID0gZnJhbWV3b3JrOyAvLyBiYXNpYyBmdW5jdGlvbmFsaXR5XG5cdFx0c2VsZi50ZW1wbGF0ZSA9IHRlbXBsYXRlOyAvLyByb290IERPTSBlbGVtZW50IG9mIFBob3RvU3dpcGVcblx0XHRzZWxmLmJnID0gZnJhbWV3b3JrLmdldENoaWxkQnlDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3BfX2JnJyk7XG5cblx0XHRfaW5pdGFsQ2xhc3NOYW1lID0gdGVtcGxhdGUuY2xhc3NOYW1lO1xuXHRcdF9pc09wZW4gPSB0cnVlO1xuXHRcdFx0XHRcblx0XHRfZmVhdHVyZXMgPSBmcmFtZXdvcmsuZGV0ZWN0RmVhdHVyZXMoKTtcblx0XHRfcmVxdWVzdEFGID0gX2ZlYXR1cmVzLnJhZjtcblx0XHRfY2FuY2VsQUYgPSBfZmVhdHVyZXMuY2FmO1xuXHRcdF90cmFuc2Zvcm1LZXkgPSBfZmVhdHVyZXMudHJhbnNmb3JtO1xuXHRcdF9vbGRJRSA9IF9mZWF0dXJlcy5vbGRJRTtcblx0XHRcblx0XHRzZWxmLnNjcm9sbFdyYXAgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHRlbXBsYXRlLCAncHN3cF9fc2Nyb2xsLXdyYXAnKTtcblx0XHRzZWxmLmNvbnRhaW5lciA9IGZyYW1ld29yay5nZXRDaGlsZEJ5Q2xhc3Moc2VsZi5zY3JvbGxXcmFwLCAncHN3cF9fY29udGFpbmVyJyk7XG5cblx0XHRfY29udGFpbmVyU3R5bGUgPSBzZWxmLmNvbnRhaW5lci5zdHlsZTsgLy8gZm9yIGZhc3QgYWNjZXNzXG5cblx0XHQvLyBPYmplY3RzIHRoYXQgaG9sZCBzbGlkZXMgKHRoZXJlIGFyZSBvbmx5IDMgaW4gRE9NKVxuXHRcdHNlbGYuaXRlbUhvbGRlcnMgPSBfaXRlbUhvbGRlcnMgPSBbXG5cdFx0XHR7ZWw6c2VsZi5jb250YWluZXIuY2hpbGRyZW5bMF0gLCB3cmFwOjAsIGluZGV4OiAtMX0sXG5cdFx0XHR7ZWw6c2VsZi5jb250YWluZXIuY2hpbGRyZW5bMV0gLCB3cmFwOjAsIGluZGV4OiAtMX0sXG5cdFx0XHR7ZWw6c2VsZi5jb250YWluZXIuY2hpbGRyZW5bMl0gLCB3cmFwOjAsIGluZGV4OiAtMX1cblx0XHRdO1xuXG5cdFx0Ly8gaGlkZSBuZWFyYnkgaXRlbSBob2xkZXJzIHVudGlsIGluaXRpYWwgem9vbSBhbmltYXRpb24gZmluaXNoZXMgKHRvIGF2b2lkIGV4dHJhIFBhaW50cylcblx0XHRfaXRlbUhvbGRlcnNbMF0uZWwuc3R5bGUuZGlzcGxheSA9IF9pdGVtSG9sZGVyc1syXS5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cdFx0X3NldHVwVHJhbnNmb3JtcygpO1xuXG5cdFx0Ly8gU2V0dXAgZ2xvYmFsIGV2ZW50c1xuXHRcdF9nbG9iYWxFdmVudEhhbmRsZXJzID0ge1xuXHRcdFx0cmVzaXplOiBzZWxmLnVwZGF0ZVNpemUsXG5cblx0XHRcdC8vIEZpeGVzOiBpT1MgMTAuMyByZXNpemUgZXZlbnRcblx0XHRcdC8vIGRvZXMgbm90IHVwZGF0ZSBzY3JvbGxXcmFwLmNsaWVudFdpZHRoIGluc3RhbnRseSBhZnRlciByZXNpemVcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kaW1zZW1lbm92L1Bob3RvU3dpcGUvaXNzdWVzLzEzMTVcblx0XHRcdG9yaWVudGF0aW9uY2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQpO1xuXHRcdFx0XHRfb3JpZW50YXRpb25DaGFuZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZihfdmlld3BvcnRTaXplLnggIT09IHNlbGYuc2Nyb2xsV3JhcC5jbGllbnRXaWR0aCkge1xuXHRcdFx0XHRcdFx0c2VsZi51cGRhdGVTaXplKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCA1MDApO1xuXHRcdFx0fSxcblx0XHRcdHNjcm9sbDogX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQsXG5cdFx0XHRrZXlkb3duOiBfb25LZXlEb3duLFxuXHRcdFx0Y2xpY2s6IF9vbkdsb2JhbENsaWNrXG5cdFx0fTtcblxuXHRcdC8vIGRpc2FibGUgc2hvdy9oaWRlIGVmZmVjdHMgb24gb2xkIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBDU1MgYW5pbWF0aW9ucyBvciB0cmFuc2Zvcm1zLCBcblx0XHQvLyBvbGQgSU9TLCBBbmRyb2lkIGFuZCBPcGVyYSBtb2JpbGUuIEJsYWNrYmVycnkgc2VlbXMgdG8gd29yayBmaW5lLCBldmVuIG9sZGVyIG1vZGVscy5cblx0XHR2YXIgb2xkUGhvbmUgPSBfZmVhdHVyZXMuaXNPbGRJT1NQaG9uZSB8fCBfZmVhdHVyZXMuaXNPbGRBbmRyb2lkIHx8IF9mZWF0dXJlcy5pc01vYmlsZU9wZXJhO1xuXHRcdGlmKCFfZmVhdHVyZXMuYW5pbWF0aW9uTmFtZSB8fCAhX2ZlYXR1cmVzLnRyYW5zZm9ybSB8fCBvbGRQaG9uZSkge1xuXHRcdFx0X29wdGlvbnMuc2hvd0FuaW1hdGlvbkR1cmF0aW9uID0gX29wdGlvbnMuaGlkZUFuaW1hdGlvbkR1cmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHQvLyBpbml0IG1vZHVsZXNcblx0XHRmb3IoaSA9IDA7IGkgPCBfbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VsZlsnaW5pdCcgKyBfbW9kdWxlc1tpXV0oKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gaW5pdFxuXHRcdGlmKFVpQ2xhc3MpIHtcblx0XHRcdHZhciB1aSA9IHNlbGYudWkgPSBuZXcgVWlDbGFzcyhzZWxmLCBmcmFtZXdvcmspO1xuXHRcdFx0dWkuaW5pdCgpO1xuXHRcdH1cblxuXHRcdF9zaG91dCgnZmlyc3RVcGRhdGUnKTtcblx0XHRfY3VycmVudEl0ZW1JbmRleCA9IF9jdXJyZW50SXRlbUluZGV4IHx8IF9vcHRpb25zLmluZGV4IHx8IDA7XG5cdFx0Ly8gdmFsaWRhdGUgaW5kZXhcblx0XHRpZiggaXNOYU4oX2N1cnJlbnRJdGVtSW5kZXgpIHx8IF9jdXJyZW50SXRlbUluZGV4IDwgMCB8fCBfY3VycmVudEl0ZW1JbmRleCA+PSBfZ2V0TnVtSXRlbXMoKSApIHtcblx0XHRcdF9jdXJyZW50SXRlbUluZGV4ID0gMDtcblx0XHR9XG5cdFx0c2VsZi5jdXJySXRlbSA9IF9nZXRJdGVtQXQoIF9jdXJyZW50SXRlbUluZGV4ICk7XG5cblx0XHRcblx0XHRpZihfZmVhdHVyZXMuaXNPbGRJT1NQaG9uZSB8fCBfZmVhdHVyZXMuaXNPbGRBbmRyb2lkKSB7XG5cdFx0XHRfaXNGaXhlZFBvc2l0aW9uID0gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHRlbXBsYXRlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblx0XHRpZihfb3B0aW9ucy5tb2RhbCkge1xuXHRcdFx0aWYoIV9pc0ZpeGVkUG9zaXRpb24pIHtcblx0XHRcdFx0dGVtcGxhdGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0XHR0ZW1wbGF0ZS5zdHlsZS50b3AgPSBmcmFtZXdvcmsuZ2V0U2Nyb2xsWSgpICsgJ3B4Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRlbXBsYXRlLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihfY3VycmVudFdpbmRvd1Njcm9sbFkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0X3Nob3V0KCdpbml0aWFsTGF5b3V0Jyk7XG5cdFx0XHRfY3VycmVudFdpbmRvd1Njcm9sbFkgPSBfaW5pdGFsV2luZG93U2Nyb2xsWSA9IGZyYW1ld29yay5nZXRTY3JvbGxZKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGFkZCBjbGFzc2VzIHRvIHJvb3QgZWxlbWVudCBvZiBQaG90b1N3aXBlXG5cdFx0dmFyIHJvb3RDbGFzc2VzID0gJ3Bzd3AtLW9wZW4gJztcblx0XHRpZihfb3B0aW9ucy5tYWluQ2xhc3MpIHtcblx0XHRcdHJvb3RDbGFzc2VzICs9IF9vcHRpb25zLm1haW5DbGFzcyArICcgJztcblx0XHR9XG5cdFx0aWYoX29wdGlvbnMuc2hvd0hpZGVPcGFjaXR5KSB7XG5cdFx0XHRyb290Q2xhc3NlcyArPSAncHN3cC0tYW5pbWF0ZV9vcGFjaXR5ICc7XG5cdFx0fVxuXHRcdHJvb3RDbGFzc2VzICs9IF9saWtlbHlUb3VjaERldmljZSA/ICdwc3dwLS10b3VjaCcgOiAncHN3cC0tbm90b3VjaCc7XG5cdFx0cm9vdENsYXNzZXMgKz0gX2ZlYXR1cmVzLmFuaW1hdGlvbk5hbWUgPyAnIHBzd3AtLWNzc19hbmltYXRpb24nIDogJyc7XG5cdFx0cm9vdENsYXNzZXMgKz0gX2ZlYXR1cmVzLnN2ZyA/ICcgcHN3cC0tc3ZnJyA6ICcnO1xuXHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgcm9vdENsYXNzZXMpO1xuXG5cdFx0c2VsZi51cGRhdGVTaXplKCk7XG5cblx0XHQvLyBpbml0aWFsIHVwZGF0ZVxuXHRcdF9jb250YWluZXJTaGlmdEluZGV4ID0gLTE7XG5cdFx0X2luZGV4RGlmZiA9IG51bGw7XG5cdFx0Zm9yKGkgPSAwOyBpIDwgTlVNX0hPTERFUlM7IGkrKykge1xuXHRcdFx0X3NldFRyYW5zbGF0ZVgoIChpK19jb250YWluZXJTaGlmdEluZGV4KSAqIF9zbGlkZVNpemUueCwgX2l0ZW1Ib2xkZXJzW2ldLmVsLnN0eWxlKTtcblx0XHR9XG5cblx0XHRpZighX29sZElFKSB7XG5cdFx0XHRmcmFtZXdvcmsuYmluZChzZWxmLnNjcm9sbFdyYXAsIF9kb3duRXZlbnRzLCBzZWxmKTsgLy8gbm8gZHJhZ2dpbmcgZm9yIG9sZCBJRVxuXHRcdH1cdFxuXG5cdFx0X2xpc3RlbignaW5pdGlhbFpvb21JbkVuZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5zZXRDb250ZW50KF9pdGVtSG9sZGVyc1swXSwgX2N1cnJlbnRJdGVtSW5kZXgtMSk7XG5cdFx0XHRzZWxmLnNldENvbnRlbnQoX2l0ZW1Ib2xkZXJzWzJdLCBfY3VycmVudEl0ZW1JbmRleCsxKTtcblxuXHRcdFx0X2l0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSBfaXRlbUhvbGRlcnNbMl0uZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cblx0XHRcdGlmKF9vcHRpb25zLmZvY3VzKSB7XG5cdFx0XHRcdC8vIGZvY3VzIGNhdXNlcyBsYXlvdXQsIFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgbGFnIGR1cmluZyB0aGUgYW5pbWF0aW9uLCBcblx0XHRcdFx0Ly8gdGhhdCdzIHdoeSB3ZSBkZWxheSBpdCB1bnRpbGwgdGhlIGluaXRpYWwgem9vbSB0cmFuc2l0aW9uIGVuZHNcblx0XHRcdFx0dGVtcGxhdGUuZm9jdXMoKTtcblx0XHRcdH1cblx0XHRcdCBcblxuXHRcdFx0X2JpbmRFdmVudHMoKTtcblx0XHR9KTtcblxuXHRcdC8vIHNldCBjb250ZW50IGZvciBjZW50ZXIgc2xpZGUgKGZpcnN0IHRpbWUpXG5cdFx0c2VsZi5zZXRDb250ZW50KF9pdGVtSG9sZGVyc1sxXSwgX2N1cnJlbnRJdGVtSW5kZXgpO1xuXHRcdFxuXHRcdHNlbGYudXBkYXRlQ3Vyckl0ZW0oKTtcblxuXHRcdF9zaG91dCgnYWZ0ZXJJbml0Jyk7XG5cblx0XHRpZighX2lzRml4ZWRQb3NpdGlvbikge1xuXG5cdFx0XHQvLyBPbiBhbGwgdmVyc2lvbnMgb2YgaU9TIGxvd2VyIHRoYW4gOC4wLCB3ZSBjaGVjayBzaXplIG9mIHZpZXdwb3J0IGV2ZXJ5IHNlY29uZC5cblx0XHRcdC8vIFxuXHRcdFx0Ly8gVGhpcyBpcyBkb25lIHRvIGRldGVjdCB3aGVuIFNhZmFyaSB0b3AgJiBib3R0b20gYmFycyBhcHBlYXIsIFxuXHRcdFx0Ly8gYXMgdGhpcyBhY3Rpb24gZG9lc24ndCB0cmlnZ2VyIGFueSBldmVudHMgKGxpa2UgcmVzaXplKS4gXG5cdFx0XHQvLyBcblx0XHRcdC8vIE9uIGlPUzggdGhleSBmaXhlZCB0aGlzLlxuXHRcdFx0Ly8gXG5cdFx0XHQvLyAxMCBOb3YgMjAxNDogaU9TIDcgdXNhZ2UgfjQwJS4gaU9TIDggdXNhZ2UgNTYlLlxuXHRcdFx0XG5cdFx0XHRfdXBkYXRlU2l6ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKCFfbnVtQW5pbWF0aW9ucyAmJiAhX2lzRHJhZ2dpbmcgJiYgIV9pc1pvb21pbmcgJiYgKF9jdXJyWm9vbUxldmVsID09PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpICApIHtcblx0XHRcdFx0XHRzZWxmLnVwZGF0ZVNpemUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwMCk7XG5cdFx0fVxuXG5cdFx0ZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0tdmlzaWJsZScpO1xuXHR9LFxuXG5cdC8vIENsb3NlIHRoZSBnYWxsZXJ5LCB0aGVuIGRlc3Ryb3kgaXRcblx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmKCFfaXNPcGVuKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0X2lzT3BlbiA9IGZhbHNlO1xuXHRcdF9pc0Rlc3Ryb3lpbmcgPSB0cnVlO1xuXHRcdF9zaG91dCgnY2xvc2UnKTtcblx0XHRfdW5iaW5kRXZlbnRzKCk7XG5cblx0XHRfc2hvd09ySGlkZShzZWxmLmN1cnJJdGVtLCBudWxsLCB0cnVlLCBzZWxmLmRlc3Ryb3kpO1xuXHR9LFxuXG5cdC8vIGRlc3Ryb3lzIHRoZSBnYWxsZXJ5ICh1bmJpbmRzIGV2ZW50cywgY2xlYW5zIHVwIGludGVydmFscyBhbmQgdGltZW91dHMgdG8gYXZvaWQgbWVtb3J5IGxlYWtzKVxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRfc2hvdXQoJ2Rlc3Ryb3knKTtcblxuXHRcdGlmKF9zaG93T3JIaWRlVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KF9zaG93T3JIaWRlVGltZW91dCk7XG5cdFx0fVxuXHRcdFxuXHRcdHRlbXBsYXRlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXHRcdHRlbXBsYXRlLmNsYXNzTmFtZSA9IF9pbml0YWxDbGFzc05hbWU7XG5cblx0XHRpZihfdXBkYXRlU2l6ZUludGVydmFsKSB7XG5cdFx0XHRjbGVhckludGVydmFsKF91cGRhdGVTaXplSW50ZXJ2YWwpO1xuXHRcdH1cblxuXHRcdGZyYW1ld29yay51bmJpbmQoc2VsZi5zY3JvbGxXcmFwLCBfZG93bkV2ZW50cywgc2VsZik7XG5cblx0XHQvLyB3ZSB1bmJpbmQgc2Nyb2xsIGV2ZW50IGF0IHRoZSBlbmQsIGFzIGNsb3NpbmcgYW5pbWF0aW9uIG1heSBkZXBlbmQgb24gaXRcblx0XHRmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ3Njcm9sbCcsIHNlbGYpO1xuXG5cdFx0X3N0b3BEcmFnVXBkYXRlTG9vcCgpO1xuXG5cdFx0X3N0b3BBbGxBbmltYXRpb25zKCk7XG5cblx0XHRfbGlzdGVuZXJzID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUGFuIGltYWdlIHRvIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgICBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgIFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIFdpbGwgaWdub3JlIGJvdW5kcyBpZiBzZXQgdG8gdHJ1ZS5cblx0ICovXG5cdHBhblRvOiBmdW5jdGlvbih4LHksZm9yY2UpIHtcblx0XHRpZighZm9yY2UpIHtcblx0XHRcdGlmKHggPiBfY3VyclBhbkJvdW5kcy5taW4ueCkge1xuXHRcdFx0XHR4ID0gX2N1cnJQYW5Cb3VuZHMubWluLng7XG5cdFx0XHR9IGVsc2UgaWYoeCA8IF9jdXJyUGFuQm91bmRzLm1heC54KSB7XG5cdFx0XHRcdHggPSBfY3VyclBhbkJvdW5kcy5tYXgueDtcblx0XHRcdH1cblxuXHRcdFx0aWYoeSA+IF9jdXJyUGFuQm91bmRzLm1pbi55KSB7XG5cdFx0XHRcdHkgPSBfY3VyclBhbkJvdW5kcy5taW4ueTtcblx0XHRcdH0gZWxzZSBpZih5IDwgX2N1cnJQYW5Cb3VuZHMubWF4LnkpIHtcblx0XHRcdFx0eSA9IF9jdXJyUGFuQm91bmRzLm1heC55O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRfcGFuT2Zmc2V0LnggPSB4O1xuXHRcdF9wYW5PZmZzZXQueSA9IHk7XG5cdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblx0fSxcblx0XG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblx0XHRpZihfZ2xvYmFsRXZlbnRIYW5kbGVyc1tlLnR5cGVdKSB7XG5cdFx0XHRfZ2xvYmFsRXZlbnRIYW5kbGVyc1tlLnR5cGVdKGUpO1xuXHRcdH1cblx0fSxcblxuXG5cdGdvVG86IGZ1bmN0aW9uKGluZGV4KSB7XG5cblx0XHRpbmRleCA9IF9nZXRMb29wZWRJZChpbmRleCk7XG5cblx0XHR2YXIgZGlmZiA9IGluZGV4IC0gX2N1cnJlbnRJdGVtSW5kZXg7XG5cdFx0X2luZGV4RGlmZiA9IGRpZmY7XG5cblx0XHRfY3VycmVudEl0ZW1JbmRleCA9IGluZGV4O1xuXHRcdHNlbGYuY3Vyckl0ZW0gPSBfZ2V0SXRlbUF0KCBfY3VycmVudEl0ZW1JbmRleCApO1xuXHRcdF9jdXJyUG9zaXRpb25JbmRleCAtPSBkaWZmO1xuXHRcdFxuXHRcdF9tb3ZlTWFpblNjcm9sbChfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXgpO1xuXHRcdFxuXG5cdFx0X3N0b3BBbGxBbmltYXRpb25zKCk7XG5cdFx0X21haW5TY3JvbGxBbmltYXRpbmcgPSBmYWxzZTtcblxuXHRcdHNlbGYudXBkYXRlQ3Vyckl0ZW0oKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi5nb1RvKCBfY3VycmVudEl0ZW1JbmRleCArIDEpO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbigpIHtcblx0XHRzZWxmLmdvVG8oIF9jdXJyZW50SXRlbUluZGV4IC0gMSk7XG5cdH0sXG5cblx0Ly8gdXBkYXRlIGN1cnJlbnQgem9vbS9wYW4gb2JqZWN0c1xuXHR1cGRhdGVDdXJyWm9vbUl0ZW06IGZ1bmN0aW9uKGVtdWxhdGVTZXRDb250ZW50KSB7XG5cdFx0aWYoZW11bGF0ZVNldENvbnRlbnQpIHtcblx0XHRcdF9zaG91dCgnYmVmb3JlQ2hhbmdlJywgMCk7XG5cdFx0fVxuXG5cdFx0Ly8gaXRlbUhvbGRlclsxXSBpcyBtaWRkbGUgKGN1cnJlbnQpIGl0ZW1cblx0XHRpZihfaXRlbUhvbGRlcnNbMV0uZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHR2YXIgem9vbUVsZW1lbnQgPSBfaXRlbUhvbGRlcnNbMV0uZWwuY2hpbGRyZW5bMF07XG5cdFx0XHRpZiggZnJhbWV3b3JrLmhhc0NsYXNzKHpvb21FbGVtZW50LCAncHN3cF9fem9vbS13cmFwJykgKSB7XG5cdFx0XHRcdF9jdXJyWm9vbUVsZW1lbnRTdHlsZSA9IHpvb21FbGVtZW50LnN0eWxlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2N1cnJab29tRWxlbWVudFN0eWxlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0X2N1cnJab29tRWxlbWVudFN0eWxlID0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0X2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kcztcdFxuXHRcdF9zdGFydFpvb21MZXZlbCA9IF9jdXJyWm9vbUxldmVsID0gc2VsZi5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsO1xuXG5cdFx0X3Bhbk9mZnNldC54ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLng7XG5cdFx0X3Bhbk9mZnNldC55ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLnk7XG5cblx0XHRpZihlbXVsYXRlU2V0Q29udGVudCkge1xuXHRcdFx0X3Nob3V0KCdhZnRlckNoYW5nZScpO1xuXHRcdH1cblx0fSxcblxuXG5cdGludmFsaWRhdGVDdXJySXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdF9pdGVtc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBOVU1fSE9MREVSUzsgaSsrKSB7XG5cdFx0XHRpZiggX2l0ZW1Ib2xkZXJzW2ldLml0ZW0gKSB7XG5cdFx0XHRcdF9pdGVtSG9sZGVyc1tpXS5pdGVtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlQ3Vyckl0ZW06IGZ1bmN0aW9uKGJlZm9yZUFuaW1hdGlvbikge1xuXG5cdFx0aWYoX2luZGV4RGlmZiA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBkaWZmQWJzID0gTWF0aC5hYnMoX2luZGV4RGlmZiksXG5cdFx0XHR0ZW1wSG9sZGVyO1xuXG5cdFx0aWYoYmVmb3JlQW5pbWF0aW9uICYmIGRpZmZBYnMgPCAyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cblx0XHRzZWxmLmN1cnJJdGVtID0gX2dldEl0ZW1BdCggX2N1cnJlbnRJdGVtSW5kZXggKTtcblx0XHRfcmVuZGVyTWF4UmVzb2x1dGlvbiA9IGZhbHNlO1xuXHRcdFxuXHRcdF9zaG91dCgnYmVmb3JlQ2hhbmdlJywgX2luZGV4RGlmZik7XG5cblx0XHRpZihkaWZmQWJzID49IE5VTV9IT0xERVJTKSB7XG5cdFx0XHRfY29udGFpbmVyU2hpZnRJbmRleCArPSBfaW5kZXhEaWZmICsgKF9pbmRleERpZmYgPiAwID8gLU5VTV9IT0xERVJTIDogTlVNX0hPTERFUlMpO1xuXHRcdFx0ZGlmZkFicyA9IE5VTV9IT0xERVJTO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGlmZkFiczsgaSsrKSB7XG5cdFx0XHRpZihfaW5kZXhEaWZmID4gMCkge1xuXHRcdFx0XHR0ZW1wSG9sZGVyID0gX2l0ZW1Ib2xkZXJzLnNoaWZ0KCk7XG5cdFx0XHRcdF9pdGVtSG9sZGVyc1tOVU1fSE9MREVSUy0xXSA9IHRlbXBIb2xkZXI7IC8vIG1vdmUgZmlyc3QgdG8gbGFzdFxuXG5cdFx0XHRcdF9jb250YWluZXJTaGlmdEluZGV4Kys7XG5cdFx0XHRcdF9zZXRUcmFuc2xhdGVYKCAoX2NvbnRhaW5lclNoaWZ0SW5kZXgrMikgKiBfc2xpZGVTaXplLngsIHRlbXBIb2xkZXIuZWwuc3R5bGUpO1xuXHRcdFx0XHRzZWxmLnNldENvbnRlbnQodGVtcEhvbGRlciwgX2N1cnJlbnRJdGVtSW5kZXggLSBkaWZmQWJzICsgaSArIDEgKyAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRlbXBIb2xkZXIgPSBfaXRlbUhvbGRlcnMucG9wKCk7XG5cdFx0XHRcdF9pdGVtSG9sZGVycy51bnNoaWZ0KCB0ZW1wSG9sZGVyICk7IC8vIG1vdmUgbGFzdCB0byBmaXJzdFxuXG5cdFx0XHRcdF9jb250YWluZXJTaGlmdEluZGV4LS07XG5cdFx0XHRcdF9zZXRUcmFuc2xhdGVYKCBfY29udGFpbmVyU2hpZnRJbmRleCAqIF9zbGlkZVNpemUueCwgdGVtcEhvbGRlci5lbC5zdHlsZSk7XG5cdFx0XHRcdHNlbGYuc2V0Q29udGVudCh0ZW1wSG9sZGVyLCBfY3VycmVudEl0ZW1JbmRleCArIGRpZmZBYnMgLSBpIC0gMSAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgem9vbS9wYW4gb24gcHJldmlvdXMgaXRlbVxuXHRcdGlmKF9jdXJyWm9vbUVsZW1lbnRTdHlsZSAmJiBNYXRoLmFicyhfaW5kZXhEaWZmKSA9PT0gMSkge1xuXG5cdFx0XHR2YXIgcHJldkl0ZW0gPSBfZ2V0SXRlbUF0KF9wcmV2SXRlbUluZGV4KTtcblx0XHRcdGlmKHByZXZJdGVtLmluaXRpYWxab29tTGV2ZWwgIT09IF9jdXJyWm9vbUxldmVsKSB7XG5cdFx0XHRcdF9jYWxjdWxhdGVJdGVtU2l6ZShwcmV2SXRlbSAsIF92aWV3cG9ydFNpemUgKTtcblx0XHRcdFx0X3NldEltYWdlU2l6ZShwcmV2SXRlbSk7XG5cdFx0XHRcdF9hcHBseVpvb21QYW5Ub0l0ZW0oIHByZXZJdGVtICk7IFx0XHRcdFx0XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXNldCBkaWZmIGFmdGVyIHVwZGF0ZVxuXHRcdF9pbmRleERpZmYgPSAwO1xuXG5cdFx0c2VsZi51cGRhdGVDdXJyWm9vbUl0ZW0oKTtcblxuXHRcdF9wcmV2SXRlbUluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXg7XG5cblx0XHRfc2hvdXQoJ2FmdGVyQ2hhbmdlJyk7XG5cdFx0XG5cdH0sXG5cblxuXG5cdHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGZvcmNlKSB7XG5cdFx0XG5cdFx0aWYoIV9pc0ZpeGVkUG9zaXRpb24gJiYgX29wdGlvbnMubW9kYWwpIHtcblx0XHRcdHZhciB3aW5kb3dTY3JvbGxZID0gZnJhbWV3b3JrLmdldFNjcm9sbFkoKTtcblx0XHRcdGlmKF9jdXJyZW50V2luZG93U2Nyb2xsWSAhPT0gd2luZG93U2Nyb2xsWSkge1xuXHRcdFx0XHR0ZW1wbGF0ZS5zdHlsZS50b3AgPSB3aW5kb3dTY3JvbGxZICsgJ3B4Jztcblx0XHRcdFx0X2N1cnJlbnRXaW5kb3dTY3JvbGxZID0gd2luZG93U2Nyb2xsWTtcblx0XHRcdH1cblx0XHRcdGlmKCFmb3JjZSAmJiBfd2luZG93VmlzaWJsZVNpemUueCA9PT0gd2luZG93LmlubmVyV2lkdGggJiYgX3dpbmRvd1Zpc2libGVTaXplLnkgPT09IHdpbmRvdy5pbm5lckhlaWdodCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRfd2luZG93VmlzaWJsZVNpemUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdFx0X3dpbmRvd1Zpc2libGVTaXplLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cblx0XHRcdC8vdGVtcGxhdGUuc3R5bGUud2lkdGggPSBfd2luZG93VmlzaWJsZVNpemUueCArICdweCc7XG5cdFx0XHR0ZW1wbGF0ZS5zdHlsZS5oZWlnaHQgPSBfd2luZG93VmlzaWJsZVNpemUueSArICdweCc7XG5cdFx0fVxuXG5cblxuXHRcdF92aWV3cG9ydFNpemUueCA9IHNlbGYuc2Nyb2xsV3JhcC5jbGllbnRXaWR0aDtcblx0XHRfdmlld3BvcnRTaXplLnkgPSBzZWxmLnNjcm9sbFdyYXAuY2xpZW50SGVpZ2h0O1xuXG5cdFx0X3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQoKTtcblxuXHRcdF9zbGlkZVNpemUueCA9IF92aWV3cG9ydFNpemUueCArIE1hdGgucm91bmQoX3ZpZXdwb3J0U2l6ZS54ICogX29wdGlvbnMuc3BhY2luZyk7XG5cdFx0X3NsaWRlU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55O1xuXG5cdFx0X21vdmVNYWluU2Nyb2xsKF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleCk7XG5cblx0XHRfc2hvdXQoJ2JlZm9yZVJlc2l6ZScpOyAvLyBldmVuIG1heSBiZSB1c2VkIGZvciBleGFtcGxlIHRvIHN3aXRjaCBpbWFnZSBzb3VyY2VzXG5cblxuXHRcdC8vIGRvbid0IHJlLWNhbGN1bGF0ZSBzaXplIG9uIGluaXRhbCBzaXplIHVwZGF0ZVxuXHRcdGlmKF9jb250YWluZXJTaGlmdEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0dmFyIGhvbGRlcixcblx0XHRcdFx0aXRlbSxcblx0XHRcdFx0aEluZGV4O1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgTlVNX0hPTERFUlM7IGkrKykge1xuXHRcdFx0XHRob2xkZXIgPSBfaXRlbUhvbGRlcnNbaV07XG5cdFx0XHRcdF9zZXRUcmFuc2xhdGVYKCAoaStfY29udGFpbmVyU2hpZnRJbmRleCkgKiBfc2xpZGVTaXplLngsIGhvbGRlci5lbC5zdHlsZSk7XG5cblx0XHRcdFx0aEluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXgraS0xO1xuXG5cdFx0XHRcdGlmKF9vcHRpb25zLmxvb3AgJiYgX2dldE51bUl0ZW1zKCkgPiAyKSB7XG5cdFx0XHRcdFx0aEluZGV4ID0gX2dldExvb3BlZElkKGhJbmRleCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1cGRhdGUgem9vbSBsZXZlbCBvbiBpdGVtcyBhbmQgcmVmcmVzaCBzb3VyY2UgKGlmIG5lZWRzVXBkYXRlKVxuXHRcdFx0XHRpdGVtID0gX2dldEl0ZW1BdCggaEluZGV4ICk7XG5cblx0XHRcdFx0Ly8gcmUtcmVuZGVyIGdhbGxlcnkgaXRlbSBpZiBgbmVlZHNVcGRhdGVgLFxuXHRcdFx0XHQvLyBvciBkb2Vzbid0IGhhdmUgYGJvdW5kc2AgKGVudGlyZWx5IG5ldyBzbGlkZSBvYmplY3QpXG5cdFx0XHRcdGlmKCBpdGVtICYmIChfaXRlbXNOZWVkVXBkYXRlIHx8IGl0ZW0ubmVlZHNVcGRhdGUgfHwgIWl0ZW0uYm91bmRzKSApIHtcblxuXHRcdFx0XHRcdHNlbGYuY2xlYW5TbGlkZSggaXRlbSApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHNlbGYuc2V0Q29udGVudCggaG9sZGVyLCBoSW5kZXggKTtcblxuXHRcdFx0XHRcdC8vIGlmIFwiY2VudGVyXCIgc2xpZGVcblx0XHRcdFx0XHRpZihpID09PSAxKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmN1cnJJdGVtID0gaXRlbTtcblx0XHRcdFx0XHRcdHNlbGYudXBkYXRlQ3Vyclpvb21JdGVtKHRydWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGl0ZW0ubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYoaG9sZGVyLmluZGV4ID09PSAtMSAmJiBoSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdC8vIGFkZCBjb250ZW50IGZpcnN0IHRpbWVcblx0XHRcdFx0XHRzZWxmLnNldENvbnRlbnQoIGhvbGRlciwgaEluZGV4ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoaXRlbSAmJiBpdGVtLmNvbnRhaW5lcikge1xuXHRcdFx0XHRcdF9jYWxjdWxhdGVJdGVtU2l6ZShpdGVtLCBfdmlld3BvcnRTaXplKTtcblx0XHRcdFx0XHRfc2V0SW1hZ2VTaXplKGl0ZW0pO1xuXHRcdFx0XHRcdF9hcHBseVpvb21QYW5Ub0l0ZW0oIGl0ZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdF9pdGVtc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR9XHRcblxuXHRcdF9zdGFydFpvb21MZXZlbCA9IF9jdXJyWm9vbUxldmVsID0gc2VsZi5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsO1xuXHRcdF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7XG5cblx0XHRpZihfY3VyclBhbkJvdW5kcykge1xuXHRcdFx0X3Bhbk9mZnNldC54ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLng7XG5cdFx0XHRfcGFuT2Zmc2V0LnkgPSBfY3VyclBhbkJvdW5kcy5jZW50ZXIueTtcblx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCB0cnVlICk7XG5cdFx0fVxuXHRcdFxuXHRcdF9zaG91dCgncmVzaXplJyk7XG5cdH0sXG5cdFxuXHQvLyBab29tIGN1cnJlbnQgaXRlbSB0b1xuXHR6b29tVG86IGZ1bmN0aW9uKGRlc3Rab29tTGV2ZWwsIGNlbnRlclBvaW50LCBzcGVlZCwgZWFzaW5nRm4sIHVwZGF0ZUZuKSB7XG5cdFx0Lypcblx0XHRcdGlmKGRlc3Rab29tTGV2ZWwgPT09ICdmaXQnKSB7XG5cdFx0XHRcdGRlc3Rab29tTGV2ZWwgPSBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvO1xuXHRcdFx0fSBlbHNlIGlmKGRlc3Rab29tTGV2ZWwgPT09ICdmaWxsJykge1xuXHRcdFx0XHRkZXN0Wm9vbUxldmVsID0gc2VsZi5jdXJySXRlbS5maWxsUmF0aW87XG5cdFx0XHR9XG5cdFx0Ki9cblxuXHRcdGlmKGNlbnRlclBvaW50KSB7XG5cdFx0XHRfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbDtcblx0XHRcdF9taWRab29tUG9pbnQueCA9IE1hdGguYWJzKGNlbnRlclBvaW50LngpIC0gX3Bhbk9mZnNldC54IDtcblx0XHRcdF9taWRab29tUG9pbnQueSA9IE1hdGguYWJzKGNlbnRlclBvaW50LnkpIC0gX3Bhbk9mZnNldC55IDtcblx0XHRcdF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQYW5PZmZzZXQsIF9wYW5PZmZzZXQpO1xuXHRcdH1cblxuXHRcdHZhciBkZXN0UGFuQm91bmRzID0gX2NhbGN1bGF0ZVBhbkJvdW5kcyhkZXN0Wm9vbUxldmVsLCBmYWxzZSksXG5cdFx0XHRkZXN0UGFuT2Zmc2V0ID0ge307XG5cblx0XHRfbW9kaWZ5RGVzdFBhbk9mZnNldCgneCcsIGRlc3RQYW5Cb3VuZHMsIGRlc3RQYW5PZmZzZXQsIGRlc3Rab29tTGV2ZWwpO1xuXHRcdF9tb2RpZnlEZXN0UGFuT2Zmc2V0KCd5JywgZGVzdFBhbkJvdW5kcywgZGVzdFBhbk9mZnNldCwgZGVzdFpvb21MZXZlbCk7XG5cblx0XHR2YXIgaW5pdGlhbFpvb21MZXZlbCA9IF9jdXJyWm9vbUxldmVsO1xuXHRcdHZhciBpbml0aWFsUGFuT2Zmc2V0ID0ge1xuXHRcdFx0eDogX3Bhbk9mZnNldC54LFxuXHRcdFx0eTogX3Bhbk9mZnNldC55XG5cdFx0fTtcblxuXHRcdF9yb3VuZFBvaW50KGRlc3RQYW5PZmZzZXQpO1xuXG5cdFx0dmFyIG9uVXBkYXRlID0gZnVuY3Rpb24obm93KSB7XG5cdFx0XHRpZihub3cgPT09IDEpIHtcblx0XHRcdFx0X2N1cnJab29tTGV2ZWwgPSBkZXN0Wm9vbUxldmVsO1xuXHRcdFx0XHRfcGFuT2Zmc2V0LnggPSBkZXN0UGFuT2Zmc2V0Lng7XG5cdFx0XHRcdF9wYW5PZmZzZXQueSA9IGRlc3RQYW5PZmZzZXQueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9jdXJyWm9vbUxldmVsID0gKGRlc3Rab29tTGV2ZWwgLSBpbml0aWFsWm9vbUxldmVsKSAqIG5vdyArIGluaXRpYWxab29tTGV2ZWw7XG5cdFx0XHRcdF9wYW5PZmZzZXQueCA9IChkZXN0UGFuT2Zmc2V0LnggLSBpbml0aWFsUGFuT2Zmc2V0LngpICogbm93ICsgaW5pdGlhbFBhbk9mZnNldC54O1xuXHRcdFx0XHRfcGFuT2Zmc2V0LnkgPSAoZGVzdFBhbk9mZnNldC55IC0gaW5pdGlhbFBhbk9mZnNldC55KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueTtcblx0XHRcdH1cblxuXHRcdFx0aWYodXBkYXRlRm4pIHtcblx0XHRcdFx0dXBkYXRlRm4obm93KTtcblx0XHRcdH1cblxuXHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oIG5vdyA9PT0gMSApO1xuXHRcdH07XG5cblx0XHRpZihzcGVlZCkge1xuXHRcdFx0X2FuaW1hdGVQcm9wKCdjdXN0b21ab29tVG8nLCAwLCAxLCBzcGVlZCwgZWFzaW5nRm4gfHwgZnJhbWV3b3JrLmVhc2luZy5zaW5lLmluT3V0LCBvblVwZGF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uVXBkYXRlKDEpO1xuXHRcdH1cblx0fVxuXG5cbn07XG5cblxuLyo+PmNvcmUqL1xuXG4vKj4+Z2VzdHVyZXMqL1xuLyoqXG4gKiBNb3VzZS90b3VjaC9wb2ludGVyIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBzZXBhcmF0ZWQgZnJvbSBAY29yZS5qcyBmb3IgcmVhZGFiaWxpdHlcbiAqL1xuXG52YXIgTUlOX1NXSVBFX0RJU1RBTkNFID0gMzAsXG5cdERJUkVDVElPTl9DSEVDS19PRkZTRVQgPSAxMDsgLy8gYW1vdW50IG9mIHBpeGVscyB0byBkcmFnIHRvIGRldGVybWluZSBkaXJlY3Rpb24gb2Ygc3dpcGVcblxudmFyIF9nZXN0dXJlU3RhcnRUaW1lLFxuXHRfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lLFxuXG5cdC8vIHBvb2wgb2Ygb2JqZWN0cyB0aGF0IGFyZSB1c2VkIGR1cmluZyBkcmFnZ2luZyBvZiB6b29taW5nXG5cdHAgPSB7fSwgLy8gZmlyc3QgcG9pbnRcblx0cDIgPSB7fSwgLy8gc2Vjb25kIHBvaW50IChmb3Igem9vbSBnZXN0dXJlKVxuXHRkZWx0YSA9IHt9LFxuXHRfY3VyclBvaW50ID0ge30sXG5cdF9zdGFydFBvaW50ID0ge30sXG5cdF9jdXJyUG9pbnRlcnMgPSBbXSxcblx0X3N0YXJ0TWFpblNjcm9sbFBvcyA9IHt9LFxuXHRfcmVsZWFzZUFuaW1EYXRhLFxuXHRfcG9zUG9pbnRzID0gW10sIC8vIGFycmF5IG9mIHBvaW50cyBkdXJpbmcgZHJhZ2dpbmcsIHVzZWQgdG8gZGV0ZXJtaW5lIHR5cGUgb2YgZ2VzdHVyZVxuXHRfdGVtcFBvaW50ID0ge30sXG5cblx0X2lzWm9vbWluZ0luLFxuXHRfdmVydGljYWxEcmFnSW5pdGlhdGVkLFxuXHRfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCxcblx0X2N1cnJab29tZWRJdGVtSW5kZXggPSAwLFxuXHRfY2VudGVyUG9pbnQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuXHRfbGFzdFJlbGVhc2VUaW1lID0gMCxcblx0X2lzRHJhZ2dpbmcsIC8vIGF0IGxlYXN0IG9uZSBwb2ludGVyIGlzIGRvd25cblx0X2lzTXVsdGl0b3VjaCwgLy8gYXQgbGVhc3QgdHdvIF9wb2ludGVycyBhcmUgZG93blxuXHRfem9vbVN0YXJ0ZWQsIC8vIHpvb20gbGV2ZWwgY2hhbmdlZCBkdXJpbmcgem9vbSBnZXN0dXJlXG5cdF9tb3ZlZCxcblx0X2RyYWdBbmltRnJhbWUsXG5cdF9tYWluU2Nyb2xsU2hpZnRlZCxcblx0X2N1cnJlbnRQb2ludHMsIC8vIGFycmF5IG9mIGN1cnJlbnQgdG91Y2ggcG9pbnRzXG5cdF9pc1pvb21pbmcsXG5cdF9jdXJyUG9pbnRzRGlzdGFuY2UsXG5cdF9zdGFydFBvaW50c0Rpc3RhbmNlLFxuXHRfY3VyclBhbkJvdW5kcyxcblx0X21haW5TY3JvbGxQb3MgPSBfZ2V0RW1wdHlQb2ludCgpLFxuXHRfY3Vyclpvb21FbGVtZW50U3R5bGUsXG5cdF9tYWluU2Nyb2xsQW5pbWF0aW5nLCAvLyB0cnVlLCBpZiBhbmltYXRpb24gYWZ0ZXIgc3dpcGUgZ2VzdHVyZSBpcyBydW5uaW5nXG5cdF9taWRab29tUG9pbnQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuXHRfY3VyckNlbnRlclBvaW50ID0gX2dldEVtcHR5UG9pbnQoKSxcblx0X2RpcmVjdGlvbixcblx0X2lzRmlyc3RNb3ZlLFxuXHRfb3BhY2l0eUNoYW5nZWQsXG5cdF9iZ09wYWNpdHksXG5cdF93YXNPdmVySW5pdGlhbFpvb20sXG5cblx0X2lzRXF1YWxQb2ludHMgPSBmdW5jdGlvbihwMSwgcDIpIHtcblx0XHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xuXHR9LFxuXHRfaXNOZWFyYnlQb2ludHMgPSBmdW5jdGlvbih0b3VjaDAsIHRvdWNoMSkge1xuXHRcdHJldHVybiBNYXRoLmFicyh0b3VjaDAueCAtIHRvdWNoMS54KSA8IERPVUJMRV9UQVBfUkFESVVTICYmIE1hdGguYWJzKHRvdWNoMC55IC0gdG91Y2gxLnkpIDwgRE9VQkxFX1RBUF9SQURJVVM7XG5cdH0sXG5cdF9jYWxjdWxhdGVQb2ludHNEaXN0YW5jZSA9IGZ1bmN0aW9uKHAxLCBwMikge1xuXHRcdF90ZW1wUG9pbnQueCA9IE1hdGguYWJzKCBwMS54IC0gcDIueCApO1xuXHRcdF90ZW1wUG9pbnQueSA9IE1hdGguYWJzKCBwMS55IC0gcDIueSApO1xuXHRcdHJldHVybiBNYXRoLnNxcnQoX3RlbXBQb2ludC54ICogX3RlbXBQb2ludC54ICsgX3RlbXBQb2ludC55ICogX3RlbXBQb2ludC55KTtcblx0fSxcblx0X3N0b3BEcmFnVXBkYXRlTG9vcCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKF9kcmFnQW5pbUZyYW1lKSB7XG5cdFx0XHRfY2FuY2VsQUYoX2RyYWdBbmltRnJhbWUpO1xuXHRcdFx0X2RyYWdBbmltRnJhbWUgPSBudWxsO1xuXHRcdH1cblx0fSxcblx0X2RyYWdVcGRhdGVMb29wID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoX2lzRHJhZ2dpbmcpIHtcblx0XHRcdF9kcmFnQW5pbUZyYW1lID0gX3JlcXVlc3RBRihfZHJhZ1VwZGF0ZUxvb3ApO1xuXHRcdFx0X3JlbmRlck1vdmVtZW50KCk7XG5cdFx0fVxuXHR9LFxuXHRfY2FuUGFuID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEoX29wdGlvbnMuc2NhbGVNb2RlID09PSAnZml0JyAmJiBfY3Vyclpvb21MZXZlbCA9PT0gIHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCk7XG5cdH0sXG5cdFxuXHQvLyBmaW5kIHRoZSBjbG9zZXN0IHBhcmVudCBET00gZWxlbWVudFxuXHRfY2xvc2VzdEVsZW1lbnQgPSBmdW5jdGlvbihlbCwgZm4pIHtcblx0ICBcdGlmKCFlbCB8fCBlbCA9PT0gZG9jdW1lbnQpIHtcblx0ICBcdFx0cmV0dXJuIGZhbHNlO1xuXHQgIFx0fVxuXG5cdCAgXHQvLyBkb24ndCBzZWFyY2ggZWxlbWVudHMgYWJvdmUgcHN3cF9fc2Nyb2xsLXdyYXBcblx0ICBcdGlmKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuaW5kZXhPZigncHN3cF9fc2Nyb2xsLXdyYXAnKSA+IC0xICkge1xuXHQgIFx0XHRyZXR1cm4gZmFsc2U7XG5cdCAgXHR9XG5cblx0ICBcdGlmKCBmbihlbCkgKSB7XG5cdCAgXHRcdHJldHVybiBlbDtcblx0ICBcdH1cblxuXHQgIFx0cmV0dXJuIF9jbG9zZXN0RWxlbWVudChlbC5wYXJlbnROb2RlLCBmbik7XG5cdH0sXG5cblx0X3ByZXZlbnRPYmogPSB7fSxcblx0X3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIgPSBmdW5jdGlvbihlLCBpc0Rvd24pIHtcblx0ICAgIF9wcmV2ZW50T2JqLnByZXZlbnQgPSAhX2Nsb3Nlc3RFbGVtZW50KGUudGFyZ2V0LCBfb3B0aW9ucy5pc0NsaWNrYWJsZUVsZW1lbnQpO1xuXG5cdFx0X3Nob3V0KCdwcmV2ZW50RHJhZ0V2ZW50JywgZSwgaXNEb3duLCBfcHJldmVudE9iaik7XG5cdFx0cmV0dXJuIF9wcmV2ZW50T2JqLnByZXZlbnQ7XG5cblx0fSxcblx0X2NvbnZlcnRUb3VjaFRvUG9pbnQgPSBmdW5jdGlvbih0b3VjaCwgcCkge1xuXHRcdHAueCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHAueSA9IHRvdWNoLnBhZ2VZO1xuXHRcdHAuaWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRfZmluZENlbnRlck9mUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyLCBwQ2VudGVyKSB7XG5cdFx0cENlbnRlci54ID0gKHAxLnggKyBwMi54KSAqIDAuNTtcblx0XHRwQ2VudGVyLnkgPSAocDEueSArIHAyLnkpICogMC41O1xuXHR9LFxuXHRfcHVzaFBvc1BvaW50ID0gZnVuY3Rpb24odGltZSwgeCwgeSkge1xuXHRcdGlmKHRpbWUgLSBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lID4gNTApIHtcblx0XHRcdHZhciBvID0gX3Bvc1BvaW50cy5sZW5ndGggPiAyID8gX3Bvc1BvaW50cy5zaGlmdCgpIDoge307XG5cdFx0XHRvLnggPSB4O1xuXHRcdFx0by55ID0geTsgXG5cdFx0XHRfcG9zUG9pbnRzLnB1c2gobyk7XG5cdFx0XHRfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lID0gdGltZTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbGN1bGF0ZVZlcnRpY2FsRHJhZ09wYWNpdHlSYXRpbyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB5T2Zmc2V0ID0gX3Bhbk9mZnNldC55IC0gc2VsZi5jdXJySXRlbS5pbml0aWFsUG9zaXRpb24ueTsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIGluaXRpYWwgYW5kIGN1cnJlbnQgcG9zaXRpb25cblx0XHRyZXR1cm4gMSAtICBNYXRoLmFicyggeU9mZnNldCAvIChfdmlld3BvcnRTaXplLnkgLyAyKSAgKTtcblx0fSxcblxuXHRcblx0Ly8gcG9pbnRzIHBvb2wsIHJldXNlZCBkdXJpbmcgdG91Y2ggZXZlbnRzXG5cdF9lUG9pbnQxID0ge30sXG5cdF9lUG9pbnQyID0ge30sXG5cdF90ZW1wUG9pbnRzQXJyID0gW10sXG5cdF90ZW1wQ291bnRlcixcblx0X2dldFRvdWNoUG9pbnRzID0gZnVuY3Rpb24oZSkge1xuXHRcdC8vIGNsZWFuIHVwIHByZXZpb3VzIHBvaW50cywgd2l0aG91dCByZWNyZWF0aW5nIGFycmF5XG5cdFx0d2hpbGUoX3RlbXBQb2ludHNBcnIubGVuZ3RoID4gMCkge1xuXHRcdFx0X3RlbXBQb2ludHNBcnIucG9wKCk7XG5cdFx0fVxuXG5cdFx0aWYoIV9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG5cdFx0XHRpZihlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA+IC0xKSB7XG5cblx0XHRcdFx0aWYoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0X3RlbXBQb2ludHNBcnJbMF0gPSBfY29udmVydFRvdWNoVG9Qb2ludChlLnRvdWNoZXNbMF0sIF9lUG9pbnQxKTtcblx0XHRcdFx0XHRpZihlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0X3RlbXBQb2ludHNBcnJbMV0gPSBfY29udmVydFRvdWNoVG9Qb2ludChlLnRvdWNoZXNbMV0sIF9lUG9pbnQyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfZVBvaW50MS54ID0gZS5wYWdlWDtcblx0XHRcdFx0X2VQb2ludDEueSA9IGUucGFnZVk7XG5cdFx0XHRcdF9lUG9pbnQxLmlkID0gJyc7XG5cdFx0XHRcdF90ZW1wUG9pbnRzQXJyWzBdID0gX2VQb2ludDE7Ly9fZVBvaW50MTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0X3RlbXBDb3VudGVyID0gMDtcblx0XHRcdC8vIHdlIGNhbiB1c2UgZm9yRWFjaCwgYXMgcG9pbnRlciBldmVudHMgYXJlIHN1cHBvcnRlZCBvbmx5IGluIG1vZGVybiBicm93c2Vyc1xuXHRcdFx0X2N1cnJQb2ludGVycy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYoX3RlbXBDb3VudGVyID09PSAwKSB7XG5cdFx0XHRcdFx0X3RlbXBQb2ludHNBcnJbMF0gPSBwO1xuXHRcdFx0XHR9IGVsc2UgaWYoX3RlbXBDb3VudGVyID09PSAxKSB7XG5cdFx0XHRcdFx0X3RlbXBQb2ludHNBcnJbMV0gPSBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90ZW1wQ291bnRlcisrO1xuXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIF90ZW1wUG9pbnRzQXJyO1xuXHR9LFxuXG5cdF9wYW5Pck1vdmVNYWluU2Nyb2xsID0gZnVuY3Rpb24oYXhpcywgZGVsdGEpIHtcblxuXHRcdHZhciBwYW5GcmljdGlvbixcblx0XHRcdG92ZXJEaWZmID0gMCxcblx0XHRcdG5ld09mZnNldCA9IF9wYW5PZmZzZXRbYXhpc10gKyBkZWx0YVtheGlzXSxcblx0XHRcdHN0YXJ0T3ZlckRpZmYsXG5cdFx0XHRkaXIgPSBkZWx0YVtheGlzXSA+IDAsXG5cdFx0XHRuZXdNYWluU2Nyb2xsUG9zaXRpb24gPSBfbWFpblNjcm9sbFBvcy54ICsgZGVsdGEueCxcblx0XHRcdG1haW5TY3JvbGxEaWZmID0gX21haW5TY3JvbGxQb3MueCAtIF9zdGFydE1haW5TY3JvbGxQb3MueCxcblx0XHRcdG5ld1BhblBvcyxcblx0XHRcdG5ld01haW5TY3JvbGxQb3M7XG5cblx0XHQvLyBjYWxjdWxhdGUgZmRpc3RhbmNlIG92ZXIgdGhlIGJvdW5kcyBhbmQgZnJpY3Rpb25cblx0XHRpZihuZXdPZmZzZXQgPiBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10gfHwgbmV3T2Zmc2V0IDwgX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdKSB7XG5cdFx0XHRwYW5GcmljdGlvbiA9IF9vcHRpb25zLnBhbkVuZEZyaWN0aW9uO1xuXHRcdFx0Ly8gTGluZWFyIGluY3JlYXNpbmcgb2YgZnJpY3Rpb24sIHNvIGF0IDEvNCBvZiB2aWV3cG9ydCBpdCdzIGF0IG1heCB2YWx1ZS4gXG5cdFx0XHQvLyBMb29rcyBub3QgYXMgbmljZSBhcyB3YXMgZXhwZWN0ZWQuIExlZnQgZm9yIGhpc3RvcnkuXG5cdFx0XHQvLyBwYW5GcmljdGlvbiA9ICgxIC0gKF9wYW5PZmZzZXRbYXhpc10gKyBkZWx0YVtheGlzXSArIHBhbkJvdW5kcy5taW5bYXhpc10pIC8gKF92aWV3cG9ydFNpemVbYXhpc10gLyA0KSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYW5GcmljdGlvbiA9IDE7XG5cdFx0fVxuXHRcdFxuXHRcdG5ld09mZnNldCA9IF9wYW5PZmZzZXRbYXhpc10gKyBkZWx0YVtheGlzXSAqIHBhbkZyaWN0aW9uO1xuXG5cdFx0Ly8gbW92ZSBtYWluIHNjcm9sbCBvciBzdGFydCBwYW5uaW5nXG5cdFx0aWYoX29wdGlvbnMuYWxsb3dQYW5Ub05leHQgfHwgX2N1cnJab29tTGV2ZWwgPT09IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkge1xuXG5cblx0XHRcdGlmKCFfY3Vyclpvb21FbGVtZW50U3R5bGUpIHtcblx0XHRcdFx0XG5cdFx0XHRcdG5ld01haW5TY3JvbGxQb3MgPSBuZXdNYWluU2Nyb2xsUG9zaXRpb247XG5cblx0XHRcdH0gZWxzZSBpZihfZGlyZWN0aW9uID09PSAnaCcgJiYgYXhpcyA9PT0gJ3gnICYmICFfem9vbVN0YXJ0ZWQgKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZihkaXIpIHtcblx0XHRcdFx0XHRpZihuZXdPZmZzZXQgPiBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10pIHtcblx0XHRcdFx0XHRcdHBhbkZyaWN0aW9uID0gX29wdGlvbnMucGFuRW5kRnJpY3Rpb247XG5cdFx0XHRcdFx0XHRvdmVyRGlmZiA9IF9jdXJyUGFuQm91bmRzLm1pbltheGlzXSAtIG5ld09mZnNldDtcblx0XHRcdFx0XHRcdHN0YXJ0T3ZlckRpZmYgPSBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10gLSBfc3RhcnRQYW5PZmZzZXRbYXhpc107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGRyYWcgcmlnaHRcblx0XHRcdFx0XHRpZiggKHN0YXJ0T3ZlckRpZmYgPD0gMCB8fCBtYWluU2Nyb2xsRGlmZiA8IDApICYmIF9nZXROdW1JdGVtcygpID4gMSApIHtcblx0XHRcdFx0XHRcdG5ld01haW5TY3JvbGxQb3MgPSBuZXdNYWluU2Nyb2xsUG9zaXRpb247XG5cdFx0XHRcdFx0XHRpZihtYWluU2Nyb2xsRGlmZiA8IDAgJiYgbmV3TWFpblNjcm9sbFBvc2l0aW9uID4gX3N0YXJ0TWFpblNjcm9sbFBvcy54KSB7XG5cdFx0XHRcdFx0XHRcdG5ld01haW5TY3JvbGxQb3MgPSBfc3RhcnRNYWluU2Nyb2xsUG9zLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmKF9jdXJyUGFuQm91bmRzLm1pbi54ICE9PSBfY3VyclBhbkJvdW5kcy5tYXgueCkge1xuXHRcdFx0XHRcdFx0XHRuZXdQYW5Qb3MgPSBuZXdPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmKG5ld09mZnNldCA8IF9jdXJyUGFuQm91bmRzLm1heFtheGlzXSApIHtcblx0XHRcdFx0XHRcdHBhbkZyaWN0aW9uID1fb3B0aW9ucy5wYW5FbmRGcmljdGlvbjtcblx0XHRcdFx0XHRcdG92ZXJEaWZmID0gbmV3T2Zmc2V0IC0gX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdO1xuXHRcdFx0XHRcdFx0c3RhcnRPdmVyRGlmZiA9IF9zdGFydFBhbk9mZnNldFtheGlzXSAtIF9jdXJyUGFuQm91bmRzLm1heFtheGlzXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiggKHN0YXJ0T3ZlckRpZmYgPD0gMCB8fCBtYWluU2Nyb2xsRGlmZiA+IDApICYmIF9nZXROdW1JdGVtcygpID4gMSApIHtcblx0XHRcdFx0XHRcdG5ld01haW5TY3JvbGxQb3MgPSBuZXdNYWluU2Nyb2xsUG9zaXRpb247XG5cblx0XHRcdFx0XHRcdGlmKG1haW5TY3JvbGxEaWZmID4gMCAmJiBuZXdNYWluU2Nyb2xsUG9zaXRpb24gPCBfc3RhcnRNYWluU2Nyb2xsUG9zLngpIHtcblx0XHRcdFx0XHRcdFx0bmV3TWFpblNjcm9sbFBvcyA9IF9zdGFydE1haW5TY3JvbGxQb3MueDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZihfY3VyclBhbkJvdW5kcy5taW4ueCAhPT0gX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcblx0XHRcdFx0XHRcdFx0bmV3UGFuUG9zID0gbmV3T2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvL1xuXHRcdFx0fVxuXG5cdFx0XHRpZihheGlzID09PSAneCcpIHtcblxuXHRcdFx0XHRpZihuZXdNYWluU2Nyb2xsUG9zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRfbW92ZU1haW5TY3JvbGwobmV3TWFpblNjcm9sbFBvcywgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYobmV3TWFpblNjcm9sbFBvcyA9PT0gX3N0YXJ0TWFpblNjcm9sbFBvcy54KSB7XG5cdFx0XHRcdFx0XHRfbWFpblNjcm9sbFNoaWZ0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X21haW5TY3JvbGxTaGlmdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihfY3VyclBhbkJvdW5kcy5taW4ueCAhPT0gX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcblx0XHRcdFx0XHRpZihuZXdQYW5Qb3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0X3Bhbk9mZnNldC54ID0gbmV3UGFuUG9zO1xuXHRcdFx0XHRcdH0gZWxzZSBpZighX21haW5TY3JvbGxTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRfcGFuT2Zmc2V0LnggKz0gZGVsdGEueCAqIHBhbkZyaWN0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXdNYWluU2Nyb2xsUG9zICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZighX21haW5TY3JvbGxBbmltYXRpbmcpIHtcblx0XHRcdFxuXHRcdFx0aWYoIV9tYWluU2Nyb2xsU2hpZnRlZCkge1xuXHRcdFx0XHRpZihfY3Vyclpvb21MZXZlbCA+IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pIHtcblx0XHRcdFx0XHRfcGFuT2Zmc2V0W2F4aXNdICs9IGRlbHRhW2F4aXNdICogcGFuRnJpY3Rpb247XG5cdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdFxuXHRcdH1cblx0XHRcblx0fSxcblxuXHQvLyBQb2ludGVyZG93bi90b3VjaHN0YXJ0L21vdXNlZG93biBoYW5kbGVyXG5cdF9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdC8vIEFsbG93IGRyYWdnaW5nIG9ubHkgdmlhIGxlZnQgbW91c2UgYnV0dG9uLlxuXHRcdC8vIEFzIHRoaXMgaGFuZGxlciBpcyBub3QgYWRkZWQgaW4gSUU4IC0gd2UgaWdub3JlIGUud2hpY2hcblx0XHQvLyBcblx0XHQvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZXZlbnQuYnV0dG9uXG5cdFx0aWYoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBlLmJ1dHRvbiA+IDAgICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKF9pbml0aWFsWm9vbVJ1bm5pbmcpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCAmJiBlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoX3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIoZSwgdHJ1ZSkpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblxuXG5cdFx0X3Nob3V0KCdwb2ludGVyRG93bicpO1xuXG5cdFx0aWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcblx0XHRcdHZhciBwb2ludGVySW5kZXggPSBmcmFtZXdvcmsuYXJyYXlTZWFyY2goX2N1cnJQb2ludGVycywgZS5wb2ludGVySWQsICdpZCcpO1xuXHRcdFx0aWYocG9pbnRlckluZGV4IDwgMCkge1xuXHRcdFx0XHRwb2ludGVySW5kZXggPSBfY3VyclBvaW50ZXJzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdF9jdXJyUG9pbnRlcnNbcG9pbnRlckluZGV4XSA9IHt4OmUucGFnZVgsIHk6ZS5wYWdlWSwgaWQ6IGUucG9pbnRlcklkfTtcblx0XHR9XG5cdFx0XG5cblxuXHRcdHZhciBzdGFydFBvaW50c0xpc3QgPSBfZ2V0VG91Y2hQb2ludHMoZSksXG5cdFx0XHRudW1Qb2ludHMgPSBzdGFydFBvaW50c0xpc3QubGVuZ3RoO1xuXG5cdFx0X2N1cnJlbnRQb2ludHMgPSBudWxsO1xuXG5cdFx0X3N0b3BBbGxBbmltYXRpb25zKCk7XG5cblx0XHQvLyBpbml0IGRyYWdcblx0XHRpZighX2lzRHJhZ2dpbmcgfHwgbnVtUG9pbnRzID09PSAxKSB7XG5cblx0XHRcdFxuXG5cdFx0XHRfaXNEcmFnZ2luZyA9IF9pc0ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0XHRmcmFtZXdvcmsuYmluZCh3aW5kb3csIF91cE1vdmVFdmVudHMsIHNlbGYpO1xuXG5cdFx0XHRfaXNab29taW5nSW4gPSBcblx0XHRcdFx0X3dhc092ZXJJbml0aWFsWm9vbSA9IFxuXHRcdFx0XHRfb3BhY2l0eUNoYW5nZWQgPSBcblx0XHRcdFx0X3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCA9IFxuXHRcdFx0XHRfbWFpblNjcm9sbFNoaWZ0ZWQgPSBcblx0XHRcdFx0X21vdmVkID0gXG5cdFx0XHRcdF9pc011bHRpdG91Y2ggPSBcblx0XHRcdFx0X3pvb21TdGFydGVkID0gZmFsc2U7XG5cblx0XHRcdF9kaXJlY3Rpb24gPSBudWxsO1xuXG5cdFx0XHRfc2hvdXQoJ2ZpcnN0VG91Y2hTdGFydCcsIHN0YXJ0UG9pbnRzTGlzdCk7XG5cblx0XHRcdF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQYW5PZmZzZXQsIF9wYW5PZmZzZXQpO1xuXG5cdFx0XHRfY3VyclBhbkRpc3QueCA9IF9jdXJyUGFuRGlzdC55ID0gMDtcblx0XHRcdF9lcXVhbGl6ZVBvaW50cyhfY3VyclBvaW50LCBzdGFydFBvaW50c0xpc3RbMF0pO1xuXHRcdFx0X2VxdWFsaXplUG9pbnRzKF9zdGFydFBvaW50LCBfY3VyclBvaW50KTtcblxuXHRcdFx0Ly9fZXF1YWxpemVQb2ludHMoX3N0YXJ0TWFpblNjcm9sbFBvcywgX21haW5TY3JvbGxQb3MpO1xuXHRcdFx0X3N0YXJ0TWFpblNjcm9sbFBvcy54ID0gX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4O1xuXG5cdFx0XHRfcG9zUG9pbnRzID0gW3tcblx0XHRcdFx0eDogX2N1cnJQb2ludC54LFxuXHRcdFx0XHR5OiBfY3VyclBvaW50Lnlcblx0XHRcdH1dO1xuXG5cdFx0XHRfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lID0gX2dlc3R1cmVTdGFydFRpbWUgPSBfZ2V0Q3VycmVudFRpbWUoKTtcblxuXHRcdFx0Ly9fbWFpblNjcm9sbEFuaW1hdGlvbkVuZCh0cnVlKTtcblx0XHRcdF9jYWxjdWxhdGVQYW5Cb3VuZHMoIF9jdXJyWm9vbUxldmVsLCB0cnVlICk7XG5cdFx0XHRcblx0XHRcdC8vIFN0YXJ0IHJlbmRlcmluZ1xuXHRcdFx0X3N0b3BEcmFnVXBkYXRlTG9vcCgpO1xuXHRcdFx0X2RyYWdVcGRhdGVMb29wKCk7XG5cdFx0XHRcblx0XHR9XG5cblx0XHQvLyBpbml0IHpvb21cblx0XHRpZighX2lzWm9vbWluZyAmJiBudW1Qb2ludHMgPiAxICYmICFfbWFpblNjcm9sbEFuaW1hdGluZyAmJiAhX21haW5TY3JvbGxTaGlmdGVkKSB7XG5cdFx0XHRfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbDtcblx0XHRcdF96b29tU3RhcnRlZCA9IGZhbHNlOyAvLyB0cnVlIGlmIHpvb20gY2hhbmdlZCBhdCBsZWFzdCBvbmNlXG5cblx0XHRcdF9pc1pvb21pbmcgPSBfaXNNdWx0aXRvdWNoID0gdHJ1ZTtcblx0XHRcdF9jdXJyUGFuRGlzdC55ID0gX2N1cnJQYW5EaXN0LnggPSAwO1xuXG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX3N0YXJ0UGFuT2Zmc2V0LCBfcGFuT2Zmc2V0KTtcblxuXHRcdFx0X2VxdWFsaXplUG9pbnRzKHAsIHN0YXJ0UG9pbnRzTGlzdFswXSk7XG5cdFx0XHRfZXF1YWxpemVQb2ludHMocDIsIHN0YXJ0UG9pbnRzTGlzdFsxXSk7XG5cblx0XHRcdF9maW5kQ2VudGVyT2ZQb2ludHMocCwgcDIsIF9jdXJyQ2VudGVyUG9pbnQpO1xuXG5cdFx0XHRfbWlkWm9vbVBvaW50LnggPSBNYXRoLmFicyhfY3VyckNlbnRlclBvaW50LngpIC0gX3Bhbk9mZnNldC54O1xuXHRcdFx0X21pZFpvb21Qb2ludC55ID0gTWF0aC5hYnMoX2N1cnJDZW50ZXJQb2ludC55KSAtIF9wYW5PZmZzZXQueTtcblx0XHRcdF9jdXJyUG9pbnRzRGlzdGFuY2UgPSBfc3RhcnRQb2ludHNEaXN0YW5jZSA9IF9jYWxjdWxhdGVQb2ludHNEaXN0YW5jZShwLCBwMik7XG5cdFx0fVxuXG5cblx0fSxcblxuXHQvLyBQb2ludGVybW92ZS90b3VjaG1vdmUvbW91c2Vtb3ZlIGhhbmRsZXJcblx0X29uRHJhZ01vdmUgPSBmdW5jdGlvbihlKSB7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZihfcG9pbnRlckV2ZW50RW5hYmxlZCkge1xuXHRcdFx0dmFyIHBvaW50ZXJJbmRleCA9IGZyYW1ld29yay5hcnJheVNlYXJjaChfY3VyclBvaW50ZXJzLCBlLnBvaW50ZXJJZCwgJ2lkJyk7XG5cdFx0XHRpZihwb2ludGVySW5kZXggPiAtMSkge1xuXHRcdFx0XHR2YXIgcCA9IF9jdXJyUG9pbnRlcnNbcG9pbnRlckluZGV4XTtcblx0XHRcdFx0cC54ID0gZS5wYWdlWDtcblx0XHRcdFx0cC55ID0gZS5wYWdlWTsgXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoX2lzRHJhZ2dpbmcpIHtcblx0XHRcdHZhciB0b3VjaGVzTGlzdCA9IF9nZXRUb3VjaFBvaW50cyhlKTtcblx0XHRcdGlmKCFfZGlyZWN0aW9uICYmICFfbW92ZWQgJiYgIV9pc1pvb21pbmcpIHtcblxuXHRcdFx0XHRpZihfbWFpblNjcm9sbFBvcy54ICE9PSBfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXgpIHtcblx0XHRcdFx0XHQvLyBpZiBtYWluIHNjcm9sbCBwb3NpdGlvbiBpcyBzaGlmdGVkIOKAkyBkaXJlY3Rpb24gaXMgYWx3YXlzIGhvcml6b250YWxcblx0XHRcdFx0XHRfZGlyZWN0aW9uID0gJ2gnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBkaWZmID0gTWF0aC5hYnModG91Y2hlc0xpc3RbMF0ueCAtIF9jdXJyUG9pbnQueCkgLSBNYXRoLmFicyh0b3VjaGVzTGlzdFswXS55IC0gX2N1cnJQb2ludC55KTtcblx0XHRcdFx0XHQvLyBjaGVjayB0aGUgZGlyZWN0aW9uIG9mIG1vdmVtZW50XG5cdFx0XHRcdFx0aWYoTWF0aC5hYnMoZGlmZikgPj0gRElSRUNUSU9OX0NIRUNLX09GRlNFVCkge1xuXHRcdFx0XHRcdFx0X2RpcmVjdGlvbiA9IGRpZmYgPiAwID8gJ2gnIDogJ3YnO1xuXHRcdFx0XHRcdFx0X2N1cnJlbnRQb2ludHMgPSB0b3VjaGVzTGlzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfY3VycmVudFBvaW50cyA9IHRvdWNoZXNMaXN0O1xuXHRcdFx0fVxuXHRcdH1cdFxuXHR9LFxuXHQvLyBcblx0X3JlbmRlck1vdmVtZW50ID0gIGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYoIV9jdXJyZW50UG9pbnRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG51bVBvaW50cyA9IF9jdXJyZW50UG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmKG51bVBvaW50cyA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF9lcXVhbGl6ZVBvaW50cyhwLCBfY3VycmVudFBvaW50c1swXSk7XG5cblx0XHRkZWx0YS54ID0gcC54IC0gX2N1cnJQb2ludC54O1xuXHRcdGRlbHRhLnkgPSBwLnkgLSBfY3VyclBvaW50Lnk7XG5cblx0XHRpZihfaXNab29taW5nICYmIG51bVBvaW50cyA+IDEpIHtcblx0XHRcdC8vIEhhbmRsZSBiZWhhdmlvdXIgZm9yIG1vcmUgdGhhbiAxIHBvaW50XG5cblx0XHRcdF9jdXJyUG9pbnQueCA9IHAueDtcblx0XHRcdF9jdXJyUG9pbnQueSA9IHAueTtcblx0XHRcblx0XHRcdC8vIGNoZWNrIGlmIG9uZSBvZiB0d28gcG9pbnRzIGNoYW5nZWRcblx0XHRcdGlmKCAhZGVsdGEueCAmJiAhZGVsdGEueSAmJiBfaXNFcXVhbFBvaW50cyhfY3VycmVudFBvaW50c1sxXSwgcDIpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdF9lcXVhbGl6ZVBvaW50cyhwMiwgX2N1cnJlbnRQb2ludHNbMV0pO1xuXG5cblx0XHRcdGlmKCFfem9vbVN0YXJ0ZWQpIHtcblx0XHRcdFx0X3pvb21TdGFydGVkID0gdHJ1ZTtcblx0XHRcdFx0X3Nob3V0KCd6b29tR2VzdHVyZVN0YXJ0ZWQnKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG5cdFx0XHR2YXIgcG9pbnRzRGlzdGFuY2UgPSBfY2FsY3VsYXRlUG9pbnRzRGlzdGFuY2UocCxwMik7XG5cblx0XHRcdHZhciB6b29tTGV2ZWwgPSBfY2FsY3VsYXRlWm9vbUxldmVsKHBvaW50c0Rpc3RhbmNlKTtcblxuXHRcdFx0Ly8gc2xpZ2h0bHkgb3ZlciB0aGUgb2YgaW5pdGlhbCB6b29tIGxldmVsXG5cdFx0XHRpZih6b29tTGV2ZWwgPiBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwgKyBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwgLyAxNSkge1xuXHRcdFx0XHRfd2FzT3ZlckluaXRpYWxab29tID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgdGhlIGZyaWN0aW9uIGlmIHpvb20gbGV2ZWwgaXMgb3V0IG9mIHRoZSBib3VuZHNcblx0XHRcdHZhciB6b29tRnJpY3Rpb24gPSAxLFxuXHRcdFx0XHRtaW5ab29tTGV2ZWwgPSBfZ2V0TWluWm9vbUxldmVsKCksXG5cdFx0XHRcdG1heFpvb21MZXZlbCA9IF9nZXRNYXhab29tTGV2ZWwoKTtcblxuXHRcdFx0aWYgKCB6b29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwgKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZihfb3B0aW9ucy5waW5jaFRvQ2xvc2UgJiYgIV93YXNPdmVySW5pdGlhbFpvb20gJiYgX3N0YXJ0Wm9vbUxldmVsIDw9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkge1xuXHRcdFx0XHRcdC8vIGZhZGUgb3V0IGJhY2tncm91bmQgaWYgem9vbWluZyBvdXRcblx0XHRcdFx0XHR2YXIgbWludXNEaWZmID0gbWluWm9vbUxldmVsIC0gem9vbUxldmVsO1xuXHRcdFx0XHRcdHZhciBwZXJjZW50ID0gMSAtIG1pbnVzRGlmZiAvIChtaW5ab29tTGV2ZWwgLyAxLjIpO1xuXG5cdFx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KHBlcmNlbnQpO1xuXHRcdFx0XHRcdF9zaG91dCgnb25QaW5jaENsb3NlJywgcGVyY2VudCk7XG5cdFx0XHRcdFx0X29wYWNpdHlDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR6b29tRnJpY3Rpb24gPSAobWluWm9vbUxldmVsIC0gem9vbUxldmVsKSAvIG1pblpvb21MZXZlbDtcblx0XHRcdFx0XHRpZih6b29tRnJpY3Rpb24gPiAxKSB7XG5cdFx0XHRcdFx0XHR6b29tRnJpY3Rpb24gPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR6b29tTGV2ZWwgPSBtaW5ab29tTGV2ZWwgLSB6b29tRnJpY3Rpb24gKiAobWluWm9vbUxldmVsIC8gMyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYgKCB6b29tTGV2ZWwgPiBtYXhab29tTGV2ZWwgKSB7XG5cdFx0XHRcdC8vIDEuNSAtIGV4dHJhIHpvb20gbGV2ZWwgYWJvdmUgdGhlIG1heC4gRS5nLiBpZiBtYXggaXMgeDYsIHJlYWwgbWF4IDYgKyAxLjUgPSA3LjVcblx0XHRcdFx0em9vbUZyaWN0aW9uID0gKHpvb21MZXZlbCAtIG1heFpvb21MZXZlbCkgLyAoIG1pblpvb21MZXZlbCAqIDYgKTtcblx0XHRcdFx0aWYoem9vbUZyaWN0aW9uID4gMSkge1xuXHRcdFx0XHRcdHpvb21GcmljdGlvbiA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0em9vbUxldmVsID0gbWF4Wm9vbUxldmVsICsgem9vbUZyaWN0aW9uICogbWluWm9vbUxldmVsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih6b29tRnJpY3Rpb24gPCAwKSB7XG5cdFx0XHRcdHpvb21GcmljdGlvbiA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRpc3RhbmNlIGJldHdlZW4gdG91Y2ggcG9pbnRzIGFmdGVyIGZyaWN0aW9uIGlzIGFwcGxpZWRcblx0XHRcdF9jdXJyUG9pbnRzRGlzdGFuY2UgPSBwb2ludHNEaXN0YW5jZTtcblxuXHRcdFx0Ly8gX2NlbnRlclBvaW50IC0gVGhlIHBvaW50IGluIHRoZSBtaWRkbGUgb2YgdHdvIHBvaW50ZXJzXG5cdFx0XHRfZmluZENlbnRlck9mUG9pbnRzKHAsIHAyLCBfY2VudGVyUG9pbnQpO1xuXHRcdFxuXHRcdFx0Ly8gcGFuaW5nIHdpdGggdHdvIHBvaW50ZXJzIHByZXNzZWRcblx0XHRcdF9jdXJyUGFuRGlzdC54ICs9IF9jZW50ZXJQb2ludC54IC0gX2N1cnJDZW50ZXJQb2ludC54O1xuXHRcdFx0X2N1cnJQYW5EaXN0LnkgKz0gX2NlbnRlclBvaW50LnkgLSBfY3VyckNlbnRlclBvaW50Lnk7XG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX2N1cnJDZW50ZXJQb2ludCwgX2NlbnRlclBvaW50KTtcblxuXHRcdFx0X3Bhbk9mZnNldC54ID0gX2NhbGN1bGF0ZVBhbk9mZnNldCgneCcsIHpvb21MZXZlbCk7XG5cdFx0XHRfcGFuT2Zmc2V0LnkgPSBfY2FsY3VsYXRlUGFuT2Zmc2V0KCd5Jywgem9vbUxldmVsKTtcblxuXHRcdFx0X2lzWm9vbWluZ0luID0gem9vbUxldmVsID4gX2N1cnJab29tTGV2ZWw7XG5cdFx0XHRfY3Vyclpvb21MZXZlbCA9IHpvb21MZXZlbDtcblx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBoYW5kbGUgYmVoYXZpb3VyIGZvciBvbmUgcG9pbnQgKGRyYWdnaW5nIG9yIHBhbm5pbmcpXG5cblx0XHRcdGlmKCFfZGlyZWN0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoX2lzRmlyc3RNb3ZlKSB7XG5cdFx0XHRcdF9pc0ZpcnN0TW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHN1YnRyYWN0IGRyYWcgZGlzdGFuY2UgdGhhdCB3YXMgdXNlZCBkdXJpbmcgdGhlIGRldGVjdGlvbiBkaXJlY3Rpb24gIFxuXG5cdFx0XHRcdGlmKCBNYXRoLmFicyhkZWx0YS54KSA+PSBESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUKSB7XG5cdFx0XHRcdFx0ZGVsdGEueCAtPSBfY3VycmVudFBvaW50c1swXS54IC0gX3N0YXJ0UG9pbnQueDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYoIE1hdGguYWJzKGRlbHRhLnkpID49IERJUkVDVElPTl9DSEVDS19PRkZTRVQpIHtcblx0XHRcdFx0XHRkZWx0YS55IC09IF9jdXJyZW50UG9pbnRzWzBdLnkgLSBfc3RhcnRQb2ludC55O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9jdXJyUG9pbnQueCA9IHAueDtcblx0XHRcdF9jdXJyUG9pbnQueSA9IHAueTtcblxuXHRcdFx0Ly8gZG8gbm90aGluZyBpZiBwb2ludGVycyBwb3NpdGlvbiBoYXNuJ3QgY2hhbmdlZFxuXHRcdFx0aWYoZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoX2RpcmVjdGlvbiA9PT0gJ3YnICYmIF9vcHRpb25zLmNsb3NlT25WZXJ0aWNhbERyYWcpIHtcblx0XHRcdFx0aWYoIV9jYW5QYW4oKSkge1xuXHRcdFx0XHRcdF9jdXJyUGFuRGlzdC55ICs9IGRlbHRhLnk7XG5cdFx0XHRcdFx0X3Bhbk9mZnNldC55ICs9IGRlbHRhLnk7XG5cblx0XHRcdFx0XHR2YXIgb3BhY2l0eVJhdGlvID0gX2NhbGN1bGF0ZVZlcnRpY2FsRHJhZ09wYWNpdHlSYXRpbygpO1xuXG5cdFx0XHRcdFx0X3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0X3Nob3V0KCdvblZlcnRpY2FsRHJhZycsIG9wYWNpdHlSYXRpbyk7XG5cblx0XHRcdFx0XHRfYXBwbHlCZ09wYWNpdHkob3BhY2l0eVJhdGlvKTtcblx0XHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0XHRcdHJldHVybiA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X3B1c2hQb3NQb2ludChfZ2V0Q3VycmVudFRpbWUoKSwgcC54LCBwLnkpO1xuXG5cdFx0XHRfbW92ZWQgPSB0cnVlO1xuXHRcdFx0X2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kcztcblx0XHRcdFxuXHRcdFx0dmFyIG1haW5TY3JvbGxDaGFuZ2VkID0gX3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3gnLCBkZWx0YSk7XG5cdFx0XHRpZighbWFpblNjcm9sbENoYW5nZWQpIHtcblx0XHRcdFx0X3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3knLCBkZWx0YSk7XG5cblx0XHRcdFx0X3JvdW5kUG9pbnQoX3Bhbk9mZnNldCk7XG5cdFx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblx0XG5cdC8vIFBvaW50ZXJ1cC9wb2ludGVyY2FuY2VsL3RvdWNoZW5kL3RvdWNoY2FuY2VsL21vdXNldXAgZXZlbnQgaGFuZGxlclxuXHRfb25EcmFnUmVsZWFzZSA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdGlmKF9mZWF0dXJlcy5pc09sZEFuZHJvaWQgKSB7XG5cblx0XHRcdGlmKF9vbGRBbmRyb2lkVG91Y2hFbmRUaW1lb3V0ICYmIGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb24gQW5kcm9pZCAodjQuMSwgNC4yLCA0LjMgJiBwb3NzaWJseSBvbGRlcikgXG5cdFx0XHQvLyBnaG9zdCBtb3VzZWRvd24vdXAgZXZlbnQgaXNuJ3QgcHJldmVudGFibGUgdmlhIGUucHJldmVudERlZmF1bHQsXG5cdFx0XHQvLyB3aGljaCBjYXVzZXMgZmFrZSBtb3VzZWRvd24gZXZlbnRcblx0XHRcdC8vIHNvIHdlIGJsb2NrIG1vdXNlZG93bi91cCBmb3IgNjAwbXNcblx0XHRcdGlmKCBlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA+IC0xICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQpO1xuXHRcdFx0XHRfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgPSAwO1xuXHRcdFx0XHR9LCA2MDApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXG5cdFx0X3Nob3V0KCdwb2ludGVyVXAnKTtcblxuXHRcdGlmKF9wcmV2ZW50RGVmYXVsdEV2ZW50QmVoYXZpb3VyKGUsIGZhbHNlKSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciByZWxlYXNlUG9pbnQ7XG5cblx0XHRpZihfcG9pbnRlckV2ZW50RW5hYmxlZCkge1xuXHRcdFx0dmFyIHBvaW50ZXJJbmRleCA9IGZyYW1ld29yay5hcnJheVNlYXJjaChfY3VyclBvaW50ZXJzLCBlLnBvaW50ZXJJZCwgJ2lkJyk7XG5cdFx0XHRcblx0XHRcdGlmKHBvaW50ZXJJbmRleCA+IC0xKSB7XG5cdFx0XHRcdHJlbGVhc2VQb2ludCA9IF9jdXJyUG9pbnRlcnMuc3BsaWNlKHBvaW50ZXJJbmRleCwgMSlbMF07XG5cblx0XHRcdFx0aWYobmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcblx0XHRcdFx0XHR2YXIgTVNQT0lOVEVSX1RZUEVTID0ge1xuXHRcdFx0XHRcdFx0NDogJ21vdXNlJywgLy8gZXZlbnQuTVNQT0lOVEVSX1RZUEVfTU9VU0Vcblx0XHRcdFx0XHRcdDI6ICd0b3VjaCcsIC8vIGV2ZW50Lk1TUE9JTlRFUl9UWVBFX1RPVUNIIFxuXHRcdFx0XHRcdFx0MzogJ3BlbicgLy8gZXZlbnQuTVNQT0lOVEVSX1RZUEVfUEVOXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZWxlYXNlUG9pbnQudHlwZSA9IE1TUE9JTlRFUl9UWVBFU1tlLnBvaW50ZXJUeXBlXTtcblxuXHRcdFx0XHRcdGlmKCFyZWxlYXNlUG9pbnQudHlwZSkge1xuXHRcdFx0XHRcdFx0cmVsZWFzZVBvaW50LnR5cGUgPSBlLnBvaW50ZXJUeXBlIHx8ICdtb3VzZSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlbGVhc2VQb2ludC50eXBlID0gZS5wb2ludGVyVHlwZSB8fCAnbW91c2UnO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgdG91Y2hMaXN0ID0gX2dldFRvdWNoUG9pbnRzKGUpLFxuXHRcdFx0Z2VzdHVyZVR5cGUsXG5cdFx0XHRudW1Qb2ludHMgPSB0b3VjaExpc3QubGVuZ3RoO1xuXG5cdFx0aWYoZS50eXBlID09PSAnbW91c2V1cCcpIHtcblx0XHRcdG51bVBvaW50cyA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gbm90aGluZyBpZiB0aGVyZSB3ZXJlIDMgdG91Y2ggcG9pbnRzIG9yIG1vcmVcblx0XHRpZihudW1Qb2ludHMgPT09IDIpIHtcblx0XHRcdF9jdXJyZW50UG9pbnRzID0gbnVsbDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIGlmIHNlY29uZCBwb2ludGVyIHJlbGVhc2VkXG5cdFx0aWYobnVtUG9pbnRzID09PSAxKSB7XG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX3N0YXJ0UG9pbnQsIHRvdWNoTGlzdFswXSk7XG5cdFx0fVx0XHRcdFx0XG5cblxuXHRcdC8vIHBvaW50ZXIgaGFzbid0IG1vdmVkLCBzZW5kIFwidGFwIHJlbGVhc2VcIiBwb2ludFxuXHRcdGlmKG51bVBvaW50cyA9PT0gMCAmJiAhX2RpcmVjdGlvbiAmJiAhX21haW5TY3JvbGxBbmltYXRpbmcpIHtcblx0XHRcdGlmKCFyZWxlYXNlUG9pbnQpIHtcblx0XHRcdFx0aWYoZS50eXBlID09PSAnbW91c2V1cCcpIHtcblx0XHRcdFx0XHRyZWxlYXNlUG9pbnQgPSB7eDogZS5wYWdlWCwgeTogZS5wYWdlWSwgdHlwZTonbW91c2UnfTtcblx0XHRcdFx0fSBlbHNlIGlmKGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlc1swXSkge1xuXHRcdFx0XHRcdHJlbGVhc2VQb2ludCA9IHt4OiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYLCB5OiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZLCB0eXBlOid0b3VjaCd9O1xuXHRcdFx0XHR9XHRcdFxuXHRcdFx0fVxuXG5cdFx0XHRfc2hvdXQoJ3RvdWNoUmVsZWFzZScsIGUsIHJlbGVhc2VQb2ludCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGlmZmVyZW5jZSBpbiB0aW1lIGJldHdlZW4gcmVsZWFzaW5nIG9mIHR3byBsYXN0IHRvdWNoIHBvaW50cyAoem9vbSBnZXN0dXJlKVxuXHRcdHZhciByZWxlYXNlVGltZURpZmYgPSAtMTtcblxuXHRcdC8vIEdlc3R1cmUgY29tcGxldGVkLCBubyBwb2ludGVycyBsZWZ0XG5cdFx0aWYobnVtUG9pbnRzID09PSAwKSB7XG5cdFx0XHRfaXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0ZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csIF91cE1vdmVFdmVudHMsIHNlbGYpO1xuXG5cdFx0XHRfc3RvcERyYWdVcGRhdGVMb29wKCk7XG5cblx0XHRcdGlmKF9pc1pvb21pbmcpIHtcblx0XHRcdFx0Ly8gVHdvIHBvaW50cyByZWxlYXNlZCBhdCB0aGUgc2FtZSB0aW1lXG5cdFx0XHRcdHJlbGVhc2VUaW1lRGlmZiA9IDA7XG5cdFx0XHR9IGVsc2UgaWYoX2xhc3RSZWxlYXNlVGltZSAhPT0gLTEpIHtcblx0XHRcdFx0cmVsZWFzZVRpbWVEaWZmID0gX2dldEN1cnJlbnRUaW1lKCkgLSBfbGFzdFJlbGVhc2VUaW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRfbGFzdFJlbGVhc2VUaW1lID0gbnVtUG9pbnRzID09PSAxID8gX2dldEN1cnJlbnRUaW1lKCkgOiAtMTtcblx0XHRcblx0XHRpZihyZWxlYXNlVGltZURpZmYgIT09IC0xICYmIHJlbGVhc2VUaW1lRGlmZiA8IDE1MCkge1xuXHRcdFx0Z2VzdHVyZVR5cGUgPSAnem9vbSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdlc3R1cmVUeXBlID0gJ3N3aXBlJztcblx0XHR9XG5cblx0XHRpZihfaXNab29taW5nICYmIG51bVBvaW50cyA8IDIpIHtcblx0XHRcdF9pc1pvb21pbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gT25seSBzZWNvbmQgcG9pbnQgcmVsZWFzZWRcblx0XHRcdGlmKG51bVBvaW50cyA9PT0gMSkge1xuXHRcdFx0XHRnZXN0dXJlVHlwZSA9ICd6b29tUG9pbnRlclVwJztcblx0XHRcdH1cblx0XHRcdF9zaG91dCgnem9vbUdlc3R1cmVFbmRlZCcpO1xuXHRcdH1cblxuXHRcdF9jdXJyZW50UG9pbnRzID0gbnVsbDtcblx0XHRpZighX21vdmVkICYmICFfem9vbVN0YXJ0ZWQgJiYgIV9tYWluU2Nyb2xsQW5pbWF0aW5nICYmICFfdmVydGljYWxEcmFnSW5pdGlhdGVkKSB7XG5cdFx0XHQvLyBub3RoaW5nIHRvIGFuaW1hdGVcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuXG5cdFx0XG5cdFx0aWYoIV9yZWxlYXNlQW5pbURhdGEpIHtcblx0XHRcdF9yZWxlYXNlQW5pbURhdGEgPSBfaW5pdERyYWdSZWxlYXNlQW5pbWF0aW9uRGF0YSgpO1xuXHRcdH1cblx0XHRcblx0XHRfcmVsZWFzZUFuaW1EYXRhLmNhbGN1bGF0ZVN3aXBlU3BlZWQoJ3gnKTtcblxuXG5cdFx0aWYoX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCkge1xuXG5cdFx0XHR2YXIgb3BhY2l0eVJhdGlvID0gX2NhbGN1bGF0ZVZlcnRpY2FsRHJhZ09wYWNpdHlSYXRpbygpO1xuXG5cdFx0XHRpZihvcGFjaXR5UmF0aW8gPCBfb3B0aW9ucy52ZXJ0aWNhbERyYWdSYW5nZSkge1xuXHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaW5pdGFsUGFuWSA9IF9wYW5PZmZzZXQueSxcblx0XHRcdFx0XHRpbml0aWFsQmdPcGFjaXR5ID0gX2JnT3BhY2l0eTtcblxuXHRcdFx0XHRfYW5pbWF0ZVByb3AoJ3ZlcnRpY2FsRHJhZycsIDAsIDEsIDMwMCwgZnJhbWV3b3JrLmVhc2luZy5jdWJpYy5vdXQsIGZ1bmN0aW9uKG5vdykge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdF9wYW5PZmZzZXQueSA9IChzZWxmLmN1cnJJdGVtLmluaXRpYWxQb3NpdGlvbi55IC0gaW5pdGFsUGFuWSkgKiBub3cgKyBpbml0YWxQYW5ZO1xuXG5cdFx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KCAgKDEgLSBpbml0aWFsQmdPcGFjaXR5KSAqIG5vdyArIGluaXRpYWxCZ09wYWNpdHkgKTtcblx0XHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfc2hvdXQoJ29uVmVydGljYWxEcmFnJywgMSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblxuXHRcdC8vIG1haW4gc2Nyb2xsIFxuXHRcdGlmKCAgKF9tYWluU2Nyb2xsU2hpZnRlZCB8fCBfbWFpblNjcm9sbEFuaW1hdGluZykgJiYgbnVtUG9pbnRzID09PSAwKSB7XG5cdFx0XHR2YXIgaXRlbUNoYW5nZWQgPSBfZmluaXNoU3dpcGVNYWluU2Nyb2xsR2VzdHVyZShnZXN0dXJlVHlwZSwgX3JlbGVhc2VBbmltRGF0YSk7XG5cdFx0XHRpZihpdGVtQ2hhbmdlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRnZXN0dXJlVHlwZSA9ICd6b29tUG9pbnRlclVwJztcblx0XHR9XG5cblx0XHQvLyBwcmV2ZW50IHpvb20vcGFuIGFuaW1hdGlvbiB3aGVuIG1haW4gc2Nyb2xsIGFuaW1hdGlvbiBydW5zXG5cdFx0aWYoX21haW5TY3JvbGxBbmltYXRpbmcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQ29tcGxldGUgc2ltcGxlIHpvb20gZ2VzdHVyZSAocmVzZXQgem9vbSBsZXZlbCBpZiBpdCdzIG91dCBvZiB0aGUgYm91bmRzKSAgXG5cdFx0aWYoZ2VzdHVyZVR5cGUgIT09ICdzd2lwZScpIHtcblx0XHRcdF9jb21wbGV0ZVpvb21HZXN0dXJlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvLyBDb21wbGV0ZSBwYW4gZ2VzdHVyZSBpZiBtYWluIHNjcm9sbCBpcyBub3Qgc2hpZnRlZCwgYW5kIGl0J3MgcG9zc2libGUgdG8gcGFuIGN1cnJlbnQgaW1hZ2Vcblx0XHRpZighX21haW5TY3JvbGxTaGlmdGVkICYmIF9jdXJyWm9vbUxldmVsID4gc2VsZi5jdXJySXRlbS5maXRSYXRpbykge1xuXHRcdFx0X2NvbXBsZXRlUGFuR2VzdHVyZShfcmVsZWFzZUFuaW1EYXRhKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG9iamVjdCB3aXRoIGRhdGEgYWJvdXQgZ2VzdHVyZVxuXHQvLyBJdCdzIGNyZWF0ZWQgb25seSBvbmNlIGFuZCB0aGVuIHJldXNlZFxuXHRfaW5pdERyYWdSZWxlYXNlQW5pbWF0aW9uRGF0YSAgPSBmdW5jdGlvbigpIHtcblx0XHQvLyB0ZW1wIGxvY2FsIHZhcnNcblx0XHR2YXIgbGFzdEZsaWNrRHVyYXRpb24sXG5cdFx0XHR0ZW1wUmVsZWFzZVBvcztcblxuXHRcdC8vIHMgPSB0aGlzXG5cdFx0dmFyIHMgPSB7XG5cdFx0XHRsYXN0RmxpY2tPZmZzZXQ6IHt9LFxuXHRcdFx0bGFzdEZsaWNrRGlzdDoge30sXG5cdFx0XHRsYXN0RmxpY2tTcGVlZDoge30sXG5cdFx0XHRzbG93RG93blJhdGlvOiAge30sXG5cdFx0XHRzbG93RG93blJhdGlvUmV2ZXJzZTogIHt9LFxuXHRcdFx0c3BlZWREZWNlbGVyYXRpb25SYXRpbzogIHt9LFxuXHRcdFx0c3BlZWREZWNlbGVyYXRpb25SYXRpb0FiczogIHt9LFxuXHRcdFx0ZGlzdGFuY2VPZmZzZXQ6ICB7fSxcblx0XHRcdGJhY2tBbmltRGVzdGluYXRpb246IHt9LFxuXHRcdFx0YmFja0FuaW1TdGFydGVkOiB7fSxcblx0XHRcdGNhbGN1bGF0ZVN3aXBlU3BlZWQ6IGZ1bmN0aW9uKGF4aXMpIHtcblx0XHRcdFx0XG5cblx0XHRcdFx0aWYoIF9wb3NQb2ludHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGxhc3RGbGlja0R1cmF0aW9uID0gX2dldEN1cnJlbnRUaW1lKCkgLSBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lICsgNTA7XG5cdFx0XHRcdFx0dGVtcFJlbGVhc2VQb3MgPSBfcG9zUG9pbnRzW19wb3NQb2ludHMubGVuZ3RoLTJdW2F4aXNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhc3RGbGlja0R1cmF0aW9uID0gX2dldEN1cnJlbnRUaW1lKCkgLSBfZ2VzdHVyZVN0YXJ0VGltZTsgLy8gdG90YWwgZ2VzdHVyZSBkdXJhdGlvblxuXHRcdFx0XHRcdHRlbXBSZWxlYXNlUG9zID0gX3N0YXJ0UG9pbnRbYXhpc107XG5cdFx0XHRcdH1cblx0XHRcdFx0cy5sYXN0RmxpY2tPZmZzZXRbYXhpc10gPSBfY3VyclBvaW50W2F4aXNdIC0gdGVtcFJlbGVhc2VQb3M7XG5cdFx0XHRcdHMubGFzdEZsaWNrRGlzdFtheGlzXSA9IE1hdGguYWJzKHMubGFzdEZsaWNrT2Zmc2V0W2F4aXNdKTtcblx0XHRcdFx0aWYocy5sYXN0RmxpY2tEaXN0W2F4aXNdID4gMjApIHtcblx0XHRcdFx0XHRzLmxhc3RGbGlja1NwZWVkW2F4aXNdID0gcy5sYXN0RmxpY2tPZmZzZXRbYXhpc10gLyBsYXN0RmxpY2tEdXJhdGlvbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzLmxhc3RGbGlja1NwZWVkW2F4aXNdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiggTWF0aC5hYnMocy5sYXN0RmxpY2tTcGVlZFtheGlzXSkgPCAwLjEgKSB7XG5cdFx0XHRcdFx0cy5sYXN0RmxpY2tTcGVlZFtheGlzXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHMuc2xvd0Rvd25SYXRpb1theGlzXSA9IDAuOTU7XG5cdFx0XHRcdHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gPSAxIC0gcy5zbG93RG93blJhdGlvW2F4aXNdO1xuXHRcdFx0XHRzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9bYXhpc10gPSAxO1xuXHRcdFx0fSxcblxuXHRcdFx0Y2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQ6IGZ1bmN0aW9uKGF4aXMsIHNwZWVkKSB7XG5cdFx0XHRcdGlmKCFzLmJhY2tBbmltU3RhcnRlZFtheGlzXSkge1xuXG5cdFx0XHRcdFx0aWYoX3Bhbk9mZnNldFtheGlzXSA+IF9jdXJyUGFuQm91bmRzLm1pbltheGlzXSkge1xuXHRcdFx0XHRcdFx0cy5iYWNrQW5pbURlc3RpbmF0aW9uW2F4aXNdID0gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fSBlbHNlIGlmKF9wYW5PZmZzZXRbYXhpc10gPCBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc10pIHtcblx0XHRcdFx0XHRcdHMuYmFja0FuaW1EZXN0aW5hdGlvbltheGlzXSA9IF9jdXJyUGFuQm91bmRzLm1heFtheGlzXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihzLmJhY2tBbmltRGVzdGluYXRpb25bYXhpc10gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cy5zbG93RG93blJhdGlvW2F4aXNdID0gMC43O1xuXHRcdFx0XHRcdFx0cy5zbG93RG93blJhdGlvUmV2ZXJzZVtheGlzXSA9IDEgLSBzLnNsb3dEb3duUmF0aW9bYXhpc107XG5cdFx0XHRcdFx0XHRpZihzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnNbYXhpc10gPCAwLjA1KSB7XG5cblx0XHRcdFx0XHRcdFx0cy5sYXN0RmxpY2tTcGVlZFtheGlzXSA9IDA7XG5cdFx0XHRcdFx0XHRcdHMuYmFja0FuaW1TdGFydGVkW2F4aXNdID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRfYW5pbWF0ZVByb3AoJ2JvdW5jZVpvb21QYW4nK2F4aXMsX3Bhbk9mZnNldFtheGlzXSwgXG5cdFx0XHRcdFx0XHRcdFx0cy5iYWNrQW5pbURlc3RpbmF0aW9uW2F4aXNdLCBcblx0XHRcdFx0XHRcdFx0XHRzcGVlZCB8fCAzMDAsIFxuXHRcdFx0XHRcdFx0XHRcdGZyYW1ld29yay5lYXNpbmcuc2luZS5vdXQsIFxuXHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKHBvcykge1xuXHRcdFx0XHRcdFx0XHRcdFx0X3Bhbk9mZnNldFtheGlzXSA9IHBvcztcblx0XHRcdFx0XHRcdFx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZWR1Y2VzIHRoZSBzcGVlZCBieSBzbG93RG93blJhdGlvIChwZXIgMTBtcylcblx0XHRcdGNhbGN1bGF0ZUFuaW1PZmZzZXQ6IGZ1bmN0aW9uKGF4aXMpIHtcblx0XHRcdFx0aWYoIXMuYmFja0FuaW1TdGFydGVkW2F4aXNdKSB7XG5cdFx0XHRcdFx0cy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdID0gcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdICogKHMuc2xvd0Rvd25SYXRpb1theGlzXSArIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cy5zbG93RG93blJhdGlvUmV2ZXJzZVtheGlzXSAtIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cy5zbG93RG93blJhdGlvUmV2ZXJzZVtheGlzXSAqIHMudGltZURpZmYgLyAxMCk7XG5cblx0XHRcdFx0XHRzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnNbYXhpc10gPSBNYXRoLmFicyhzLmxhc3RGbGlja1NwZWVkW2F4aXNdICogcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdKTtcblx0XHRcdFx0XHRzLmRpc3RhbmNlT2Zmc2V0W2F4aXNdID0gcy5sYXN0RmxpY2tTcGVlZFtheGlzXSAqIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSAqIHMudGltZURpZmY7XG5cdFx0XHRcdFx0X3Bhbk9mZnNldFtheGlzXSArPSBzLmRpc3RhbmNlT2Zmc2V0W2F4aXNdO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHBhbkFuaW1Mb29wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBfYW5pbWF0aW9ucy56b29tUGFuICkge1xuXHRcdFx0XHRcdF9hbmltYXRpb25zLnpvb21QYW4ucmFmID0gX3JlcXVlc3RBRihzLnBhbkFuaW1Mb29wKTtcblxuXHRcdFx0XHRcdHMubm93ID0gX2dldEN1cnJlbnRUaW1lKCk7XG5cdFx0XHRcdFx0cy50aW1lRGlmZiA9IHMubm93IC0gcy5sYXN0Tm93O1xuXHRcdFx0XHRcdHMubGFzdE5vdyA9IHMubm93O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHMuY2FsY3VsYXRlQW5pbU9mZnNldCgneCcpO1xuXHRcdFx0XHRcdHMuY2FsY3VsYXRlQW5pbU9mZnNldCgneScpO1xuXG5cdFx0XHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzLmNhbGN1bGF0ZU92ZXJCb3VuZHNBbmltT2Zmc2V0KCd4Jyk7XG5cdFx0XHRcdFx0cy5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneScpO1xuXG5cblx0XHRcdFx0XHRpZiAocy5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzLnggPCAwLjA1ICYmIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb0Ficy55IDwgMC4wNSkge1xuXG5cdFx0XHRcdFx0XHQvLyByb3VuZCBwYW4gcG9zaXRpb25cblx0XHRcdFx0XHRcdF9wYW5PZmZzZXQueCA9IE1hdGgucm91bmQoX3Bhbk9mZnNldC54KTtcblx0XHRcdFx0XHRcdF9wYW5PZmZzZXQueSA9IE1hdGgucm91bmQoX3Bhbk9mZnNldC55KTtcblx0XHRcdFx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdF9zdG9wQW5pbWF0aW9uKCd6b29tUGFuJyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBzO1xuXHR9LFxuXG5cdF9jb21wbGV0ZVBhbkdlc3R1cmUgPSBmdW5jdGlvbihhbmltRGF0YSkge1xuXHRcdC8vIGNhbGN1bGF0ZSBzd2lwZSBzcGVlZCBmb3IgWSBheGlzIChwYWFubmluZylcblx0XHRhbmltRGF0YS5jYWxjdWxhdGVTd2lwZVNwZWVkKCd5Jyk7XG5cblx0XHRfY3VyclBhbkJvdW5kcyA9IHNlbGYuY3Vyckl0ZW0uYm91bmRzO1xuXHRcdFxuXHRcdGFuaW1EYXRhLmJhY2tBbmltRGVzdGluYXRpb24gPSB7fTtcblx0XHRhbmltRGF0YS5iYWNrQW5pbVN0YXJ0ZWQgPSB7fTtcblxuXHRcdC8vIEF2b2lkIGFjY2VsZXJhdGlvbiBhbmltYXRpb24gaWYgc3BlZWQgaXMgdG9vIGxvd1xuXHRcdGlmKE1hdGguYWJzKGFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLngpIDw9IDAuMDUgJiYgTWF0aC5hYnMoYW5pbURhdGEubGFzdEZsaWNrU3BlZWQueSkgPD0gMC4wNSApIHtcblx0XHRcdGFuaW1EYXRhLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueCA9IGFuaW1EYXRhLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueSA9IDA7XG5cblx0XHRcdC8vIFJ1biBwYW4gZHJhZyByZWxlYXNlIGFuaW1hdGlvbi4gRS5nLiBpZiB5b3UgZHJhZyBpbWFnZSBhbmQgcmVsZWFzZSBmaW5nZXIgd2l0aG91dCBtb21lbnR1bS5cblx0XHRcdGFuaW1EYXRhLmNhbGN1bGF0ZU92ZXJCb3VuZHNBbmltT2Zmc2V0KCd4Jyk7XG5cdFx0XHRhbmltRGF0YS5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneScpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0aW9uIGxvb3AgdGhhdCBjb250cm9scyB0aGUgYWNjZWxlcmF0aW9uIGFmdGVyIHBhbiBnZXN0dXJlIGVuZHNcblx0XHRfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbignem9vbVBhbicpO1xuXHRcdGFuaW1EYXRhLmxhc3ROb3cgPSBfZ2V0Q3VycmVudFRpbWUoKTtcblx0XHRhbmltRGF0YS5wYW5BbmltTG9vcCgpO1xuXHR9LFxuXG5cblx0X2ZpbmlzaFN3aXBlTWFpblNjcm9sbEdlc3R1cmUgPSBmdW5jdGlvbihnZXN0dXJlVHlwZSwgX3JlbGVhc2VBbmltRGF0YSkge1xuXHRcdHZhciBpdGVtQ2hhbmdlZDtcblx0XHRpZighX21haW5TY3JvbGxBbmltYXRpbmcpIHtcblx0XHRcdF9jdXJyWm9vbWVkSXRlbUluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXg7XG5cdFx0fVxuXG5cblx0XHRcblx0XHR2YXIgaXRlbXNEaWZmO1xuXG5cdFx0aWYoZ2VzdHVyZVR5cGUgPT09ICdzd2lwZScpIHtcblx0XHRcdHZhciB0b3RhbFNoaWZ0RGlzdCA9IF9jdXJyUG9pbnQueCAtIF9zdGFydFBvaW50LngsXG5cdFx0XHRcdGlzRmFzdExhc3RGbGljayA9IF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrRGlzdC54IDwgMTA7XG5cblx0XHRcdC8vIGlmIGNvbnRhaW5lciBpcyBzaGlmdGVkIGZvciBtb3JlIHRoYW4gTUlOX1NXSVBFX0RJU1RBTkNFLCBcblx0XHRcdC8vIGFuZCBsYXN0IGZsaWNrIGdlc3R1cmUgd2FzIGluIHJpZ2h0IGRpcmVjdGlvblxuXHRcdFx0aWYodG90YWxTaGlmdERpc3QgPiBNSU5fU1dJUEVfRElTVEFOQ0UgJiYgXG5cdFx0XHRcdChpc0Zhc3RMYXN0RmxpY2sgfHwgX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tPZmZzZXQueCA+IDIwKSApIHtcblx0XHRcdFx0Ly8gZ28gdG8gcHJldiBpdGVtXG5cdFx0XHRcdGl0ZW1zRGlmZiA9IC0xO1xuXHRcdFx0fSBlbHNlIGlmKHRvdGFsU2hpZnREaXN0IDwgLU1JTl9TV0lQRV9ESVNUQU5DRSAmJiBcblx0XHRcdFx0KGlzRmFzdExhc3RGbGljayB8fCBfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja09mZnNldC54IDwgLTIwKSApIHtcblx0XHRcdFx0Ly8gZ28gdG8gbmV4dCBpdGVtXG5cdFx0XHRcdGl0ZW1zRGlmZiA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG5leHRDaXJjbGU7XG5cblx0XHRpZihpdGVtc0RpZmYpIHtcblx0XHRcdFxuXHRcdFx0X2N1cnJlbnRJdGVtSW5kZXggKz0gaXRlbXNEaWZmO1xuXG5cdFx0XHRpZihfY3VycmVudEl0ZW1JbmRleCA8IDApIHtcblx0XHRcdFx0X2N1cnJlbnRJdGVtSW5kZXggPSBfb3B0aW9ucy5sb29wID8gX2dldE51bUl0ZW1zKCktMSA6IDA7XG5cdFx0XHRcdG5leHRDaXJjbGUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmKF9jdXJyZW50SXRlbUluZGV4ID49IF9nZXROdW1JdGVtcygpKSB7XG5cdFx0XHRcdF9jdXJyZW50SXRlbUluZGV4ID0gX29wdGlvbnMubG9vcCA/IDAgOiBfZ2V0TnVtSXRlbXMoKS0xO1xuXHRcdFx0XHRuZXh0Q2lyY2xlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIW5leHRDaXJjbGUgfHwgX29wdGlvbnMubG9vcCkge1xuXHRcdFx0XHRfaW5kZXhEaWZmICs9IGl0ZW1zRGlmZjtcblx0XHRcdFx0X2N1cnJQb3NpdGlvbkluZGV4IC09IGl0ZW1zRGlmZjtcblx0XHRcdFx0aXRlbUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdFxuXHRcdH1cblxuXHRcdHZhciBhbmltYXRlVG9YID0gX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4O1xuXHRcdHZhciBhbmltYXRlVG9EaXN0ID0gTWF0aC5hYnMoIGFuaW1hdGVUb1ggLSBfbWFpblNjcm9sbFBvcy54ICk7XG5cdFx0dmFyIGZpbmlzaEFuaW1EdXJhdGlvbjtcblxuXG5cdFx0aWYoIWl0ZW1DaGFuZ2VkICYmIGFuaW1hdGVUb1ggPiBfbWFpblNjcm9sbFBvcy54ICE9PSBfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLnggPiAwKSB7XG5cdFx0XHQvLyBcInJldHVybiB0byBjdXJyZW50XCIgZHVyYXRpb24sIGUuZy4gd2hlbiBkcmFnZ2luZyBmcm9tIHNsaWRlIDAgdG8gLTFcblx0XHRcdGZpbmlzaEFuaW1EdXJhdGlvbiA9IDMzMzsgXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZpbmlzaEFuaW1EdXJhdGlvbiA9IE1hdGguYWJzKF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrU3BlZWQueCkgPiAwID8gXG5cdFx0XHRcdFx0XHRcdFx0XHRhbmltYXRlVG9EaXN0IC8gTWF0aC5hYnMoX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tTcGVlZC54KSA6IFxuXHRcdFx0XHRcdFx0XHRcdFx0MzMzO1xuXG5cdFx0XHRmaW5pc2hBbmltRHVyYXRpb24gPSBNYXRoLm1pbihmaW5pc2hBbmltRHVyYXRpb24sIDQwMCk7XG5cdFx0XHRmaW5pc2hBbmltRHVyYXRpb24gPSBNYXRoLm1heChmaW5pc2hBbmltRHVyYXRpb24sIDI1MCk7XG5cdFx0fVxuXG5cdFx0aWYoX2N1cnJab29tZWRJdGVtSW5kZXggPT09IF9jdXJyZW50SXRlbUluZGV4KSB7XG5cdFx0XHRpdGVtQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHRfbWFpblNjcm9sbEFuaW1hdGluZyA9IHRydWU7XG5cdFx0XG5cdFx0X3Nob3V0KCdtYWluU2Nyb2xsQW5pbVN0YXJ0Jyk7XG5cblx0XHRfYW5pbWF0ZVByb3AoJ21haW5TY3JvbGwnLCBfbWFpblNjcm9sbFBvcy54LCBhbmltYXRlVG9YLCBmaW5pc2hBbmltRHVyYXRpb24sIGZyYW1ld29yay5lYXNpbmcuY3ViaWMub3V0LCBcblx0XHRcdF9tb3ZlTWFpblNjcm9sbCxcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfc3RvcEFsbEFuaW1hdGlvbnMoKTtcblx0XHRcdFx0X21haW5TY3JvbGxBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0X2N1cnJab29tZWRJdGVtSW5kZXggPSAtMTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKGl0ZW1DaGFuZ2VkIHx8IF9jdXJyWm9vbWVkSXRlbUluZGV4ICE9PSBfY3VycmVudEl0ZW1JbmRleCkge1xuXHRcdFx0XHRcdHNlbGYudXBkYXRlQ3Vyckl0ZW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0X3Nob3V0KCdtYWluU2Nyb2xsQW5pbUNvbXBsZXRlJyk7XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGlmKGl0ZW1DaGFuZ2VkKSB7XG5cdFx0XHRzZWxmLnVwZGF0ZUN1cnJJdGVtKHRydWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtQ2hhbmdlZDtcblx0fSxcblxuXHRfY2FsY3VsYXRlWm9vbUxldmVsID0gZnVuY3Rpb24odG91Y2hlc0Rpc3RhbmNlKSB7XG5cdFx0cmV0dXJuICAxIC8gX3N0YXJ0UG9pbnRzRGlzdGFuY2UgKiB0b3VjaGVzRGlzdGFuY2UgKiBfc3RhcnRab29tTGV2ZWw7XG5cdH0sXG5cblx0Ly8gUmVzZXRzIHpvb20gaWYgaXQncyBvdXQgb2YgYm91bmRzXG5cdF9jb21wbGV0ZVpvb21HZXN0dXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlc3Rab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCxcblx0XHRcdG1pblpvb21MZXZlbCA9IF9nZXRNaW5ab29tTGV2ZWwoKSxcblx0XHRcdG1heFpvb21MZXZlbCA9IF9nZXRNYXhab29tTGV2ZWwoKTtcblxuXHRcdGlmICggX2N1cnJab29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwgKSB7XG5cdFx0XHRkZXN0Wm9vbUxldmVsID0gbWluWm9vbUxldmVsO1xuXHRcdH0gZWxzZSBpZiAoIF9jdXJyWm9vbUxldmVsID4gbWF4Wm9vbUxldmVsICkge1xuXHRcdFx0ZGVzdFpvb21MZXZlbCA9IG1heFpvb21MZXZlbDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdE9wYWNpdHkgPSAxLFxuXHRcdFx0b25VcGRhdGUsXG5cdFx0XHRpbml0aWFsT3BhY2l0eSA9IF9iZ09wYWNpdHk7XG5cblx0XHRpZihfb3BhY2l0eUNoYW5nZWQgJiYgIV9pc1pvb21pbmdJbiAmJiAhX3dhc092ZXJJbml0aWFsWm9vbSAmJiBfY3Vyclpvb21MZXZlbCA8IG1pblpvb21MZXZlbCkge1xuXHRcdFx0Ly9fY2xvc2VkQnlTY3JvbGwgPSB0cnVlO1xuXHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYoX29wYWNpdHlDaGFuZ2VkKSB7XG5cdFx0XHRvblVwZGF0ZSA9IGZ1bmN0aW9uKG5vdykge1xuXHRcdFx0XHRfYXBwbHlCZ09wYWNpdHkoICAoZGVzdE9wYWNpdHkgLSBpbml0aWFsT3BhY2l0eSkgKiBub3cgKyBpbml0aWFsT3BhY2l0eSApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRzZWxmLnpvb21UbyhkZXN0Wm9vbUxldmVsLCAwLCAyMDAsICBmcmFtZXdvcmsuZWFzaW5nLmN1YmljLm91dCwgb25VcGRhdGUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cbl9yZWdpc3Rlck1vZHVsZSgnR2VzdHVyZXMnLCB7XG5cdHB1YmxpY01ldGhvZHM6IHtcblxuXHRcdGluaXRHZXN0dXJlczogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIGhlbHBlciBmdW5jdGlvbiB0aGF0IGJ1aWxkcyB0b3VjaC9wb2ludGVyL21vdXNlIGV2ZW50c1xuXHRcdFx0dmFyIGFkZEV2ZW50TmFtZXMgPSBmdW5jdGlvbihwcmVmLCBkb3duLCBtb3ZlLCB1cCwgY2FuY2VsKSB7XG5cdFx0XHRcdF9kcmFnU3RhcnRFdmVudCA9IHByZWYgKyBkb3duO1xuXHRcdFx0XHRfZHJhZ01vdmVFdmVudCA9IHByZWYgKyBtb3ZlO1xuXHRcdFx0XHRfZHJhZ0VuZEV2ZW50ID0gcHJlZiArIHVwO1xuXHRcdFx0XHRpZihjYW5jZWwpIHtcblx0XHRcdFx0XHRfZHJhZ0NhbmNlbEV2ZW50ID0gcHJlZiArIGNhbmNlbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZHJhZ0NhbmNlbEV2ZW50ID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdF9wb2ludGVyRXZlbnRFbmFibGVkID0gX2ZlYXR1cmVzLnBvaW50ZXJFdmVudDtcblx0XHRcdGlmKF9wb2ludGVyRXZlbnRFbmFibGVkICYmIF9mZWF0dXJlcy50b3VjaCkge1xuXHRcdFx0XHQvLyB3ZSBkb24ndCBuZWVkIHRvdWNoIGV2ZW50cywgaWYgYnJvd3NlciBzdXBwb3J0cyBwb2ludGVyIGV2ZW50c1xuXHRcdFx0XHRfZmVhdHVyZXMudG91Y2ggPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcblx0XHRcdFx0aWYobmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcblx0XHRcdFx0XHQvLyBJRTEwIHBvaW50ZXIgZXZlbnRzIGFyZSBjYXNlLXNlbnNpdGl2ZVxuXHRcdFx0XHRcdGFkZEV2ZW50TmFtZXMoJ01TUG9pbnRlcicsICdEb3duJywgJ01vdmUnLCAnVXAnLCAnQ2FuY2VsJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWRkRXZlbnROYW1lcygncG9pbnRlcicsICdkb3duJywgJ21vdmUnLCAndXAnLCAnY2FuY2VsJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZihfZmVhdHVyZXMudG91Y2gpIHtcblx0XHRcdFx0YWRkRXZlbnROYW1lcygndG91Y2gnLCAnc3RhcnQnLCAnbW92ZScsICdlbmQnLCAnY2FuY2VsJyk7XG5cdFx0XHRcdF9saWtlbHlUb3VjaERldmljZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRFdmVudE5hbWVzKCdtb3VzZScsICdkb3duJywgJ21vdmUnLCAndXAnKTtcdFxuXHRcdFx0fVxuXG5cdFx0XHRfdXBNb3ZlRXZlbnRzID0gX2RyYWdNb3ZlRXZlbnQgKyAnICcgKyBfZHJhZ0VuZEV2ZW50ICArICcgJyArICBfZHJhZ0NhbmNlbEV2ZW50O1xuXHRcdFx0X2Rvd25FdmVudHMgPSBfZHJhZ1N0YXJ0RXZlbnQ7XG5cblx0XHRcdGlmKF9wb2ludGVyRXZlbnRFbmFibGVkICYmICFfbGlrZWx5VG91Y2hEZXZpY2UpIHtcblx0XHRcdFx0X2xpa2VseVRvdWNoRGV2aWNlID0gKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpIHx8IChuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDEpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbWFrZSB2YXJpYWJsZSBwdWJsaWNcblx0XHRcdHNlbGYubGlrZWx5VG91Y2hEZXZpY2UgPSBfbGlrZWx5VG91Y2hEZXZpY2U7IFxuXHRcdFx0XG5cdFx0XHRfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ1N0YXJ0RXZlbnRdID0gX29uRHJhZ1N0YXJ0O1xuXHRcdFx0X2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdNb3ZlRXZlbnRdID0gX29uRHJhZ01vdmU7XG5cdFx0XHRfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0VuZEV2ZW50XSA9IF9vbkRyYWdSZWxlYXNlOyAvLyB0aGUgS3Jha2VuXG5cblx0XHRcdGlmKF9kcmFnQ2FuY2VsRXZlbnQpIHtcblx0XHRcdFx0X2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdDYW5jZWxFdmVudF0gPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0VuZEV2ZW50XTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQmluZCBtb3VzZSBldmVudHMgb24gZGV2aWNlIHdpdGggZGV0ZWN0ZWQgaGFyZHdhcmUgdG91Y2ggc3VwcG9ydCwgaW4gY2FzZSBpdCBzdXBwb3J0cyBtdWx0aXBsZSB0eXBlcyBvZiBpbnB1dC5cblx0XHRcdGlmKF9mZWF0dXJlcy50b3VjaCkge1xuXHRcdFx0XHRfZG93bkV2ZW50cyArPSAnIG1vdXNlZG93bic7XG5cdFx0XHRcdF91cE1vdmVFdmVudHMgKz0gJyBtb3VzZW1vdmUgbW91c2V1cCc7XG5cdFx0XHRcdF9nbG9iYWxFdmVudEhhbmRsZXJzLm1vdXNlZG93biA9IF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnU3RhcnRFdmVudF07XG5cdFx0XHRcdF9nbG9iYWxFdmVudEhhbmRsZXJzLm1vdXNlbW92ZSA9IF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnTW92ZUV2ZW50XTtcblx0XHRcdFx0X2dsb2JhbEV2ZW50SGFuZGxlcnMubW91c2V1cCA9IF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnRW5kRXZlbnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighX2xpa2VseVRvdWNoRGV2aWNlKSB7XG5cdFx0XHRcdC8vIGRvbid0IGFsbG93IHBhbiB0byBuZXh0IHNsaWRlIGZyb20gem9vbWVkIHN0YXRlIG9uIERlc2t0b3Bcblx0XHRcdFx0X29wdGlvbnMuYWxsb3dQYW5Ub05leHQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxufSk7XG5cblxuLyo+Pmdlc3R1cmVzKi9cblxuLyo+PnNob3ctaGlkZS10cmFuc2l0aW9uKi9cbi8qKlxuICogc2hvdy1oaWRlLXRyYW5zaXRpb24uanM6XG4gKlxuICogTWFuYWdlcyBpbml0aWFsIG9wZW5pbmcgb3IgY2xvc2luZyB0cmFuc2l0aW9uLlxuICpcbiAqIElmIHlvdSdyZSBub3QgcGxhbm5pbmcgdG8gdXNlIHRyYW5zaXRpb24gZm9yIGdhbGxlcnkgYXQgYWxsLFxuICogeW91IG1heSBzZXQgb3B0aW9ucyBoaWRlQW5pbWF0aW9uRHVyYXRpb24gYW5kIHNob3dBbmltYXRpb25EdXJhdGlvbiB0byAwLFxuICogYW5kIGp1c3QgZGVsZXRlIHN0YXJ0QW5pbWF0aW9uIGZ1bmN0aW9uLlxuICogXG4gKi9cblxuXG52YXIgX3Nob3dPckhpZGVUaW1lb3V0LFxuXHRfc2hvd09ySGlkZSA9IGZ1bmN0aW9uKGl0ZW0sIGltZywgb3V0LCBjb21wbGV0ZUZuKSB7XG5cblx0XHRpZihfc2hvd09ySGlkZVRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dChfc2hvd09ySGlkZVRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdF9pbml0aWFsWm9vbVJ1bm5pbmcgPSB0cnVlO1xuXHRcdF9pbml0aWFsQ29udGVudFNldCA9IHRydWU7XG5cdFx0XG5cdFx0Ly8gZGltZW5zaW9ucyBvZiBzbWFsbCB0aHVtYm5haWwge3g6LHk6LHc6fS5cblx0XHQvLyBIZWlnaHQgaXMgb3B0aW9uYWwsIGFzIGNhbGN1bGF0ZWQgYmFzZWQgb24gbGFyZ2UgaW1hZ2UuXG5cdFx0dmFyIHRodW1iQm91bmRzOyBcblx0XHRpZihpdGVtLmluaXRpYWxMYXlvdXQpIHtcblx0XHRcdHRodW1iQm91bmRzID0gaXRlbS5pbml0aWFsTGF5b3V0O1xuXHRcdFx0aXRlbS5pbml0aWFsTGF5b3V0ID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGh1bWJCb3VuZHMgPSBfb3B0aW9ucy5nZXRUaHVtYkJvdW5kc0ZuICYmIF9vcHRpb25zLmdldFRodW1iQm91bmRzRm4oX2N1cnJlbnRJdGVtSW5kZXgpO1xuXHRcdH1cblxuXHRcdHZhciBkdXJhdGlvbiA9IG91dCA/IF9vcHRpb25zLmhpZGVBbmltYXRpb25EdXJhdGlvbiA6IF9vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbjtcblxuXHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRfc3RvcEFuaW1hdGlvbignaW5pdGlhbFpvb20nKTtcblx0XHRcdGlmKCFvdXQpIHtcblx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KDEpO1xuXHRcdFx0XHRpZihpbWcpIHtcblx0XHRcdFx0XHRpbWcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0tYW5pbWF0ZWQtaW4nKTtcblx0XHRcdFx0X3Nob3V0KCdpbml0aWFsWm9vbScgKyAob3V0ID8gJ091dEVuZCcgOiAnSW5FbmQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLnRlbXBsYXRlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblx0XHRcdFx0c2VsZi5iZy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGNvbXBsZXRlRm4pIHtcblx0XHRcdFx0Y29tcGxldGVGbigpO1xuXHRcdFx0fVxuXHRcdFx0X2luaXRpYWxab29tUnVubmluZyA9IGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBpZiBib3VuZHMgYXJlbid0IHByb3ZpZGVkLCBqdXN0IG9wZW4gZ2FsbGVyeSB3aXRob3V0IGFuaW1hdGlvblxuXHRcdGlmKCFkdXJhdGlvbiB8fCAhdGh1bWJCb3VuZHMgfHwgdGh1bWJCb3VuZHMueCA9PT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdF9zaG91dCgnaW5pdGlhbFpvb20nICsgKG91dCA/ICdPdXQnIDogJ0luJykgKTtcblxuXHRcdFx0X2N1cnJab29tTGV2ZWwgPSBpdGVtLmluaXRpYWxab29tTGV2ZWw7XG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX3Bhbk9mZnNldCwgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uICk7XG5cdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXG5cdFx0XHR0ZW1wbGF0ZS5zdHlsZS5vcGFjaXR5ID0gb3V0ID8gMCA6IDE7XG5cdFx0XHRfYXBwbHlCZ09wYWNpdHkoMSk7XG5cblx0XHRcdGlmKGR1cmF0aW9uKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25Db21wbGV0ZSgpO1xuXHRcdFx0XHR9LCBkdXJhdGlvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbkNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc3RhcnRBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbG9zZVdpdGhSYWYgPSBfY2xvc2VkQnlTY3JvbGwsXG5cdFx0XHRcdGZhZGVFdmVyeXRoaW5nID0gIXNlbGYuY3Vyckl0ZW0uc3JjIHx8IHNlbGYuY3Vyckl0ZW0ubG9hZEVycm9yIHx8IF9vcHRpb25zLnNob3dIaWRlT3BhY2l0eTtcblx0XHRcdFxuXHRcdFx0Ly8gYXBwbHkgaHctYWNjZWxlcmF0aW9uIHRvIGltYWdlXG5cdFx0XHRpZihpdGVtLm1pbmlJbWcpIHtcblx0XHRcdFx0aXRlbS5taW5pSW1nLnN0eWxlLndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighb3V0KSB7XG5cdFx0XHRcdF9jdXJyWm9vbUxldmVsID0gdGh1bWJCb3VuZHMudyAvIGl0ZW0udztcblx0XHRcdFx0X3Bhbk9mZnNldC54ID0gdGh1bWJCb3VuZHMueDtcblx0XHRcdFx0X3Bhbk9mZnNldC55ID0gdGh1bWJCb3VuZHMueSAtIF9pbml0YWxXaW5kb3dTY3JvbGxZO1xuXG5cdFx0XHRcdHNlbGZbZmFkZUV2ZXJ5dGhpbmcgPyAndGVtcGxhdGUnIDogJ2JnJ10uc3R5bGUub3BhY2l0eSA9IDAuMDAxO1xuXHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0fVxuXG5cdFx0XHRfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbignaW5pdGlhbFpvb20nKTtcblx0XHRcdFxuXHRcdFx0aWYob3V0ICYmICFjbG9zZVdpdGhSYWYpIHtcblx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHRlbXBsYXRlLCAncHN3cC0tYW5pbWF0ZWQtaW4nKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoZmFkZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdFx0aWYob3V0KSB7XG5cdFx0XHRcdFx0ZnJhbWV3b3JrWyAoY2xvc2VXaXRoUmFmID8gJ3JlbW92ZScgOiAnYWRkJykgKyAnQ2xhc3MnIF0odGVtcGxhdGUsICdwc3dwLS1hbmltYXRlX29wYWNpdHknKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0tYW5pbWF0ZV9vcGFjaXR5Jyk7XG5cdFx0XHRcdFx0fSwgMzApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9zaG93T3JIaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0X3Nob3V0KCdpbml0aWFsWm9vbScgKyAob3V0ID8gJ091dCcgOiAnSW4nKSApO1xuXHRcdFx0XHRcblxuXHRcdFx0XHRpZighb3V0KSB7XG5cblx0XHRcdFx0XHQvLyBcImluXCIgYW5pbWF0aW9uIGFsd2F5cyB1c2VzIENTUyB0cmFuc2l0aW9ucyAoaW5zdGVhZCBvZiByQUYpLlxuXHRcdFx0XHRcdC8vIENTUyB0cmFuc2l0aW9uIHdvcmsgZmFzdGVyIGhlcmUsIFxuXHRcdFx0XHRcdC8vIGFzIGRldmVsb3BlciBtYXkgYWxzbyB3YW50IHRvIGFuaW1hdGUgb3RoZXIgdGhpbmdzLCBcblx0XHRcdFx0XHQvLyBsaWtlIHVpIG9uIHRvcCBvZiBzbGlkaW5nIGFyZWEsIHdoaWNoIGNhbiBiZSBhbmltYXRlZCBqdXN0IHZpYSBDU1Ncblx0XHRcdFx0XHRcblx0XHRcdFx0XHRfY3Vyclpvb21MZXZlbCA9IGl0ZW0uaW5pdGlhbFpvb21MZXZlbDtcblx0XHRcdFx0XHRfZXF1YWxpemVQb2ludHMoX3Bhbk9mZnNldCwgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uICk7XG5cdFx0XHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblx0XHRcdFx0XHRfYXBwbHlCZ09wYWNpdHkoMSk7XG5cblx0XHRcdFx0XHRpZihmYWRlRXZlcnl0aGluZykge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUuc3R5bGUub3BhY2l0eSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9hcHBseUJnT3BhY2l0eSgxKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfc2hvd09ySGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uQ29tcGxldGUsIGR1cmF0aW9uICsgMjApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gXCJvdXRcIiBhbmltYXRpb24gdXNlcyByQUYgb25seSB3aGVuIFBob3RvU3dpcGUgaXMgY2xvc2VkIGJ5IGJyb3dzZXIgc2Nyb2xsLCB0byByZWNhbGN1bGF0ZSBwb3NpdGlvblxuXHRcdFx0XHRcdHZhciBkZXN0Wm9vbUxldmVsID0gdGh1bWJCb3VuZHMudyAvIGl0ZW0udyxcblx0XHRcdFx0XHRcdGluaXRpYWxQYW5PZmZzZXQgPSB7XG5cdFx0XHRcdFx0XHRcdHg6IF9wYW5PZmZzZXQueCxcblx0XHRcdFx0XHRcdFx0eTogX3Bhbk9mZnNldC55XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aW5pdGlhbFpvb21MZXZlbCA9IF9jdXJyWm9vbUxldmVsLFxuXHRcdFx0XHRcdFx0aW5pdGFsQmdPcGFjaXR5ID0gX2JnT3BhY2l0eSxcblx0XHRcdFx0XHRcdG9uVXBkYXRlID0gZnVuY3Rpb24obm93KSB7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZihub3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRfY3Vyclpvb21MZXZlbCA9IGRlc3Rab29tTGV2ZWw7XG5cdFx0XHRcdFx0XHRcdFx0X3Bhbk9mZnNldC54ID0gdGh1bWJCb3VuZHMueDtcblx0XHRcdFx0XHRcdFx0XHRfcGFuT2Zmc2V0LnkgPSB0aHVtYkJvdW5kcy55ICAtIF9jdXJyZW50V2luZG93U2Nyb2xsWTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRfY3Vyclpvb21MZXZlbCA9IChkZXN0Wm9vbUxldmVsIC0gaW5pdGlhbFpvb21MZXZlbCkgKiBub3cgKyBpbml0aWFsWm9vbUxldmVsO1xuXHRcdFx0XHRcdFx0XHRcdF9wYW5PZmZzZXQueCA9ICh0aHVtYkJvdW5kcy54IC0gaW5pdGlhbFBhbk9mZnNldC54KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueDtcblx0XHRcdFx0XHRcdFx0XHRfcGFuT2Zmc2V0LnkgPSAodGh1bWJCb3VuZHMueSAtIF9jdXJyZW50V2luZG93U2Nyb2xsWSAtIGluaXRpYWxQYW5PZmZzZXQueSkgKiBub3cgKyBpbml0aWFsUGFuT2Zmc2V0Lnk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdFx0XHRcdFx0XHRcdGlmKGZhZGVFdmVyeXRoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGVtcGxhdGUuc3R5bGUub3BhY2l0eSA9IDEgLSBub3c7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KCBpbml0YWxCZ09wYWNpdHkgLSBub3cgKiBpbml0YWxCZ09wYWNpdHkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmKGNsb3NlV2l0aFJhZikge1xuXHRcdFx0XHRcdFx0X2FuaW1hdGVQcm9wKCdpbml0aWFsWm9vbScsIDAsIDEsIGR1cmF0aW9uLCBmcmFtZXdvcmsuZWFzaW5nLmN1YmljLm91dCwgb25VcGRhdGUsIG9uQ29tcGxldGUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvblVwZGF0ZSgxKTtcblx0XHRcdFx0XHRcdF9zaG93T3JIaWRlVGltZW91dCA9IHNldFRpbWVvdXQob25Db21wbGV0ZSwgZHVyYXRpb24gKyAyMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdH0sIG91dCA/IDI1IDogOTApOyAvLyBNYWluIHB1cnBvc2Ugb2YgdGhpcyBkZWxheSBpcyB0byBnaXZlIGJyb3dzZXIgdGltZSB0byBwYWludCBhbmRcblx0XHRcdFx0XHQvLyBjcmVhdGUgY29tcG9zaXRlIGxheWVycyBvZiBQaG90b1N3aXBlIFVJIHBhcnRzIChiYWNrZ3JvdW5kLCBjb250cm9scywgY2FwdGlvbiwgYXJyb3dzKS5cblx0XHRcdFx0XHQvLyBXaGljaCBhdm9pZHMgbGFnIGF0IHRoZSBiZWdpbm5pbmcgb2Ygc2NhbGUgdHJhbnNpdGlvbi5cblx0XHR9O1xuXHRcdHN0YXJ0QW5pbWF0aW9uKCk7XG5cblx0XHRcblx0fTtcblxuLyo+PnNob3ctaGlkZS10cmFuc2l0aW9uKi9cblxuLyo+Pml0ZW1zLWNvbnRyb2xsZXIqL1xuLyoqXG4qXG4qIENvbnRyb2xsZXIgbWFuYWdlcyBnYWxsZXJ5IGl0ZW1zLCB0aGVpciBkaW1lbnNpb25zLCBhbmQgdGhlaXIgY29udGVudC5cbiogXG4qL1xuXG52YXIgX2l0ZW1zLFxuXHRfdGVtcFBhbkFyZWFTaXplID0ge30sXG5cdF9pbWFnZXNUb0FwcGVuZFBvb2wgPSBbXSxcblx0X2luaXRpYWxDb250ZW50U2V0LFxuXHRfaW5pdGlhbFpvb21SdW5uaW5nLFxuXHRfY29udHJvbGxlckRlZmF1bHRPcHRpb25zID0ge1xuXHRcdGluZGV4OiAwLFxuXHRcdGVycm9yTXNnOiAnPGRpdiBjbGFzcz1cInBzd3BfX2Vycm9yLW1zZ1wiPjxhIGhyZWY9XCIldXJsJVwiIHRhcmdldD1cIl9ibGFua1wiPlRoZSBpbWFnZTwvYT4gY291bGQgbm90IGJlIGxvYWRlZC48L2Rpdj4nLFxuXHRcdGZvcmNlUHJvZ3Jlc3NpdmVMb2FkaW5nOiBmYWxzZSwgLy8gVE9ET1xuXHRcdHByZWxvYWQ6IFsxLDFdLFxuXHRcdGdldE51bUl0ZW1zRm46IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIF9pdGVtcy5sZW5ndGg7XG5cdFx0fVxuXHR9O1xuXG5cbnZhciBfZ2V0SXRlbUF0LFxuXHRfZ2V0TnVtSXRlbXMsXG5cdF9pbml0aWFsSXNMb29wLFxuXHRfZ2V0WmVyb0JvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjZW50ZXI6e3g6MCx5OjB9LCBcblx0XHRcdG1heDp7eDowLHk6MH0sIFxuXHRcdFx0bWluOnt4OjAseTowfVxuXHRcdH07XG5cdH0sXG5cdF9jYWxjdWxhdGVTaW5nbGVJdGVtUGFuQm91bmRzID0gZnVuY3Rpb24oaXRlbSwgcmVhbFBhbkVsZW1lbnRXLCByZWFsUGFuRWxlbWVudEggKSB7XG5cdFx0dmFyIGJvdW5kcyA9IGl0ZW0uYm91bmRzO1xuXG5cdFx0Ly8gcG9zaXRpb24gb2YgZWxlbWVudCB3aGVuIGl0J3MgY2VudGVyZWRcblx0XHRib3VuZHMuY2VudGVyLnggPSBNYXRoLnJvdW5kKChfdGVtcFBhbkFyZWFTaXplLnggLSByZWFsUGFuRWxlbWVudFcpIC8gMik7XG5cdFx0Ym91bmRzLmNlbnRlci55ID0gTWF0aC5yb3VuZCgoX3RlbXBQYW5BcmVhU2l6ZS55IC0gcmVhbFBhbkVsZW1lbnRIKSAvIDIpICsgaXRlbS52R2FwLnRvcDtcblxuXHRcdC8vIG1heGltdW0gcGFuIHBvc2l0aW9uXG5cdFx0Ym91bmRzLm1heC54ID0gKHJlYWxQYW5FbGVtZW50VyA+IF90ZW1wUGFuQXJlYVNpemUueCkgPyBcblx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZChfdGVtcFBhbkFyZWFTaXplLnggLSByZWFsUGFuRWxlbWVudFcpIDogXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5jZW50ZXIueDtcblx0XHRcblx0XHRib3VuZHMubWF4LnkgPSAocmVhbFBhbkVsZW1lbnRIID4gX3RlbXBQYW5BcmVhU2l6ZS55KSA/IFxuXHRcdFx0XHRcdFx0XHRNYXRoLnJvdW5kKF90ZW1wUGFuQXJlYVNpemUueSAtIHJlYWxQYW5FbGVtZW50SCkgKyBpdGVtLnZHYXAudG9wIDogXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5jZW50ZXIueTtcblx0XHRcblx0XHQvLyBtaW5pbXVtIHBhbiBwb3NpdGlvblxuXHRcdGJvdW5kcy5taW4ueCA9IChyZWFsUGFuRWxlbWVudFcgPiBfdGVtcFBhbkFyZWFTaXplLngpID8gMCA6IGJvdW5kcy5jZW50ZXIueDtcblx0XHRib3VuZHMubWluLnkgPSAocmVhbFBhbkVsZW1lbnRIID4gX3RlbXBQYW5BcmVhU2l6ZS55KSA/IGl0ZW0udkdhcC50b3AgOiBib3VuZHMuY2VudGVyLnk7XG5cdH0sXG5cdF9jYWxjdWxhdGVJdGVtU2l6ZSA9IGZ1bmN0aW9uKGl0ZW0sIHZpZXdwb3J0U2l6ZSwgem9vbUxldmVsKSB7XG5cblx0XHRpZiAoaXRlbS5zcmMgJiYgIWl0ZW0ubG9hZEVycm9yKSB7XG5cdFx0XHR2YXIgaXNJbml0aWFsID0gIXpvb21MZXZlbDtcblx0XHRcdFxuXHRcdFx0aWYoaXNJbml0aWFsKSB7XG5cdFx0XHRcdGlmKCFpdGVtLnZHYXApIHtcblx0XHRcdFx0XHRpdGVtLnZHYXAgPSB7dG9wOjAsYm90dG9tOjB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFsbG93cyBvdmVycmlkaW5nIHZlcnRpY2FsIG1hcmdpbiBmb3IgaW5kaXZpZHVhbCBpdGVtc1xuXHRcdFx0XHRfc2hvdXQoJ3BhcnNlVmVydGljYWxNYXJnaW4nLCBpdGVtKTtcblx0XHRcdH1cblxuXG5cdFx0XHRfdGVtcFBhbkFyZWFTaXplLnggPSB2aWV3cG9ydFNpemUueDtcblx0XHRcdF90ZW1wUGFuQXJlYVNpemUueSA9IHZpZXdwb3J0U2l6ZS55IC0gaXRlbS52R2FwLnRvcCAtIGl0ZW0udkdhcC5ib3R0b207XG5cblx0XHRcdGlmIChpc0luaXRpYWwpIHtcblx0XHRcdFx0dmFyIGhSYXRpbyA9IF90ZW1wUGFuQXJlYVNpemUueCAvIGl0ZW0udztcblx0XHRcdFx0dmFyIHZSYXRpbyA9IF90ZW1wUGFuQXJlYVNpemUueSAvIGl0ZW0uaDtcblxuXHRcdFx0XHRpdGVtLmZpdFJhdGlvID0gaFJhdGlvIDwgdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvO1xuXHRcdFx0XHQvL2l0ZW0uZmlsbFJhdGlvID0gaFJhdGlvID4gdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvO1xuXG5cdFx0XHRcdHZhciBzY2FsZU1vZGUgPSBfb3B0aW9ucy5zY2FsZU1vZGU7XG5cblx0XHRcdFx0aWYgKHNjYWxlTW9kZSA9PT0gJ29yaWcnKSB7XG5cdFx0XHRcdFx0em9vbUxldmVsID0gMTtcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZU1vZGUgPT09ICdmaXQnKSB7XG5cdFx0XHRcdFx0em9vbUxldmVsID0gaXRlbS5maXRSYXRpbztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6b29tTGV2ZWwgPiAxKSB7XG5cdFx0XHRcdFx0em9vbUxldmVsID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGl0ZW0uaW5pdGlhbFpvb21MZXZlbCA9IHpvb21MZXZlbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKCFpdGVtLmJvdW5kcykge1xuXHRcdFx0XHRcdC8vIHJldXNlIGJvdW5kcyBvYmplY3Rcblx0XHRcdFx0XHRpdGVtLmJvdW5kcyA9IF9nZXRaZXJvQm91bmRzKCk7IFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF6b29tTGV2ZWwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfY2FsY3VsYXRlU2luZ2xlSXRlbVBhbkJvdW5kcyhpdGVtLCBpdGVtLncgKiB6b29tTGV2ZWwsIGl0ZW0uaCAqIHpvb21MZXZlbCk7XG5cblx0XHRcdGlmIChpc0luaXRpYWwgJiYgem9vbUxldmVsID09PSBpdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcblx0XHRcdFx0aXRlbS5pbml0aWFsUG9zaXRpb24gPSBpdGVtLmJvdW5kcy5jZW50ZXI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpdGVtLmJvdW5kcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbS53ID0gaXRlbS5oID0gMDtcblx0XHRcdGl0ZW0uaW5pdGlhbFpvb21MZXZlbCA9IGl0ZW0uZml0UmF0aW8gPSAxO1xuXHRcdFx0aXRlbS5ib3VuZHMgPSBfZ2V0WmVyb0JvdW5kcygpO1xuXHRcdFx0aXRlbS5pbml0aWFsUG9zaXRpb24gPSBpdGVtLmJvdW5kcy5jZW50ZXI7XG5cblx0XHRcdC8vIGlmIGl0J3Mgbm90IGltYWdlLCB3ZSByZXR1cm4gemVybyBib3VuZHMgKGNvbnRlbnQgaXMgbm90IHpvb21hYmxlKVxuXHRcdFx0cmV0dXJuIGl0ZW0uYm91bmRzO1xuXHRcdH1cblx0XHRcblx0fSxcblxuXHRcblxuXG5cdF9hcHBlbmRJbWFnZSA9IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBiYXNlRGl2LCBpbWcsIHByZXZlbnRBbmltYXRpb24sIGtlZXBQbGFjZWhvbGRlcikge1xuXHRcdFxuXG5cdFx0aWYoaXRlbS5sb2FkRXJyb3IpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihpbWcpIHtcblxuXHRcdFx0aXRlbS5pbWFnZUFwcGVuZGVkID0gdHJ1ZTtcblx0XHRcdF9zZXRJbWFnZVNpemUoaXRlbSwgaW1nLCAoaXRlbSA9PT0gc2VsZi5jdXJySXRlbSAmJiBfcmVuZGVyTWF4UmVzb2x1dGlvbikgKTtcblx0XHRcdFxuXHRcdFx0YmFzZURpdi5hcHBlbmRDaGlsZChpbWcpO1xuXG5cdFx0XHRpZihrZWVwUGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZihpdGVtICYmIGl0ZW0ubG9hZGVkICYmIGl0ZW0ucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0XHRcdGl0ZW0ucGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0XHRcdGl0ZW0ucGxhY2Vob2xkZXIgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgNTAwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFxuXG5cblx0X3ByZWxvYWRJbWFnZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpdGVtLmxvYWRpbmcgPSB0cnVlO1xuXHRcdGl0ZW0ubG9hZGVkID0gZmFsc2U7XG5cdFx0dmFyIGltZyA9IGl0ZW0uaW1nID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19pbWcnLCAnaW1nJyk7XG5cdFx0dmFyIG9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGl0ZW0ubG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0aXRlbS5sb2FkZWQgPSB0cnVlO1xuXG5cdFx0XHRpZihpdGVtLmxvYWRDb21wbGV0ZSkge1xuXHRcdFx0XHRpdGVtLmxvYWRDb21wbGV0ZShpdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGl0ZW0uaW1nID0gbnVsbDsgLy8gbm8gbmVlZCB0byBzdG9yZSBpbWFnZSBvYmplY3Rcblx0XHRcdH1cblx0XHRcdGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG5cdFx0XHRpbWcgPSBudWxsO1xuXHRcdH07XG5cdFx0aW1nLm9ubG9hZCA9IG9uQ29tcGxldGU7XG5cdFx0aW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdGl0ZW0ubG9hZEVycm9yID0gdHJ1ZTtcblx0XHRcdG9uQ29tcGxldGUoKTtcblx0XHR9O1x0XHRcblxuXHRcdGltZy5zcmMgPSBpdGVtLnNyYzsvLyArICc/YT0nICsgTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiBpbWc7XG5cdH0sXG5cdF9jaGVja0ZvckVycm9yID0gZnVuY3Rpb24oaXRlbSwgY2xlYW5VcCkge1xuXHRcdGlmKGl0ZW0uc3JjICYmIGl0ZW0ubG9hZEVycm9yICYmIGl0ZW0uY29udGFpbmVyKSB7XG5cblx0XHRcdGlmKGNsZWFuVXApIHtcblx0XHRcdFx0aXRlbS5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW0uY29udGFpbmVyLmlubmVySFRNTCA9IF9vcHRpb25zLmVycm9yTXNnLnJlcGxhY2UoJyV1cmwlJywgIGl0ZW0uc3JjICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdH1cblx0fSxcblx0X3NldEltYWdlU2l6ZSA9IGZ1bmN0aW9uKGl0ZW0sIGltZywgbWF4UmVzKSB7XG5cdFx0aWYoIWl0ZW0uc3JjKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoIWltZykge1xuXHRcdFx0aW1nID0gaXRlbS5jb250YWluZXIubGFzdENoaWxkO1xuXHRcdH1cblxuXHRcdHZhciB3ID0gbWF4UmVzID8gaXRlbS53IDogTWF0aC5yb3VuZChpdGVtLncgKiBpdGVtLmZpdFJhdGlvKSxcblx0XHRcdGggPSBtYXhSZXMgPyBpdGVtLmggOiBNYXRoLnJvdW5kKGl0ZW0uaCAqIGl0ZW0uZml0UmF0aW8pO1xuXHRcdFxuXHRcdGlmKGl0ZW0ucGxhY2Vob2xkZXIgJiYgIWl0ZW0ubG9hZGVkKSB7XG5cdFx0XHRpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLndpZHRoID0gdyArICdweCc7XG5cdFx0XHRpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXHRcdH1cblxuXHRcdGltZy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuXHRcdGltZy5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4Jztcblx0fSxcblx0X2FwcGVuZEltYWdlc1Bvb2wgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmKF9pbWFnZXNUb0FwcGVuZFBvb2wubGVuZ3RoKSB7XG5cdFx0XHR2YXIgcG9vbEl0ZW07XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBfaW1hZ2VzVG9BcHBlbmRQb29sLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHBvb2xJdGVtID0gX2ltYWdlc1RvQXBwZW5kUG9vbFtpXTtcblx0XHRcdFx0aWYoIHBvb2xJdGVtLmhvbGRlci5pbmRleCA9PT0gcG9vbEl0ZW0uaW5kZXggKSB7XG5cdFx0XHRcdFx0X2FwcGVuZEltYWdlKHBvb2xJdGVtLmluZGV4LCBwb29sSXRlbS5pdGVtLCBwb29sSXRlbS5iYXNlRGl2LCBwb29sSXRlbS5pbWcsIGZhbHNlLCBwb29sSXRlbS5jbGVhclBsYWNlaG9sZGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0X2ltYWdlc1RvQXBwZW5kUG9vbCA9IFtdO1xuXHRcdH1cblx0fTtcblx0XG5cblxuX3JlZ2lzdGVyTW9kdWxlKCdDb250cm9sbGVyJywge1xuXG5cdHB1YmxpY01ldGhvZHM6IHtcblxuXHRcdGxhenlMb2FkSXRlbTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdGluZGV4ID0gX2dldExvb3BlZElkKGluZGV4KTtcblx0XHRcdHZhciBpdGVtID0gX2dldEl0ZW1BdChpbmRleCk7XG5cblx0XHRcdGlmKCFpdGVtIHx8ICgoaXRlbS5sb2FkZWQgfHwgaXRlbS5sb2FkaW5nKSAmJiAhX2l0ZW1zTmVlZFVwZGF0ZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfc2hvdXQoJ2dldHRpbmdEYXRhJywgaW5kZXgsIGl0ZW0pO1xuXG5cdFx0XHRpZiAoIWl0ZW0uc3JjKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X3ByZWxvYWRJbWFnZShpdGVtKTtcblx0XHR9LFxuXHRcdGluaXRDb250cm9sbGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGZyYW1ld29yay5leHRlbmQoX29wdGlvbnMsIF9jb250cm9sbGVyRGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuXHRcdFx0c2VsZi5pdGVtcyA9IF9pdGVtcyA9IGl0ZW1zO1xuXHRcdFx0X2dldEl0ZW1BdCA9IHNlbGYuZ2V0SXRlbUF0O1xuXHRcdFx0X2dldE51bUl0ZW1zID0gX29wdGlvbnMuZ2V0TnVtSXRlbXNGbjsgLy9zZWxmLmdldE51bUl0ZW1zO1xuXG5cblxuXHRcdFx0X2luaXRpYWxJc0xvb3AgPSBfb3B0aW9ucy5sb29wO1xuXHRcdFx0aWYoX2dldE51bUl0ZW1zKCkgPCAzKSB7XG5cdFx0XHRcdF9vcHRpb25zLmxvb3AgPSBmYWxzZTsgLy8gZGlzYWJsZSBsb29wIGlmIGxlc3MgdGhlbiAzIGl0ZW1zXG5cdFx0XHR9XG5cblx0XHRcdF9saXN0ZW4oJ2JlZm9yZUNoYW5nZScsIGZ1bmN0aW9uKGRpZmYpIHtcblxuXHRcdFx0XHR2YXIgcCA9IF9vcHRpb25zLnByZWxvYWQsXG5cdFx0XHRcdFx0aXNOZXh0ID0gZGlmZiA9PT0gbnVsbCA/IHRydWUgOiAoZGlmZiA+PSAwKSxcblx0XHRcdFx0XHRwcmVsb2FkQmVmb3JlID0gTWF0aC5taW4ocFswXSwgX2dldE51bUl0ZW1zKCkgKSxcblx0XHRcdFx0XHRwcmVsb2FkQWZ0ZXIgPSBNYXRoLm1pbihwWzFdLCBfZ2V0TnVtSXRlbXMoKSApLFxuXHRcdFx0XHRcdGk7XG5cblxuXHRcdFx0XHRmb3IoaSA9IDE7IGkgPD0gKGlzTmV4dCA/IHByZWxvYWRBZnRlciA6IHByZWxvYWRCZWZvcmUpOyBpKyspIHtcblx0XHRcdFx0XHRzZWxmLmxhenlMb2FkSXRlbShfY3VycmVudEl0ZW1JbmRleCtpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IoaSA9IDE7IGkgPD0gKGlzTmV4dCA/IHByZWxvYWRCZWZvcmUgOiBwcmVsb2FkQWZ0ZXIpOyBpKyspIHtcblx0XHRcdFx0XHRzZWxmLmxhenlMb2FkSXRlbShfY3VycmVudEl0ZW1JbmRleC1pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdF9saXN0ZW4oJ2luaXRpYWxMYXlvdXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5jdXJySXRlbS5pbml0aWFsTGF5b3V0ID0gX29wdGlvbnMuZ2V0VGh1bWJCb3VuZHNGbiAmJiBfb3B0aW9ucy5nZXRUaHVtYkJvdW5kc0ZuKF9jdXJyZW50SXRlbUluZGV4KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRfbGlzdGVuKCdtYWluU2Nyb2xsQW5pbUNvbXBsZXRlJywgX2FwcGVuZEltYWdlc1Bvb2wpO1xuXHRcdFx0X2xpc3RlbignaW5pdGlhbFpvb21JbkVuZCcsIF9hcHBlbmRJbWFnZXNQb29sKTtcblxuXG5cblx0XHRcdF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGl0ZW07XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBfaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpdGVtID0gX2l0ZW1zW2ldO1xuXHRcdFx0XHRcdC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnRzLCBmb3IgR0Ncblx0XHRcdFx0XHRpZihpdGVtLmNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0aXRlbS5jb250YWluZXIgPSBudWxsOyBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoaXRlbS5wbGFjZWhvbGRlcikge1xuXHRcdFx0XHRcdFx0aXRlbS5wbGFjZWhvbGRlciA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGl0ZW0uaW1nKSB7XG5cdFx0XHRcdFx0XHRpdGVtLmltZyA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGl0ZW0ucHJlbG9hZGVyKSB7XG5cdFx0XHRcdFx0XHRpdGVtLnByZWxvYWRlciA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGl0ZW0ubG9hZEVycm9yKSB7XG5cdFx0XHRcdFx0XHRpdGVtLmxvYWRlZCA9IGl0ZW0ubG9hZEVycm9yID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9pbWFnZXNUb0FwcGVuZFBvb2wgPSBudWxsO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXG5cdFx0Z2V0SXRlbUF0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdFx0cmV0dXJuIF9pdGVtc1tpbmRleF0gIT09IHVuZGVmaW5lZCA/IF9pdGVtc1tpbmRleF0gOiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0YWxsb3dQcm9ncmVzc2l2ZUltZzogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyAxLiBQcm9ncmVzc2l2ZSBpbWFnZSBsb2FkaW5nIGlzbid0IHdvcmtpbmcgb24gd2Via2l0L2JsaW5rIFxuXHRcdFx0Ly8gICAgd2hlbiBody1hY2NlbGVyYXRpb24gKGUuZy4gdHJhbnNsYXRlWikgaXMgYXBwbGllZCB0byBJTUcgZWxlbWVudC5cblx0XHRcdC8vICAgIFRoYXQncyB3aHkgaW4gUGhvdG9Td2lwZSBwYXJlbnQgZWxlbWVudCBnZXRzIHpvb20gdHJhbnNmb3JtLCBub3QgaW1hZ2UgaXRzZWxmLlxuXHRcdFx0Ly8gICAgXG5cdFx0XHQvLyAyLiBQcm9ncmVzc2l2ZSBpbWFnZSBsb2FkaW5nIHNvbWV0aW1lcyBibGlua3MgaW4gd2Via2l0L2JsaW5rIHdoZW4gYXBwbHlpbmcgYW5pbWF0aW9uIHRvIHBhcmVudCBlbGVtZW50LlxuXHRcdFx0Ly8gICAgVGhhdCdzIHdoeSBpdCdzIGRpc2FibGVkIG9uIHRvdWNoIGRldmljZXMgKG1haW5seSBiZWNhdXNlIG9mIHN3aXBlIHRyYW5zaXRpb24pXG5cdFx0XHQvLyAgICBcblx0XHRcdC8vIDMuIFByb2dyZXNzaXZlIGltYWdlIGxvYWRpbmcgc29tZXRpbWVzIGRvZXNuJ3Qgd29yayBpbiBJRSAodXAgdG8gMTEpLlxuXG5cdFx0XHQvLyBEb24ndCBhbGxvdyBwcm9ncmVzc2l2ZSBsb2FkaW5nIG9uIG5vbi1sYXJnZSB0b3VjaCBkZXZpY2VzXG5cdFx0XHRyZXR1cm4gX29wdGlvbnMuZm9yY2VQcm9ncmVzc2l2ZUxvYWRpbmcgfHwgIV9saWtlbHlUb3VjaERldmljZSB8fCBfb3B0aW9ucy5tb3VzZVVzZWQgfHwgc2NyZWVuLndpZHRoID4gMTIwMDsgXG5cdFx0XHQvLyAxMjAwIC0gdG8gZWxpbWluYXRlIHRvdWNoIGRldmljZXMgd2l0aCBsYXJnZSBzY3JlZW4gKGxpa2UgQ2hyb21lYm9vayBQaXhlbClcblx0XHR9LFxuXG5cdFx0c2V0Q29udGVudDogZnVuY3Rpb24oaG9sZGVyLCBpbmRleCkge1xuXG5cdFx0XHRpZihfb3B0aW9ucy5sb29wKSB7XG5cdFx0XHRcdGluZGV4ID0gX2dldExvb3BlZElkKGluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHByZXZJdGVtID0gc2VsZi5nZXRJdGVtQXQoaG9sZGVyLmluZGV4KTtcblx0XHRcdGlmKHByZXZJdGVtKSB7XG5cdFx0XHRcdHByZXZJdGVtLmNvbnRhaW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dmFyIGl0ZW0gPSBzZWxmLmdldEl0ZW1BdChpbmRleCksXG5cdFx0XHRcdGltZztcblx0XHRcdFxuXHRcdFx0aWYoIWl0ZW0pIHtcblx0XHRcdFx0aG9sZGVyLmVsLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFsbG93IHRvIG92ZXJyaWRlIGRhdGFcblx0XHRcdF9zaG91dCgnZ2V0dGluZ0RhdGEnLCBpbmRleCwgaXRlbSk7XG5cblx0XHRcdGhvbGRlci5pbmRleCA9IGluZGV4O1xuXHRcdFx0aG9sZGVyLml0ZW0gPSBpdGVtO1xuXG5cdFx0XHQvLyBiYXNlIGNvbnRhaW5lciBESVYgaXMgY3JlYXRlZCBvbmx5IG9uY2UgZm9yIGVhY2ggb2YgMyBob2xkZXJzXG5cdFx0XHR2YXIgYmFzZURpdiA9IGl0ZW0uY29udGFpbmVyID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX196b29tLXdyYXAnKTsgXG5cblx0XHRcdFxuXG5cdFx0XHRpZighaXRlbS5zcmMgJiYgaXRlbS5odG1sKSB7XG5cdFx0XHRcdGlmKGl0ZW0uaHRtbC50YWdOYW1lKSB7XG5cdFx0XHRcdFx0YmFzZURpdi5hcHBlbmRDaGlsZChpdGVtLmh0bWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJhc2VEaXYuaW5uZXJIVE1MID0gaXRlbS5odG1sO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9jaGVja0ZvckVycm9yKGl0ZW0pO1xuXG5cdFx0XHRfY2FsY3VsYXRlSXRlbVNpemUoaXRlbSwgX3ZpZXdwb3J0U2l6ZSk7XG5cdFx0XHRcblx0XHRcdGlmKGl0ZW0uc3JjICYmICFpdGVtLmxvYWRFcnJvciAmJiAhaXRlbS5sb2FkZWQpIHtcblxuXHRcdFx0XHRpdGVtLmxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblxuXHRcdFx0XHRcdC8vIGdhbGxlcnkgY2xvc2VkIGJlZm9yZSBpbWFnZSBmaW5pc2hlZCBsb2FkaW5nXG5cdFx0XHRcdFx0aWYoIV9pc09wZW4pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiBob2xkZXIgaGFzbid0IGNoYW5nZWQgd2hpbGUgaW1hZ2Ugd2FzIGxvYWRpbmdcblx0XHRcdFx0XHRpZihob2xkZXIgJiYgaG9sZGVyLmluZGV4ID09PSBpbmRleCApIHtcblx0XHRcdFx0XHRcdGlmKCBfY2hlY2tGb3JFcnJvcihpdGVtLCB0cnVlKSApIHtcblx0XHRcdFx0XHRcdFx0aXRlbS5sb2FkQ29tcGxldGUgPSBpdGVtLmltZyA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdF9jYWxjdWxhdGVJdGVtU2l6ZShpdGVtLCBfdmlld3BvcnRTaXplKTtcblx0XHRcdFx0XHRcdFx0X2FwcGx5Wm9vbVBhblRvSXRlbShpdGVtKTtcblxuXHRcdFx0XHRcdFx0XHRpZihob2xkZXIuaW5kZXggPT09IF9jdXJyZW50SXRlbUluZGV4KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVjYWxjdWxhdGUgZGltZW5zaW9uc1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYudXBkYXRlQ3Vyclpvb21JdGVtKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoICFpdGVtLmltYWdlQXBwZW5kZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGlmKF9mZWF0dXJlcy50cmFuc2Zvcm0gJiYgKF9tYWluU2Nyb2xsQW5pbWF0aW5nIHx8IF9pbml0aWFsWm9vbVJ1bm5pbmcpICkge1xuXHRcdFx0XHRcdFx0XHRcdF9pbWFnZXNUb0FwcGVuZFBvb2wucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVtOml0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiYXNlRGl2OmJhc2VEaXYsXG5cdFx0XHRcdFx0XHRcdFx0XHRpbWc6aXRlbS5pbWcsXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleDppbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdGhvbGRlcjpob2xkZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGVhclBsYWNlaG9sZGVyOnRydWVcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRfYXBwZW5kSW1hZ2UoaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGl0ZW0uaW1nLCBfbWFpblNjcm9sbEFuaW1hdGluZyB8fCBfaW5pdGlhbFpvb21SdW5uaW5nLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHByZWxvYWRlciAmIG1pbmktaW1nXG5cdFx0XHRcdFx0XHRcdGlmKCFfaW5pdGlhbFpvb21SdW5uaW5nICYmIGl0ZW0ucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdFx0XHRcdFx0aXRlbS5wbGFjZWhvbGRlciA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpdGVtLmxvYWRDb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdFx0aXRlbS5pbWcgPSBudWxsOyAvLyBubyBuZWVkIHRvIHN0b3JlIGltYWdlIGVsZW1lbnQgYWZ0ZXIgaXQncyBhZGRlZFxuXG5cdFx0XHRcdFx0X3Nob3V0KCdpbWFnZUxvYWRDb21wbGV0ZScsIGluZGV4LCBpdGVtKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZihmcmFtZXdvcmsuZmVhdHVyZXMudHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHBsYWNlaG9sZGVyQ2xhc3NOYW1lID0gJ3Bzd3BfX2ltZyBwc3dwX19pbWctLXBsYWNlaG9sZGVyJzsgXG5cdFx0XHRcdFx0cGxhY2Vob2xkZXJDbGFzc05hbWUgKz0gKGl0ZW0ubXNyYyA/ICcnIDogJyBwc3dwX19pbWctLXBsYWNlaG9sZGVyLS1ibGFuaycpO1xuXG5cdFx0XHRcdFx0dmFyIHBsYWNlaG9sZGVyID0gZnJhbWV3b3JrLmNyZWF0ZUVsKHBsYWNlaG9sZGVyQ2xhc3NOYW1lLCBpdGVtLm1zcmMgPyAnaW1nJyA6ICcnKTtcblx0XHRcdFx0XHRpZihpdGVtLm1zcmMpIHtcblx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyLnNyYyA9IGl0ZW0ubXNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0X3NldEltYWdlU2l6ZShpdGVtLCBwbGFjZWhvbGRlcik7XG5cblx0XHRcdFx0XHRiYXNlRGl2LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcblx0XHRcdFx0XHRpdGVtLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRcblxuXHRcdFx0XHRcblxuXHRcdFx0XHRpZighaXRlbS5sb2FkaW5nKSB7XG5cdFx0XHRcdFx0X3ByZWxvYWRJbWFnZShpdGVtKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0aWYoIHNlbGYuYWxsb3dQcm9ncmVzc2l2ZUltZygpICkge1xuXHRcdFx0XHRcdC8vIGp1c3QgYXBwZW5kIGltYWdlXG5cdFx0XHRcdFx0aWYoIV9pbml0aWFsQ29udGVudFNldCAmJiBfZmVhdHVyZXMudHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRfaW1hZ2VzVG9BcHBlbmRQb29sLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRpdGVtOml0ZW0sIFxuXHRcdFx0XHRcdFx0XHRiYXNlRGl2OmJhc2VEaXYsIFxuXHRcdFx0XHRcdFx0XHRpbWc6aXRlbS5pbWcsIFxuXHRcdFx0XHRcdFx0XHRpbmRleDppbmRleCwgXG5cdFx0XHRcdFx0XHRcdGhvbGRlcjpob2xkZXJcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfYXBwZW5kSW1hZ2UoaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGl0ZW0uaW1nLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYoaXRlbS5zcmMgJiYgIWl0ZW0ubG9hZEVycm9yKSB7XG5cdFx0XHRcdC8vIGltYWdlIG9iamVjdCBpcyBjcmVhdGVkIGV2ZXJ5IHRpbWUsIGR1ZSB0byBidWdzIG9mIGltYWdlIGxvYWRpbmcgJiBkZWxheSB3aGVuIHN3aXRjaGluZyBpbWFnZXNcblx0XHRcdFx0aW1nID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19pbWcnLCAnaW1nJyk7XG5cdFx0XHRcdGltZy5zdHlsZS5vcGFjaXR5ID0gMTtcblx0XHRcdFx0aW1nLnNyYyA9IGl0ZW0uc3JjO1xuXHRcdFx0XHRfc2V0SW1hZ2VTaXplKGl0ZW0sIGltZyk7XG5cdFx0XHRcdF9hcHBlbmRJbWFnZShpbmRleCwgaXRlbSwgYmFzZURpdiwgaW1nLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdFxuXG5cdFx0XHRpZighX2luaXRpYWxDb250ZW50U2V0ICYmIGluZGV4ID09PSBfY3VycmVudEl0ZW1JbmRleCkge1xuXHRcdFx0XHRfY3Vyclpvb21FbGVtZW50U3R5bGUgPSBiYXNlRGl2LnN0eWxlO1xuXHRcdFx0XHRfc2hvd09ySGlkZShpdGVtLCAoaW1nIHx8aXRlbS5pbWcpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfYXBwbHlab29tUGFuVG9JdGVtKGl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob2xkZXIuZWwuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRob2xkZXIuZWwuYXBwZW5kQ2hpbGQoYmFzZURpdik7XG5cdFx0fSxcblxuXHRcdGNsZWFuU2xpZGU6IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0aWYoaXRlbS5pbWcgKSB7XG5cdFx0XHRcdGl0ZW0uaW1nLm9ubG9hZCA9IGl0ZW0uaW1nLm9uZXJyb3IgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aXRlbS5sb2FkZWQgPSBpdGVtLmxvYWRpbmcgPSBpdGVtLmltZyA9IGl0ZW0uaW1hZ2VBcHBlbmRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHR9XG59KTtcblxuLyo+Pml0ZW1zLWNvbnRyb2xsZXIqL1xuXG4vKj4+dGFwKi9cbi8qKlxuICogdGFwLmpzOlxuICpcbiAqIERpc3BsYXRjaGVzIHRhcCBhbmQgZG91YmxlLXRhcCBldmVudHMuXG4gKiBcbiAqL1xuXG52YXIgdGFwVGltZXIsXG5cdHRhcFJlbGVhc2VQb2ludCA9IHt9LFxuXHRfZGlzcGF0Y2hUYXBFdmVudCA9IGZ1bmN0aW9uKG9yaWdFdmVudCwgcmVsZWFzZVBvaW50LCBwb2ludGVyVHlwZSkge1x0XHRcblx0XHR2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCAnQ3VzdG9tRXZlbnQnICksXG5cdFx0XHRlRGV0YWlsID0ge1xuXHRcdFx0XHRvcmlnRXZlbnQ6b3JpZ0V2ZW50LCBcblx0XHRcdFx0dGFyZ2V0Om9yaWdFdmVudC50YXJnZXQsIFxuXHRcdFx0XHRyZWxlYXNlUG9pbnQ6IHJlbGVhc2VQb2ludCwgXG5cdFx0XHRcdHBvaW50ZXJUeXBlOnBvaW50ZXJUeXBlIHx8ICd0b3VjaCdcblx0XHRcdH07XG5cblx0XHRlLmluaXRDdXN0b21FdmVudCggJ3Bzd3BUYXAnLCB0cnVlLCB0cnVlLCBlRGV0YWlsICk7XG5cdFx0b3JpZ0V2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuXHR9O1xuXG5fcmVnaXN0ZXJNb2R1bGUoJ1RhcCcsIHtcblx0cHVibGljTWV0aG9kczoge1xuXHRcdGluaXRUYXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0X2xpc3RlbignZmlyc3RUb3VjaFN0YXJ0Jywgc2VsZi5vblRhcFN0YXJ0KTtcblx0XHRcdF9saXN0ZW4oJ3RvdWNoUmVsZWFzZScsIHNlbGYub25UYXBSZWxlYXNlKTtcblx0XHRcdF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGFwUmVsZWFzZVBvaW50ID0ge307XG5cdFx0XHRcdHRhcFRpbWVyID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b25UYXBTdGFydDogZnVuY3Rpb24odG91Y2hMaXN0KSB7XG5cdFx0XHRpZih0b3VjaExpc3QubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGFwVGltZXIpO1xuXHRcdFx0XHR0YXBUaW1lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblRhcFJlbGVhc2U6IGZ1bmN0aW9uKGUsIHJlbGVhc2VQb2ludCkge1xuXHRcdFx0aWYoIXJlbGVhc2VQb2ludCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFfbW92ZWQgJiYgIV9pc011bHRpdG91Y2ggJiYgIV9udW1BbmltYXRpb25zKSB7XG5cdFx0XHRcdHZhciBwMCA9IHJlbGVhc2VQb2ludDtcblx0XHRcdFx0aWYodGFwVGltZXIpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGFwVGltZXIpO1xuXHRcdFx0XHRcdHRhcFRpbWVyID0gbnVsbDtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIHRhcGVkIG9uIHRoZSBzYW1lIHBsYWNlXG5cdFx0XHRcdFx0aWYgKCBfaXNOZWFyYnlQb2ludHMocDAsIHRhcFJlbGVhc2VQb2ludCkgKSB7XG5cdFx0XHRcdFx0XHRfc2hvdXQoJ2RvdWJsZVRhcCcsIHAwKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihyZWxlYXNlUG9pbnQudHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHRcdF9kaXNwYXRjaFRhcEV2ZW50KGUsIHJlbGVhc2VQb2ludCwgJ21vdXNlJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNsaWNrZWRUYWdOYW1lID0gZS50YXJnZXQudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHQvLyBhdm9pZCBkb3VibGUgdGFwIGRlbGF5IG9uIGJ1dHRvbnMgYW5kIGVsZW1lbnRzIHRoYXQgaGF2ZSBjbGFzcyBwc3dwX19zaW5nbGUtdGFwXG5cdFx0XHRcdGlmKGNsaWNrZWRUYWdOYW1lID09PSAnQlVUVE9OJyB8fCBmcmFtZXdvcmsuaGFzQ2xhc3MoZS50YXJnZXQsICdwc3dwX19zaW5nbGUtdGFwJykgKSB7XG5cdFx0XHRcdFx0X2Rpc3BhdGNoVGFwRXZlbnQoZSwgcmVsZWFzZVBvaW50KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZXF1YWxpemVQb2ludHModGFwUmVsZWFzZVBvaW50LCBwMCk7XG5cblx0XHRcdFx0dGFwVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF9kaXNwYXRjaFRhcEV2ZW50KGUsIHJlbGVhc2VQb2ludCk7XG5cdFx0XHRcdFx0dGFwVGltZXIgPSBudWxsO1xuXHRcdFx0XHR9LCAzMDApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8qPj50YXAqL1xuXG4vKj4+ZGVza3RvcC16b29tKi9cbi8qKlxuICpcbiAqIGRlc2t0b3Atem9vbS5qczpcbiAqXG4gKiAtIEJpbmRzIG1vdXNld2hlZWwgZXZlbnQgZm9yIHBhbmluZyB6b29tZWQgaW1hZ2UuXG4gKiAtIE1hbmFnZXMgXCJkcmFnZ2luZ1wiLCBcInpvb21lZC1pblwiLCBcInpvb20tb3V0XCIgY2xhc3Nlcy5cbiAqICAgKHdoaWNoIGFyZSB1c2VkIGZvciBjdXJzb3JzIGFuZCB6b29tIGljb24pXG4gKiAtIEFkZHMgdG9nZ2xlRGVza3RvcFpvb20gZnVuY3Rpb24uXG4gKiBcbiAqL1xuXG52YXIgX3doZWVsRGVsdGE7XG5cdFxuX3JlZ2lzdGVyTW9kdWxlKCdEZXNrdG9wWm9vbScsIHtcblxuXHRwdWJsaWNNZXRob2RzOiB7XG5cblx0XHRpbml0RGVza3RvcFpvb206IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZihfb2xkSUUpIHtcblx0XHRcdFx0Ly8gbm8gem9vbSBmb3Igb2xkIElFICg8PTgpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoX2xpa2VseVRvdWNoRGV2aWNlKSB7XG5cdFx0XHRcdC8vIGlmIGRldGVjdGVkIGhhcmR3YXJlIHRvdWNoIHN1cHBvcnQsIHdlIHdhaXQgdW50aWwgbW91c2UgaXMgdXNlZCxcblx0XHRcdFx0Ly8gYW5kIG9ubHkgdGhlbiBhcHBseSBkZXNrdG9wLXpvb20gZmVhdHVyZXNcblx0XHRcdFx0X2xpc3RlbignbW91c2VVc2VkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5zZXR1cERlc2t0b3Bab29tKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5zZXR1cERlc2t0b3Bab29tKHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHNldHVwRGVza3RvcFpvb206IGZ1bmN0aW9uKG9uSW5pdCkge1xuXG5cdFx0XHRfd2hlZWxEZWx0YSA9IHt9O1xuXG5cdFx0XHR2YXIgZXZlbnRzID0gJ3doZWVsIG1vdXNld2hlZWwgRE9NTW91c2VTY3JvbGwnO1xuXHRcdFx0XG5cdFx0XHRfbGlzdGVuKCdiaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZyYW1ld29yay5iaW5kKHRlbXBsYXRlLCBldmVudHMsICBzZWxmLmhhbmRsZU1vdXNlV2hlZWwpO1xuXHRcdFx0fSk7XG5cblx0XHRcdF9saXN0ZW4oJ3VuYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihfd2hlZWxEZWx0YSkge1xuXHRcdFx0XHRcdGZyYW1ld29yay51bmJpbmQodGVtcGxhdGUsIGV2ZW50cywgc2VsZi5oYW5kbGVNb3VzZVdoZWVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHNlbGYubW91c2Vab29tZWRJbiA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgaGFzRHJhZ2dpbmdDbGFzcyxcblx0XHRcdFx0dXBkYXRlWm9vbWFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZihzZWxmLm1vdXNlWm9vbWVkSW4pIHtcblx0XHRcdFx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb21lZC1pbicpO1xuXHRcdFx0XHRcdFx0c2VsZi5tb3VzZVpvb21lZEluID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKF9jdXJyWm9vbUxldmVsIDwgMSkge1xuXHRcdFx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0tem9vbS1hbGxvd2VkJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb20tYWxsb3dlZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVEcmFnZ2luZ0NsYXNzKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZURyYWdnaW5nQ2xhc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZihoYXNEcmFnZ2luZ0NsYXNzKSB7XG5cdFx0XHRcdFx0XHRmcmFtZXdvcmsucmVtb3ZlQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1kcmFnZ2luZycpO1xuXHRcdFx0XHRcdFx0aGFzRHJhZ2dpbmdDbGFzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0X2xpc3RlbigncmVzaXplJyAsIHVwZGF0ZVpvb21hYmxlKTtcblx0XHRcdF9saXN0ZW4oJ2FmdGVyQ2hhbmdlJyAsIHVwZGF0ZVpvb21hYmxlKTtcblx0XHRcdF9saXN0ZW4oJ3BvaW50ZXJEb3duJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYubW91c2Vab29tZWRJbikge1xuXHRcdFx0XHRcdGhhc0RyYWdnaW5nQ2xhc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWRyYWdnaW5nJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0X2xpc3RlbigncG9pbnRlclVwJywgcmVtb3ZlRHJhZ2dpbmdDbGFzcyk7XG5cblx0XHRcdGlmKCFvbkluaXQpIHtcblx0XHRcdFx0dXBkYXRlWm9vbWFibGUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH0sXG5cblx0XHRoYW5kbGVNb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG5cblx0XHRcdGlmKF9jdXJyWm9vbUxldmVsIDw9IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pIHtcblx0XHRcdFx0aWYoIF9vcHRpb25zLm1vZGFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCFfb3B0aW9ucy5jbG9zZU9uU2Nyb2xsIHx8IF9udW1BbmltYXRpb25zIHx8IF9pc0RyYWdnaW5nKSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKF90cmFuc2Zvcm1LZXkgJiYgTWF0aC5hYnMoZS5kZWx0YVkpID4gMikge1xuXHRcdFx0XHRcdFx0Ly8gY2xvc2UgUGhvdG9Td2lwZVxuXHRcdFx0XHRcdFx0Ly8gaWYgYnJvd3NlciBzdXBwb3J0cyB0cmFuc2Zvcm1zICYgc2Nyb2xsIGNoYW5nZWQgZW5vdWdoXG5cdFx0XHRcdFx0XHRfY2xvc2VkQnlTY3JvbGwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhbGxvdyBqdXN0IG9uZSBldmVudCB0byBmaXJlXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcblx0XHRcdF93aGVlbERlbHRhLnggPSAwO1xuXG5cdFx0XHRpZignZGVsdGFYJyBpbiBlKSB7XG5cdFx0XHRcdGlmKGUuZGVsdGFNb2RlID09PSAxIC8qIERPTV9ERUxUQV9MSU5FICovKSB7XG5cdFx0XHRcdFx0Ly8gMTggLSBhdmVyYWdlIGxpbmUgaGVpZ2h0XG5cdFx0XHRcdFx0X3doZWVsRGVsdGEueCA9IGUuZGVsdGFYICogMTg7XG5cdFx0XHRcdFx0X3doZWVsRGVsdGEueSA9IGUuZGVsdGFZICogMTg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3doZWVsRGVsdGEueCA9IGUuZGVsdGFYO1xuXHRcdFx0XHRcdF93aGVlbERlbHRhLnkgPSBlLmRlbHRhWTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmKCd3aGVlbERlbHRhJyBpbiBlKSB7XG5cdFx0XHRcdGlmKGUud2hlZWxEZWx0YVgpIHtcblx0XHRcdFx0XHRfd2hlZWxEZWx0YS54ID0gLTAuMTYgKiBlLndoZWVsRGVsdGFYO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGUud2hlZWxEZWx0YVkpIHtcblx0XHRcdFx0XHRfd2hlZWxEZWx0YS55ID0gLTAuMTYgKiBlLndoZWVsRGVsdGFZO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF93aGVlbERlbHRhLnkgPSAtMC4xNiAqIGUud2hlZWxEZWx0YTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmKCdkZXRhaWwnIGluIGUpIHtcblx0XHRcdFx0X3doZWVsRGVsdGEueSA9IGUuZGV0YWlsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfY2FsY3VsYXRlUGFuQm91bmRzKF9jdXJyWm9vbUxldmVsLCB0cnVlKTtcblxuXHRcdFx0dmFyIG5ld1BhblggPSBfcGFuT2Zmc2V0LnggLSBfd2hlZWxEZWx0YS54LFxuXHRcdFx0XHRuZXdQYW5ZID0gX3Bhbk9mZnNldC55IC0gX3doZWVsRGVsdGEueTtcblxuXHRcdFx0Ly8gb25seSBwcmV2ZW50IHNjcm9sbGluZyBpbiBub25tb2RhbCBtb2RlIHdoZW4gbm90IGF0IGVkZ2VzXG5cdFx0XHRpZiAoX29wdGlvbnMubW9kYWwgfHxcblx0XHRcdFx0KFxuXHRcdFx0XHRuZXdQYW5YIDw9IF9jdXJyUGFuQm91bmRzLm1pbi54ICYmIG5ld1BhblggPj0gX2N1cnJQYW5Cb3VuZHMubWF4LnggJiZcblx0XHRcdFx0bmV3UGFuWSA8PSBfY3VyclBhbkJvdW5kcy5taW4ueSAmJiBuZXdQYW5ZID49IF9jdXJyUGFuQm91bmRzLm1heC55XG5cdFx0XHRcdCkgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogdXNlIHJBRiBpbnN0ZWFkIG9mIG1vdXNld2hlZWw/XG5cdFx0XHRzZWxmLnBhblRvKG5ld1BhblgsIG5ld1BhblkpO1xuXHRcdH0sXG5cblx0XHR0b2dnbGVEZXNrdG9wWm9vbTogZnVuY3Rpb24oY2VudGVyUG9pbnQpIHtcblx0XHRcdGNlbnRlclBvaW50ID0gY2VudGVyUG9pbnQgfHwge3g6X3ZpZXdwb3J0U2l6ZS54LzIgKyBfb2Zmc2V0LngsIHk6X3ZpZXdwb3J0U2l6ZS55LzIgKyBfb2Zmc2V0LnkgfTtcblxuXHRcdFx0dmFyIGRvdWJsZVRhcFpvb21MZXZlbCA9IF9vcHRpb25zLmdldERvdWJsZVRhcFpvb20odHJ1ZSwgc2VsZi5jdXJySXRlbSk7XG5cdFx0XHR2YXIgem9vbU91dCA9IF9jdXJyWm9vbUxldmVsID09PSBkb3VibGVUYXBab29tTGV2ZWw7XG5cdFx0XHRcblx0XHRcdHNlbGYubW91c2Vab29tZWRJbiA9ICF6b29tT3V0O1xuXG5cdFx0XHRzZWxmLnpvb21Ubyh6b29tT3V0ID8gc2VsZi5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsIDogZG91YmxlVGFwWm9vbUxldmVsLCBjZW50ZXJQb2ludCwgMzMzKTtcblx0XHRcdGZyYW1ld29ya1sgKCF6b29tT3V0ID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnQ2xhc3MnXSh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb21lZC1pbicpO1xuXHRcdH1cblxuXHR9XG59KTtcblxuXG4vKj4+ZGVza3RvcC16b29tKi9cblxuLyo+Pmhpc3RvcnkqL1xuLyoqXG4gKlxuICogaGlzdG9yeS5qczpcbiAqXG4gKiAtIEJhY2sgYnV0dG9uIHRvIGNsb3NlIGdhbGxlcnkuXG4gKiBcbiAqIC0gVW5pcXVlIFVSTCBmb3IgZWFjaCBzbGlkZTogZXhhbXBsZS5jb20vJnBpZD0xJmdpZD0zXG4gKiAgICh3aGVyZSBQSUQgaXMgcGljdHVyZSBpbmRleCwgYW5kIEdJRCBhbmQgZ2FsbGVyeSBpbmRleClcbiAqICAgXG4gKiAtIFN3aXRjaCBVUkwgd2hlbiBzbGlkZXMgY2hhbmdlLlxuICogXG4gKi9cblxuXG52YXIgX2hpc3RvcnlEZWZhdWx0T3B0aW9ucyA9IHtcblx0aGlzdG9yeTogdHJ1ZSxcblx0Z2FsbGVyeVVJRDogMVxufTtcblxudmFyIF9oaXN0b3J5VXBkYXRlVGltZW91dCxcblx0X2hhc2hDaGFuZ2VUaW1lb3V0LFxuXHRfaGFzaEFuaW1DaGVja1RpbWVvdXQsXG5cdF9oYXNoQ2hhbmdlZEJ5U2NyaXB0LFxuXHRfaGFzaENoYW5nZWRCeUhpc3RvcnksXG5cdF9oYXNoUmVzZXRlZCxcblx0X2luaXRpYWxIYXNoLFxuXHRfaGlzdG9yeUNoYW5nZWQsXG5cdF9jbG9zZWRGcm9tVVJMLFxuXHRfdXJsQ2hhbmdlZE9uY2UsXG5cdF93aW5kb3dMb2MsXG5cblx0X3N1cHBvcnRzUHVzaFN0YXRlLFxuXG5cdF9nZXRIYXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF93aW5kb3dMb2MuaGFzaC5zdWJzdHJpbmcoMSk7XG5cdH0sXG5cdF9jbGVhbkhpc3RvcnlUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYoX2hpc3RvcnlVcGRhdGVUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoX2hpc3RvcnlVcGRhdGVUaW1lb3V0KTtcblx0XHR9XG5cblx0XHRpZihfaGFzaEFuaW1DaGVja1RpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dChfaGFzaEFuaW1DaGVja1RpbWVvdXQpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBwaWQgLSBQaWN0dXJlIGluZGV4XG5cdC8vIGdpZCAtIEdhbGxlcnkgaW5kZXhcblx0X3BhcnNlSXRlbUluZGV4RnJvbVVSTCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNoID0gX2dldEhhc2goKSxcblx0XHRcdHBhcmFtcyA9IHt9O1xuXG5cdFx0aWYoaGFzaC5sZW5ndGggPCA1KSB7IC8vIHBpZD0xXG5cdFx0XHRyZXR1cm4gcGFyYW1zO1xuXHRcdH1cblxuXHRcdHZhciBpLCB2YXJzID0gaGFzaC5zcGxpdCgnJicpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZighdmFyc1tpXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpO1x0XG5cdFx0XHRpZihwYWlyLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRwYXJhbXNbcGFpclswXV0gPSBwYWlyWzFdO1xuXHRcdH1cblx0XHRpZihfb3B0aW9ucy5nYWxsZXJ5UElEcykge1xuXHRcdFx0Ly8gZGV0ZWN0IGN1c3RvbSBwaWQgaW4gaGFzaCBhbmQgc2VhcmNoIGZvciBpdCBhbW9uZyB0aGUgaXRlbXMgY29sbGVjdGlvblxuXHRcdFx0dmFyIHNlYXJjaGZvciA9IHBhcmFtcy5waWQ7XG5cdFx0XHRwYXJhbXMucGlkID0gMDsgLy8gaWYgY3VzdG9tIHBpZCBjYW5ub3QgYmUgZm91bmQsIGZhbGxiYWNrIHRvIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRmb3IoaSA9IDA7IGkgPCBfaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYoX2l0ZW1zW2ldLnBpZCA9PT0gc2VhcmNoZm9yKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnBpZCA9IGk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyYW1zLnBpZCA9IHBhcnNlSW50KHBhcmFtcy5waWQsMTApLTE7XG5cdFx0fVxuXHRcdGlmKCBwYXJhbXMucGlkIDwgMCApIHtcblx0XHRcdHBhcmFtcy5waWQgPSAwO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1zO1xuXHR9LFxuXHRfdXBkYXRlSGFzaCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYoX2hhc2hBbmltQ2hlY2tUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoX2hhc2hBbmltQ2hlY2tUaW1lb3V0KTtcblx0XHR9XG5cblxuXHRcdGlmKF9udW1BbmltYXRpb25zIHx8IF9pc0RyYWdnaW5nKSB7XG5cdFx0XHQvLyBjaGFuZ2luZyBicm93c2VyIFVSTCBmb3JjZXMgbGF5b3V0L3BhaW50IGluIHNvbWUgYnJvd3NlcnMsIHdoaWNoIGNhdXNlcyBub3RpY2FibGUgbGFnIGR1cmluZyBhbmltYXRpb25cblx0XHRcdC8vIHRoYXQncyB3aHkgd2UgdXBkYXRlIGhhc2ggb25seSB3aGVuIG5vIGFuaW1hdGlvbnMgcnVubmluZ1xuXHRcdFx0X2hhc2hBbmltQ2hlY2tUaW1lb3V0ID0gc2V0VGltZW91dChfdXBkYXRlSGFzaCwgNTAwKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0aWYoX2hhc2hDaGFuZ2VkQnlTY3JpcHQpIHtcblx0XHRcdGNsZWFyVGltZW91dChfaGFzaENoYW5nZVRpbWVvdXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfaGFzaENoYW5nZWRCeVNjcmlwdCA9IHRydWU7XG5cdFx0fVxuXG5cblx0XHR2YXIgcGlkID0gKF9jdXJyZW50SXRlbUluZGV4ICsgMSk7XG5cdFx0dmFyIGl0ZW0gPSBfZ2V0SXRlbUF0KCBfY3VycmVudEl0ZW1JbmRleCApO1xuXHRcdGlmKGl0ZW0uaGFzT3duUHJvcGVydHkoJ3BpZCcpKSB7XG5cdFx0XHQvLyBjYXJyeSBmb3J3YXJkIGFueSBjdXN0b20gcGlkIGFzc2lnbmVkIHRvIHRoZSBpdGVtXG5cdFx0XHRwaWQgPSBpdGVtLnBpZDtcblx0XHR9XG5cdFx0dmFyIG5ld0hhc2ggPSBfaW5pdGlhbEhhc2ggKyAnJicgICsgICdnaWQ9JyArIF9vcHRpb25zLmdhbGxlcnlVSUQgKyAnJicgKyAncGlkPScgKyBwaWQ7XG5cblx0XHRpZighX2hpc3RvcnlDaGFuZ2VkKSB7XG5cdFx0XHRpZihfd2luZG93TG9jLmhhc2guaW5kZXhPZihuZXdIYXNoKSA9PT0gLTEpIHtcblx0XHRcdFx0X3VybENoYW5nZWRPbmNlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIGZpcnN0IHRpbWUgLSBhZGQgbmV3IGhpc29yeSByZWNvcmQsIHRoZW4ganVzdCByZXBsYWNlXG5cdFx0fVxuXG5cdFx0dmFyIG5ld1VSTCA9IF93aW5kb3dMb2MuaHJlZi5zcGxpdCgnIycpWzBdICsgJyMnICsgIG5ld0hhc2g7XG5cblx0XHRpZiggX3N1cHBvcnRzUHVzaFN0YXRlICkge1xuXG5cdFx0XHRpZignIycgKyBuZXdIYXNoICE9PSB3aW5kb3cubG9jYXRpb24uaGFzaCkge1xuXHRcdFx0XHRoaXN0b3J5W19oaXN0b3J5Q2hhbmdlZCA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKCcnLCBkb2N1bWVudC50aXRsZSwgbmV3VVJMKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZihfaGlzdG9yeUNoYW5nZWQpIHtcblx0XHRcdFx0X3dpbmRvd0xvYy5yZXBsYWNlKCBuZXdVUkwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF93aW5kb3dMb2MuaGFzaCA9IG5ld0hhc2g7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdFxuXG5cdFx0X2hpc3RvcnlDaGFuZ2VkID0gdHJ1ZTtcblx0XHRfaGFzaENoYW5nZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0X2hhc2hDaGFuZ2VkQnlTY3JpcHQgPSBmYWxzZTtcblx0XHR9LCA2MCk7XG5cdH07XG5cblxuXG5cdFxuXG5fcmVnaXN0ZXJNb2R1bGUoJ0hpc3RvcnknLCB7XG5cblx0XG5cblx0cHVibGljTWV0aG9kczoge1xuXHRcdGluaXRIaXN0b3J5OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0ZnJhbWV3b3JrLmV4dGVuZChfb3B0aW9ucywgX2hpc3RvcnlEZWZhdWx0T3B0aW9ucywgdHJ1ZSk7XG5cblx0XHRcdGlmKCAhX29wdGlvbnMuaGlzdG9yeSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cblx0XHRcdF93aW5kb3dMb2MgPSB3aW5kb3cubG9jYXRpb247XG5cdFx0XHRfdXJsQ2hhbmdlZE9uY2UgPSBmYWxzZTtcblx0XHRcdF9jbG9zZWRGcm9tVVJMID0gZmFsc2U7XG5cdFx0XHRfaGlzdG9yeUNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdF9pbml0aWFsSGFzaCA9IF9nZXRIYXNoKCk7XG5cdFx0XHRfc3VwcG9ydHNQdXNoU3RhdGUgPSAoJ3B1c2hTdGF0ZScgaW4gaGlzdG9yeSk7XG5cblxuXHRcdFx0aWYoX2luaXRpYWxIYXNoLmluZGV4T2YoJ2dpZD0nKSA+IC0xKSB7XG5cdFx0XHRcdF9pbml0aWFsSGFzaCA9IF9pbml0aWFsSGFzaC5zcGxpdCgnJmdpZD0nKVswXTtcblx0XHRcdFx0X2luaXRpYWxIYXNoID0gX2luaXRpYWxIYXNoLnNwbGl0KCc/Z2lkPScpWzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdF9saXN0ZW4oJ2FmdGVyQ2hhbmdlJywgc2VsZi51cGRhdGVVUkwpO1xuXHRcdFx0X2xpc3RlbigndW5iaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZyYW1ld29yay51bmJpbmQod2luZG93LCAnaGFzaGNoYW5nZScsIHNlbGYub25IYXNoQ2hhbmdlKTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdHZhciByZXR1cm5Ub09yaWdpbmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9oYXNoUmVzZXRlZCA9IHRydWU7XG5cdFx0XHRcdGlmKCFfY2xvc2VkRnJvbVVSTCkge1xuXG5cdFx0XHRcdFx0aWYoX3VybENoYW5nZWRPbmNlKSB7XG5cdFx0XHRcdFx0XHRoaXN0b3J5LmJhY2soKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZihfaW5pdGlhbEhhc2gpIHtcblx0XHRcdFx0XHRcdFx0X3dpbmRvd0xvYy5oYXNoID0gX2luaXRpYWxIYXNoO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKF9zdXBwb3J0c1B1c2hTdGF0ZSkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIGhhc2ggZnJvbSB1cmwgd2l0aG91dCByZWZyZXNoaW5nIGl0IG9yIHNjcm9sbGluZyB0byB0b3Bcblx0XHRcdFx0XHRcdFx0XHRoaXN0b3J5LnB1c2hTdGF0ZSgnJywgZG9jdW1lbnQudGl0bGUsICBfd2luZG93TG9jLnBhdGhuYW1lICsgX3dpbmRvd0xvYy5zZWFyY2ggKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRfd2luZG93TG9jLmhhc2ggPSAnJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9jbGVhbkhpc3RvcnlUaW1lb3V0cygpO1xuXHRcdFx0fTtcblxuXG5cdFx0XHRfbGlzdGVuKCd1bmJpbmRFdmVudHMnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoX2Nsb3NlZEJ5U2Nyb2xsKSB7XG5cdFx0XHRcdFx0Ly8gaWYgUGhvdG9Td2lwZSBpcyBjbG9zZWQgYnkgc2Nyb2xsLCB3ZSBnbyBcImJhY2tcIiBiZWZvcmUgdGhlIGNsb3NpbmcgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzY3JvbGwgcG9zaXRpb25cblx0XHRcdFx0XHRyZXR1cm5Ub09yaWdpbmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0X2xpc3RlbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZighX2hhc2hSZXNldGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuVG9PcmlnaW5hbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdF9saXN0ZW4oJ2ZpcnN0VXBkYXRlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9jdXJyZW50SXRlbUluZGV4ID0gX3BhcnNlSXRlbUluZGV4RnJvbVVSTCgpLnBpZDtcblx0XHRcdH0pO1xuXG5cdFx0XHRcblxuXHRcdFx0XG5cdFx0XHR2YXIgaW5kZXggPSBfaW5pdGlhbEhhc2guaW5kZXhPZigncGlkPScpO1xuXHRcdFx0aWYoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRfaW5pdGlhbEhhc2ggPSBfaW5pdGlhbEhhc2guc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0XHRcdFx0aWYoX2luaXRpYWxIYXNoLnNsaWNlKC0xKSA9PT0gJyYnKSB7XG5cdFx0XHRcdFx0X2luaXRpYWxIYXNoID0gX2luaXRpYWxIYXNoLnNsaWNlKDAsIC0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKF9pc09wZW4pIHsgLy8gaGFzbid0IGRlc3Ryb3llZCB5ZXRcblx0XHRcdFx0XHRmcmFtZXdvcmsuYmluZCh3aW5kb3csICdoYXNoY2hhbmdlJywgc2VsZi5vbkhhc2hDaGFuZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCA0MCk7XG5cdFx0XHRcblx0XHR9LFxuXHRcdG9uSGFzaENoYW5nZTogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmKF9nZXRIYXNoKCkgPT09IF9pbml0aWFsSGFzaCkge1xuXG5cdFx0XHRcdF9jbG9zZWRGcm9tVVJMID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighX2hhc2hDaGFuZ2VkQnlTY3JpcHQpIHtcblxuXHRcdFx0XHRfaGFzaENoYW5nZWRCeUhpc3RvcnkgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLmdvVG8oIF9wYXJzZUl0ZW1JbmRleEZyb21VUkwoKS5waWQgKTtcblx0XHRcdFx0X2hhc2hDaGFuZ2VkQnlIaXN0b3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9LFxuXHRcdHVwZGF0ZVVSTDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERlbGF5IHRoZSB1cGRhdGUgb2YgVVJMLCB0byBhdm9pZCBsYWcgZHVyaW5nIHRyYW5zaXRpb24sIFxuXHRcdFx0Ly8gYW5kIHRvIG5vdCB0byB0cmlnZ2VyIGFjdGlvbnMgbGlrZSBcInJlZnJlc2ggcGFnZSBzb3VuZFwiIG9yIFwiYmxpbmtpbmcgZmF2aWNvblwiIHRvIG9mdGVuXG5cdFx0XHRcblx0XHRcdF9jbGVhbkhpc3RvcnlUaW1lb3V0cygpO1xuXHRcdFx0XG5cblx0XHRcdGlmKF9oYXNoQ2hhbmdlZEJ5SGlzdG9yeSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFfaGlzdG9yeUNoYW5nZWQpIHtcblx0XHRcdFx0X3VwZGF0ZUhhc2goKTsgLy8gZmlyc3QgdGltZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2hpc3RvcnlVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChfdXBkYXRlSGFzaCwgODAwKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHR9XG59KTtcblxuXG4vKj4+aGlzdG9yeSovXG5cdGZyYW1ld29yay5leHRlbmQoc2VsZiwgcHVibGljTWV0aG9kcyk7IH07XG5cdHJldHVybiBQaG90b1N3aXBlO1xufSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/photoswipe/dist/photoswipe.js\n");

/***/ }),

/***/ "./node_modules/ssr-window/dist/ssr-window.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/ssr-window/dist/ssr-window.esm.js ***!
  \********************************************************/
/*! exports provided: window, document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"window\", function() { return win; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"document\", function() { return doc; });\n/**\n * SSR Window 1.0.1\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2018, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: July 18, 2018\n */\nvar doc = (typeof document === 'undefined') ? {\n  body: {},\n  addEventListener: function addEventListener() {},\n  removeEventListener: function removeEventListener() {},\n  activeElement: {\n    blur: function blur() {},\n    nodeName: '',\n  },\n  querySelector: function querySelector() {\n    return null;\n  },\n  querySelectorAll: function querySelectorAll() {\n    return [];\n  },\n  getElementById: function getElementById() {\n    return null;\n  },\n  createEvent: function createEvent() {\n    return {\n      initEvent: function initEvent() {},\n    };\n  },\n  createElement: function createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute: function setAttribute() {},\n      getElementsByTagName: function getElementsByTagName() {\n        return [];\n      },\n    };\n  },\n  location: { hash: '' },\n} : document; // eslint-disable-line\n\nvar win = (typeof window === 'undefined') ? {\n  document: doc,\n  navigator: {\n    userAgent: '',\n  },\n  location: {},\n  history: {},\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener: function addEventListener() {},\n  removeEventListener: function removeEventListener() {},\n  getComputedStyle: function getComputedStyle() {\n    return {\n      getPropertyValue: function getPropertyValue() {\n        return '';\n      },\n    };\n  },\n  Image: function Image() {},\n  Date: function Date() {},\n  screen: {},\n  setTimeout: function setTimeout() {},\n  clearTimeout: function clearTimeout() {},\n} : window; // eslint-disable-line\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzP2Q3ZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtEQUFrRDtBQUNsRCx3REFBd0Q7QUFDeEQ7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxhQUFhLFdBQVc7QUFDeEIsQ0FBQyxZQUFZOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBLEdBQUc7QUFDSCxrREFBa0Q7QUFDbEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsWUFBWTtBQUNaLHNDQUFzQztBQUN0QywwQ0FBMEM7QUFDMUMsQ0FBQyxVQUFVOztBQUUrQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L2Rpc3Qvc3NyLXdpbmRvdy5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNTUiBXaW5kb3cgMS4wLjFcbiAqIEJldHRlciBoYW5kbGluZyBmb3Igd2luZG93IG9iamVjdCBpbiBTU1IgZW52aXJvbm1lbnRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2xpbWl0czR3ZWIvc3NyLXdpbmRvd1xuICpcbiAqIENvcHlyaWdodCAyMDE4LCBWbGFkaW1pciBLaGFybGFtcGlkaVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICpcbiAqIFJlbGVhc2VkIG9uOiBKdWx5IDE4LCAyMDE4XG4gKi9cbnZhciBkb2MgPSAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgPyB7XG4gIGJvZHk6IHt9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge30sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgYWN0aXZlRWxlbWVudDoge1xuICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7fSxcbiAgICBub2RlTmFtZTogJycsXG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGNyZWF0ZUV2ZW50OiBmdW5jdGlvbiBjcmVhdGVFdmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdEV2ZW50OiBmdW5jdGlvbiBpbml0RXZlbnQoKSB7fSxcbiAgICB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlKCkge30sXG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAgbG9jYXRpb246IHsgaGFzaDogJycgfSxcbn0gOiBkb2N1bWVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgd2luID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSA/IHtcbiAgZG9jdW1lbnQ6IGRvYyxcbiAgbmF2aWdhdG9yOiB7XG4gICAgdXNlckFnZW50OiAnJyxcbiAgfSxcbiAgbG9jYXRpb246IHt9LFxuICBoaXN0b3J5OiB7fSxcbiAgQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge30sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgZ2V0Q29tcHV0ZWRTdHlsZTogZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuICBJbWFnZTogZnVuY3Rpb24gSW1hZ2UoKSB7fSxcbiAgRGF0ZTogZnVuY3Rpb24gRGF0ZSgpIHt9LFxuICBzY3JlZW46IHt9LFxuICBzZXRUaW1lb3V0OiBmdW5jdGlvbiBzZXRUaW1lb3V0KCkge30sXG4gIGNsZWFyVGltZW91dDogZnVuY3Rpb24gY2xlYXJUaW1lb3V0KCkge30sXG59IDogd2luZG93OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCB7IHdpbiBhcyB3aW5kb3csIGRvYyBhcyBkb2N1bWVudCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ssr-window/dist/ssr-window.esm.js\n");

/***/ }),

/***/ "./node_modules/swiper/dist/js/swiper.esm.bundle.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/dist/js/swiper.esm.bundle.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom7/dist/dom7.modular */ \"./node_modules/dom7/dist/dom7.modular.js\");\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/dist/ssr-window.esm.js\");\n/**\n * Swiper 4.5.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * http://www.idangero.us/swiper/\n *\n * Copyright 2014-2019 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: February 22, 2019\n */\n\n\n\n\nconst Methods = {\n  addClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"addClass\"],\n  removeClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"removeClass\"],\n  hasClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"hasClass\"],\n  toggleClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"toggleClass\"],\n  attr: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"attr\"],\n  removeAttr: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"removeAttr\"],\n  data: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"data\"],\n  transform: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"transform\"],\n  transition: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"transition\"],\n  on: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"on\"],\n  off: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"off\"],\n  trigger: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"trigger\"],\n  transitionEnd: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"transitionEnd\"],\n  outerWidth: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"outerWidth\"],\n  outerHeight: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"outerHeight\"],\n  offset: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"offset\"],\n  css: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"css\"],\n  each: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"each\"],\n  html: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"html\"],\n  text: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"text\"],\n  is: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"is\"],\n  index: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"index\"],\n  eq: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"eq\"],\n  append: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"append\"],\n  prepend: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"prepend\"],\n  next: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"next\"],\n  nextAll: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"nextAll\"],\n  prev: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"prev\"],\n  prevAll: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"prevAll\"],\n  parent: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"parent\"],\n  parents: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"parents\"],\n  closest: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"closest\"],\n  find: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"find\"],\n  children: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"children\"],\n  remove: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"remove\"],\n  add: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"add\"],\n  styles: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"styles\"],\n};\n\nObject.keys(Methods).forEach((methodName) => {\n  dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"].fn[methodName] = Methods[methodName];\n});\n\nconst Utils = {\n  deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach((key) => {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  },\n  nextTick(callback, delay = 0) {\n    return setTimeout(callback, delay);\n  },\n  now() {\n    return Date.now();\n  },\n  getTranslate(el, axis = 'x') {\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n\n    const curStyle = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].getComputedStyle(el, null);\n\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n      }\n      // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n      transformMatrix = new ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix) curTransform = transformMatrix.m41;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix) curTransform = transformMatrix.m42;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n  },\n  parseUrlQuery(url) {\n    const query = {};\n    let urlToParse = url || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].location.href;\n    let i;\n    let params;\n    let param;\n    let length;\n    if (typeof urlToParse === 'string' && urlToParse.length) {\n      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\\S*\\?/, '') : '';\n      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');\n      length = params.length;\n\n      for (i = 0; i < length; i += 1) {\n        param = params[i].replace(/#\\S+/g, '').split('=');\n        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';\n      }\n    }\n    return query;\n  },\n  isObject(o) {\n    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;\n  },\n  extend(...args) {\n    const to = Object(args[0]);\n    for (let i = 1; i < args.length; i += 1) {\n      const nextSource = args[i];\n      if (nextSource !== undefined && nextSource !== null) {\n        const keysArray = Object.keys(Object(nextSource));\n        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          const nextKey = keysArray[nextIndex];\n          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n    return to;\n  },\n};\n\nconst Support = (function Support() {\n  const testDiv = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].createElement('div');\n  return {\n    touch: (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Modernizr && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Modernizr.touch === true) || (function checkTouch() {\n      return !!((ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.maxTouchPoints > 0) || ('ontouchstart' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]) || (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].DocumentTouch && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"] instanceof ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].DocumentTouch));\n    }()),\n\n    pointerEvents: !!(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.pointerEnabled || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].PointerEvent || ('maxTouchPoints' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.maxTouchPoints > 0)),\n    prefixedPointerEvents: !!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.msPointerEnabled,\n\n    transition: (function checkTransition() {\n      const style = testDiv.style;\n      return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);\n    }()),\n    transforms3d: (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Modernizr && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Modernizr.csstransforms3d === true) || (function checkTransforms3d() {\n      const style = testDiv.style;\n      return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);\n    }()),\n\n    flexbox: (function checkFlexbox() {\n      const style = testDiv.style;\n      const styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');\n      for (let i = 0; i < styles.length; i += 1) {\n        if (styles[i] in style) return true;\n      }\n      return false;\n    }()),\n\n    observer: (function checkObserver() {\n      return ('MutationObserver' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"] || 'WebkitMutationObserver' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]);\n    }()),\n\n    passiveListener: (function checkPassiveListener() {\n      let supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          // eslint-disable-next-line\n          get() {\n            supportsPassive = true;\n          },\n        });\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('testPassiveListener', null, opts);\n      } catch (e) {\n        // No support\n      }\n      return supportsPassive;\n    }()),\n\n    gestures: (function checkGestures() {\n      return 'ongesturestart' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"];\n    }()),\n  };\n}());\n\nconst Browser = (function Browser() {\n  function isSafari() {\n    const ua = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.toLowerCase();\n    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);\n  }\n  return {\n    isIE: !!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.match(/Trident/g) || !!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.match(/MSIE/g),\n    isEdge: !!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.match(/Edge/g),\n    isSafari: isSafari(),\n    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent),\n  };\n}());\n\nclass SwiperClass {\n  constructor(params = {}) {\n    const self = this;\n    self.params = params;\n\n    // Events\n    self.eventsListeners = {};\n\n    if (self.params && self.params.on) {\n      Object.keys(self.params.on).forEach((eventName) => {\n        self.on(eventName, self.params.on[eventName]);\n      });\n    }\n  }\n\n  on(events, handler, priority) {\n    const self = this;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach((event) => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  }\n\n  once(events, handler, priority) {\n    const self = this;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      handler.apply(self, args);\n      self.off(events, onceHandler);\n      if (onceHandler.f7proxy) {\n        delete onceHandler.f7proxy;\n      }\n    }\n    onceHandler.f7proxy = handler;\n    return self.on(events, onceHandler, priority);\n  }\n\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach((event) => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  }\n\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach((event) => {\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        const handlers = [];\n        self.eventsListeners[event].forEach((eventHandler) => {\n          handlers.push(eventHandler);\n        });\n        handlers.forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n\n  useModulesParams(instanceParams) {\n    const instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach((moduleName) => {\n      const module = instance.modules[moduleName];\n      // Extend params\n      if (module.params) {\n        Utils.extend(instanceParams, module.params);\n      }\n    });\n  }\n\n  useModules(modulesParams = {}) {\n    const instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach((moduleName) => {\n      const module = instance.modules[moduleName];\n      const moduleParams = modulesParams[moduleName] || {};\n      // Extend instance methods and props\n      if (module.instance) {\n        Object.keys(module.instance).forEach((modulePropName) => {\n          const moduleProp = module.instance[modulePropName];\n          if (typeof moduleProp === 'function') {\n            instance[modulePropName] = moduleProp.bind(instance);\n          } else {\n            instance[modulePropName] = moduleProp;\n          }\n        });\n      }\n      // Add event listeners\n      if (module.on && instance.on) {\n        Object.keys(module.on).forEach((moduleEventName) => {\n          instance.on(moduleEventName, module.on[moduleEventName]);\n        });\n      }\n\n      // Module create callback\n      if (module.create) {\n        module.create.bind(instance)(moduleParams);\n      }\n    });\n  }\n\n  static set components(components) {\n    const Class = this;\n    if (!Class.use) return;\n    Class.use(components);\n  }\n\n  static installModule(module, ...params) {\n    const Class = this;\n    if (!Class.prototype.modules) Class.prototype.modules = {};\n    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);\n    Class.prototype.modules[name] = module;\n    // Prototype\n    if (module.proto) {\n      Object.keys(module.proto).forEach((key) => {\n        Class.prototype[key] = module.proto[key];\n      });\n    }\n    // Class\n    if (module.static) {\n      Object.keys(module.static).forEach((key) => {\n        Class[key] = module.static[key];\n      });\n    }\n    // Callback\n    if (module.install) {\n      module.install.apply(Class, params);\n    }\n    return Class;\n  }\n\n  static use(module, ...params) {\n    const Class = this;\n    if (Array.isArray(module)) {\n      module.forEach(m => Class.installModule(m));\n      return Class;\n    }\n    return Class.installModule(module, ...params);\n  }\n}\n\nfunction updateSize () {\n  const swiper = this;\n  let width;\n  let height;\n  const $el = swiper.$el;\n  if (typeof swiper.params.width !== 'undefined') {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined') {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);\n  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);\n\n  Utils.extend(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n}\n\nfunction updateSlides () {\n  const swiper = this;\n  const params = swiper.params;\n\n  const {\n    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.snapGrid.length;\n\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  if (rtl) slides.css({ marginLeft: '', marginTop: '' });\n  else slides.css({ marginRight: '', marginBottom: '' });\n\n  let slidesNumberEvenToRows;\n  if (params.slidesPerColumn > 1) {\n    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;\n    }\n    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);\n    }\n  }\n\n  // Calc slides\n  let slideSize;\n  const slidesPerColumn = params.slidesPerColumn;\n  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;\n  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides.eq(i);\n    if (params.slidesPerColumn > 1) {\n      // Set slides order\n      let newSlideOrderIndex;\n      let column;\n      let row;\n      if (params.slidesPerColumnFill === 'column') {\n        column = Math.floor(i / slidesPerColumn);\n        row = i - (column * slidesPerColumn);\n        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {\n          row += 1;\n          if (row >= slidesPerColumn) {\n            row = 0;\n            column += 1;\n          }\n        }\n        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);\n        slide\n          .css({\n            '-webkit-box-ordinal-group': newSlideOrderIndex,\n            '-moz-box-ordinal-group': newSlideOrderIndex,\n            '-ms-flex-order': newSlideOrderIndex,\n            '-webkit-order': newSlideOrderIndex,\n            order: newSlideOrderIndex,\n          });\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - (row * slidesPerRow);\n      }\n      slide\n        .css(\n          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,\n          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)\n        )\n        .attr('data-swiper-column', column)\n        .attr('data-swiper-row', row);\n    }\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      const slideStyles = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].getComputedStyle(slide[0], null);\n      const currentTransform = slide[0].style.transform;\n      const currentWebKitTransform = slide[0].style.webkitTransform;\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal()\n          ? slide.outerWidth(true)\n          : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        if (swiper.isHorizontal()) {\n          const width = parseFloat(slideStyles.getPropertyValue('width'));\n          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));\n          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));\n          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));\n          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = width + marginLeft + marginRight;\n          } else {\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;\n          }\n        } else {\n          const height = parseFloat(slideStyles.getPropertyValue('height'));\n          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));\n          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));\n          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));\n          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = height + marginTop + marginBottom;\n          } else {\n            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;\n          }\n        }\n      }\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        if (swiper.isHorizontal()) {\n          slides[i].style.width = `${slideSize}px`;\n        } else {\n          slides[i].style.height = `${slideSize}px`;\n        }\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  let newSlidesGrid;\n\n  if (\n    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n  if (!Support.flexbox || params.setWrapperSize) {\n    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n\n  if (params.slidesPerColumn > 1) {\n    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;\n    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });\n    if (params.centeredSlides) {\n      newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid = newSlidesGrid;\n    }\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    if (swiper.isHorizontal()) {\n      if (rtl) slides.css({ marginLeft: `${spaceBetween}px` });\n      else slides.css({ marginRight: `${spaceBetween}px` });\n    } else slides.css({ marginBottom: `${spaceBetween}px` });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Utils.extend(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid,\n  });\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateSlidesOffset();\n  }\n}\n\nfunction updateAutoHeight (speed) {\n  const swiper = this;\n  const activeSlides = [];\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n      const index = swiper.activeIndex + i;\n      if (index > swiper.slides.length) break;\n      activeSlides.push(swiper.slides.eq(index)[0]);\n    }\n  } else {\n    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);\n}\n\nfunction updateSlidesOffset () {\n  const swiper = this;\n  const slides = swiper.slides;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n  }\n}\n\nfunction updateSlidesProgress (translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const { slides, rtlTranslate: rtl } = swiper;\n\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.removeClass(params.slideVisibleClass);\n\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    const slideProgress = (\n      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset\n    ) / (slide.swiperSlideSize + params.spaceBetween);\n    if (params.watchSlidesVisibility) {\n      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);\n      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size)\n                || (slideAfter > 0 && slideAfter <= swiper.size)\n                || (slideBefore <= 0 && slideAfter >= swiper.size);\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides.eq(i).addClass(params.slideVisibleClass);\n      }\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n  }\n  swiper.visibleSlides = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.visibleSlides);\n}\n\nfunction updateProgress (translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let { progress, isBeginning, isEnd } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / (translatesDiff);\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n  Utils.extend(swiper, {\n    progress,\n    isBeginning,\n    isEnd,\n  });\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n\nfunction updateSlidesClasses () {\n  const swiper = this;\n\n  const {\n    slides, params, $wrapperEl, activeIndex, realIndex,\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);\n\n  let activeSlide;\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`);\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  }\n\n  // Active classes\n  activeSlide.addClass(params.slideActiveClass);\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`)\n        .addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`)\n        .addClass(params.slideDuplicateActiveClass);\n    }\n  }\n  // Next Slide\n  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  }\n  // Prev Slide\n  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicateNextClass);\n    }\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicatePrevClass);\n    }\n  }\n}\n\nfunction updateActiveIndex (newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  if (typeof activeIndex === 'undefined') {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n\n  // Get real index\n  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n\n  Utils.extend(swiper, {\n    snapIndex,\n    realIndex,\n    previousIndex,\n    activeIndex,\n  });\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  swiper.emit('slideChange');\n}\n\nfunction updateClickedSlide (e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).closest(`.${params.slideClass}`)[0];\n  let slideFound = false;\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) slideFound = true;\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slide).attr('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slide).index();\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide,\n};\n\nfunction getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n\n  const {\n    params, rtlTranslate: rtl, translate, $wrapperEl,\n  } = swiper;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n\n  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);\n  if (rtl) currentTranslate = -currentTranslate;\n\n  return currentTranslate || 0;\n}\n\nfunction setTranslate (translate, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl, params, $wrapperEl, progress,\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  if (!params.virtualTranslate) {\n    if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n    else $wrapperEl.transform(`translate(${x}px, ${y}px)`);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\nfunction minTranslate () {\n  return (-this.snapGrid[0]);\n}\n\nfunction maxTranslate () {\n  return (-this.snapGrid[this.snapGrid.length - 1]);\n}\n\nvar translate = {\n  getTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n};\n\nfunction setTransition (duration, byController) {\n  const swiper = this;\n\n  swiper.$wrapperEl.transition(duration);\n\n  swiper.emit('setTransition', duration, byController);\n}\n\nfunction transitionStart (runCallbacks = true, direction) {\n  const swiper = this;\n  const { activeIndex, params, previousIndex } = swiper;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit('transitionStart');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionStart');\n      return;\n    }\n    swiper.emit('slideChangeTransitionStart');\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionStart');\n    } else {\n      swiper.emit('slidePrevTransitionStart');\n    }\n  }\n}\n\nfunction transitionEnd (runCallbacks = true, direction) {\n  const swiper = this;\n  const { activeIndex, previousIndex } = swiper;\n  swiper.animating = false;\n  swiper.setTransition(0);\n\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit('transitionEnd');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionEnd');\n      return;\n    }\n    swiper.emit('slideChangeTransitionEnd');\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionEnd');\n    } else {\n      swiper.emit('slidePrevTransitionEnd');\n    }\n  }\n}\n\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd,\n};\n\nfunction slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl,\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  const translate = -snapGrid[snapIndex];\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n\n  if (speed === 0 || !Support.transition) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n\nfunction slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    newIndex += swiper.loopedSlides;\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { params, animating } = swiper;\n  if (params.loop) {\n    if (animating) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    params, animating, snapGrid, slidesGrid, rtlTranslate,\n  } = swiper;\n\n  if (params.loop) {\n    if (animating) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n  const normalizedSlidesGrid = slidesGrid.map(val => normalize(val));\n\n  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];\n  const prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  let prevIndex;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const snapIndex = Math.floor(index / swiper.params.slidesPerGroup);\n\n  if (snapIndex < swiper.snapGrid.length - 1) {\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n\n    if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {\n      index = swiper.params.slidesPerGroup;\n    }\n  }\n\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\nfunction slideToClickedSlide () {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))\n        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))\n      ) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl\n          .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n          .eq(0)\n          .index();\n\n        Utils.nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl\n        .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n        .eq(0)\n        .index();\n\n      Utils.nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide,\n};\n\nfunction loopCreate () {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n  // Remove duplicated slides\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n\n  let slides = $wrapperEl.children(`.${params.slideClass}`);\n\n  if (params.loopFillGroupWithBlank) {\n    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (let i = 0; i < blankSlidesNum; i += 1) {\n        const blankNode = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);\n        $wrapperEl.append(blankNode);\n      }\n      slides = $wrapperEl.children(`.${params.slideClass}`);\n    }\n  }\n\n  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n\n  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);\n  swiper.loopedSlides += params.loopAdditionalSlides;\n  if (swiper.loopedSlides > slides.length) {\n    swiper.loopedSlides = slides.length;\n  }\n\n  const prependSlides = [];\n  const appendSlides = [];\n  slides.each((index, el) => {\n    const slide = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(el);\n    if (index < swiper.loopedSlides) appendSlides.push(el);\n    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);\n    slide.attr('data-swiper-slide-index', index);\n  });\n  for (let i = 0; i < appendSlides.length; i += 1) {\n    $wrapperEl.append(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n    $wrapperEl.prepend(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n}\n\nfunction loopFix () {\n  const swiper = this;\n  const {\n    params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,\n  } = swiper;\n  let newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n\n  const snapTranslate = -snapGrid[activeIndex];\n  const diff = snapTranslate - swiper.getTranslate();\n\n\n  // Fix For Negative Oversliding\n  if (activeIndex < loopedSlides) {\n    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {\n    // Fix For Positive Oversliding\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n}\n\nfunction loopDestroy () {\n  const swiper = this;\n  const { $wrapperEl, params, slides } = swiper;\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();\n  slides.removeAttr('data-swiper-slide-index');\n}\n\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy,\n};\n\nfunction setGrabCursor (moving) {\n  const swiper = this;\n  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) return;\n  const el = swiper.el;\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\n  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n}\n\nfunction unsetGrabCursor () {\n  const swiper = this;\n  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) return;\n  swiper.el.style.cursor = '';\n}\n\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor,\n};\n\nfunction appendSlide (slides) {\n  const swiper = this;\n  const { $wrapperEl, params } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n  } else {\n    $wrapperEl.append(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n}\n\nfunction prependSlide (slides) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.prepend(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    $wrapperEl.prepend(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n\nfunction addSlide (index, slides) {\n  const swiper = this;\n  const { $wrapperEl, params, activeIndex } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides.eq(i);\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    $wrapperEl.append(slides);\n  }\n\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    $wrapperEl.append(slidesBuffer[i]);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeSlide (slidesIndexes) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeAllSlides () {\n  const swiper = this;\n\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n\nvar manipulation = {\n  appendSlide,\n  prependSlide,\n  addSlide,\n  removeSlide,\n  removeAllSlides,\n};\n\nconst Device = (function Device() {\n  const ua = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent;\n\n  const device = {\n    ios: false,\n    android: false,\n    androidChrome: false,\n    desktop: false,\n    windows: false,\n    iphone: false,\n    ipod: false,\n    ipad: false,\n    cordova: ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].cordova || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].phonegap,\n    phonegap: ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].cordova || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].phonegap,\n  };\n\n  const windows = ua.match(/(Windows Phone);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  const ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n\n\n  // Windows\n  if (windows) {\n    device.os = 'windows';\n    device.osVersion = windows[2];\n    device.windows = true;\n  }\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.osVersion = android[2];\n    device.android = true;\n    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n  // iOS\n  if (iphone && !ipod) {\n    device.osVersion = iphone[2].replace(/_/g, '.');\n    device.iphone = true;\n  }\n  if (ipad) {\n    device.osVersion = ipad[2].replace(/_/g, '.');\n    device.ipad = true;\n  }\n  if (ipod) {\n    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n    device.iphone = true;\n  }\n  // iOS 8+ changed UA\n  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {\n    if (device.osVersion.split('.')[0] === '10') {\n      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];\n    }\n  }\n\n  // Desktop\n  device.desktop = !(device.os || device.android || device.webView);\n\n  // Webview\n  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);\n\n  // Minimal UI\n  if (device.os && device.os === 'ios') {\n    const osVersionArr = device.osVersion.split('.');\n    const metaViewport = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].querySelector('meta[name=\"viewport\"]');\n    device.minimalUi = !device.webView\n      && (ipod || iphone)\n      && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)\n      && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;\n  }\n\n  // Pixel Ratio\n  device.pixelRatio = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].devicePixelRatio || 1;\n\n  // Export object\n  return device;\n}());\n\nfunction onTouchStart (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  data.isTouchEvent = e.type === 'touchstart';\n  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n  if (params.noSwiping && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e).closest(params.swipeHandler)[0]) return;\n  }\n\n  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (\n    edgeSwipeDetection\n    && ((startX <= edgeSwipeThreshold)\n    || (startX >= ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].screen.width - edgeSwipeThreshold))\n  ) {\n    return;\n  }\n\n  Utils.extend(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = Utils.now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  if (e.type !== 'touchstart') {\n    let preventDefault = true;\n    if (Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is(data.formElements)) preventDefault = false;\n    if (\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement\n      && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement).is(data.formElements)\n      && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement !== e.target\n    ) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.blur();\n    }\n\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if (params.touchStartForcePreventDefault || shouldPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  swiper.emit('touchStart', e);\n}\n\nfunction onTouchMove (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches, rtlTranslate: rtl } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  if (data.isTouchEvent && e.type === 'mousemove') return;\n  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    // isMoved = true;\n    swiper.allowClick = false;\n    if (data.isTouched) {\n      Utils.extend(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = Utils.now();\n    }\n    return;\n  }\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())\n        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())\n      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (data.isTouchEvent && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement) {\n    if (e.target === ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is(data.formElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if ((diffX * diffX) + (diffY * diffY) >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  e.preventDefault();\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  if (!data.isMoved) {\n    if (params.loop) {\n      swiper.loopFix();\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) diff = -diff;\n\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  data.currentTranslate = diff + data.startTranslate;\n\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger) return;\n\n  // Update active index in free mode\n  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode) {\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: Utils.now(),\n    });\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n\nfunction onTouchEnd (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n\n  const {\n    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap', e);\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      data.clickTimeout = Utils.nextTick(() => {\n        if (!swiper || swiper.destroyed) return;\n        swiper.emit('click', e);\n      }, 300);\n    }\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      swiper.emit('doubleTap', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {\n    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);\n      else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      swiper.slideTo(stopIndex + params.slidesPerGroup);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\nfunction onResize () {\n  const swiper = this;\n\n  const { params, el } = swiper;\n\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  if (params.freeMode) {\n    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());\n    swiper.setTranslate(newTranslate);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n  } else {\n    swiper.updateSlidesClasses();\n    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\nfunction onClick (e) {\n  const swiper = this;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\nfunction attachEvents() {\n  const swiper = this;\n  const {\n    params, touchEvents, el, wrapperEl,\n  } = swiper;\n\n  {\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n\n  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;\n  const capture = !!params.nested;\n\n  // Touch Events\n  {\n    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      if (Support.touch) {\n        const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);\n        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      }\n      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n        target.addEventListener('mousedown', swiper.onTouchStart, false);\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener('mousemove', swiper.onTouchMove, capture);\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener('mouseup', swiper.onTouchEnd, false);\n      }\n    }\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      target.addEventListener('click', swiper.onClick, true);\n    }\n  }\n\n  // Resize handler\n  swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);\n}\n\nfunction detachEvents() {\n  const swiper = this;\n\n  const {\n    params, touchEvents, el, wrapperEl,\n  } = swiper;\n\n  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;\n  const capture = !!params.nested;\n\n  // Touch Events\n  {\n    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      if (Support.touch) {\n        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      }\n      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n        target.removeEventListener('mousedown', swiper.onTouchStart, false);\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener('mousemove', swiper.onTouchMove, capture);\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener('mouseup', swiper.onTouchEnd, false);\n      }\n    }\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      target.removeEventListener('click', swiper.onClick, true);\n    }\n  }\n\n  // Resize handler\n  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);\n}\n\nvar events = {\n  attachEvents,\n  detachEvents,\n};\n\nfunction setBreakpoint () {\n  const swiper = this;\n  const {\n    activeIndex, initialized, loopedSlides = 0, params,\n  } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;\n\n  // Set breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints);\n\n  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    if (breakpointOnlyParams) {\n      ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach((param) => {\n        const paramValue = breakpointOnlyParams[param];\n        if (typeof paramValue === 'undefined') return;\n        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {\n          breakpointOnlyParams[param] = 'auto';\n        } else if (param === 'slidesPerView') {\n          breakpointOnlyParams[param] = parseFloat(paramValue);\n        } else {\n          breakpointOnlyParams[param] = parseInt(paramValue, 10);\n        }\n      });\n    }\n\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n    if (directionChanged && initialized) {\n      swiper.changeDirection();\n    }\n\n    Utils.extend(swiper.params, breakpointParams);\n\n    Utils.extend(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n    });\n\n    swiper.currentBreakpoint = breakpoint;\n\n    if (needsReLoop && initialized) {\n      swiper.loopDestroy();\n      swiper.loopCreate();\n      swiper.updateSlides();\n      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);\n    }\n\n    swiper.emit('breakpoint', breakpointParams);\n  }\n}\n\nfunction getBreakpoint (breakpoints) {\n  const swiper = this;\n  // Get breakpoint for window width\n  if (!breakpoints) return undefined;\n  let breakpoint = false;\n  const points = [];\n  Object.keys(breakpoints).forEach((point) => {\n    points.push(point);\n  });\n  points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const point = points[i];\n    if (swiper.params.breakpointsInverse) {\n      if (point <= ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerWidth) {\n        breakpoint = point;\n      }\n    } else if (point >= ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerWidth && !breakpoint) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n\nvar breakpoints = { setBreakpoint, getBreakpoint };\n\nfunction addClasses () {\n  const swiper = this;\n  const {\n    classNames, params, rtl, $el,\n  } = swiper;\n  const suffixes = [];\n\n  suffixes.push('initialized');\n  suffixes.push(params.direction);\n\n  if (params.freeMode) {\n    suffixes.push('free-mode');\n  }\n  if (!Support.flexbox) {\n    suffixes.push('no-flexbox');\n  }\n  if (params.autoHeight) {\n    suffixes.push('autoheight');\n  }\n  if (rtl) {\n    suffixes.push('rtl');\n  }\n  if (params.slidesPerColumn > 1) {\n    suffixes.push('multirow');\n  }\n  if (Device.android) {\n    suffixes.push('android');\n  }\n  if (Device.ios) {\n    suffixes.push('ios');\n  }\n  // WP8 Touch Events Fix\n  if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n    suffixes.push(`wp8-${params.direction}`);\n  }\n\n  suffixes.forEach((suffix) => {\n    classNames.push(params.containerModifierClass + suffix);\n  });\n\n  $el.addClass(classNames.join(' '));\n}\n\nfunction removeClasses () {\n  const swiper = this;\n  const { $el, classNames } = swiper;\n\n  $el.removeClass(classNames.join(' '));\n}\n\nvar classes = { addClasses, removeClasses };\n\nfunction loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {\n  let image;\n  function onReady() {\n    if (callback) callback();\n  }\n  if (!imageEl.complete || !checkForComplete) {\n    if (src) {\n      image = new ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n      if (sizes) {\n        image.sizes = sizes;\n      }\n      if (srcset) {\n        image.srcset = srcset;\n      }\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    // image already loaded...\n    onReady();\n  }\n}\n\nfunction preloadImages () {\n  const swiper = this;\n  swiper.imagesToLoad = swiper.$el.find('img');\n  function onReady() {\n    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady) swiper.update();\n      swiper.emit('imagesReady');\n    }\n  }\n  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    const imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(\n      imageEl,\n      imageEl.currentSrc || imageEl.getAttribute('src'),\n      imageEl.srcset || imageEl.getAttribute('srcset'),\n      imageEl.sizes || imageEl.getAttribute('sizes'),\n      true,\n      onReady\n    );\n  }\n}\n\nvar images = {\n  loadImage,\n  preloadImages,\n};\n\nfunction checkOverflow() {\n  const swiper = this;\n  const wasLocked = swiper.isLocked;\n\n  swiper.isLocked = swiper.snapGrid.length === 1;\n  swiper.allowSlideNext = !swiper.isLocked;\n  swiper.allowSlidePrev = !swiper.isLocked;\n\n  // events\n  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n    swiper.navigation.update();\n  }\n}\n\nvar checkOverflow$1 = { checkOverflow };\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  touchEventsTarget: 'container',\n  initialSlide: 0,\n  speed: 300,\n  //\n  preventInteractionOnTransition: false,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n\n  // Free mode\n  freeMode: false,\n  freeModeMomentum: true,\n  freeModeMomentumRatio: 1,\n  freeModeMomentumBounce: true,\n  freeModeMomentumBounceRatio: 1,\n  freeModeMomentumVelocityRatio: 1,\n  freeModeSticky: false,\n  freeModeMinimumVelocity: 0.02,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsInverse: false,\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerColumn: 1,\n  slidesPerColumnFill: 'column',\n  slidesPerGroup: 1,\n  centeredSlides: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: false,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: true,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n  watchSlidesVisibility: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopFillGroupWithBlank: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  // NS\n  containerModifierClass: 'swiper-container-', // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-invisible-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideDuplicateClass: 'swiper-slide-duplicate',\n  slideNextClass: 'swiper-slide-next',\n  slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n  slidePrevClass: 'swiper-slide-prev',\n  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n  wrapperClass: 'swiper-wrapper',\n\n  // Callbacks\n  runCallbacksOnInit: true,\n};\n\n/* eslint no-param-reassign: \"off\" */\n\nconst prototypes = {\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  manipulation,\n  events,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes,\n  images,\n};\n\nconst extendedDefaults = {};\n\nclass Swiper extends SwiperClass {\n  constructor(...args) {\n    let el;\n    let params;\n    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n\n    params = Utils.extend({}, params);\n    if (el && !params.el) params.el = el;\n\n    super(params);\n\n    Object.keys(prototypes).forEach((prototypeGroup) => {\n      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n        if (!Swiper.prototype[protoMethod]) {\n          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        }\n      });\n    });\n\n    // Swiper Instance\n    const swiper = this;\n    if (typeof swiper.modules === 'undefined') {\n      swiper.modules = {};\n    }\n    Object.keys(swiper.modules).forEach((moduleName) => {\n      const module = swiper.modules[moduleName];\n      if (module.params) {\n        const moduleParamName = Object.keys(module.params)[0];\n        const moduleParams = module.params[moduleParamName];\n        if (typeof moduleParams !== 'object' || moduleParams === null) return;\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = { enabled: true };\n        }\n        if (\n          typeof params[moduleParamName] === 'object'\n          && !('enabled' in params[moduleParamName])\n        ) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };\n      }\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = Utils.extend({}, defaults);\n    swiper.useModulesParams(swiperParams);\n\n    // Extend defaults with passed params\n    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = Utils.extend({}, swiper.params);\n    swiper.passedParams = Utils.extend({}, params);\n\n    // Save Dom lib\n    swiper.$ = dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"];\n\n    // Find el\n    const $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.el);\n    el = $el[0];\n\n    if (!el) {\n      return undefined;\n    }\n\n    if ($el.length > 1) {\n      const swipers = [];\n      $el.each((index, containerEl) => {\n        const newParams = Utils.extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n\n    el.swiper = swiper;\n    $el.data('swiper', swiper);\n\n    // Find Wrapper\n    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);\n\n    // Extend Swiper\n    Utils.extend(swiper, {\n      $el,\n      el,\n      $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // RTL\n      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEvents: (function touchEvents() {\n        const touch = ['touchstart', 'touchmove', 'touchend'];\n        let desktop = ['mousedown', 'mousemove', 'mouseup'];\n        if (Support.pointerEvents) {\n          desktop = ['pointerdown', 'pointermove', 'pointerup'];\n        } else if (Support.prefixedPointerEvents) {\n          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];\n        }\n        swiper.touchEventsTouch = {\n          start: touch[0],\n          move: touch[1],\n          end: touch[2],\n        };\n        swiper.touchEventsDesktop = {\n          start: desktop[0],\n          move: desktop[1],\n          end: desktop[2],\n        };\n        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\n      }()),\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        formElements: 'input, select, option, textarea, button, video',\n        // Last click time\n        lastClickTime: Utils.now(),\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        isTouchEvent: undefined,\n        startMoving: undefined,\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n\n    });\n\n    // Install Modules\n    swiper.useModules();\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    return swiper;\n  }\n\n  slidesPerViewDynamic() {\n    const swiper = this;\n    const {\n      params, slides, slidesGrid, size: swiperSize, activeIndex,\n    } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex].swiperSlideSize;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {\n          spv += 1;\n        }\n      }\n    }\n    return spv;\n  }\n\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const { snapGrid, params } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (swiper.params.freeMode) {\n      setTranslate();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {\n      return swiper;\n    }\n\n    if (currentDirection === 'vertical') {\n      swiper.$el\n        .removeClass(`${swiper.params.containerModifierClass}vertical wp8-vertical`)\n        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n\n      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);\n      }\n    }\n    if (currentDirection === 'horizontal') {\n      swiper.$el\n        .removeClass(`${swiper.params.containerModifierClass}horizontal wp8-horizontal`)\n        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n\n      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);\n      }\n    }\n\n    swiper.params.direction = newDirection;\n\n    swiper.slides.each((slideIndex, slideEl) => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n\n    return swiper;\n  }\n\n  init() {\n    const swiper = this;\n    if (swiper.initialized) return;\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    // Init Flag\n    swiper.initialized = true;\n\n    // Emit\n    swiper.emit('init');\n  }\n\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const {\n      params, $el, $wrapperEl, slides,\n    } = swiper;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr('style');\n      $wrapperEl.removeAttr('style');\n      if (slides && slides.length) {\n        slides\n          .removeClass([\n            params.slideVisibleClass,\n            params.slideActiveClass,\n            params.slideNextClass,\n            params.slidePrevClass,\n          ].join(' '))\n          .removeAttr('style')\n          .removeAttr('data-swiper-slide-index')\n          .removeAttr('data-swiper-column')\n          .removeAttr('data-swiper-row');\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      swiper.$el.data('swiper', null);\n      Utils.deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n\n    return null;\n  }\n\n  static extendDefaults(newDefaults) {\n    Utils.extend(extendedDefaults, newDefaults);\n  }\n\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static get Class() {\n    return SwiperClass;\n  }\n\n  static get $() {\n    return dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"];\n  }\n}\n\nvar Device$1 = {\n  name: 'device',\n  proto: {\n    device: Device,\n  },\n  static: {\n    device: Device,\n  },\n};\n\nvar Support$1 = {\n  name: 'support',\n  proto: {\n    support: Support,\n  },\n  static: {\n    support: Support,\n  },\n};\n\nvar Browser$1 = {\n  name: 'browser',\n  proto: {\n    browser: Browser,\n  },\n  static: {\n    browser: Browser,\n  },\n};\n\nvar Resize = {\n  name: 'resize',\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      resize: {\n        resizeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('beforeResize');\n          swiper.emit('resize');\n        },\n        orientationChangeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('orientationchange');\n        },\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      // Emit resize\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('resize', swiper.resize.resizeHandler);\n\n      // Emit orientationchange\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n    destroy() {\n      const swiper = this;\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].removeEventListener('resize', swiper.resize.resizeHandler);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n  },\n};\n\nconst Observer = {\n  func: ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].MutationObserver || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebkitMutationObserver,\n  attach(target, options = {}) {\n    const swiper = this;\n\n    const ObserverFunc = Observer.func;\n    const observer = new ObserverFunc((mutations) => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (mutations.length === 1) {\n        swiper.emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        swiper.emit('observerUpdate', mutations[0]);\n      };\n\n      if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].requestAnimationFrame) {\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].requestAnimationFrame(observerUpdate);\n      } else {\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].setTimeout(observerUpdate, 0);\n      }\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    swiper.observer.observers.push(observer);\n  },\n  init() {\n    const swiper = this;\n    if (!Support.observer || !swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = swiper.$el.parents();\n      for (let i = 0; i < containerParents.length; i += 1) {\n        swiper.observer.attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });\n\n    // Observe wrapper\n    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });\n  },\n  destroy() {\n    const swiper = this;\n    swiper.observer.observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    swiper.observer.observers = [];\n  },\n};\n\nvar Observer$1 = {\n  name: 'observer',\n  params: {\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false,\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      observer: {\n        init: Observer.init.bind(swiper),\n        attach: Observer.attach.bind(swiper),\n        destroy: Observer.destroy.bind(swiper),\n        observers: [],\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.observer.init();\n    },\n    destroy() {\n      const swiper = this;\n      swiper.observer.destroy();\n    },\n  },\n};\n\nconst Virtual = {\n  update(force) {\n    const swiper = this;\n    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;\n    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      renderSlide,\n      offset: previousOffset,\n    } = swiper.virtual;\n    swiper.updateActiveIndex();\n    const activeIndex = swiper.activeIndex || 0;\n\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';\n    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;\n      slidesBefore = slidesPerGroup + addSlidesAfter;\n    }\n    const from = Math.max((activeIndex || 0) - slidesBefore, 0);\n    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\n    Utils.extend(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      if (swiper.lazy && swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.css(offsetProp, `${offset}px`);\n      }\n      swiper.updateProgress();\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: (function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()),\n      });\n      onRendered();\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    if (force) {\n      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${i}\"]`).remove();\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      if (i >= from && i <= to) {\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(i);\n        } else {\n          if (i > previousTo) appendIndexes.push(i);\n          if (i < previousFrom) prependIndexes.push(i);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.$wrapperEl.append(renderSlide(slides[index], index));\n    });\n    prependIndexes.sort((a, b) => b - a).forEach((index) => {\n      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n    });\n    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);\n    onRendered();\n  },\n  renderSlide(slide, index) {\n    const swiper = this;\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    const $slideEl = params.renderSlide\n      ? Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.renderSlide.call(swiper, slide, index))\n      : Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"${swiper.params.slideClass}\" data-swiper-slide-index=\"${index}\">${slide}</div>`);\n    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);\n    if (params.cache) swiper.virtual.cache[index] = $slideEl;\n    return $slideEl;\n  },\n  appendSlide(slides) {\n    const swiper = this;\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    swiper.virtual.update(true);\n  },\n  prependSlide(slides) {\n    const swiper = this;\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];\n      });\n      swiper.virtual.cache = newCache;\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  },\n  removeSlide(slidesIndexes) {\n    const swiper = this;\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(activeIndex, 0);\n  },\n  removeAllSlides() {\n    const swiper = this;\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(0, 0);\n  },\n};\n\nvar Virtual$1 = {\n  name: 'virtual',\n  params: {\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      virtual: {\n        update: Virtual.update.bind(swiper),\n        appendSlide: Virtual.appendSlide.bind(swiper),\n        prependSlide: Virtual.prependSlide.bind(swiper),\n        removeSlide: Virtual.removeSlide.bind(swiper),\n        removeAllSlides: Virtual.removeAllSlides.bind(swiper),\n        renderSlide: Virtual.renderSlide.bind(swiper),\n        slides: swiper.params.virtual.slides,\n        cache: {},\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (!swiper.params.virtual.enabled) return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n      const overwriteParams = {\n        watchSlidesProgress: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n\n      if (!swiper.params.initialSlide) {\n        swiper.virtual.update();\n      }\n    },\n    setTranslate() {\n      const swiper = this;\n      if (!swiper.params.virtual.enabled) return;\n      swiper.virtual.update();\n    },\n  },\n};\n\nconst Keyboard = {\n  handle(event) {\n    const swiper = this;\n    const { rtlTranslate: rtl } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    // Directions locks\n    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.nodeName && (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.nodeName.toLowerCase() === 'input' || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.nodeName.toLowerCase() === 'textarea')) {\n      return undefined;\n    }\n    if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {\n        return undefined;\n      }\n      const windowWidth = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerWidth;\n      const windowHeight = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerHeight;\n      const swiperOffset = swiper.$el.offset();\n      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiper.width, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiper.height],\n        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],\n      ];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (\n          point[0] >= 0 && point[0] <= windowWidth\n          && point[1] >= 0 && point[1] <= windowHeight\n        ) {\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (kc === 37 || kc === 39) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if ((kc === 39 && !rtl) || (kc === 37 && rtl)) swiper.slideNext();\n      if ((kc === 37 && !rtl) || (kc === 39 && rtl)) swiper.slidePrev();\n    } else {\n      if (kc === 38 || kc === 40) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (kc === 40) swiper.slideNext();\n      if (kc === 38) swiper.slidePrev();\n    }\n    swiper.emit('keyPress', kc);\n    return undefined;\n  },\n  enable() {\n    const swiper = this;\n    if (swiper.keyboard.enabled) return;\n    Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"]).on('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = true;\n  },\n  disable() {\n    const swiper = this;\n    if (!swiper.keyboard.enabled) return;\n    Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"]).off('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = false;\n  },\n};\n\nvar Keyboard$1 = {\n  name: 'keyboard',\n  params: {\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      keyboard: {\n        enabled: false,\n        enable: Keyboard.enable.bind(swiper),\n        disable: Keyboard.disable.bind(swiper),\n        handle: Keyboard.handle.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.keyboard.enabled) {\n        swiper.keyboard.enable();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.keyboard.enabled) {\n        swiper.keyboard.disable();\n      }\n    },\n  },\n};\n\nfunction isEventSupported() {\n  const eventName = 'onwheel';\n  let isSupported = eventName in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"];\n\n  if (!isSupported) {\n    const element = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported\n    && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation\n    && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation.hasFeature\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation.hasFeature('', '') !== true\n  ) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\nconst Mousewheel = {\n  lastScrollTime: Utils.now(),\n  event: (function getEvent() {\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  }()),\n  normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) { // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else { // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = (pX < 1) ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = (pY < 1) ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  },\n  handleMouseEnter() {\n    const swiper = this;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave() {\n    const swiper = this;\n    swiper.mouseEntered = false;\n  },\n  handle(event) {\n    let e = event;\n    const swiper = this;\n    const params = swiper.params.mousewheel;\n\n    if (!swiper.mouseEntered && !params.releaseOnEdges) return true;\n\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\n    const data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;\n        else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;\n      else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n\n    if (params.invert) delta = -delta;\n\n    if (!swiper.params.freeMode) {\n      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {\n        if (delta < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            swiper.emit('scroll', e);\n          } else if (params.releaseOnEdges) return true;\n        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n          swiper.slidePrev();\n          swiper.emit('scroll', e);\n        } else if (params.releaseOnEdges) return true;\n      }\n      swiper.mousewheel.lastScrollTime = (new ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Date()).getTime();\n    } else {\n      // Freemode or scrollContainer:\n      if (swiper.params.loop) {\n        swiper.loopFix();\n      }\n      let position = swiper.getTranslate() + (delta * params.sensitivity);\n      const wasBeginning = swiper.isBeginning;\n      const wasEnd = swiper.isEnd;\n\n      if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n      if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\n      swiper.setTransition(0);\n      swiper.setTranslate(position);\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n\n      if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n        swiper.updateSlidesClasses();\n      }\n\n      if (swiper.params.freeModeSticky) {\n        clearTimeout(swiper.mousewheel.timeout);\n        swiper.mousewheel.timeout = Utils.nextTick(() => {\n          swiper.slideToClosest();\n        }, 300);\n      }\n      // Emit event\n      swiper.emit('scroll', e);\n\n      // Stop autoplay\n      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n      // Return page scroll on edge positions\n      if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n    }\n\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    return false;\n  },\n  enable() {\n    const swiper = this;\n    if (!Mousewheel.event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.mousewheel.eventsTarged);\n    }\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(Mousewheel.event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable() {\n    const swiper = this;\n    if (!Mousewheel.event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.mousewheel.eventsTarged);\n    }\n    target.off(Mousewheel.event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  },\n};\n\nvar Mousewheel$1 = {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarged: 'container',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      mousewheel: {\n        enabled: false,\n        enable: Mousewheel.enable.bind(swiper),\n        disable: Mousewheel.disable.bind(swiper),\n        handle: Mousewheel.handle.bind(swiper),\n        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),\n        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),\n        lastScrollTime: Utils.now(),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    },\n  },\n};\n\nconst Navigation = {\n  update() {\n    // Update Navigation Buttons\n    const swiper = this;\n    const params = swiper.params.navigation;\n\n    if (swiper.params.loop) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        $prevEl.addClass(params.disabledClass);\n      } else {\n        $prevEl.removeClass(params.disabledClass);\n      }\n      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        $nextEl.addClass(params.disabledClass);\n      } else {\n        $nextEl.removeClass(params.disabledClass);\n      }\n      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n  },\n  onPrevClick(e) {\n    const swiper = this;\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop) return;\n    swiper.slidePrev();\n  },\n  onNextClick(e) {\n    const swiper = this;\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop) return;\n    swiper.slideNext();\n  },\n  init() {\n    const swiper = this;\n    const params = swiper.params.navigation;\n    if (!(params.nextEl || params.prevEl)) return;\n\n    let $nextEl;\n    let $prevEl;\n    if (params.nextEl) {\n      $nextEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.nextEl);\n      if (\n        swiper.params.uniqueNavElements\n        && typeof params.nextEl === 'string'\n        && $nextEl.length > 1\n        && swiper.$el.find(params.nextEl).length === 1\n      ) {\n        $nextEl = swiper.$el.find(params.nextEl);\n      }\n    }\n    if (params.prevEl) {\n      $prevEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.prevEl);\n      if (\n        swiper.params.uniqueNavElements\n        && typeof params.prevEl === 'string'\n        && $prevEl.length > 1\n        && swiper.$el.find(params.prevEl).length === 1\n      ) {\n        $prevEl = swiper.$el.find(params.prevEl);\n      }\n    }\n\n    if ($nextEl && $nextEl.length > 0) {\n      $nextEl.on('click', swiper.navigation.onNextClick);\n    }\n    if ($prevEl && $prevEl.length > 0) {\n      $prevEl.on('click', swiper.navigation.onPrevClick);\n    }\n\n    Utils.extend(swiper.navigation, {\n      $nextEl,\n      nextEl: $nextEl && $nextEl[0],\n      $prevEl,\n      prevEl: $prevEl && $prevEl[0],\n    });\n  },\n  destroy() {\n    const swiper = this;\n    const { $nextEl, $prevEl } = swiper.navigation;\n    if ($nextEl && $nextEl.length) {\n      $nextEl.off('click', swiper.navigation.onNextClick);\n      $nextEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n    if ($prevEl && $prevEl.length) {\n      $prevEl.off('click', swiper.navigation.onPrevClick);\n      $prevEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n  },\n};\n\nvar Navigation$1 = {\n  name: 'navigation',\n  params: {\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      navigation: {\n        init: Navigation.init.bind(swiper),\n        update: Navigation.update.bind(swiper),\n        destroy: Navigation.destroy.bind(swiper),\n        onNextClick: Navigation.onNextClick.bind(swiper),\n        onPrevClick: Navigation.onPrevClick.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.navigation.init();\n      swiper.navigation.update();\n    },\n    toEdge() {\n      const swiper = this;\n      swiper.navigation.update();\n    },\n    fromEdge() {\n      const swiper = this;\n      swiper.navigation.update();\n    },\n    destroy() {\n      const swiper = this;\n      swiper.navigation.destroy();\n    },\n    click(e) {\n      const swiper = this;\n      const { $nextEl, $prevEl } = swiper.navigation;\n      if (\n        swiper.params.navigation.hideOnClick\n        && !Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is($prevEl)\n        && !Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is($nextEl)\n      ) {\n        let isHidden;\n        if ($nextEl) {\n          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n        } else if ($prevEl) {\n          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n        }\n        if (isHidden === true) {\n          swiper.emit('navigationShow', swiper);\n        } else {\n          swiper.emit('navigationHide', swiper);\n        }\n        if ($nextEl) {\n          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n        if ($prevEl) {\n          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n      }\n    },\n  },\n};\n\nconst Pagination = {\n  update() {\n    // Render || Update Pagination bullets/items\n    const swiper = this;\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const $el = swiper.pagination.$el;\n    // Current/Total\n    let current;\n    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {\n        current -= (slidesLength - (swiper.loopedSlides * 2));\n      }\n      if (current > total - 1) current -= total;\n      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);\n          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {\n            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (swiper.pagination.dynamicBulletIndex < 0) {\n            swiper.pagination.dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = current - swiper.pagination.dynamicBulletIndex;\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);\n      if ($el.length > 1) {\n        bullets.each((index, bullet) => {\n          const $bullet = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(bullet);\n          const bulletIndex = $bullet.index();\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(`${params.bulletActiveClass}-main`);\n            }\n            if (bulletIndex === firstIndex) {\n              $bullet\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev`)\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev-prev`);\n            }\n            if (bulletIndex === lastIndex) {\n              $bullet\n                .next()\n                .addClass(`${params.bulletActiveClass}-next`)\n                .next()\n                .addClass(`${params.bulletActiveClass}-next-next`);\n            }\n          }\n        });\n      } else {\n        const $bullet = bullets.eq(current);\n        $bullet.addClass(params.bulletActiveClass);\n        if (params.dynamicBullets) {\n          const $firstDisplayedBullet = bullets.eq(firstIndex);\n          const $lastDisplayedBullet = bullets.eq(lastIndex);\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n          }\n          $firstDisplayedBullet\n            .prev()\n            .addClass(`${params.bulletActiveClass}-prev`)\n            .prev()\n            .addClass(`${params.bulletActiveClass}-prev-prev`);\n          $lastDisplayedBullet\n            .next()\n            .addClass(`${params.bulletActiveClass}-next`)\n            .next()\n            .addClass(`${params.bulletActiveClass}-next-next`);\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);\n      }\n    }\n    if (params.type === 'fraction') {\n      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));\n      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));\n    }\n    if (params.type === 'progressbar') {\n      let progressbarDirection;\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n      }\n      const scale = (current + 1) / total;\n      let scaleX = 1;\n      let scaleY = 1;\n      if (progressbarDirection === 'horizontal') {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);\n    }\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      swiper.emit('paginationRender', swiper, $el[0]);\n    } else {\n      swiper.emit('paginationUpdate', swiper, $el[0]);\n    }\n    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n  },\n  render() {\n    // Render Container\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\n    const $el = swiper.pagination.$el;\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span>`\n        + ' / '\n        + `<span class=\"${params.totalClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type !== 'custom') {\n      swiper.emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  },\n  init() {\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n\n    let $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.el);\n    if ($el.length === 0) return;\n\n    if (\n      swiper.params.uniqueNavElements\n      && typeof params.el === 'string'\n      && $el.length > 1\n      && swiper.$el.find(params.el).length === 1\n    ) {\n      $el = swiper.$el.find(params.el);\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n      swiper.pagination.dynamicBulletIndex = 0;\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n    if (params.type === 'progressbar' && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n\n    if (params.clickable) {\n      $el.on('click', `.${params.bulletClass}`, function onClick(e) {\n        e.preventDefault();\n        let index = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) index += swiper.loopedSlides;\n        swiper.slideTo(index);\n      });\n    }\n\n    Utils.extend(swiper.pagination, {\n      $el,\n      el: $el[0],\n    });\n  },\n  destroy() {\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const $el = swiper.pagination.$el;\n\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n    if (params.clickable) {\n      $el.off('click', `.${params.bulletClass}`);\n    }\n  },\n};\n\nvar Pagination$1 = {\n  name: 'pagination',\n  params: {\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: number => number,\n      formatFractionTotal: number => number,\n      bulletClass: 'swiper-pagination-bullet',\n      bulletActiveClass: 'swiper-pagination-bullet-active',\n      modifierClass: 'swiper-pagination-', // NEW\n      currentClass: 'swiper-pagination-current',\n      totalClass: 'swiper-pagination-total',\n      hiddenClass: 'swiper-pagination-hidden',\n      progressbarFillClass: 'swiper-pagination-progressbar-fill',\n      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',\n      clickableClass: 'swiper-pagination-clickable', // NEW\n      lockClass: 'swiper-pagination-lock',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      pagination: {\n        init: Pagination.init.bind(swiper),\n        render: Pagination.render.bind(swiper),\n        update: Pagination.update.bind(swiper),\n        destroy: Pagination.destroy.bind(swiper),\n        dynamicBulletIndex: 0,\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.pagination.init();\n      swiper.pagination.render();\n      swiper.pagination.update();\n    },\n    activeIndexChange() {\n      const swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        swiper.pagination.update();\n      }\n    },\n    snapIndexChange() {\n      const swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.update();\n      }\n    },\n    slidesLengthChange() {\n      const swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    snapGridLengthChange() {\n      const swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      swiper.pagination.destroy();\n    },\n    click(e) {\n      const swiper = this;\n      if (\n        swiper.params.pagination.el\n        && swiper.params.pagination.hideOnClick\n        && swiper.pagination.$el.length > 0\n        && !Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).hasClass(swiper.params.pagination.bulletClass)\n      ) {\n        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);\n        if (isHidden === true) {\n          swiper.emit('paginationShow', swiper);\n        } else {\n          swiper.emit('paginationHide', swiper);\n        }\n        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    },\n  },\n};\n\nconst Scrollbar = {\n  setTranslate() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const { scrollbar, rtlTranslate: rtl, progress } = swiper;\n    const {\n      dragSize, trackSize, $dragEl, $el,\n    } = scrollbar;\n    const params = swiper.params.scrollbar;\n\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      if (Support.transforms3d) {\n        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);\n      } else {\n        $dragEl.transform(`translateX(${newPos}px)`);\n      }\n      $dragEl[0].style.width = `${newSize}px`;\n    } else {\n      if (Support.transforms3d) {\n        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);\n      } else {\n        $dragEl.transform(`translateY(${newPos}px)`);\n      }\n      $dragEl[0].style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.timeout);\n      $el[0].style.opacity = 1;\n      swiper.scrollbar.timeout = setTimeout(() => {\n        $el[0].style.opacity = 0;\n        $el.transition(400);\n      }, 1000);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.$dragEl.transition(duration);\n  },\n  updateSize() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\n    const { scrollbar } = swiper;\n    const { $dragEl, $el } = scrollbar;\n\n    $dragEl[0].style.width = '';\n    $dragEl[0].style.height = '';\n    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n\n    const divider = swiper.size / swiper.virtualSize;\n    const moveDivider = divider * (trackSize / swiper.size);\n    let dragSize;\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      $dragEl[0].style.width = `${dragSize}px`;\n    } else {\n      $dragEl[0].style.height = `${dragSize}px`;\n    }\n\n    if (divider >= 1) {\n      $el[0].style.display = 'none';\n    } else {\n      $el[0].style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      $el[0].style.opacity = 0;\n    }\n    Utils.extend(scrollbar, {\n      trackSize,\n      divider,\n      moveDivider,\n      dragSize,\n    });\n    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\n  },\n  setDragPosition(e) {\n    const swiper = this;\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { $el, dragSize, trackSize } = scrollbar;\n\n    let pointerPosition;\n    if (swiper.isHorizontal()) {\n      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);\n    } else {\n      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);\n    }\n    let positionRatio;\n    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  },\n  onDragStart(e) {\n    const swiper = this;\n    const params = swiper.params.scrollbar;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n    swiper.scrollbar.isTouched = true;\n    e.preventDefault();\n    e.stopPropagation();\n\n    $wrapperEl.transition(100);\n    $dragEl.transition(100);\n    scrollbar.setDragPosition(e);\n\n    clearTimeout(swiper.scrollbar.dragTimeout);\n\n    $el.transition(0);\n    if (params.hide) {\n      $el.css('opacity', 1);\n    }\n    swiper.emit('scrollbarDragStart', e);\n  },\n  onDragMove(e) {\n    const swiper = this;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n\n    if (!swiper.scrollbar.isTouched) return;\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    scrollbar.setDragPosition(e);\n    $wrapperEl.transition(0);\n    $el.transition(0);\n    $dragEl.transition(0);\n    swiper.emit('scrollbarDragMove', e);\n  },\n  onDragEnd(e) {\n    const swiper = this;\n\n    const params = swiper.params.scrollbar;\n    const { scrollbar } = swiper;\n    const { $el } = scrollbar;\n\n    if (!swiper.scrollbar.isTouched) return;\n    swiper.scrollbar.isTouched = false;\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.dragTimeout);\n      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {\n        $el.css('opacity', 0);\n        $el.transition(400);\n      }, 1000);\n    }\n    swiper.emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  },\n  enableDraggable() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const {\n      scrollbar, touchEventsTouch, touchEventsDesktop, params,\n    } = swiper;\n    const $el = scrollbar.$el;\n    const target = $el[0];\n    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!Support.touch) {\n      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\n    } else {\n      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\n      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\n      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\n    }\n  },\n  disableDraggable() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const {\n      scrollbar, touchEventsTouch, touchEventsDesktop, params,\n    } = swiper;\n    const $el = scrollbar.$el;\n    const target = $el[0];\n    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!Support.touch) {\n      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\n    } else {\n      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\n      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\n      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\n    }\n  },\n  init() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const { scrollbar, $el: $swiperEl } = swiper;\n    const params = swiper.params.scrollbar;\n\n    let $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.el);\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {\n      $el = $swiperEl.find(params.el);\n    }\n\n    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);\n    if ($dragEl.length === 0) {\n      $dragEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"${swiper.params.scrollbar.dragClass}\"></div>`);\n      $el.append($dragEl);\n    }\n\n    Utils.extend(scrollbar, {\n      $el,\n      el: $el[0],\n      $dragEl,\n      dragEl: $dragEl[0],\n    });\n\n    if (params.draggable) {\n      scrollbar.enableDraggable();\n    }\n  },\n  destroy() {\n    const swiper = this;\n    swiper.scrollbar.disableDraggable();\n  },\n};\n\nvar Scrollbar$1 = {\n  name: 'scrollbar',\n  params: {\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      scrollbar: {\n        init: Scrollbar.init.bind(swiper),\n        destroy: Scrollbar.destroy.bind(swiper),\n        updateSize: Scrollbar.updateSize.bind(swiper),\n        setTranslate: Scrollbar.setTranslate.bind(swiper),\n        setTransition: Scrollbar.setTransition.bind(swiper),\n        enableDraggable: Scrollbar.enableDraggable.bind(swiper),\n        disableDraggable: Scrollbar.disableDraggable.bind(swiper),\n        setDragPosition: Scrollbar.setDragPosition.bind(swiper),\n        onDragStart: Scrollbar.onDragStart.bind(swiper),\n        onDragMove: Scrollbar.onDragMove.bind(swiper),\n        onDragEnd: Scrollbar.onDragEnd.bind(swiper),\n        isTouched: false,\n        timeout: null,\n        dragTimeout: null,\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.scrollbar.init();\n      swiper.scrollbar.updateSize();\n      swiper.scrollbar.setTranslate();\n    },\n    update() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    resize() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    observerUpdate() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    setTranslate() {\n      const swiper = this;\n      swiper.scrollbar.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      swiper.scrollbar.setTransition(duration);\n    },\n    destroy() {\n      const swiper = this;\n      swiper.scrollbar.destroy();\n    },\n  },\n};\n\nconst Parallax = {\n  setTransform(el, progress) {\n    const swiper = this;\n    const { rtl } = swiper;\n\n    const $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(el);\n    const rtlFactor = rtl ? -1 : 1;\n\n    const p = $el.attr('data-swiper-parallax') || '0';\n    let x = $el.attr('data-swiper-parallax-x');\n    let y = $el.attr('data-swiper-parallax-y');\n    const scale = $el.attr('data-swiper-parallax-scale');\n    const opacity = $el.attr('data-swiper-parallax-opacity');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if ((x).indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if ((y).indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));\n      $el[0].style.opacity = currentOpacity;\n    }\n    if (typeof scale === 'undefined' || scale === null) {\n      $el.transform(`translate3d(${x}, ${y}, 0px)`);\n    } else {\n      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));\n      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);\n    }\n  },\n  setTranslate() {\n    const swiper = this;\n    const {\n      $el, slides, progress, snapGrid,\n    } = swiper;\n    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n      .each((index, el) => {\n        swiper.parallax.setTransform(el, progress);\n      });\n    slides.each((slideIndex, slideEl) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n        .each((index, el) => {\n          swiper.parallax.setTransform(el, slideProgress);\n        });\n    });\n  },\n  setTransition(duration = this.params.speed) {\n    const swiper = this;\n    const { $el } = swiper;\n    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n      .each((index, parallaxEl) => {\n        const $parallaxEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(parallaxEl);\n        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) parallaxDuration = 0;\n        $parallaxEl.transition(parallaxDuration);\n      });\n  },\n};\n\nvar Parallax$1 = {\n  name: 'parallax',\n  params: {\n    parallax: {\n      enabled: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      parallax: {\n        setTransform: Parallax.setTransform.bind(swiper),\n        setTranslate: Parallax.setTranslate.bind(swiper),\n        setTransition: Parallax.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    init() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTranslate();\n    },\n    setTranslate() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTransition(duration);\n    },\n  },\n};\n\nconst Zoom = {\n  // Calc Scale From Multi-touches\n  getDistanceBetweenTouches(e) {\n    if (e.targetTouches.length < 2) return 1;\n    const x1 = e.targetTouches[0].pageX;\n    const y1 = e.targetTouches[0].pageY;\n    const x2 = e.targetTouches[1].pageX;\n    const y2 = e.targetTouches[1].pageY;\n    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));\n    return distance;\n  },\n  // Events\n  onGestureStart(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    zoom.fakeGestureTouched = false;\n    zoom.fakeGestureMoved = false;\n    if (!Support.gestures) {\n      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureTouched = true;\n      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$slideEl || !gesture.$slideEl.length) {\n      gesture.$slideEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).closest('.swiper-slide');\n      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n      if (gesture.$imageWrapEl.length === 0) {\n        gesture.$imageEl = undefined;\n        return;\n      }\n    }\n    gesture.$imageEl.transition(0);\n    swiper.zoom.isScaling = true;\n  },\n  onGestureChange(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (!Support.gestures) {\n      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureMoved = true;\n      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (Support.gestures) {\n      zoom.scale = e.scale * zoom.currentScale;\n    } else {\n      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;\n    }\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);\n    }\n    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  },\n  onGestureEnd(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (!Support.gestures) {\n      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {\n        return;\n      }\n      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {\n        return;\n      }\n      zoom.fakeGestureTouched = false;\n      zoom.fakeGestureMoved = false;\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n    zoom.currentScale = zoom.scale;\n    zoom.isScaling = false;\n    if (zoom.scale === 1) gesture.$slideEl = undefined;\n  },\n  onTouchStart(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (image.isTouched) return;\n    if (Device.android) e.preventDefault();\n    image.isTouched = true;\n    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  },\n  onTouchMove(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image, velocity } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    swiper.allowClick = false;\n    if (!image.isTouched || !gesture.$slideEl) return;\n\n    if (!image.isMoved) {\n      image.width = gesture.$imageEl[0].offsetWidth;\n      image.height = gesture.$imageEl[0].offsetHeight;\n      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n      gesture.$imageWrapEl.transition(0);\n      if (swiper.rtl) {\n        image.startX = -image.startX;\n        image.startY = -image.startY;\n      }\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n    if (!image.isMoved && !zoom.isScaling) {\n      if (\n        swiper.isHorizontal()\n        && (\n          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)\n          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      } if (\n        !swiper.isHorizontal()\n        && (\n          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)\n          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    e.preventDefault();\n    e.stopPropagation();\n\n    image.isMoved = true;\n    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;\n    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;\n\n    if (image.currentX < image.minX) {\n      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  },\n  onTouchEnd() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image, velocity } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  },\n  onTransitionEnd() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n      gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n\n      zoom.scale = 1;\n      zoom.currentScale = 1;\n\n      gesture.$slideEl = undefined;\n      gesture.$imageEl = undefined;\n      gesture.$imageWrapEl = undefined;\n    }\n  },\n  // Toggle Zoom\n  toggle(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoom.out();\n    } else {\n      // Zoom In\n      zoom.in(e);\n    }\n  },\n  in(e) {\n    const swiper = this;\n\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    const { gesture, image } = zoom;\n\n    if (!gesture.$slideEl) {\n      gesture.$slideEl = swiper.clickedSlide ? Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);\n\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    if (e) {\n      slideWidth = gesture.$slideEl[0].offsetWidth;\n      slideHeight = gesture.$slideEl[0].offsetHeight;\n      offsetX = gesture.$slideEl.offset().left;\n      offsetY = gesture.$slideEl.offset().top;\n      diffX = (offsetX + (slideWidth / 2)) - touchX;\n      diffY = (offsetY + (slideHeight / 2)) - touchY;\n\n      imageWidth = gesture.$imageEl[0].offsetWidth;\n      imageHeight = gesture.$imageEl[0].offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);\n      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);\n    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  },\n  out() {\n    const swiper = this;\n\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    const { gesture } = zoom;\n\n    if (!gesture.$slideEl) {\n      gesture.$slideEl = swiper.clickedSlide ? Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n    zoom.scale = 1;\n    zoom.currentScale = 1;\n    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);\n    gesture.$slideEl = undefined;\n  },\n  // Attach/Detach Events\n  enable() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n\n    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n\n    // Scale image\n    if (Support.gestures) {\n      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    }\n\n    // Move image\n    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);\n  },\n  disable() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n\n    swiper.zoom.enabled = false;\n\n    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n\n    // Scale image\n    if (Support.gestures) {\n      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    }\n\n    // Move image\n    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);\n  },\n};\n\nvar Zoom$1 = {\n  name: 'zoom',\n  params: {\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  },\n  create() {\n    const swiper = this;\n    const zoom = {\n      enabled: false,\n      scale: 1,\n      currentScale: 1,\n      isScaling: false,\n      gesture: {\n        $slideEl: undefined,\n        slideWidth: undefined,\n        slideHeight: undefined,\n        $imageEl: undefined,\n        $imageWrapEl: undefined,\n        maxRatio: 3,\n      },\n      image: {\n        isTouched: undefined,\n        isMoved: undefined,\n        currentX: undefined,\n        currentY: undefined,\n        minX: undefined,\n        minY: undefined,\n        maxX: undefined,\n        maxY: undefined,\n        width: undefined,\n        height: undefined,\n        startX: undefined,\n        startY: undefined,\n        touchesStart: {},\n        touchesCurrent: {},\n      },\n      velocity: {\n        x: undefined,\n        y: undefined,\n        prevPositionX: undefined,\n        prevPositionY: undefined,\n        prevTime: undefined,\n      },\n    };\n\n    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {\n      zoom[methodName] = Zoom[methodName].bind(swiper);\n    });\n    Utils.extend(swiper, {\n      zoom,\n    });\n\n    let scale = 1;\n    Object.defineProperty(swiper.zoom, 'scale', {\n      get() {\n        return scale;\n      },\n      set(value) {\n        if (scale !== value) {\n          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;\n          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;\n          swiper.emit('zoomChange', value, imageEl, slideEl);\n        }\n        scale = value;\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.zoom.enabled) {\n        swiper.zoom.enable();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      swiper.zoom.disable();\n    },\n    touchStart(e) {\n      const swiper = this;\n      if (!swiper.zoom.enabled) return;\n      swiper.zoom.onTouchStart(e);\n    },\n    touchEnd(e) {\n      const swiper = this;\n      if (!swiper.zoom.enabled) return;\n      swiper.zoom.onTouchEnd(e);\n    },\n    doubleTap(e) {\n      const swiper = this;\n      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        swiper.zoom.toggle(e);\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        swiper.zoom.onTransitionEnd();\n      }\n    },\n  },\n};\n\nconst Lazy = {\n  loadInSlide(index, loadInDuplicate = true) {\n    const swiper = this;\n    const params = swiper.params.lazy;\n    if (typeof index === 'undefined') return;\n    if (swiper.slides.length === 0) return;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    const $slideEl = isVirtual\n      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${index}\"]`)\n      : swiper.slides.eq(index);\n\n    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);\n    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {\n      $images = $images.add($slideEl[0]);\n    }\n    if ($images.length === 0) return;\n\n    $images.each((imageIndex, imageEl) => {\n      const $imageEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(imageEl);\n      $imageEl.addClass(params.loadingClass);\n\n      const background = $imageEl.attr('data-background');\n      const src = $imageEl.attr('data-src');\n      const srcset = $imageEl.attr('data-srcset');\n      const sizes = $imageEl.attr('data-sizes');\n\n      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {\n        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;\n        if (background) {\n          $imageEl.css('background-image', `url(\"${background}\")`);\n          $imageEl.removeAttr('data-background');\n        } else {\n          if (srcset) {\n            $imageEl.attr('srcset', srcset);\n            $imageEl.removeAttr('data-srcset');\n          }\n          if (sizes) {\n            $imageEl.attr('sizes', sizes);\n            $imageEl.removeAttr('data-sizes');\n          }\n          if (src) {\n            $imageEl.attr('src', src);\n            $imageEl.removeAttr('data-src');\n          }\n        }\n\n        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n        $slideEl.find(`.${params.preloaderClass}`).remove();\n        if (swiper.params.loop && loadInDuplicate) {\n          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index=\"${slideOriginalIndex}\"]:not(.${swiper.params.slideDuplicateClass})`);\n            swiper.lazy.loadInSlide(originalSlide.index(), false);\n          } else {\n            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index=\"${slideOriginalIndex}\"]`);\n            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);\n          }\n        }\n        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n      });\n\n      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n    });\n  },\n  load() {\n    const swiper = this;\n    const {\n      $wrapperEl, params: swiperParams, slides, activeIndex,\n    } = swiper;\n    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n    const params = swiperParams.lazy;\n\n    let slidesPerView = swiperParams.slidesPerView;\n    if (slidesPerView === 'auto') {\n      slidesPerView = 0;\n    }\n\n    function slideExist(index) {\n      if (isVirtual) {\n        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index=\"${index}\"]`).length) {\n          return true;\n        }\n      } else if (slides[index]) return true;\n      return false;\n    }\n    function slideIndex(slideEl) {\n      if (isVirtual) {\n        return Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).attr('data-swiper-slide-index');\n      }\n      return Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).index();\n    }\n\n    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;\n    if (swiper.params.watchSlidesVisibility) {\n      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {\n        const index = isVirtual ? Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).attr('data-swiper-slide-index') : Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).index();\n        swiper.lazy.loadInSlide(index);\n      });\n    } else if (slidesPerView > 1) {\n      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n        if (slideExist(i)) swiper.lazy.loadInSlide(i);\n      }\n    } else {\n      swiper.lazy.loadInSlide(activeIndex);\n    }\n    if (params.loadPrevNext) {\n      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n        const amount = params.loadPrevNextAmount;\n        const spv = slidesPerView;\n        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);\n        // Next Slides\n        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {\n          if (slideExist(i)) swiper.lazy.loadInSlide(i);\n        }\n        // Prev Slides\n        for (let i = minIndex; i < activeIndex; i += 1) {\n          if (slideExist(i)) swiper.lazy.loadInSlide(i);\n        }\n      } else {\n        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);\n        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));\n\n        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);\n        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));\n      }\n    }\n  },\n};\n\nvar Lazy$1 = {\n  name: 'lazy',\n  params: {\n    lazy: {\n      enabled: false,\n      loadPrevNext: false,\n      loadPrevNextAmount: 1,\n      loadOnTransitionStart: false,\n\n      elementClass: 'swiper-lazy',\n      loadingClass: 'swiper-lazy-loading',\n      loadedClass: 'swiper-lazy-loaded',\n      preloaderClass: 'swiper-lazy-preloader',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      lazy: {\n        initialImageLoaded: false,\n        load: Lazy.load.bind(swiper),\n        loadInSlide: Lazy.loadInSlide.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n        swiper.params.preloadImages = false;\n      }\n    },\n    init() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {\n        swiper.lazy.load();\n      }\n    },\n    scroll() {\n      const swiper = this;\n      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {\n        swiper.lazy.load();\n      }\n    },\n    resize() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    scrollbarDragMove() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    transitionStart() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {\n          swiper.lazy.load();\n        }\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n        swiper.lazy.load();\n      }\n    },\n  },\n};\n\n/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n\nconst Controller = {\n  LinearSpline: function LinearSpline(x, y) {\n    const binarySearch = (function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }());\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];\n    };\n    return this;\n  },\n  // xxx: for now i will just save one spline function to to\n  getInterpolateFunction(c) {\n    const swiper = this;\n    if (!swiper.controller.spline) {\n      swiper.controller.spline = swiper.params.loop\n        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)\n        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n  },\n  setTranslate(setTranslate, byController) {\n    const swiper = this;\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    function setControlledTranslate(c) {\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        swiper.controller.getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  },\n  setTransition(duration, byController) {\n    const swiper = this;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          Utils.nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        c.$wrapperEl.transitionEnd(() => {\n          if (!controlled) return;\n          if (c.params.loop && swiper.params.controller.by === 'slide') {\n            c.loopFix();\n          }\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  },\n};\nvar Controller$1 = {\n  name: 'controller',\n  params: {\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      controller: {\n        control: swiper.params.controller.control,\n        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),\n        setTranslate: Controller.setTranslate.bind(swiper),\n        setTransition: Controller.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    update() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    resize() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    observerUpdate() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    setTranslate(translate, byController) {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      swiper.controller.setTranslate(translate, byController);\n    },\n    setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      swiper.controller.setTransition(duration, byController);\n    },\n  },\n};\n\nconst a11y = {\n  makeElFocusable($el) {\n    $el.attr('tabIndex', '0');\n    return $el;\n  },\n  addElRole($el, role) {\n    $el.attr('role', role);\n    return $el;\n  },\n  addElLabel($el, label) {\n    $el.attr('aria-label', label);\n    return $el;\n  },\n  disableEl($el) {\n    $el.attr('aria-disabled', true);\n    return $el;\n  },\n  enableEl($el) {\n    $el.attr('aria-disabled', false);\n    return $el;\n  },\n  onEnterKey(e) {\n    const swiper = this;\n    const params = swiper.params.a11y;\n    if (e.keyCode !== 13) return;\n    const $targetEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target);\n    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        swiper.a11y.notify(params.lastSlideMessage);\n      } else {\n        swiper.a11y.notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        swiper.a11y.notify(params.firstSlideMessage);\n      } else {\n        swiper.a11y.notify(params.prevSlideMessage);\n      }\n    }\n    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {\n      $targetEl[0].click();\n    }\n  },\n  notify(message) {\n    const swiper = this;\n    const notification = swiper.a11y.liveRegion;\n    if (notification.length === 0) return;\n    notification.html('');\n    notification.html(message);\n  },\n  updateNavigation() {\n    const swiper = this;\n\n    if (swiper.params.loop) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        swiper.a11y.disableEl($prevEl);\n      } else {\n        swiper.a11y.enableEl($prevEl);\n      }\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        swiper.a11y.disableEl($nextEl);\n      } else {\n        swiper.a11y.enableEl($nextEl);\n      }\n    }\n  },\n  updatePagination() {\n    const swiper = this;\n    const params = swiper.params.a11y;\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {\n        const $bulletEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(bulletEl);\n        swiper.a11y.makeElFocusable($bulletEl);\n        swiper.a11y.addElRole($bulletEl, 'button');\n        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));\n      });\n    }\n  },\n  init() {\n    const swiper = this;\n\n    swiper.$el.append(swiper.a11y.liveRegion);\n\n    // Navigation\n    const params = swiper.params.a11y;\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      swiper.a11y.makeElFocusable($nextEl);\n      swiper.a11y.addElRole($nextEl, 'button');\n      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);\n      $nextEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      swiper.a11y.makeElFocusable($prevEl);\n      swiper.a11y.addElRole($prevEl, 'button');\n      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);\n      $prevEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();\n\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      $nextEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      $prevEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);\n    }\n  },\n};\nvar A11y = {\n  name: 'a11y',\n  params: {\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      a11y: {\n        liveRegion: Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<span class=\"${swiper.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`),\n      },\n    });\n    Object.keys(a11y).forEach((methodName) => {\n      swiper.a11y[methodName] = a11y[methodName].bind(swiper);\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.init();\n      swiper.a11y.updateNavigation();\n    },\n    toEdge() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updateNavigation();\n    },\n    fromEdge() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updateNavigation();\n    },\n    paginationUpdate() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updatePagination();\n    },\n    destroy() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.destroy();\n    },\n  },\n};\n\nconst History = {\n  init() {\n    const swiper = this;\n    if (!swiper.params.history) return;\n    if (!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history || !ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    const history = swiper.history;\n    history.initialized = true;\n    history.paths = History.getPathValues();\n    if (!history.paths.key && !history.paths.value) return;\n    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (!swiper.params.history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].removeEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  setHistoryPopState() {\n    const swiper = this;\n    swiper.history.paths = History.getPathValues();\n    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);\n  },\n  getPathValues() {\n    const pathArray = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].location.pathname.slice(1).split('/').filter(part => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return { key, value };\n  },\n  setHistory(key, index) {\n    const swiper = this;\n    if (!swiper.history.initialized || !swiper.params.history.enabled) return;\n    const slide = swiper.slides.eq(index);\n    let value = History.slugify(slide.attr('data-history'));\n    if (!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].location.pathname.includes(key)) {\n      value = `${key}/${value}`;\n    }\n    const currentState = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.replaceState({ value }, null, value);\n    } else {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.pushState({ value }, null, value);\n    }\n  },\n  slugify(text) {\n    return text.toString()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  },\n  scrollToSlide(speed, value, runCallbacks) {\n    const swiper = this;\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHistory = History.slugify(slide.attr('data-history'));\n        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  },\n};\n\nvar History$1 = {\n  name: 'history',\n  params: {\n    history: {\n      enabled: false,\n      replaceState: false,\n      key: 'slides',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      history: {\n        init: History.init.bind(swiper),\n        setHistory: History.setHistory.bind(swiper),\n        setHistoryPopState: History.setHistoryPopState.bind(swiper),\n        scrollToSlide: History.scrollToSlide.bind(swiper),\n        destroy: History.destroy.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.init();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.destroy();\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.history.initialized) {\n        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    },\n  },\n};\n\nconst HashNavigation = {\n  onHashCange() {\n    const swiper = this;\n    const newHash = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].location.hash.replace('#', '');\n    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash=\"${newHash}\"]`).index();\n      if (typeof newIndex === 'undefined') return;\n      swiper.slideTo(newIndex);\n    }\n  },\n  setHash() {\n    const swiper = this;\n    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;\n    if (swiper.params.hashNavigation.replaceState && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));\n    } else {\n      const slide = swiper.slides.eq(swiper.activeIndex);\n      const hash = slide.attr('data-hash') || slide.attr('data-history');\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].location.hash = hash || '';\n    }\n  },\n  init() {\n    const swiper = this;\n    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;\n    swiper.hashNavigation.initialized = true;\n    const hash = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHash = slide.attr('data-hash') || slide.attr('data-history');\n        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n        }\n      }\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]).on('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (swiper.params.hashNavigation.watchState) {\n      Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]).off('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n};\nvar HashNavigation$1 = {\n  name: 'hash-navigation',\n  params: {\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      hashNavigation: {\n        initialized: false,\n        init: HashNavigation.init.bind(swiper),\n        destroy: HashNavigation.destroy.bind(swiper),\n        setHash: HashNavigation.setHash.bind(swiper),\n        onHashCange: HashNavigation.onHashCange.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.init();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.destroy();\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.hashNavigation.initialized) {\n        swiper.hashNavigation.setHash();\n      }\n    },\n  },\n};\n\n/* eslint no-underscore-dangle: \"off\" */\n\nconst Autoplay = {\n  run() {\n    const swiper = this;\n    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    let delay = swiper.params.autoplay.delay;\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n    swiper.autoplay.timeout = Utils.nextTick(() => {\n      if (swiper.params.autoplay.reverseDirection) {\n        if (swiper.params.loop) {\n          swiper.loopFix();\n          swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.isBeginning) {\n          swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else {\n          swiper.autoplay.stop();\n        }\n      } else if (swiper.params.loop) {\n        swiper.loopFix();\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.isEnd) {\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        swiper.slideTo(0, swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else {\n        swiper.autoplay.stop();\n      }\n    }, delay);\n  },\n  start() {\n    const swiper = this;\n    if (typeof swiper.autoplay.timeout !== 'undefined') return false;\n    if (swiper.autoplay.running) return false;\n    swiper.autoplay.running = true;\n    swiper.emit('autoplayStart');\n    swiper.autoplay.run();\n    return true;\n  },\n  stop() {\n    const swiper = this;\n    if (!swiper.autoplay.running) return false;\n    if (typeof swiper.autoplay.timeout === 'undefined') return false;\n\n    if (swiper.autoplay.timeout) {\n      clearTimeout(swiper.autoplay.timeout);\n      swiper.autoplay.timeout = undefined;\n    }\n    swiper.autoplay.running = false;\n    swiper.emit('autoplayStop');\n    return true;\n  },\n  pause(speed) {\n    const swiper = this;\n    if (!swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) return;\n    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.paused = true;\n    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n      swiper.autoplay.paused = false;\n      swiper.autoplay.run();\n    } else {\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n    }\n  },\n};\n\nvar Autoplay$1 = {\n  name: 'autoplay',\n  params: {\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      autoplay: {\n        running: false,\n        paused: false,\n        run: Autoplay.run.bind(swiper),\n        start: Autoplay.start.bind(swiper),\n        stop: Autoplay.stop.bind(swiper),\n        pause: Autoplay.pause.bind(swiper),\n        onTransitionEnd(e) {\n          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n          swiper.autoplay.paused = false;\n          if (!swiper.autoplay.running) {\n            swiper.autoplay.stop();\n          } else {\n            swiper.autoplay.run();\n          }\n        },\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.autoplay.enabled) {\n        swiper.autoplay.start();\n      }\n    },\n    beforeTransitionStart(speed, internal) {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          swiper.autoplay.stop();\n        }\n      }\n    },\n    sliderFirstMove() {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.pause();\n        }\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        swiper.autoplay.stop();\n      }\n    },\n  },\n};\n\nconst Fade = {\n  setTranslate() {\n    const swiper = this;\n    const { slides } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = swiper.slides.eq(i);\n      const offset = $slideEl[0].swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade\n        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\n        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n      $slideEl\n        .css({\n          opacity: slideOpacity,\n        })\n        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { slides, $wrapperEl } = swiper;\n    slides.transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      slides.transitionEnd(() => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar EffectFade = {\n  name: 'effect-fade',\n  params: {\n    fadeEffect: {\n      crossFade: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      fadeEffect: {\n        setTranslate: Fade.setTranslate.bind(swiper),\n        setTransition: Fade.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.fadeEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.fadeEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Cube = {\n  setTranslate() {\n    const swiper = this;\n    const {\n      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let $cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])('<div class=\"swiper-cube-shadow\"></div>');\n          $wrapperEl.append($cubeShadowEl);\n        }\n        $cubeShadowEl.css({ height: `${swiperWidth}px` });\n      } else {\n        $cubeShadowEl = $el.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])('<div class=\"swiper-cube-shadow\"></div>');\n          $el.append($cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + (round * 4 * swiperSize);\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = (3 * swiperSize) + (swiperSize * 4 * round);\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = (slideIndex * 90) + (progress * 90);\n        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);\n      }\n      $slideEl.transform(transform);\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n      }\n    }\n    $wrapperEl.css({\n      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      'transform-origin': `50% 50% -${swiperSize / 2}px`,\n    });\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);\n        const multiplier = 1.5 - (\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)\n          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)\n        );\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);\n      }\n    }\n    const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;\n    $wrapperEl\n      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { $el, slides } = swiper;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      $el.find('.swiper-cube-shadow').transition(duration);\n    }\n  },\n};\n\nvar EffectCube = {\n  name: 'effect-cube',\n  params: {\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      cubeEffect: {\n        setTranslate: Cube.setTranslate.bind(swiper),\n        setTransition: Cube.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.cubeEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.cubeEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Flip = {\n  setTranslate() {\n    const swiper = this;\n    const { slides, rtlTranslate: rtl } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let progress = $slideEl[0].progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      }\n      const offset = $slideEl[0].swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (swiper.params.flipEffect.slideShadows) {\n        // Set shadows\n        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}\"></div>`);\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n      }\n      $slideEl\n        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { slides, activeIndex, $wrapperEl } = swiper;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      // eslint-disable-next-line\n      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar EffectFlip = {\n  name: 'effect-flip',\n  params: {\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      flipEffect: {\n        setTranslate: Flip.setTranslate.bind(swiper),\n        setTransition: Flip.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.flipEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.flipEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Coverflow = {\n  setTranslate() {\n    const swiper = this;\n    const {\n      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,\n    } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const $slideEl = slides.eq(i);\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = $slideEl[0].swiperSlideOffset;\n      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;\n\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n\n      let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);\n      let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n\n      $slideEl.transform(slideTransform);\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        // Set shadows\n        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if ($shadowBeforeEl.length === 0) {\n          $shadowBeforeEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n          $slideEl.append($shadowBeforeEl);\n        }\n        if ($shadowAfterEl.length === 0) {\n          $shadowAfterEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append($shadowAfterEl);\n        }\n        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;\n      }\n    }\n\n    // Set correct perspective for IE10\n    if (Support.pointerEvents || Support.prefixedPointerEvents) {\n      const ws = $wrapperEl[0].style;\n      ws.perspectiveOrigin = `${center}px 50%`;\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    swiper.slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n  },\n};\n\nvar EffectCoverflow = {\n  name: 'effect-coverflow',\n  params: {\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      modifier: 1,\n      slideShadows: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      coverflowEffect: {\n        setTranslate: Coverflow.setTranslate.bind(swiper),\n        setTransition: Coverflow.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n\n      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n      swiper.coverflowEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n      swiper.coverflowEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Thumbs = {\n  init() {\n    const swiper = this;\n    const { thumbs: thumbsParams } = swiper.params;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Utils.extend(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      Utils.extend(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n    } else if (Utils.isObject(thumbsParams.swiper)) {\n      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {\n        watchSlidesVisibility: true,\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      }));\n      swiper.thumbs.swiperCreated = true;\n    }\n    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);\n  },\n  onThumbClick() {\n    const swiper = this;\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      let currentIndex = swiper.activeIndex;\n      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n        swiper.loopFix();\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        currentIndex = swiper.activeIndex;\n      }\n      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`).eq(0).index();\n      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`).eq(0).index();\n      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;\n      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;\n      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;\n      else slideToIndex = prevIndex;\n    }\n    swiper.slideTo(slideToIndex);\n  },\n  update(initial) {\n    const swiper = this;\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n\n    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'\n      ? thumbsSwiper.slidesPerViewDynamic()\n      : thumbsSwiper.params.slidesPerView;\n\n    if (swiper.realIndex !== thumbsSwiper.realIndex) {\n      let currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      if (thumbsSwiper.params.loop) {\n        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\n          thumbsSwiper.loopFix();\n          // eslint-disable-next-line\n          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n          currentThumbsIndex = thumbsSwiper.activeIndex;\n        }\n        // Find actual thumbs index to slide to\n        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`).eq(0).index();\n        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`).eq(0).index();\n        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;\n        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;\n        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;\n        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;\n        else newThumbsIndex = prevThumbsIndex;\n      } else {\n        newThumbsIndex = swiper.realIndex;\n      }\n      if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex) {\n          newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    thumbsSwiper.slides.removeClass(thumbActiveClass);\n    if (thumbsSwiper.params.loop) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).addClass(thumbActiveClass);\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);\n      }\n    }\n  },\n};\nvar Thumbs$1 = {\n  name: 'thumbs',\n  params: {\n    thumbs: {\n      swiper: null,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-container-thumbs',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      thumbs: {\n        swiper: null,\n        init: Thumbs.init.bind(swiper),\n        update: Thumbs.update.bind(swiper),\n        onThumbClick: Thumbs.onThumbClick.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      const { thumbs } = swiper.params;\n      if (!thumbs || !thumbs.swiper) return;\n      swiper.thumbs.init();\n      swiper.thumbs.update(true);\n    },\n    slideChange() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    update() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    resize() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    observerUpdate() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      thumbsSwiper.setTransition(duration);\n    },\n    beforeDestroy() {\n      const swiper = this;\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      if (swiper.thumbs.swiperCreated && thumbsSwiper) {\n        thumbsSwiper.destroy();\n      }\n    },\n  },\n};\n\n// Swiper Class\n\nconst components = [\n  Device$1,\n  Support$1,\n  Browser$1,\n  Resize,\n  Observer$1,\n  Virtual$1,\n  Keyboard$1,\n  Mousewheel$1,\n  Navigation$1,\n  Pagination$1,\n  Scrollbar$1,\n  Parallax$1,\n  Zoom$1,\n  Lazy$1,\n  Controller$1,\n  A11y,\n  History$1,\n  HashNavigation$1,\n  Autoplay$1,\n  EffectFade,\n  EffectCube,\n  EffectFlip,\n  EffectCoverflow,\n  Thumbs$1\n];\n\nif (typeof Swiper.use === 'undefined') {\n  Swiper.use = Swiper.Class.use;\n  Swiper.installModule = Swiper.Class.installModule;\n}\n\nSwiper.use(components);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Swiper);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dpcGVyL2Rpc3QvanMvc3dpcGVyLmVzbS5idW5kbGUuanM/NDFkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpWTtBQUNuVjs7QUFFOUM7QUFDQSxFQUFFLHlFQUFRO0FBQ1YsRUFBRSwrRUFBVztBQUNiLEVBQUUseUVBQVE7QUFDVixFQUFFLCtFQUFXO0FBQ2IsRUFBRSxpRUFBSTtBQUNOLEVBQUUsNkVBQVU7QUFDWixFQUFFLGlFQUFJO0FBQ04sRUFBRSwyRUFBUztBQUNYLGNBQWMsaUVBQVk7QUFDMUIsRUFBRSw2REFBRTtBQUNKLEVBQUUsK0RBQUc7QUFDTCxFQUFFLHVFQUFPO0FBQ1QsaUJBQWlCLG9FQUFlO0FBQ2hDLEVBQUUsNkVBQVU7QUFDWixFQUFFLCtFQUFXO0FBQ2IsRUFBRSxxRUFBTTtBQUNSLEVBQUUsK0RBQUc7QUFDTCxFQUFFLGlFQUFJO0FBQ04sRUFBRSxpRUFBSTtBQUNOLEVBQUUsaUVBQUk7QUFDTixFQUFFLDZEQUFFO0FBQ0osRUFBRSxtRUFBSztBQUNQLEVBQUUsNkRBQUU7QUFDSixFQUFFLHFFQUFNO0FBQ1IsRUFBRSx1RUFBTztBQUNULEVBQUUsaUVBQUk7QUFDTixFQUFFLHVFQUFPO0FBQ1QsRUFBRSxpRUFBSTtBQUNOLEVBQUUsdUVBQU87QUFDVCxFQUFFLHFFQUFNO0FBQ1IsRUFBRSx1RUFBTztBQUNULEVBQUUsdUVBQU87QUFDVCxFQUFFLGlFQUFJO0FBQ04sRUFBRSx5RUFBUTtBQUNWLEVBQUUscUVBQU07QUFDUixFQUFFLCtEQUFHO0FBQ0wsRUFBRSxxRUFBTTtBQUNSOztBQUVBO0FBQ0EsRUFBRSx3REFBQztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNB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QUNBLGtFQUFrRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDcEYsMkNBQTJDLEVBQUUsTUFBTSxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQVE7QUFDbkMscUJBQXFCLG1EQUFRLGtCQUFrQixnRUFBQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxhQUFhOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsMkNBQTJDOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFRO0FBQ2QsTUFBTSxtREFBUTtBQUNkLEtBQUs7QUFDTDtBQUNBLDRIQUE0SCxnQ0FBZ0M7QUFDNUo7QUFDQSxpR0FBaUcsMEJBQTBCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBUTtBQUNoQixRQUFRLG1EQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFRO0FBQ2QsTUFBTSxtREFBUTtBQUNkLEtBQUs7QUFDTDtBQUNBLDhIQUE4SCxnQ0FBZ0M7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBUTtBQUNoQixRQUFRLG1EQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdB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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQyxHQUFHLE1BQU0sR0FBRztBQUM5QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQUM7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQixZQUFZLFlBQVksS0FBSztBQUN4RCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQixnRUFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLCtCQUErQixlQUFlLDhCQUE4QixtQkFBbUIsR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFDLG9DQUFvQyw4QkFBOEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFDLG9DQUFvQyxrQ0FBa0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RCwyQ0FBMkMsZUFBZTtBQUMxRCwwQ0FBMEMsZUFBZTtBQUN6RCxzQ0FBc0MsZUFBZTtBQUNyRCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvREFBb0Qsd0NBQXdDLE1BQU0saUJBQWlCLHlDQUF5QyxtQkFBbUI7QUFDL0ssT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTyxPQUFPLE9BQU8scUJBQXFCLDRCQUE0QixNQUFNLDJCQUEyQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRLGNBQWMsMENBQTBDLGVBQWUsMkNBQTJDO0FBQ2hLLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQUMsb0NBQW9DLHVDQUF1QztBQUNyRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQUMsb0NBQW9DLDJDQUEyQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxNQUFNLEdBQUcsbUJBQW1CLFFBQVEsZUFBZSxRQUFRO0FBQ2hHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsV0FBVyxLQUFLLFdBQVcsS0FBSyxXQUFXLGVBQWUsUUFBUSxlQUFlLFFBQVE7O0FBRXJJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFDLG9DQUFvQyw4QkFBOEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFDLG9DQUFvQyxrQ0FBa0M7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxxQ0FBcUM7QUFDckUsZ0NBQWdDLHFDQUFxQzs7QUFFckU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQUM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdFQUFDO0FBQy9CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixhQUFhO0FBQ3pHLDRGQUE0RixhQUFhO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxpQkFBaUI7QUFDakksZ0hBQWdILGlCQUFpQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQyxzRUFBc0UscUJBQXFCO0FBQzNGO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUscUVBQU0sRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZGlzdC9qcy9zd2lwZXIuZXNtLmJ1bmRsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3dpcGVyIDQuNS4wXG4gKiBNb3N0IG1vZGVybiBtb2JpbGUgdG91Y2ggc2xpZGVyIGFuZCBmcmFtZXdvcmsgd2l0aCBoYXJkd2FyZSBhY2NlbGVyYXRlZCB0cmFuc2l0aW9uc1xuICogaHR0cDovL3d3dy5pZGFuZ2Vyby51cy9zd2lwZXIvXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOSBWbGFkaW1pciBLaGFybGFtcGlkaVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICpcbiAqIFJlbGVhc2VkIG9uOiBGZWJydWFyeSAyMiwgMjAxOVxuICovXG5cbmltcG9ydCB7ICQsIGFkZENsYXNzLCByZW1vdmVDbGFzcywgaGFzQ2xhc3MsIHRvZ2dsZUNsYXNzLCBhdHRyLCByZW1vdmVBdHRyLCBkYXRhLCB0cmFuc2Zvcm0sIHRyYW5zaXRpb24gYXMgdHJhbnNpdGlvbiQxLCBvbiwgb2ZmLCB0cmlnZ2VyLCB0cmFuc2l0aW9uRW5kIGFzIHRyYW5zaXRpb25FbmQkMSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQsIG9mZnNldCwgY3NzLCBlYWNoLCBodG1sLCB0ZXh0LCBpcywgaW5kZXgsIGVxLCBhcHBlbmQsIHByZXBlbmQsIG5leHQsIG5leHRBbGwsIHByZXYsIHByZXZBbGwsIHBhcmVudCwgcGFyZW50cywgY2xvc2VzdCwgZmluZCwgY2hpbGRyZW4sIHJlbW92ZSwgYWRkLCBzdHlsZXMgfSBmcm9tICdkb203L2Rpc3QvZG9tNy5tb2R1bGFyJztcbmltcG9ydCB7IHdpbmRvdywgZG9jdW1lbnQgfSBmcm9tICdzc3Itd2luZG93JztcblxuY29uc3QgTWV0aG9kcyA9IHtcbiAgYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzLFxuICBoYXNDbGFzcyxcbiAgdG9nZ2xlQ2xhc3MsXG4gIGF0dHIsXG4gIHJlbW92ZUF0dHIsXG4gIGRhdGEsXG4gIHRyYW5zZm9ybSxcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxLFxuICBvbixcbiAgb2ZmLFxuICB0cmlnZ2VyLFxuICB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kJDEsXG4gIG91dGVyV2lkdGgsXG4gIG91dGVySGVpZ2h0LFxuICBvZmZzZXQsXG4gIGNzcyxcbiAgZWFjaCxcbiAgaHRtbCxcbiAgdGV4dCxcbiAgaXMsXG4gIGluZGV4LFxuICBlcSxcbiAgYXBwZW5kLFxuICBwcmVwZW5kLFxuICBuZXh0LFxuICBuZXh0QWxsLFxuICBwcmV2LFxuICBwcmV2QWxsLFxuICBwYXJlbnQsXG4gIHBhcmVudHMsXG4gIGNsb3Nlc3QsXG4gIGZpbmQsXG4gIGNoaWxkcmVuLFxuICByZW1vdmUsXG4gIGFkZCxcbiAgc3R5bGVzLFxufTtcblxuT2JqZWN0LmtleXMoTWV0aG9kcykuZm9yRWFjaCgobWV0aG9kTmFtZSkgPT4ge1xuICAkLmZuW21ldGhvZE5hbWVdID0gTWV0aG9kc1ttZXRob2ROYW1lXTtcbn0pO1xuXG5jb25zdCBVdGlscyA9IHtcbiAgZGVsZXRlUHJvcHMob2JqKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vIGdldHRlciBmb3Igb2JqZWN0XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBkZWxldGUgb2JqZWN0W2tleV07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyBnb3Qgd3JvbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgbmV4dFRpY2soY2FsbGJhY2ssIGRlbGF5ID0gMCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gIH0sXG4gIG5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfSxcbiAgZ2V0VHJhbnNsYXRlKGVsLCBheGlzID0gJ3gnKSB7XG4gICAgbGV0IG1hdHJpeDtcbiAgICBsZXQgY3VyVHJhbnNmb3JtO1xuICAgIGxldCB0cmFuc2Zvcm1NYXRyaXg7XG5cbiAgICBjb25zdCBjdXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcblxuICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSB7XG4gICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgICAgaWYgKGN1clRyYW5zZm9ybS5zcGxpdCgnLCcpLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgY3VyVHJhbnNmb3JtID0gY3VyVHJhbnNmb3JtLnNwbGl0KCcsICcpLm1hcChhID0+IGEucmVwbGFjZSgnLCcsICcuJykpLmpvaW4oJywgJyk7XG4gICAgICB9XG4gICAgICAvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBXZWJraXQgY2hva2Ugd2hlbiAnbm9uZScgaXMgcGFzc2VkOyBwYXNzXG4gICAgICAvLyBlbXB0eSBzdHJpbmcgaW5zdGVhZCBpbiB0aGlzIGNhc2VcbiAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KGN1clRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBjdXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcbiAgICAgIG1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeC50b1N0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQxO1xuICAgICAgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxMl0pO1xuICAgICAgLy8gTm9ybWFsIEJyb3dzZXJzXG4gICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzRdKTtcbiAgICB9XG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQyO1xuICAgICAgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxM10pO1xuICAgICAgLy8gTm9ybWFsIEJyb3dzZXJzXG4gICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzVdKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1clRyYW5zZm9ybSB8fCAwO1xuICB9LFxuICBwYXJzZVVybFF1ZXJ5KHVybCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0ge307XG4gICAgbGV0IHVybFRvUGFyc2UgPSB1cmwgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgbGV0IGk7XG4gICAgbGV0IHBhcmFtcztcbiAgICBsZXQgcGFyYW07XG4gICAgbGV0IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIHVybFRvUGFyc2UgPT09ICdzdHJpbmcnICYmIHVybFRvUGFyc2UubGVuZ3RoKSB7XG4gICAgICB1cmxUb1BhcnNlID0gdXJsVG9QYXJzZS5pbmRleE9mKCc/JykgPiAtMSA/IHVybFRvUGFyc2UucmVwbGFjZSgvXFxTKlxcPy8sICcnKSA6ICcnO1xuICAgICAgcGFyYW1zID0gdXJsVG9QYXJzZS5zcGxpdCgnJicpLmZpbHRlcihwYXJhbXNQYXJ0ID0+IHBhcmFtc1BhcnQgIT09ICcnKTtcbiAgICAgIGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwYXJhbSA9IHBhcmFtc1tpXS5yZXBsYWNlKC8jXFxTKy9nLCAnJykuc3BsaXQoJz0nKTtcbiAgICAgICAgcXVlcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtWzBdKV0gPSB0eXBlb2YgcGFyYW1bMV0gPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtWzFdKSB8fCAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9LFxuICBpc09iamVjdChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9LFxuICBleHRlbmQoLi4uYXJncykge1xuICAgIGNvbnN0IHRvID0gT2JqZWN0KGFyZ3NbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3NbaV07XG4gICAgICBpZiAobmV4dFNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIG5leHRTb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICAgICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXggKz0gMSkge1xuICAgICAgICAgIGNvbnN0IG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0KHRvW25leHRLZXldKSAmJiBVdGlscy5pc09iamVjdChuZXh0U291cmNlW25leHRLZXldKSkge1xuICAgICAgICAgICAgICBVdGlscy5leHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghVXRpbHMuaXNPYmplY3QodG9bbmV4dEtleV0pICYmIFV0aWxzLmlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgIHRvW25leHRLZXldID0ge307XG4gICAgICAgICAgICAgIFV0aWxzLmV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfSxcbn07XG5cbmNvbnN0IFN1cHBvcnQgPSAoZnVuY3Rpb24gU3VwcG9ydCgpIHtcbiAgY29uc3QgdGVzdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICByZXR1cm4ge1xuICAgIHRvdWNoOiAod2luZG93Lk1vZGVybml6ciAmJiB3aW5kb3cuTW9kZXJuaXpyLnRvdWNoID09PSB0cnVlKSB8fCAoZnVuY3Rpb24gY2hlY2tUb3VjaCgpIHtcbiAgICAgIHJldHVybiAhISgod2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApIHx8ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8ICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XG4gICAgfSgpKSxcblxuICAgIHBvaW50ZXJFdmVudHM6ICEhKHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgd2luZG93LlBvaW50ZXJFdmVudCB8fCAoJ21heFRvdWNoUG9pbnRzJyBpbiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKSksXG4gICAgcHJlZml4ZWRQb2ludGVyRXZlbnRzOiAhIXdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCxcblxuICAgIHRyYW5zaXRpb246IChmdW5jdGlvbiBjaGVja1RyYW5zaXRpb24oKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IHRlc3REaXYuc3R5bGU7XG4gICAgICByZXR1cm4gKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSB8fCAnd2Via2l0VHJhbnNpdGlvbicgaW4gc3R5bGUgfHwgJ01velRyYW5zaXRpb24nIGluIHN0eWxlKTtcbiAgICB9KCkpLFxuICAgIHRyYW5zZm9ybXMzZDogKHdpbmRvdy5Nb2Rlcm5penIgJiYgd2luZG93Lk1vZGVybml6ci5jc3N0cmFuc2Zvcm1zM2QgPT09IHRydWUpIHx8IChmdW5jdGlvbiBjaGVja1RyYW5zZm9ybXMzZCgpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGVzdERpdi5zdHlsZTtcbiAgICAgIHJldHVybiAoJ3dlYmtpdFBlcnNwZWN0aXZlJyBpbiBzdHlsZSB8fCAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlIHx8ICdPUGVyc3BlY3RpdmUnIGluIHN0eWxlIHx8ICdNc1BlcnNwZWN0aXZlJyBpbiBzdHlsZSB8fCAncGVyc3BlY3RpdmUnIGluIHN0eWxlKTtcbiAgICB9KCkpLFxuXG4gICAgZmxleGJveDogKGZ1bmN0aW9uIGNoZWNrRmxleGJveCgpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGVzdERpdi5zdHlsZTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9ICgnYWxpZ25JdGVtcyB3ZWJraXRBbGlnbkl0ZW1zIHdlYmtpdEJveEFsaWduIG1zRmxleEFsaWduIG1vekJveEFsaWduIHdlYmtpdEZsZXhEaXJlY3Rpb24gbXNGbGV4RGlyZWN0aW9uIG1vekJveERpcmVjdGlvbiBtb3pCb3hPcmllbnQgd2Via2l0Qm94RGlyZWN0aW9uIHdlYmtpdEJveE9yaWVudCcpLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoc3R5bGVzW2ldIGluIHN0eWxlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KCkpLFxuXG4gICAgb2JzZXJ2ZXI6IChmdW5jdGlvbiBjaGVja09ic2VydmVyKCkge1xuICAgICAgcmV0dXJuICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93IHx8ICdXZWJraXRNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpO1xuICAgIH0oKSksXG5cbiAgICBwYXNzaXZlTGlzdGVuZXI6IChmdW5jdGlvbiBjaGVja1Bhc3NpdmVMaXN0ZW5lcigpIHtcbiAgICAgIGxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUxpc3RlbmVyJywgbnVsbCwgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE5vIHN1cHBvcnRcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XG4gICAgfSgpKSxcblxuICAgIGdlc3R1cmVzOiAoZnVuY3Rpb24gY2hlY2tHZXN0dXJlcygpIHtcbiAgICAgIHJldHVybiAnb25nZXN0dXJlc3RhcnQnIGluIHdpbmRvdztcbiAgICB9KCkpLFxuICB9O1xufSgpKTtcblxuY29uc3QgQnJvd3NlciA9IChmdW5jdGlvbiBCcm93c2VyKCkge1xuICBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICBjb25zdCB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuICh1YS5pbmRleE9mKCdzYWZhcmknKSA+PSAwICYmIHVhLmluZGV4T2YoJ2Nocm9tZScpIDwgMCAmJiB1YS5pbmRleE9mKCdhbmRyb2lkJykgPCAwKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzSUU6ICEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvZykgfHwgISF3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRS9nKSxcbiAgICBpc0VkZ2U6ICEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2UvZyksXG4gICAgaXNTYWZhcmk6IGlzU2FmYXJpKCksXG4gICAgaXNVaVdlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gIH07XG59KCkpO1xuXG5jbGFzcyBTd2lwZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5wYXJhbXMgPSBwYXJhbXM7XG5cbiAgICAvLyBFdmVudHNcbiAgICBzZWxmLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xuXG4gICAgaWYgKHNlbGYucGFyYW1zICYmIHNlbGYucGFyYW1zLm9uKSB7XG4gICAgICBPYmplY3Qua2V5cyhzZWxmLnBhcmFtcy5vbikuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIHNlbGYub24oZXZlbnROYW1lLCBzZWxmLnBhcmFtcy5vbltldmVudE5hbWVdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF1bbWV0aG9kXShoYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIG9uY2UoZXZlbnRzLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoLi4uYXJncykge1xuICAgICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIHNlbGYub2ZmKGV2ZW50cywgb25jZUhhbmRsZXIpO1xuICAgICAgaWYgKG9uY2VIYW5kbGVyLmY3cHJveHkpIHtcbiAgICAgICAgZGVsZXRlIG9uY2VIYW5kbGVyLmY3cHJveHk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uY2VIYW5kbGVyLmY3cHJveHkgPSBoYW5kbGVyO1xuICAgIHJldHVybiBzZWxmLm9uKGV2ZW50cywgb25jZUhhbmRsZXIsIHByaW9yaXR5KTtcbiAgfVxuXG4gIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdICYmIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLmZvckVhY2goKGV2ZW50SGFuZGxlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyID09PSBoYW5kbGVyIHx8IChldmVudEhhbmRsZXIuZjdwcm94eSAmJiBldmVudEhhbmRsZXIuZjdwcm94eSA9PT0gaGFuZGxlcikpIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBlbWl0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBsZXQgZXZlbnRzO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgZXZlbnRzID0gYXJnc1swXTtcbiAgICAgIGRhdGEgPSBhcmdzLnNsaWNlKDEsIGFyZ3MubGVuZ3RoKTtcbiAgICAgIGNvbnRleHQgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudHMgPSBhcmdzWzBdLmV2ZW50cztcbiAgICAgIGRhdGEgPSBhcmdzWzBdLmRhdGE7XG4gICAgICBjb250ZXh0ID0gYXJnc1swXS5jb250ZXh0IHx8IHNlbGY7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c0FycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KCcgJyk7XG4gICAgZXZlbnRzQXJyYXkuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIGlmIChzZWxmLmV2ZW50c0xpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLmZvckVhY2goKGV2ZW50SGFuZGxlcikgPT4ge1xuICAgICAgICAgIGhhbmRsZXJzLnB1c2goZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGV2ZW50SGFuZGxlcikgPT4ge1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5hcHBseShjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICB1c2VNb2R1bGVzUGFyYW1zKGluc3RhbmNlUGFyYW1zKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuICAgIGlmICghaW5zdGFuY2UubW9kdWxlcykgcmV0dXJuO1xuICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm1vZHVsZXMpLmZvckVhY2goKG1vZHVsZU5hbWUpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RhbmNlLm1vZHVsZXNbbW9kdWxlTmFtZV07XG4gICAgICAvLyBFeHRlbmQgcGFyYW1zXG4gICAgICBpZiAobW9kdWxlLnBhcmFtcykge1xuICAgICAgICBVdGlscy5leHRlbmQoaW5zdGFuY2VQYXJhbXMsIG1vZHVsZS5wYXJhbXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXNlTW9kdWxlcyhtb2R1bGVzUGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG4gICAgaWYgKCFpbnN0YW5jZS5tb2R1bGVzKSByZXR1cm47XG4gICAgT2JqZWN0LmtleXMoaW5zdGFuY2UubW9kdWxlcykuZm9yRWFjaCgobW9kdWxlTmFtZSkgPT4ge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdGFuY2UubW9kdWxlc1ttb2R1bGVOYW1lXTtcbiAgICAgIGNvbnN0IG1vZHVsZVBhcmFtcyA9IG1vZHVsZXNQYXJhbXNbbW9kdWxlTmFtZV0gfHwge307XG4gICAgICAvLyBFeHRlbmQgaW5zdGFuY2UgbWV0aG9kcyBhbmQgcHJvcHNcbiAgICAgIGlmIChtb2R1bGUuaW5zdGFuY2UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobW9kdWxlLmluc3RhbmNlKS5mb3JFYWNoKChtb2R1bGVQcm9wTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZHVsZVByb3AgPSBtb2R1bGUuaW5zdGFuY2VbbW9kdWxlUHJvcE5hbWVdO1xuICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaW5zdGFuY2VbbW9kdWxlUHJvcE5hbWVdID0gbW9kdWxlUHJvcC5iaW5kKGluc3RhbmNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2VbbW9kdWxlUHJvcE5hbWVdID0gbW9kdWxlUHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgaWYgKG1vZHVsZS5vbiAmJiBpbnN0YW5jZS5vbikge1xuICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGUub24pLmZvckVhY2goKG1vZHVsZUV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgIGluc3RhbmNlLm9uKG1vZHVsZUV2ZW50TmFtZSwgbW9kdWxlLm9uW21vZHVsZUV2ZW50TmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTW9kdWxlIGNyZWF0ZSBjYWxsYmFja1xuICAgICAgaWYgKG1vZHVsZS5jcmVhdGUpIHtcbiAgICAgICAgbW9kdWxlLmNyZWF0ZS5iaW5kKGluc3RhbmNlKShtb2R1bGVQYXJhbXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHNldCBjb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCBDbGFzcyA9IHRoaXM7XG4gICAgaWYgKCFDbGFzcy51c2UpIHJldHVybjtcbiAgICBDbGFzcy51c2UoY29tcG9uZW50cyk7XG4gIH1cblxuICBzdGF0aWMgaW5zdGFsbE1vZHVsZShtb2R1bGUsIC4uLnBhcmFtcykge1xuICAgIGNvbnN0IENsYXNzID0gdGhpcztcbiAgICBpZiAoIUNsYXNzLnByb3RvdHlwZS5tb2R1bGVzKSBDbGFzcy5wcm90b3R5cGUubW9kdWxlcyA9IHt9O1xuICAgIGNvbnN0IG5hbWUgPSBtb2R1bGUubmFtZSB8fCAoYCR7T2JqZWN0LmtleXMoQ2xhc3MucHJvdG90eXBlLm1vZHVsZXMpLmxlbmd0aH1fJHtVdGlscy5ub3coKX1gKTtcbiAgICBDbGFzcy5wcm90b3R5cGUubW9kdWxlc1tuYW1lXSA9IG1vZHVsZTtcbiAgICAvLyBQcm90b3R5cGVcbiAgICBpZiAobW9kdWxlLnByb3RvKSB7XG4gICAgICBPYmplY3Qua2V5cyhtb2R1bGUucHJvdG8pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBDbGFzcy5wcm90b3R5cGVba2V5XSA9IG1vZHVsZS5wcm90b1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENsYXNzXG4gICAgaWYgKG1vZHVsZS5zdGF0aWMpIHtcbiAgICAgIE9iamVjdC5rZXlzKG1vZHVsZS5zdGF0aWMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBDbGFzc1trZXldID0gbW9kdWxlLnN0YXRpY1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENhbGxiYWNrXG4gICAgaWYgKG1vZHVsZS5pbnN0YWxsKSB7XG4gICAgICBtb2R1bGUuaW5zdGFsbC5hcHBseShDbGFzcywgcGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIENsYXNzO1xuICB9XG5cbiAgc3RhdGljIHVzZShtb2R1bGUsIC4uLnBhcmFtcykge1xuICAgIGNvbnN0IENsYXNzID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGUpKSB7XG4gICAgICBtb2R1bGUuZm9yRWFjaChtID0+IENsYXNzLmluc3RhbGxNb2R1bGUobSkpO1xuICAgICAgcmV0dXJuIENsYXNzO1xuICAgIH1cbiAgICByZXR1cm4gQ2xhc3MuaW5zdGFsbE1vZHVsZShtb2R1bGUsIC4uLnBhcmFtcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgY29uc3QgJGVsID0gc3dpcGVyLiRlbDtcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpZHRoID0gc3dpcGVyLnBhcmFtcy53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9ICRlbFswXS5jbGllbnRXaWR0aDtcbiAgfVxuICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMuaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGhlaWdodCA9IHN3aXBlci5wYXJhbXMuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGhlaWdodCA9ICRlbFswXS5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgaWYgKCh3aWR0aCA9PT0gMCAmJiBzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHx8IChoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTdWJ0cmFjdCBwYWRkaW5nc1xuICB3aWR0aCA9IHdpZHRoIC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy1sZWZ0JyksIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctcmlnaHQnKSwgMTApO1xuICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLXRvcCcpLCAxMCkgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG5cbiAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBzaXplOiBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB3aWR0aCA6IGhlaWdodCxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlcyAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG5cbiAgY29uc3Qge1xuICAgICR3cmFwcGVyRWwsIHNpemU6IHN3aXBlclNpemUsIHJ0bFRyYW5zbGF0ZTogcnRsLCB3cm9uZ1JUTCxcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgY29uc3QgcHJldmlvdXNTbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gIGNvbnN0IHNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHNsaWRlcy5sZW5ndGg7XG4gIGxldCBzbmFwR3JpZCA9IFtdO1xuICBjb25zdCBzbGlkZXNHcmlkID0gW107XG4gIGNvbnN0IHNsaWRlc1NpemVzR3JpZCA9IFtdO1xuXG4gIGxldCBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlO1xuICBpZiAodHlwZW9mIG9mZnNldEJlZm9yZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9mZnNldEJlZm9yZSA9IHBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmUuY2FsbChzd2lwZXIpO1xuICB9XG5cbiAgbGV0IG9mZnNldEFmdGVyID0gcGFyYW1zLnNsaWRlc09mZnNldEFmdGVyO1xuICBpZiAodHlwZW9mIG9mZnNldEFmdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXIuY2FsbChzd2lwZXIpO1xuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG5cbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gIGxldCBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcbiAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICBzcGFjZUJldHdlZW4gPSAocGFyc2VGbG9hdChzcGFjZUJldHdlZW4ucmVwbGFjZSgnJScsICcnKSkgLyAxMDApICogc3dpcGVyU2l6ZTtcbiAgfVxuXG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IC1zcGFjZUJldHdlZW47XG5cbiAgLy8gcmVzZXQgbWFyZ2luc1xuICBpZiAocnRsKSBzbGlkZXMuY3NzKHsgbWFyZ2luTGVmdDogJycsIG1hcmdpblRvcDogJycgfSk7XG4gIGVsc2Ugc2xpZGVzLmNzcyh7IG1hcmdpblJpZ2h0OiAnJywgbWFyZ2luQm90dG9tOiAnJyB9KTtcblxuICBsZXQgc2xpZGVzTnVtYmVyRXZlblRvUm93cztcbiAgaWYgKHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxKSB7XG4gICAgaWYgKE1hdGguZmxvb3Ioc2xpZGVzTGVuZ3RoIC8gcGFyYW1zLnNsaWRlc1BlckNvbHVtbikgPT09IHNsaWRlc0xlbmd0aCAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSB7XG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gc2xpZGVzTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5jZWlsKHNsaWRlc0xlbmd0aCAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pICogcGFyYW1zLnNsaWRlc1BlckNvbHVtbjtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgcGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdyb3cnKSB7XG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5tYXgoc2xpZGVzTnVtYmVyRXZlblRvUm93cywgcGFyYW1zLnNsaWRlc1BlclZpZXcgKiBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjIHNsaWRlc1xuICBsZXQgc2xpZGVTaXplO1xuICBjb25zdCBzbGlkZXNQZXJDb2x1bW4gPSBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uO1xuICBjb25zdCBzbGlkZXNQZXJSb3cgPSBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzIC8gc2xpZGVzUGVyQ29sdW1uO1xuICBjb25zdCBudW1GdWxsQ29sdW1ucyA9IE1hdGguZmxvb3Ioc2xpZGVzTGVuZ3RoIC8gcGFyYW1zLnNsaWRlc1BlckNvbHVtbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZVNpemUgPSAwO1xuICAgIGNvbnN0IHNsaWRlID0gc2xpZGVzLmVxKGkpO1xuICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkge1xuICAgICAgLy8gU2V0IHNsaWRlcyBvcmRlclxuICAgICAgbGV0IG5ld1NsaWRlT3JkZXJJbmRleDtcbiAgICAgIGxldCBjb2x1bW47XG4gICAgICBsZXQgcm93O1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJDb2x1bW5GaWxsID09PSAnY29sdW1uJykge1xuICAgICAgICBjb2x1bW4gPSBNYXRoLmZsb29yKGkgLyBzbGlkZXNQZXJDb2x1bW4pO1xuICAgICAgICByb3cgPSBpIC0gKGNvbHVtbiAqIHNsaWRlc1BlckNvbHVtbik7XG4gICAgICAgIGlmIChjb2x1bW4gPiBudW1GdWxsQ29sdW1ucyB8fCAoY29sdW1uID09PSBudW1GdWxsQ29sdW1ucyAmJiByb3cgPT09IHNsaWRlc1BlckNvbHVtbiAtIDEpKSB7XG4gICAgICAgICAgcm93ICs9IDE7XG4gICAgICAgICAgaWYgKHJvdyA+PSBzbGlkZXNQZXJDb2x1bW4pIHtcbiAgICAgICAgICAgIHJvdyA9IDA7XG4gICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2xpZGVPcmRlckluZGV4ID0gY29sdW1uICsgKChyb3cgKiBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzKSAvIHNsaWRlc1BlckNvbHVtbik7XG4gICAgICAgIHNsaWRlXG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAnLXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cCc6IG5ld1NsaWRlT3JkZXJJbmRleCxcbiAgICAgICAgICAgICctbW96LWJveC1vcmRpbmFsLWdyb3VwJzogbmV3U2xpZGVPcmRlckluZGV4LFxuICAgICAgICAgICAgJy1tcy1mbGV4LW9yZGVyJzogbmV3U2xpZGVPcmRlckluZGV4LFxuICAgICAgICAgICAgJy13ZWJraXQtb3JkZXInOiBuZXdTbGlkZU9yZGVySW5kZXgsXG4gICAgICAgICAgICBvcmRlcjogbmV3U2xpZGVPcmRlckluZGV4LFxuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93ID0gTWF0aC5mbG9vcihpIC8gc2xpZGVzUGVyUm93KTtcbiAgICAgICAgY29sdW1uID0gaSAtIChyb3cgKiBzbGlkZXNQZXJSb3cpO1xuICAgICAgfVxuICAgICAgc2xpZGVcbiAgICAgICAgLmNzcyhcbiAgICAgICAgICBgbWFyZ2luLSR7c3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3RvcCcgOiAnbGVmdCd9YCxcbiAgICAgICAgICAocm93ICE9PSAwICYmIHBhcmFtcy5zcGFjZUJldHdlZW4pICYmIChgJHtwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YClcbiAgICAgICAgKVxuICAgICAgICAuYXR0cignZGF0YS1zd2lwZXItY29sdW1uJywgY29sdW1uKVxuICAgICAgICAuYXR0cignZGF0YS1zd2lwZXItcm93Jywgcm93KTtcbiAgICB9XG4gICAgaWYgKHNsaWRlLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgICAgY29uc3Qgc2xpZGVTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZVswXSwgbnVsbCk7XG4gICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtO1xuICAgICAgY29uc3QgY3VycmVudFdlYktpdFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybTtcbiAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50V2ViS2l0VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSB7XG4gICAgICAgIHNsaWRlU2l6ZSA9IHN3aXBlci5pc0hvcml6b250YWwoKVxuICAgICAgICAgID8gc2xpZGUub3V0ZXJXaWR0aCh0cnVlKVxuICAgICAgICAgIDogc2xpZGUub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKTtcbiAgICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0JykpO1xuICAgICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcbiAgICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpKTtcbiAgICAgICAgICBjb25zdCBtYXJnaW5SaWdodCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpO1xuICAgICAgICAgIGNvbnN0IGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcbiAgICAgICAgICBpZiAoYm94U2l6aW5nICYmIGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XG4gICAgICAgICAgICBzbGlkZVNpemUgPSB3aWR0aCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSk7XG4gICAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSk7XG4gICAgICAgICAgY29uc3QgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1ib3R0b20nKSk7XG4gICAgICAgICAgY29uc3QgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcbiAgICAgICAgICBjb25zdCBib3hTaXppbmcgPSBzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdib3gtc2l6aW5nJyk7XG4gICAgICAgICAgaWYgKGJveFNpemluZyAmJiBib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgICAgc2xpZGVTaXplID0gaGVpZ2h0ICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGlkZVNpemUgPSBoZWlnaHQgKyBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbSArIG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybSA9IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xuICAgICAgICBzbGlkZVswXS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBjdXJyZW50V2ViS2l0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVTaXplID0gKHN3aXBlclNpemUgLSAoKHBhcmFtcy5zbGlkZXNQZXJWaWV3IC0gMSkgKiBzcGFjZUJldHdlZW4pKSAvIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcblxuICAgICAgaWYgKHNsaWRlc1tpXSkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgc2xpZGVzW2ldLnN0eWxlLndpZHRoID0gYCR7c2xpZGVTaXplfXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZXNbaV0uc3R5bGUuaGVpZ2h0ID0gYCR7c2xpZGVTaXplfXB4YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgIH1cbiAgICBzbGlkZXNTaXplc0dyaWQucHVzaChzbGlkZVNpemUpO1xuXG5cbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiArIChzbGlkZVNpemUgLyAyKSArIChwcmV2U2xpZGVTaXplIC8gMikgKyBzcGFjZUJldHdlZW47XG4gICAgICBpZiAocHJldlNsaWRlU2l6ZSA9PT0gMCAmJiBpICE9PSAwKSBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiAtIChzd2lwZXJTaXplIC8gMikgLSBzcGFjZUJldHdlZW47XG4gICAgICBpZiAoaSA9PT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSAoc3dpcGVyU2l6ZSAvIDIpIC0gc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKE1hdGguYWJzKHNsaWRlUG9zaXRpb24pIDwgMSAvIDEwMDApIHNsaWRlUG9zaXRpb24gPSAwO1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgaWYgKChpbmRleCkgJSBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDApIHNuYXBHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVBvc2l0aW9uID0gTWF0aC5mbG9vcihzbGlkZVBvc2l0aW9uKTtcbiAgICAgIGlmICgoaW5kZXgpICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgfVxuXG4gICAgc3dpcGVyLnZpcnR1YWxTaXplICs9IHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbjtcblxuICAgIHByZXZTbGlkZVNpemUgPSBzbGlkZVNpemU7XG5cbiAgICBpbmRleCArPSAxO1xuICB9XG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcbiAgbGV0IG5ld1NsaWRlc0dyaWQ7XG5cbiAgaWYgKFxuICAgIHJ0bCAmJiB3cm9uZ1JUTCAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnY292ZXJmbG93JykpIHtcbiAgICAkd3JhcHBlckVsLmNzcyh7IHdpZHRoOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgfVxuICBpZiAoIVN1cHBvcnQuZmxleGJveCB8fCBwYXJhbXMuc2V0V3JhcHBlclNpemUpIHtcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSAkd3JhcHBlckVsLmNzcyh7IHdpZHRoOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgICBlbHNlICR3cmFwcGVyRWwuY3NzKHsgaGVpZ2h0OiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgfVxuXG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkge1xuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSA9IChzbGlkZVNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVuKSAqIHNsaWRlc051bWJlckV2ZW5Ub1Jvd3M7XG4gICAgc3dpcGVyLnZpcnR1YWxTaXplID0gTWF0aC5jZWlsKHN3aXBlci52aXJ0dWFsU2l6ZSAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pIC0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSAkd3JhcHBlckVsLmNzcyh7IHdpZHRoOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgICBlbHNlICR3cmFwcGVyRWwuY3NzKHsgaGVpZ2h0OiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBuZXdTbGlkZXNHcmlkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBzbGlkZXNHcmlkSXRlbSA9IHNuYXBHcmlkW2ldO1xuICAgICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVzR3JpZEl0ZW0gPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgICAgaWYgKHNuYXBHcmlkW2ldIDwgc3dpcGVyLnZpcnR1YWxTaXplICsgc25hcEdyaWRbMF0pIG5ld1NsaWRlc0dyaWQucHVzaChzbGlkZXNHcmlkSXRlbSk7XG4gICAgICB9XG4gICAgICBzbmFwR3JpZCA9IG5ld1NsaWRlc0dyaWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGxhc3QgZ3JpZCBlbGVtZW50cyBkZXBlbmRpbmcgb24gd2lkdGhcbiAgaWYgKCFwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICBuZXdTbGlkZXNHcmlkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFwR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGV0IHNsaWRlc0dyaWRJdGVtID0gc25hcEdyaWRbaV07XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVzR3JpZEl0ZW0gPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgIGlmIChzbmFwR3JpZFtpXSA8PSBzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKSB7XG4gICAgICAgIG5ld1NsaWRlc0dyaWQucHVzaChzbGlkZXNHcmlkSXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNuYXBHcmlkID0gbmV3U2xpZGVzR3JpZDtcbiAgICBpZiAoTWF0aC5mbG9vcihzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKSAtIE1hdGguZmxvb3Ioc25hcEdyaWRbc25hcEdyaWQubGVuZ3RoIC0gMV0pID4gMSkge1xuICAgICAgc25hcEdyaWQucHVzaChzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCA9PT0gMCkgc25hcEdyaWQgPSBbMF07XG5cbiAgaWYgKHBhcmFtcy5zcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBpZiAocnRsKSBzbGlkZXMuY3NzKHsgbWFyZ2luTGVmdDogYCR7c3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgICAgIGVsc2Ugc2xpZGVzLmNzcyh7IG1hcmdpblJpZ2h0OiBgJHtzcGFjZUJldHdlZW59cHhgIH0pO1xuICAgIH0gZWxzZSBzbGlkZXMuY3NzKHsgbWFyZ2luQm90dG9tOiBgJHtzcGFjZUJldHdlZW59cHhgIH0pO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICBsZXQgYWxsU2xpZGVzU2l6ZSA9IDA7XG4gICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goKHNsaWRlU2l6ZVZhbHVlKSA9PiB7XG4gICAgICBhbGxTbGlkZXNTaXplICs9IHNsaWRlU2l6ZVZhbHVlICsgKHBhcmFtcy5zcGFjZUJldHdlZW4gPyBwYXJhbXMuc3BhY2VCZXR3ZWVuIDogMCk7XG4gICAgfSk7XG4gICAgYWxsU2xpZGVzU2l6ZSAtPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuICAgIGlmIChhbGxTbGlkZXNTaXplIDwgc3dpcGVyU2l6ZSkge1xuICAgICAgY29uc3QgYWxsU2xpZGVzT2Zmc2V0ID0gKHN3aXBlclNpemUgLSBhbGxTbGlkZXNTaXplKSAvIDI7XG4gICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgc25hcEdyaWRbc25hcEluZGV4XSA9IHNuYXAgLSBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIHNsaWRlc0dyaWQuZm9yRWFjaCgoc25hcCwgc25hcEluZGV4KSA9PiB7XG4gICAgICAgIHNsaWRlc0dyaWRbc25hcEluZGV4XSA9IHNuYXAgKyBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgc2xpZGVzLFxuICAgIHNuYXBHcmlkLFxuICAgIHNsaWRlc0dyaWQsXG4gICAgc2xpZGVzU2l6ZXNHcmlkLFxuICB9KTtcblxuICBpZiAoc2xpZGVzTGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0xlbmd0aCkge1xuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuICBpZiAoc25hcEdyaWQubGVuZ3RoICE9PSBwcmV2aW91c1NuYXBHcmlkTGVuZ3RoKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICBzd2lwZXIuZW1pdCgnc25hcEdyaWRMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuICBpZiAoc2xpZGVzR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCkge1xuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVBdXRvSGVpZ2h0IChzcGVlZCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBhY3RpdmVTbGlkZXMgPSBbXTtcbiAgbGV0IG5ld0hlaWdodCA9IDA7XG4gIGxldCBpO1xuICBpZiAodHlwZW9mIHNwZWVkID09PSAnbnVtYmVyJykge1xuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcbiAgfSBlbHNlIGlmIChzcGVlZCA9PT0gdHJ1ZSkge1xuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHN3aXBlci5wYXJhbXMuc3BlZWQpO1xuICB9XG4gIC8vIEZpbmQgc2xpZGVzIGN1cnJlbnRseSBpbiB2aWV3XG4gIGlmIChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IE1hdGguY2VpbChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcpOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4ICsgaTtcbiAgICAgIGlmIChpbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoKSBicmVhaztcbiAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKHN3aXBlci5zbGlkZXMuZXEoaW5kZXgpWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlU2xpZGVzLnB1c2goc3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpWzBdKTtcbiAgfVxuXG4gIC8vIEZpbmQgbmV3IGhlaWdodCBmcm9tIGhpZ2hlc3Qgc2xpZGUgaW4gdmlld1xuICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVTbGlkZXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTbGlkZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgbmV3SGVpZ2h0ID0gaGVpZ2h0ID4gbmV3SGVpZ2h0ID8gaGVpZ2h0IDogbmV3SGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBIZWlnaHRcbiAgaWYgKG5ld0hlaWdodCkgc3dpcGVyLiR3cmFwcGVyRWwuY3NzKCdoZWlnaHQnLCBgJHtuZXdIZWlnaHR9cHhgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0ICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qgc2xpZGVzID0gc3dpcGVyLnNsaWRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVPZmZzZXQgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBzbGlkZXNbaV0ub2Zmc2V0TGVmdCA6IHNsaWRlc1tpXS5vZmZzZXRUb3A7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzUHJvZ3Jlc3MgKHRyYW5zbGF0ZSA9ICh0aGlzICYmIHRoaXMudHJhbnNsYXRlKSB8fCAwKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG5cbiAgY29uc3QgeyBzbGlkZXMsIHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XG5cbiAgaWYgKHNsaWRlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQgPT09ICd1bmRlZmluZWQnKSBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XG5cbiAgbGV0IG9mZnNldENlbnRlciA9IC10cmFuc2xhdGU7XG4gIGlmIChydGwpIG9mZnNldENlbnRlciA9IHRyYW5zbGF0ZTtcblxuICAvLyBWaXNpYmxlIFNsaWRlc1xuICBzbGlkZXMucmVtb3ZlQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcblxuICBzd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMgPSBbXTtcbiAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNsaWRlID0gc2xpZGVzW2ldO1xuICAgIGNvbnN0IHNsaWRlUHJvZ3Jlc3MgPSAoXG4gICAgICAob2Zmc2V0Q2VudGVyICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApKSAtIHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0XG4gICAgKSAvIChzbGlkZS5zd2lwZXJTbGlkZVNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVuKTtcbiAgICBpZiAocGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xuICAgICAgY29uc3Qgc2xpZGVCZWZvcmUgPSAtKG9mZnNldENlbnRlciAtIHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IHNsaWRlQWZ0ZXIgPSBzbGlkZUJlZm9yZSArIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbaV07XG4gICAgICBjb25zdCBpc1Zpc2libGUgPSAoc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8IHN3aXBlci5zaXplKVxuICAgICAgICAgICAgICAgIHx8IChzbGlkZUFmdGVyID4gMCAmJiBzbGlkZUFmdGVyIDw9IHN3aXBlci5zaXplKVxuICAgICAgICAgICAgICAgIHx8IChzbGlkZUJlZm9yZSA8PSAwICYmIHNsaWRlQWZ0ZXIgPj0gc3dpcGVyLnNpemUpO1xuICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLnB1c2goaSk7XG4gICAgICAgIHNsaWRlcy5lcShpKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBzbGlkZS5wcm9ncmVzcyA9IHJ0bCA/IC1zbGlkZVByb2dyZXNzIDogc2xpZGVQcm9ncmVzcztcbiAgfVxuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9ICQoc3dpcGVyLnZpc2libGVTbGlkZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyAodHJhbnNsYXRlID0gKHRoaXMgJiYgdGhpcy50cmFuc2xhdGUpIHx8IDApIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcblxuICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgbGV0IHsgcHJvZ3Jlc3MsIGlzQmVnaW5uaW5nLCBpc0VuZCB9ID0gc3dpcGVyO1xuICBjb25zdCB3YXNCZWdpbm5pbmcgPSBpc0JlZ2lubmluZztcbiAgY29uc3Qgd2FzRW5kID0gaXNFbmQ7XG4gIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgIHByb2dyZXNzID0gMDtcbiAgICBpc0JlZ2lubmluZyA9IHRydWU7XG4gICAgaXNFbmQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHByb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyAodHJhbnNsYXRlc0RpZmYpO1xuICAgIGlzQmVnaW5uaW5nID0gcHJvZ3Jlc3MgPD0gMDtcbiAgICBpc0VuZCA9IHByb2dyZXNzID49IDE7XG4gIH1cbiAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgIHByb2dyZXNzLFxuICAgIGlzQmVnaW5uaW5nLFxuICAgIGlzRW5kLFxuICB9KTtcblxuICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkgc3dpcGVyLnVwZGF0ZVNsaWRlc1Byb2dyZXNzKHRyYW5zbGF0ZSk7XG5cbiAgaWYgKGlzQmVnaW5uaW5nICYmICF3YXNCZWdpbm5pbmcpIHtcbiAgICBzd2lwZXIuZW1pdCgncmVhY2hCZWdpbm5pbmcgdG9FZGdlJyk7XG4gIH1cbiAgaWYgKGlzRW5kICYmICF3YXNFbmQpIHtcbiAgICBzd2lwZXIuZW1pdCgncmVhY2hFbmQgdG9FZGdlJyk7XG4gIH1cbiAgaWYgKCh3YXNCZWdpbm5pbmcgJiYgIWlzQmVnaW5uaW5nKSB8fCAod2FzRW5kICYmICFpc0VuZCkpIHtcbiAgICBzd2lwZXIuZW1pdCgnZnJvbUVkZ2UnKTtcbiAgfVxuXG4gIHN3aXBlci5lbWl0KCdwcm9ncmVzcycsIHByb2dyZXNzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzQ2xhc3NlcyAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgY29uc3Qge1xuICAgIHNsaWRlcywgcGFyYW1zLCAkd3JhcHBlckVsLCBhY3RpdmVJbmRleCwgcmVhbEluZGV4LFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuXG4gIHNsaWRlcy5yZW1vdmVDbGFzcyhgJHtwYXJhbXMuc2xpZGVBY3RpdmVDbGFzc30gJHtwYXJhbXMuc2xpZGVOZXh0Q2xhc3N9ICR7cGFyYW1zLnNsaWRlUHJldkNsYXNzfSAke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzfSAke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzc30gJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3N9YCk7XG5cbiAgbGV0IGFjdGl2ZVNsaWRlO1xuICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgYWN0aXZlU2xpZGUgPSBzd2lwZXIuJHdyYXBwZXJFbC5maW5kKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2FjdGl2ZUluZGV4fVwiXWApO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZVNsaWRlID0gc2xpZGVzLmVxKGFjdGl2ZUluZGV4KTtcbiAgfVxuXG4gIC8vIEFjdGl2ZSBjbGFzc2VzXG4gIGFjdGl2ZVNsaWRlLmFkZENsYXNzKHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKTtcblxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAvLyBEdXBsaWNhdGUgdG8gYWxsIGxvb3BlZCBzbGlkZXNcbiAgICBpZiAoYWN0aXZlU2xpZGUuaGFzQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XG4gICAgICAkd3JhcHBlckVsXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9Om5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdYClcbiAgICAgICAgLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHdyYXBwZXJFbFxuICAgICAgICAuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfS4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cmVhbEluZGV4fVwiXWApXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICB9XG4gIC8vIE5leHQgU2xpZGVcbiAgbGV0IG5leHRTbGlkZSA9IGFjdGl2ZVNsaWRlLm5leHRBbGwoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApLmVxKDApLmFkZENsYXNzKHBhcmFtcy5zbGlkZU5leHRDbGFzcyk7XG4gIGlmIChwYXJhbXMubG9vcCAmJiBuZXh0U2xpZGUubGVuZ3RoID09PSAwKSB7XG4gICAgbmV4dFNsaWRlID0gc2xpZGVzLmVxKDApO1xuICAgIG5leHRTbGlkZS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVOZXh0Q2xhc3MpO1xuICB9XG4gIC8vIFByZXYgU2xpZGVcbiAgbGV0IHByZXZTbGlkZSA9IGFjdGl2ZVNsaWRlLnByZXZBbGwoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApLmVxKDApLmFkZENsYXNzKHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gIGlmIChwYXJhbXMubG9vcCAmJiBwcmV2U2xpZGUubGVuZ3RoID09PSAwKSB7XG4gICAgcHJldlNsaWRlID0gc2xpZGVzLmVxKC0xKTtcbiAgICBwcmV2U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcbiAgfVxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAvLyBEdXBsaWNhdGUgdG8gYWxsIGxvb3BlZCBzbGlkZXNcbiAgICBpZiAobmV4dFNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgJHdyYXBwZXJFbFxuICAgICAgICAuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7bmV4dFNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYClcbiAgICAgICAgLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpO1xuICAgIH1cbiAgICBpZiAocHJldlNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgJHdyYXBwZXJFbFxuICAgICAgICAuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYClcbiAgICAgICAgLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3ByZXZTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVBY3RpdmVJbmRleCAobmV3QWN0aXZlSW5kZXgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgY29uc3Qge1xuICAgIHNsaWRlc0dyaWQsIHNuYXBHcmlkLCBwYXJhbXMsIGFjdGl2ZUluZGV4OiBwcmV2aW91c0luZGV4LCByZWFsSW5kZXg6IHByZXZpb3VzUmVhbEluZGV4LCBzbmFwSW5kZXg6IHByZXZpb3VzU25hcEluZGV4LFxuICB9ID0gc3dpcGVyO1xuICBsZXQgYWN0aXZlSW5kZXggPSBuZXdBY3RpdmVJbmRleDtcbiAgbGV0IHNuYXBJbmRleDtcbiAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtICgoc2xpZGVzR3JpZFtpICsgMV0gLSBzbGlkZXNHcmlkW2ldKSAvIDIpKSB7XG4gICAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdKSB7XG4gICAgICAgICAgYWN0aXZlSW5kZXggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG4gICAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPCAwIHx8IHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIGFjdGl2ZUluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSA+PSAwKSB7XG4gICAgc25hcEluZGV4ID0gc25hcEdyaWQuaW5kZXhPZih0cmFuc2xhdGUpO1xuICB9IGVsc2Uge1xuICAgIHNuYXBJbmRleCA9IE1hdGguZmxvb3IoYWN0aXZlSW5kZXggLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICB9XG4gIGlmIChzbmFwSW5kZXggPj0gc25hcEdyaWQubGVuZ3RoKSBzbmFwSW5kZXggPSBzbmFwR3JpZC5sZW5ndGggLSAxO1xuICBpZiAoYWN0aXZlSW5kZXggPT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xuICAgICAgc3dpcGVyLnNuYXBJbmRleCA9IHNuYXBJbmRleDtcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2V0IHJlYWwgaW5kZXhcbiAgY29uc3QgcmVhbEluZGV4ID0gcGFyc2VJbnQoc3dpcGVyLnNsaWRlcy5lcShhY3RpdmVJbmRleCkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSB8fCBhY3RpdmVJbmRleCwgMTApO1xuXG4gIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICBzbmFwSW5kZXgsXG4gICAgcmVhbEluZGV4LFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgYWN0aXZlSW5kZXgsXG4gIH0pO1xuICBzd2lwZXIuZW1pdCgnYWN0aXZlSW5kZXhDaGFuZ2UnKTtcbiAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xuICBpZiAocHJldmlvdXNSZWFsSW5kZXggIT09IHJlYWxJbmRleCkge1xuICAgIHN3aXBlci5lbWl0KCdyZWFsSW5kZXhDaGFuZ2UnKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVDaGFuZ2UnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xpY2tlZFNsaWRlIChlKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG4gIGNvbnN0IHNsaWRlID0gJChlLnRhcmdldCkuY2xvc2VzdChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YClbMF07XG4gIGxldCBzbGlkZUZvdW5kID0gZmFsc2U7XG4gIGlmIChzbGlkZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHN3aXBlci5zbGlkZXNbaV0gPT09IHNsaWRlKSBzbGlkZUZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2xpZGUgJiYgc2xpZGVGb3VuZCkge1xuICAgIHN3aXBlci5jbGlja2VkU2xpZGUgPSBzbGlkZTtcbiAgICBpZiAoc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSBwYXJzZUludCgkKHNsaWRlKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSAkKHNsaWRlKS5pbmRleCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gdW5kZWZpbmVkO1xuICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuc2xpZGVUb0NsaWNrZWRTbGlkZSAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSB1bmRlZmluZWQgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gc3dpcGVyLmFjdGl2ZUluZGV4KSB7XG4gICAgc3dpcGVyLnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcbiAgfVxufVxuXG52YXIgdXBkYXRlID0ge1xuICB1cGRhdGVTaXplLFxuICB1cGRhdGVTbGlkZXMsXG4gIHVwZGF0ZUF1dG9IZWlnaHQsXG4gIHVwZGF0ZVNsaWRlc09mZnNldCxcbiAgdXBkYXRlU2xpZGVzUHJvZ3Jlc3MsXG4gIHVwZGF0ZVByb2dyZXNzLFxuICB1cGRhdGVTbGlkZXNDbGFzc2VzLFxuICB1cGRhdGVBY3RpdmVJbmRleCxcbiAgdXBkYXRlQ2xpY2tlZFNsaWRlLFxufTtcblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlIChheGlzID0gdGhpcy5pc0hvcml6b250YWwoKSA/ICd4JyA6ICd5Jykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsIHJ0bFRyYW5zbGF0ZTogcnRsLCB0cmFuc2xhdGUsICR3cmFwcGVyRWwsXG4gIH0gPSBzd2lwZXI7XG5cbiAgaWYgKHBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB7XG4gICAgcmV0dXJuIHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XG4gIH1cblxuICBsZXQgY3VycmVudFRyYW5zbGF0ZSA9IFV0aWxzLmdldFRyYW5zbGF0ZSgkd3JhcHBlckVsWzBdLCBheGlzKTtcbiAgaWYgKHJ0bCkgY3VycmVudFRyYW5zbGF0ZSA9IC1jdXJyZW50VHJhbnNsYXRlO1xuXG4gIHJldHVybiBjdXJyZW50VHJhbnNsYXRlIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zbGF0ZSAodHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLCBwYXJhbXMsICR3cmFwcGVyRWwsIHByb2dyZXNzLFxuICB9ID0gc3dpcGVyO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgY29uc3QgeiA9IDA7XG5cbiAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgIHggPSBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICB9IGVsc2Uge1xuICAgIHkgPSB0cmFuc2xhdGU7XG4gIH1cblxuICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xuICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgIHkgPSBNYXRoLmZsb29yKHkpO1xuICB9XG5cbiAgaWYgKCFwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgIGlmIChTdXBwb3J0LnRyYW5zZm9ybXMzZCkgJHdyYXBwZXJFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAke3p9cHgpYCk7XG4gICAgZWxzZSAkd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWApO1xuICB9XG4gIHN3aXBlci5wcmV2aW91c1RyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XG4gIHN3aXBlci50cmFuc2xhdGUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB4IDogeTtcblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBwcm9ncmVzc1xuICBsZXQgbmV3UHJvZ3Jlc3M7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcbiAgICBuZXdQcm9ncmVzcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvICh0cmFuc2xhdGVzRGlmZik7XG4gIH1cbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBwcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpO1xuICB9XG5cbiAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zbGF0ZScsIHN3aXBlci50cmFuc2xhdGUsIGJ5Q29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIG1pblRyYW5zbGF0ZSAoKSB7XG4gIHJldHVybiAoLXRoaXMuc25hcEdyaWRbMF0pO1xufVxuXG5mdW5jdGlvbiBtYXhUcmFuc2xhdGUgKCkge1xuICByZXR1cm4gKC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV0pO1xufVxuXG52YXIgdHJhbnNsYXRlID0ge1xuICBnZXRUcmFuc2xhdGUsXG4gIHNldFRyYW5zbGF0ZSxcbiAgbWluVHJhbnNsYXRlLFxuICBtYXhUcmFuc2xhdGUsXG59O1xuXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uIChkdXJhdGlvbiwgYnlDb250cm9sbGVyKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgc3dpcGVyLiR3cmFwcGVyRWwudHJhbnNpdGlvbihkdXJhdGlvbik7XG5cbiAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zaXRpb24nLCBkdXJhdGlvbiwgYnlDb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvblN0YXJ0IChydW5DYWxsYmFja3MgPSB0cnVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyBhY3RpdmVJbmRleCwgcGFyYW1zLCBwcmV2aW91c0luZGV4IH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gIH1cblxuICBsZXQgZGlyID0gZGlyZWN0aW9uO1xuICBpZiAoIWRpcikge1xuICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztcbiAgICBlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztcbiAgICBlbHNlIGRpciA9ICdyZXNldCc7XG4gIH1cblxuICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvblN0YXJ0Jyk7XG5cbiAgaWYgKHJ1bkNhbGxiYWNrcyAmJiBhY3RpdmVJbmRleCAhPT0gcHJldmlvdXNJbmRleCkge1xuICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVJlc2V0VHJhbnNpdGlvblN0YXJ0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZVRyYW5zaXRpb25TdGFydCcpO1xuICAgIGlmIChkaXIgPT09ICduZXh0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlTmV4dFRyYW5zaXRpb25TdGFydCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuZW1pdCgnc2xpZGVQcmV2VHJhbnNpdGlvblN0YXJ0Jyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmQgKHJ1bkNhbGxiYWNrcyA9IHRydWUsIGRpcmVjdGlvbikge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7IGFjdGl2ZUluZGV4LCBwcmV2aW91c0luZGV4IH0gPSBzd2lwZXI7XG4gIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG5cbiAgbGV0IGRpciA9IGRpcmVjdGlvbjtcbiAgaWYgKCFkaXIpIHtcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBwcmV2aW91c0luZGV4KSBkaXIgPSAnbmV4dCc7XG4gICAgZWxzZSBpZiAoYWN0aXZlSW5kZXggPCBwcmV2aW91c0luZGV4KSBkaXIgPSAncHJldic7XG4gICAgZWxzZSBkaXIgPSAncmVzZXQnO1xuICB9XG5cbiAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcblxuICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgaWYgKGRpciA9PT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlUmVzZXRUcmFuc2l0aW9uRW5kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZVRyYW5zaXRpb25FbmQnKTtcbiAgICBpZiAoZGlyID09PSAnbmV4dCcpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZU5leHRUcmFuc2l0aW9uRW5kJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVByZXZUcmFuc2l0aW9uRW5kJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0ge1xuICBzZXRUcmFuc2l0aW9uLFxuICB0cmFuc2l0aW9uU3RhcnQsXG4gIHRyYW5zaXRpb25FbmQsXG59O1xuXG5mdW5jdGlvbiBzbGlkZVRvIChpbmRleCA9IDAsIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XG4gIGlmIChzbGlkZUluZGV4IDwgMCkgc2xpZGVJbmRleCA9IDA7XG5cbiAgY29uc3Qge1xuICAgIHBhcmFtcywgc25hcEdyaWQsIHNsaWRlc0dyaWQsIHByZXZpb3VzSW5kZXgsIGFjdGl2ZUluZGV4LCBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBzbmFwSW5kZXggPSBNYXRoLmZsb29yKHNsaWRlSW5kZXggLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcblxuICBpZiAoKGFjdGl2ZUluZGV4IHx8IHBhcmFtcy5pbml0aWFsU2xpZGUgfHwgMCkgPT09IChwcmV2aW91c0luZGV4IHx8IDApICYmIHJ1bkNhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0Jyk7XG4gIH1cblxuICBjb25zdCB0cmFuc2xhdGUgPSAtc25hcEdyaWRbc25hcEluZGV4XTtcblxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7XG5cbiAgLy8gTm9ybWFsaXplIHNsaWRlSW5kZXhcbiAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoLU1hdGguZmxvb3IodHJhbnNsYXRlICogMTAwKSA+PSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaV0gKiAxMDApKSB7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgJiYgc2xpZGVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiB0cmFuc2xhdGUgPCBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA8IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiB0cmFuc2xhdGUgPiBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA+IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgaWYgKChhY3RpdmVJbmRleCB8fCAwKSAhPT0gc2xpZGVJbmRleCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCBkaXJlY3Rpb247XG4gIGlmIChzbGlkZUluZGV4ID4gYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICduZXh0JztcbiAgZWxzZSBpZiAoc2xpZGVJbmRleCA8IGFjdGl2ZUluZGV4KSBkaXJlY3Rpb24gPSAncHJldic7XG4gIGVsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JztcblxuXG4gIC8vIFVwZGF0ZSBJbmRleFxuICBpZiAoKHJ0bCAmJiAtdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSB8fCAoIXJ0bCAmJiB0cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUpKSB7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICAgIC8vIFVwZGF0ZSBIZWlnaHRcbiAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgfVxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzcGVlZCA9PT0gMCB8fCAhU3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICBpZiAoIXN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICBkZWxldGUgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kO1xuICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNsaWRlVG9Mb29wIChpbmRleCA9IDAsIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCBuZXdJbmRleCA9IGluZGV4O1xuICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgbmV3SW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgfVxuXG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlTmV4dCAoc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyBwYXJhbXMsIGFuaW1hdGluZyB9ID0gc3dpcGVyO1xuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoYW5pbWF0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0O1xuICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBwYXJhbXMuc2xpZGVzUGVyR3JvdXAsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgfVxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4ICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG59XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuZnVuY3Rpb24gc2xpZGVQcmV2IChzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkLCBydW5DYWxsYmFja3MgPSB0cnVlLCBpbnRlcm5hbCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLCBhbmltYXRpbmcsIHNuYXBHcmlkLCBzbGlkZXNHcmlkLCBydGxUcmFuc2xhdGUsXG4gIH0gPSBzd2lwZXI7XG5cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKGFuaW1hdGluZykgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUgPSBydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWwpIHtcbiAgICBpZiAodmFsIDwgMCkgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGguYWJzKHZhbCkpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKHZhbCk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IG5vcm1hbGl6ZSh0cmFuc2xhdGUpO1xuICBjb25zdCBub3JtYWxpemVkU25hcEdyaWQgPSBzbmFwR3JpZC5tYXAodmFsID0+IG5vcm1hbGl6ZSh2YWwpKTtcbiAgY29uc3Qgbm9ybWFsaXplZFNsaWRlc0dyaWQgPSBzbGlkZXNHcmlkLm1hcCh2YWwgPT4gbm9ybWFsaXplKHZhbCkpO1xuXG4gIGNvbnN0IGN1cnJlbnRTbmFwID0gc25hcEdyaWRbbm9ybWFsaXplZFNuYXBHcmlkLmluZGV4T2Yobm9ybWFsaXplZFRyYW5zbGF0ZSldO1xuICBjb25zdCBwcmV2U25hcCA9IHNuYXBHcmlkW25vcm1hbGl6ZWRTbmFwR3JpZC5pbmRleE9mKG5vcm1hbGl6ZWRUcmFuc2xhdGUpIC0gMV07XG4gIGxldCBwcmV2SW5kZXg7XG4gIGlmICh0eXBlb2YgcHJldlNuYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcHJldkluZGV4ID0gc2xpZGVzR3JpZC5pbmRleE9mKHByZXZTbmFwKTtcbiAgICBpZiAocHJldkluZGV4IDwgMCkgcHJldkluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMTtcbiAgfVxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8ocHJldkluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG59XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuZnVuY3Rpb24gc2xpZGVSZXNldCAoc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0IChzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkLCBydW5DYWxsYmFja3MgPSB0cnVlLCBpbnRlcm5hbCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBsZXQgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gIGNvbnN0IHNuYXBJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcblxuICBpZiAoc25hcEluZGV4IDwgc3dpcGVyLnNuYXBHcmlkLmxlbmd0aCAtIDEpIHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuXG4gICAgY29uc3QgY3VycmVudFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XTtcbiAgICBjb25zdCBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcblxuICAgIGlmICgodHJhbnNsYXRlIC0gY3VycmVudFNuYXApID4gKG5leHRTbmFwIC0gY3VycmVudFNuYXApIC8gMikge1xuICAgICAgaW5kZXggPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG5mdW5jdGlvbiBzbGlkZVRvQ2xpY2tlZFNsaWRlICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyBwYXJhbXMsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcblxuICBjb25zdCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gIGxldCBzbGlkZVRvSW5kZXggPSBzd2lwZXIuY2xpY2tlZEluZGV4O1xuICBsZXQgcmVhbEluZGV4O1xuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc3dpcGVyLmFuaW1hdGluZykgcmV0dXJuO1xuICAgIHJlYWxJbmRleCA9IHBhcnNlSW50KCQoc3dpcGVyLmNsaWNrZWRTbGlkZSkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHNsaWRlVG9JbmRleCA8IHN3aXBlci5sb29wZWRTbGlkZXMgLSAoc2xpZGVzUGVyVmlldyAvIDIpKVxuICAgICAgICB8fCAoc2xpZGVUb0luZGV4ID4gKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcykgKyAoc2xpZGVzUGVyVmlldyAvIDIpKVxuICAgICAgKSB7XG4gICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgIHNsaWRlVG9JbmRleCA9ICR3cmFwcGVyRWxcbiAgICAgICAgICAuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cmVhbEluZGV4fVwiXTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KWApXG4gICAgICAgICAgLmVxKDApXG4gICAgICAgICAgLmluZGV4KCk7XG5cbiAgICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgIHNsaWRlVG9JbmRleCA9ICR3cmFwcGVyRWxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl06bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKVxuICAgICAgICAuZXEoMClcbiAgICAgICAgLmluZGV4KCk7XG5cbiAgICAgIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICB9XG59XG5cbnZhciBzbGlkZSA9IHtcbiAgc2xpZGVUbyxcbiAgc2xpZGVUb0xvb3AsXG4gIHNsaWRlTmV4dCxcbiAgc2xpZGVQcmV2LFxuICBzbGlkZVJlc2V0LFxuICBzbGlkZVRvQ2xvc2VzdCxcbiAgc2xpZGVUb0NsaWNrZWRTbGlkZSxcbn07XG5cbmZ1bmN0aW9uIGxvb3BDcmVhdGUgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7IHBhcmFtcywgJHdyYXBwZXJFbCB9ID0gc3dpcGVyO1xuICAvLyBSZW1vdmUgZHVwbGljYXRlZCBzbGlkZXNcbiAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9YCkucmVtb3ZlKCk7XG5cbiAgbGV0IHNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApO1xuXG4gIGlmIChwYXJhbXMubG9vcEZpbGxHcm91cFdpdGhCbGFuaykge1xuICAgIGNvbnN0IGJsYW5rU2xpZGVzTnVtID0gcGFyYW1zLnNsaWRlc1Blckdyb3VwIC0gKHNsaWRlcy5sZW5ndGggJSBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgIGlmIChibGFua1NsaWRlc051bSAhPT0gcGFyYW1zLnNsaWRlc1Blckdyb3VwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsYW5rU2xpZGVzTnVtOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYmxhbmtOb2RlID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkuYWRkQ2xhc3MoYCR7cGFyYW1zLnNsaWRlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlQmxhbmtDbGFzc31gKTtcbiAgICAgICAgJHdyYXBwZXJFbC5hcHBlbmQoYmxhbmtOb2RlKTtcbiAgICAgIH1cbiAgICAgIHNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmICFwYXJhbXMubG9vcGVkU2xpZGVzKSBwYXJhbXMubG9vcGVkU2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcblxuICBzd2lwZXIubG9vcGVkU2xpZGVzID0gcGFyc2VJbnQocGFyYW1zLmxvb3BlZFNsaWRlcyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApO1xuICBzd2lwZXIubG9vcGVkU2xpZGVzICs9IHBhcmFtcy5sb29wQWRkaXRpb25hbFNsaWRlcztcbiAgaWYgKHN3aXBlci5sb29wZWRTbGlkZXMgPiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgc3dpcGVyLmxvb3BlZFNsaWRlcyA9IHNsaWRlcy5sZW5ndGg7XG4gIH1cblxuICBjb25zdCBwcmVwZW5kU2xpZGVzID0gW107XG4gIGNvbnN0IGFwcGVuZFNsaWRlcyA9IFtdO1xuICBzbGlkZXMuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgY29uc3Qgc2xpZGUgPSAkKGVsKTtcbiAgICBpZiAoaW5kZXggPCBzd2lwZXIubG9vcGVkU2xpZGVzKSBhcHBlbmRTbGlkZXMucHVzaChlbCk7XG4gICAgaWYgKGluZGV4IDwgc2xpZGVzLmxlbmd0aCAmJiBpbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcykgcHJlcGVuZFNsaWRlcy5wdXNoKGVsKTtcbiAgICBzbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXBwZW5kU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgJHdyYXBwZXJFbC5hcHBlbmQoJChhcHBlbmRTbGlkZXNbaV0uY2xvbmVOb2RlKHRydWUpKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwcmVwZW5kU2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgJHdyYXBwZXJFbC5wcmVwZW5kKCQocHJlcGVuZFNsaWRlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vcEZpeCAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsIGFjdGl2ZUluZGV4LCBzbGlkZXMsIGxvb3BlZFNsaWRlcywgYWxsb3dTbGlkZVByZXYsIGFsbG93U2xpZGVOZXh0LCBzbmFwR3JpZCwgcnRsVHJhbnNsYXRlOiBydGwsXG4gIH0gPSBzd2lwZXI7XG4gIGxldCBuZXdJbmRleDtcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gdHJ1ZTtcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcblxuICBjb25zdCBzbmFwVHJhbnNsYXRlID0gLXNuYXBHcmlkW2FjdGl2ZUluZGV4XTtcbiAgY29uc3QgZGlmZiA9IHNuYXBUcmFuc2xhdGUgLSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCk7XG5cblxuICAvLyBGaXggRm9yIE5lZ2F0aXZlIE92ZXJzbGlkaW5nXG4gIGlmIChhY3RpdmVJbmRleCA8IGxvb3BlZFNsaWRlcykge1xuICAgIG5ld0luZGV4ID0gKHNsaWRlcy5sZW5ndGggLSAobG9vcGVkU2xpZGVzICogMykpICsgYWN0aXZlSW5kZXg7XG4gICAgbmV3SW5kZXggKz0gbG9vcGVkU2xpZGVzO1xuICAgIGNvbnN0IHNsaWRlQ2hhbmdlZCA9IHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgaWYgKHNsaWRlQ2hhbmdlZCAmJiBkaWZmICE9PSAwKSB7XG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKChydGwgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGUpIC0gZGlmZik7XG4gICAgfVxuICB9IGVsc2UgaWYgKChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIGFjdGl2ZUluZGV4ID49IGxvb3BlZFNsaWRlcyAqIDIpIHx8IChhY3RpdmVJbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gbG9vcGVkU2xpZGVzKSkge1xuICAgIC8vIEZpeCBGb3IgUG9zaXRpdmUgT3ZlcnNsaWRpbmdcbiAgICBuZXdJbmRleCA9IC1zbGlkZXMubGVuZ3RoICsgYWN0aXZlSW5kZXggKyBsb29wZWRTbGlkZXM7XG4gICAgbmV3SW5kZXggKz0gbG9vcGVkU2xpZGVzO1xuICAgIGNvbnN0IHNsaWRlQ2hhbmdlZCA9IHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgaWYgKHNsaWRlQ2hhbmdlZCAmJiBkaWZmICE9PSAwKSB7XG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKChydGwgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGUpIC0gZGlmZik7XG4gICAgfVxuICB9XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcbn1cblxuZnVuY3Rpb24gbG9vcERlc3Ryb3kgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7ICR3cmFwcGVyRWwsIHBhcmFtcywgc2xpZGVzIH0gPSBzd2lwZXI7XG4gICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfS4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSwuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVCbGFua0NsYXNzfWApLnJlbW92ZSgpO1xuICBzbGlkZXMucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbn1cblxudmFyIGxvb3AgPSB7XG4gIGxvb3BDcmVhdGUsXG4gIGxvb3BGaXgsXG4gIGxvb3BEZXN0cm95LFxufTtcblxuZnVuY3Rpb24gc2V0R3JhYkN1cnNvciAobW92aW5nKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChTdXBwb3J0LnRvdWNoIHx8ICFzd2lwZXIucGFyYW1zLnNpbXVsYXRlVG91Y2ggfHwgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQpKSByZXR1cm47XG4gIGNvbnN0IGVsID0gc3dpcGVyLmVsO1xuICBlbC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICctd2Via2l0LWdyYWJiaW5nJyA6ICctd2Via2l0LWdyYWInO1xuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnLW1vei1ncmFiYmluJyA6ICctbW96LWdyYWInO1xuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnZ3JhYmJpbmcnIDogJ2dyYWInO1xufVxuXG5mdW5jdGlvbiB1bnNldEdyYWJDdXJzb3IgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoU3VwcG9ydC50b3VjaCB8fCAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCkpIHJldHVybjtcbiAgc3dpcGVyLmVsLnN0eWxlLmN1cnNvciA9ICcnO1xufVxuXG52YXIgZ3JhYkN1cnNvciA9IHtcbiAgc2V0R3JhYkN1cnNvcixcbiAgdW5zZXRHcmFiQ3Vyc29yLFxufTtcblxuZnVuY3Rpb24gYXBwZW5kU2xpZGUgKHNsaWRlcykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7ICR3cmFwcGVyRWwsIHBhcmFtcyB9ID0gc3dpcGVyO1xuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgfVxuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzbGlkZXNbaV0pICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlc1tpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlcyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgfVxuICBpZiAoIShwYXJhbXMub2JzZXJ2ZXIgJiYgU3VwcG9ydC5vYnNlcnZlcikpIHtcbiAgICBzd2lwZXIudXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGVuZFNsaWRlIChzbGlkZXMpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyBwYXJhbXMsICR3cmFwcGVyRWwsIGFjdGl2ZUluZGV4IH0gPSBzd2lwZXI7XG5cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gIH1cbiAgbGV0IG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggKyAxO1xuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzbGlkZXNbaV0pICR3cmFwcGVyRWwucHJlcGVuZChzbGlkZXNbaV0pO1xuICAgIH1cbiAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICAkd3JhcHBlckVsLnByZXBlbmQoc2xpZGVzKTtcbiAgfVxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICB9XG4gIGlmICghKHBhcmFtcy5vYnNlcnZlciAmJiBTdXBwb3J0Lm9ic2VydmVyKSkge1xuICAgIHN3aXBlci51cGRhdGUoKTtcbiAgfVxuICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBhZGRTbGlkZSAoaW5kZXgsIHNsaWRlcykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7ICR3cmFwcGVyRWwsIHBhcmFtcywgYWN0aXZlSW5kZXggfSA9IHN3aXBlcjtcbiAgbGV0IGFjdGl2ZUluZGV4QnVmZmVyID0gYWN0aXZlSW5kZXg7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGFjdGl2ZUluZGV4QnVmZmVyIC09IHN3aXBlci5sb29wZWRTbGlkZXM7XG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgc3dpcGVyLnNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApO1xuICB9XG4gIGNvbnN0IGJhc2VMZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgaWYgKGluZGV4IDw9IDApIHtcbiAgICBzd2lwZXIucHJlcGVuZFNsaWRlKHNsaWRlcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmRleCA+PSBiYXNlTGVuZ3RoKSB7XG4gICAgc3dpcGVyLmFwcGVuZFNsaWRlKHNsaWRlcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIDEgOiBhY3RpdmVJbmRleEJ1ZmZlcjtcblxuICBjb25zdCBzbGlkZXNCdWZmZXIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IGJhc2VMZW5ndGggLSAxOyBpID49IGluZGV4OyBpIC09IDEpIHtcbiAgICBjb25zdCBjdXJyZW50U2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xuICAgIGN1cnJlbnRTbGlkZS5yZW1vdmUoKTtcbiAgICBzbGlkZXNCdWZmZXIudW5zaGlmdChjdXJyZW50U2xpZGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzbGlkZXMgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIHNsaWRlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc2xpZGVzW2ldKSAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXNbaV0pO1xuICAgIH1cbiAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIHNsaWRlcy5sZW5ndGggOiBhY3RpdmVJbmRleEJ1ZmZlcjtcbiAgfSBlbHNlIHtcbiAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXMpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNCdWZmZXIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXNCdWZmZXJbaV0pO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgfVxuICBpZiAoIShwYXJhbXMub2JzZXJ2ZXIgJiYgU3VwcG9ydC5vYnNlcnZlcikpIHtcbiAgICBzd2lwZXIudXBkYXRlKCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXggKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXgsIDAsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVTbGlkZSAoc2xpZGVzSW5kZXhlcykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7IHBhcmFtcywgJHdyYXBwZXJFbCwgYWN0aXZlSW5kZXggfSA9IHN3aXBlcjtcblxuICBsZXQgYWN0aXZlSW5kZXhCdWZmZXIgPSBhY3RpdmVJbmRleDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgYWN0aXZlSW5kZXhCdWZmZXIgLT0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICBzd2lwZXIuc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG4gIH1cbiAgbGV0IG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXhCdWZmZXI7XG4gIGxldCBpbmRleFRvUmVtb3ZlO1xuXG4gIGlmICh0eXBlb2Ygc2xpZGVzSW5kZXhlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzSW5kZXhlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzSW5kZXhlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaW5kZXhUb1JlbW92ZSA9IHNsaWRlc0luZGV4ZXNbaV07XG4gICAgICBpZiAoc3dpcGVyLnNsaWRlc1tpbmRleFRvUmVtb3ZlXSkgc3dpcGVyLnNsaWRlcy5lcShpbmRleFRvUmVtb3ZlKS5yZW1vdmUoKTtcbiAgICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgbmV3QWN0aXZlSW5kZXgpIG5ld0FjdGl2ZUluZGV4IC09IDE7XG4gICAgfVxuICAgIG5ld0FjdGl2ZUluZGV4ID0gTWF0aC5tYXgobmV3QWN0aXZlSW5kZXgsIDApO1xuICB9IGVsc2Uge1xuICAgIGluZGV4VG9SZW1vdmUgPSBzbGlkZXNJbmRleGVzO1xuICAgIGlmIChzd2lwZXIuc2xpZGVzW2luZGV4VG9SZW1vdmVdKSBzd2lwZXIuc2xpZGVzLmVxKGluZGV4VG9SZW1vdmUpLnJlbW92ZSgpO1xuICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgbmV3QWN0aXZlSW5kZXgpIG5ld0FjdGl2ZUluZGV4IC09IDE7XG4gICAgbmV3QWN0aXZlSW5kZXggPSBNYXRoLm1heChuZXdBY3RpdmVJbmRleCwgMCk7XG4gIH1cblxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICB9XG5cbiAgaWYgKCEocGFyYW1zLm9ic2VydmVyICYmIFN1cHBvcnQub2JzZXJ2ZXIpKSB7XG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4ICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4LCAwLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsU2xpZGVzICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICBjb25zdCBzbGlkZXNJbmRleGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHNsaWRlc0luZGV4ZXMucHVzaChpKTtcbiAgfVxuICBzd2lwZXIucmVtb3ZlU2xpZGUoc2xpZGVzSW5kZXhlcyk7XG59XG5cbnZhciBtYW5pcHVsYXRpb24gPSB7XG4gIGFwcGVuZFNsaWRlLFxuICBwcmVwZW5kU2xpZGUsXG4gIGFkZFNsaWRlLFxuICByZW1vdmVTbGlkZSxcbiAgcmVtb3ZlQWxsU2xpZGVzLFxufTtcblxuY29uc3QgRGV2aWNlID0gKGZ1bmN0aW9uIERldmljZSgpIHtcbiAgY29uc3QgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBjb25zdCBkZXZpY2UgPSB7XG4gICAgaW9zOiBmYWxzZSxcbiAgICBhbmRyb2lkOiBmYWxzZSxcbiAgICBhbmRyb2lkQ2hyb21lOiBmYWxzZSxcbiAgICBkZXNrdG9wOiBmYWxzZSxcbiAgICB3aW5kb3dzOiBmYWxzZSxcbiAgICBpcGhvbmU6IGZhbHNlLFxuICAgIGlwb2Q6IGZhbHNlLFxuICAgIGlwYWQ6IGZhbHNlLFxuICAgIGNvcmRvdmE6IHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCxcbiAgICBwaG9uZWdhcDogd2luZG93LmNvcmRvdmEgfHwgd2luZG93LnBob25lZ2FwLFxuICB9O1xuXG4gIGNvbnN0IHdpbmRvd3MgPSB1YS5tYXRjaCgvKFdpbmRvd3MgUGhvbmUpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgY29uc3QgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBjb25zdCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIGNvbnN0IGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pO1xuXG5cbiAgLy8gV2luZG93c1xuICBpZiAod2luZG93cykge1xuICAgIGRldmljZS5vcyA9ICd3aW5kb3dzJztcbiAgICBkZXZpY2Uub3NWZXJzaW9uID0gd2luZG93c1syXTtcbiAgICBkZXZpY2Uud2luZG93cyA9IHRydWU7XG4gIH1cbiAgLy8gQW5kcm9pZFxuICBpZiAoYW5kcm9pZCAmJiAhd2luZG93cykge1xuICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICBkZXZpY2Uub3NWZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgICBkZXZpY2UuYW5kcm9pZCA9IHRydWU7XG4gICAgZGV2aWNlLmFuZHJvaWRDaHJvbWUgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID49IDA7XG4gIH1cbiAgaWYgKGlwYWQgfHwgaXBob25lIHx8IGlwb2QpIHtcbiAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICBkZXZpY2UuaW9zID0gdHJ1ZTtcbiAgfVxuICAvLyBpT1NcbiAgaWYgKGlwaG9uZSAmJiAhaXBvZCkge1xuICAgIGRldmljZS5vc1ZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgIGRldmljZS5pcGhvbmUgPSB0cnVlO1xuICB9XG4gIGlmIChpcGFkKSB7XG4gICAgZGV2aWNlLm9zVmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgIGRldmljZS5pcGFkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXBvZCkge1xuICAgIGRldmljZS5vc1ZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAgIGRldmljZS5pcGhvbmUgPSB0cnVlO1xuICB9XG4gIC8vIGlPUyA4KyBjaGFuZ2VkIFVBXG4gIGlmIChkZXZpY2UuaW9zICYmIGRldmljZS5vc1ZlcnNpb24gJiYgdWEuaW5kZXhPZignVmVyc2lvbi8nKSA+PSAwKSB7XG4gICAgaWYgKGRldmljZS5vc1ZlcnNpb24uc3BsaXQoJy4nKVswXSA9PT0gJzEwJykge1xuICAgICAgZGV2aWNlLm9zVmVyc2lvbiA9IHVhLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3ZlcnNpb24vJylbMV0uc3BsaXQoJyAnKVswXTtcbiAgICB9XG4gIH1cblxuICAvLyBEZXNrdG9wXG4gIGRldmljZS5kZXNrdG9wID0gIShkZXZpY2Uub3MgfHwgZGV2aWNlLmFuZHJvaWQgfHwgZGV2aWNlLndlYlZpZXcpO1xuXG4gIC8vIFdlYnZpZXdcbiAgZGV2aWNlLndlYlZpZXcgPSAoaXBob25lIHx8IGlwYWQgfHwgaXBvZCkgJiYgdWEubWF0Y2goLy4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaSk7XG5cbiAgLy8gTWluaW1hbCBVSVxuICBpZiAoZGV2aWNlLm9zICYmIGRldmljZS5vcyA9PT0gJ2lvcycpIHtcbiAgICBjb25zdCBvc1ZlcnNpb25BcnIgPSBkZXZpY2Uub3NWZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgbWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwidmlld3BvcnRcIl0nKTtcbiAgICBkZXZpY2UubWluaW1hbFVpID0gIWRldmljZS53ZWJWaWV3XG4gICAgICAmJiAoaXBvZCB8fCBpcGhvbmUpXG4gICAgICAmJiAob3NWZXJzaW9uQXJyWzBdICogMSA9PT0gNyA/IG9zVmVyc2lvbkFyclsxXSAqIDEgPj0gMSA6IG9zVmVyc2lvbkFyclswXSAqIDEgPiA3KVxuICAgICAgJiYgbWV0YVZpZXdwb3J0ICYmIG1ldGFWaWV3cG9ydC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKS5pbmRleE9mKCdtaW5pbWFsLXVpJykgPj0gMDtcbiAgfVxuXG4gIC8vIFBpeGVsIFJhdGlvXG4gIGRldmljZS5waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAvLyBFeHBvcnQgb2JqZWN0XG4gIHJldHVybiBkZXZpY2U7XG59KCkpO1xuXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQgKGV2ZW50KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICBjb25zdCB7IHBhcmFtcywgdG91Y2hlcyB9ID0gc3dpcGVyO1xuICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gZXZlbnQ7XG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gIGRhdGEuaXNUb3VjaEV2ZW50ID0gZS50eXBlID09PSAndG91Y2hzdGFydCc7XG4gIGlmICghZGF0YS5pc1RvdWNoRXZlbnQgJiYgJ3doaWNoJyBpbiBlICYmIGUud2hpY2ggPT09IDMpIHJldHVybjtcbiAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uID4gMCkgcmV0dXJuO1xuICBpZiAoZGF0YS5pc1RvdWNoZWQgJiYgZGF0YS5pc01vdmVkKSByZXR1cm47XG4gIGlmIChwYXJhbXMubm9Td2lwaW5nICYmICQoZS50YXJnZXQpLmNsb3Nlc3QocGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yID8gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke3BhcmFtcy5ub1N3aXBpbmdDbGFzc31gKVswXSkge1xuICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5zd2lwZUhhbmRsZXIpIHtcbiAgICBpZiAoISQoZSkuY2xvc2VzdChwYXJhbXMuc3dpcGVIYW5kbGVyKVswXSkgcmV0dXJuO1xuICB9XG5cbiAgdG91Y2hlcy5jdXJyZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgdG91Y2hlcy5jdXJyZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgY29uc3Qgc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcblxuICAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIChVSVdlYlZpZXcpIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcblxuICBjb25zdCBlZGdlU3dpcGVEZXRlY3Rpb24gPSBwYXJhbXMuZWRnZVN3aXBlRGV0ZWN0aW9uIHx8IHBhcmFtcy5pT1NFZGdlU3dpcGVEZXRlY3Rpb247XG4gIGNvbnN0IGVkZ2VTd2lwZVRocmVzaG9sZCA9IHBhcmFtcy5lZGdlU3dpcGVUaHJlc2hvbGQgfHwgcGFyYW1zLmlPU0VkZ2VTd2lwZVRocmVzaG9sZDtcbiAgaWYgKFxuICAgIGVkZ2VTd2lwZURldGVjdGlvblxuICAgICYmICgoc3RhcnRYIDw9IGVkZ2VTd2lwZVRocmVzaG9sZClcbiAgICB8fCAoc3RhcnRYID49IHdpbmRvdy5zY3JlZW4ud2lkdGggLSBlZGdlU3dpcGVUaHJlc2hvbGQpKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBVdGlscy5leHRlbmQoZGF0YSwge1xuICAgIGlzVG91Y2hlZDogdHJ1ZSxcbiAgICBpc01vdmVkOiBmYWxzZSxcbiAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiB0cnVlLFxuICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZCxcbiAgfSk7XG5cbiAgdG91Y2hlcy5zdGFydFggPSBzdGFydFg7XG4gIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xuICBkYXRhLnRvdWNoU3RhcnRUaW1lID0gVXRpbHMubm93KCk7XG4gIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XG4gIGlmIChlLnR5cGUgIT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIGxldCBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgaWYgKCQoZS50YXJnZXQpLmlzKGRhdGEuZm9ybUVsZW1lbnRzKSkgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICAmJiAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKGRhdGEuZm9ybUVsZW1lbnRzKVxuICAgICAgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZS50YXJnZXRcbiAgICApIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZFByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQgJiYgc3dpcGVyLmFsbG93VG91Y2hNb3ZlICYmIHBhcmFtcy50b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ7XG4gICAgaWYgKHBhcmFtcy50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBzd2lwZXIuZW1pdCgndG91Y2hTdGFydCcsIGUpO1xufVxuXG5mdW5jdGlvbiBvblRvdWNoTW92ZSAoZXZlbnQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gIGNvbnN0IHsgcGFyYW1zLCB0b3VjaGVzLCBydGxUcmFuc2xhdGU6IHJ0bCB9ID0gc3dpcGVyO1xuICBsZXQgZSA9IGV2ZW50O1xuICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuc3RhcnRNb3ZpbmcgJiYgZGF0YS5pc1Njcm9sbGluZykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgZS50eXBlID09PSAnbW91c2Vtb3ZlJykgcmV0dXJuO1xuICBjb25zdCBwYWdlWCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICBpZiAoZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikge1xuICAgIHRvdWNoZXMuc3RhcnRYID0gcGFnZVg7XG4gICAgdG91Y2hlcy5zdGFydFkgPSBwYWdlWTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzd2lwZXIuYWxsb3dUb3VjaE1vdmUpIHtcbiAgICAvLyBpc01vdmVkID0gdHJ1ZTtcbiAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICAgIGlmIChkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgVXRpbHMuZXh0ZW5kKHRvdWNoZXMsIHtcbiAgICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgICAgc3RhcnRZOiBwYWdlWSxcbiAgICAgICAgY3VycmVudFg6IHBhZ2VYLFxuICAgICAgICBjdXJyZW50WTogcGFnZVksXG4gICAgICB9KTtcbiAgICAgIGRhdGEudG91Y2hTdGFydFRpbWUgPSBVdGlscy5ub3coKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcyAmJiAhcGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgICAgLy8gVmVydGljYWxcbiAgICAgIGlmIChcbiAgICAgICAgKHBhZ2VZIDwgdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpXG4gICAgICAgIHx8IChwYWdlWSA+IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKVxuICAgICAgKSB7XG4gICAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChwYWdlWCA8IHRvdWNoZXMuc3RhcnRYICYmIHN3aXBlci50cmFuc2xhdGUgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKVxuICAgICAgfHwgKHBhZ2VYID4gdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICQoZS50YXJnZXQpLmlzKGRhdGEuZm9ybUVsZW1lbnRzKSkge1xuICAgICAgZGF0YS5pc01vdmVkID0gdHJ1ZTtcbiAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MpIHtcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlJywgZSk7XG4gIH1cbiAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkgcmV0dXJuO1xuXG4gIHRvdWNoZXMuY3VycmVudFggPSBwYWdlWDtcbiAgdG91Y2hlcy5jdXJyZW50WSA9IHBhZ2VZO1xuXG4gIGNvbnN0IGRpZmZYID0gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMuc3RhcnRYO1xuICBjb25zdCBkaWZmWSA9IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnN0YXJ0WTtcbiAgaWYgKHN3aXBlci5wYXJhbXMudGhyZXNob2xkICYmIE1hdGguc3FydCgoZGlmZlggKiogMikgKyAoZGlmZlkgKiogMikpIDwgc3dpcGVyLnBhcmFtcy50aHJlc2hvbGQpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGRhdGEuaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHRvdWNoQW5nbGU7XG4gICAgaWYgKChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgdG91Y2hlcy5jdXJyZW50WSA9PT0gdG91Y2hlcy5zdGFydFkpIHx8IChzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIHRvdWNoZXMuY3VycmVudFggPT09IHRvdWNoZXMuc3RhcnRYKSkge1xuICAgICAgZGF0YS5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGlmICgoZGlmZlggKiBkaWZmWCkgKyAoZGlmZlkgKiBkaWZmWSkgPj0gMjUpIHtcbiAgICAgICAgdG91Y2hBbmdsZSA9IChNYXRoLmF0YW4yKE1hdGguYWJzKGRpZmZZKSwgTWF0aC5hYnMoZGlmZlgpKSAqIDE4MCkgLyBNYXRoLlBJO1xuICAgICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlIDogKDkwIC0gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlT3Bwb3NpdGUnLCBlKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEuc3RhcnRNb3ZpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHRvdWNoZXMuY3VycmVudFggIT09IHRvdWNoZXMuc3RhcnRYIHx8IHRvdWNoZXMuY3VycmVudFkgIT09IHRvdWNoZXMuc3RhcnRZKSB7XG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRhdGEuc3RhcnRNb3ZpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBpZiAoIWRhdGEuaXNNb3ZlZCkge1xuICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICB9XG4gICAgZGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICBpZiAoc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwudHJpZ2dlcignd2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kJyk7XG4gICAgfVxuICAgIGRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSA9IGZhbHNlO1xuICAgIC8vIEdyYWIgQ3Vyc29yXG4gICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IodHJ1ZSk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXJGaXJzdE1vdmUnLCBlKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVyTW92ZScsIGUpO1xuICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuXG4gIGxldCBkaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZGlmZlggOiBkaWZmWTtcbiAgdG91Y2hlcy5kaWZmID0gZGlmZjtcblxuICBkaWZmICo9IHBhcmFtcy50b3VjaFJhdGlvO1xuICBpZiAocnRsKSBkaWZmID0gLWRpZmY7XG5cbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gZGlmZiA+IDAgPyAncHJldicgOiAnbmV4dCc7XG4gIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuXG4gIGxldCBkaXNhYmxlUGFyZW50U3dpcGVyID0gdHJ1ZTtcbiAgbGV0IHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XG4gIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgIHJlc2lzdGFuY2VSYXRpbyA9IDA7XG4gIH1cbiAgaWYgKChkaWZmID4gMCAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkpKSB7XG4gICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gKHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEpICsgKCgtc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgZGF0YS5zdGFydFRyYW5zbGF0ZSArIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbyk7XG4gIH0gZWxzZSBpZiAoZGlmZiA8IDAgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gKHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIDEpIC0gKChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBkYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvKTtcbiAgfVxuXG4gIGlmIChkaXNhYmxlUGFyZW50U3dpcGVyKSB7XG4gICAgZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9IHRydWU7XG4gIH1cblxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG5cblxuICAvLyBUaHJlc2hvbGRcbiAgaWYgKHBhcmFtcy50aHJlc2hvbGQgPiAwKSB7XG4gICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgaWYgKCFkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgICBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSA9IHRydWU7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgICAgdG91Y2hlcy5zdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZO1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhcmFtcy5mb2xsb3dGaW5nZXIpIHJldHVybjtcblxuICAvLyBVcGRhdGUgYWN0aXZlIGluZGV4IGluIGZyZWUgbW9kZVxuICBpZiAocGFyYW1zLmZyZWVNb2RlIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICB9XG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICAvLyBWZWxvY2l0eVxuICAgIGlmIChkYXRhLnZlbG9jaXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkYXRhLnZlbG9jaXRpZXMucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzdGFydFgnIDogJ3N0YXJ0WSddLFxuICAgICAgICB0aW1lOiBkYXRhLnRvdWNoU3RhcnRUaW1lLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudmVsb2NpdGllcy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdjdXJyZW50WCcgOiAnY3VycmVudFknXSxcbiAgICAgIHRpbWU6IFV0aWxzLm5vdygpLFxuICAgIH0pO1xuICB9XG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcbiAgLy8gVXBkYXRlIHRyYW5zbGF0ZVxuICBzd2lwZXIuc2V0VHJhbnNsYXRlKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQgKGV2ZW50KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuXG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsIHRvdWNoZXMsIHJ0bFRyYW5zbGF0ZTogcnRsLCAkd3JhcHBlckVsLCBzbGlkZXNHcmlkLCBzbmFwR3JpZCxcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGUgPSBldmVudDtcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaEVuZCcsIGUpO1xuICB9XG4gIGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcyA9IGZhbHNlO1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgIH1cbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFJldHVybiBHcmFiIEN1cnNvclxuICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgZGF0YS5pc01vdmVkICYmIGRhdGEuaXNUb3VjaGVkICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcbiAgfVxuXG4gIC8vIFRpbWUgZGlmZlxuICBjb25zdCB0b3VjaEVuZFRpbWUgPSBVdGlscy5ub3coKTtcbiAgY29uc3QgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lO1xuXG4gIC8vIFRhcCwgZG91YmxlVGFwLCBDbGlja1xuICBpZiAoc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICBzd2lwZXIudXBkYXRlQ2xpY2tlZFNsaWRlKGUpO1xuICAgIHN3aXBlci5lbWl0KCd0YXAnLCBlKTtcbiAgICBpZiAodGltZURpZmYgPCAzMDAgJiYgKHRvdWNoRW5kVGltZSAtIGRhdGEubGFzdENsaWNrVGltZSkgPiAzMDApIHtcbiAgICAgIGlmIChkYXRhLmNsaWNrVGltZW91dCkgY2xlYXJUaW1lb3V0KGRhdGEuY2xpY2tUaW1lb3V0KTtcbiAgICAgIGRhdGEuY2xpY2tUaW1lb3V0ID0gVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIHN3aXBlci5lbWl0KCdjbGljaycsIGUpO1xuICAgICAgfSwgMzAwKTtcbiAgICB9XG4gICAgaWYgKHRpbWVEaWZmIDwgMzAwICYmICh0b3VjaEVuZFRpbWUgLSBkYXRhLmxhc3RDbGlja1RpbWUpIDwgMzAwKSB7XG4gICAgICBpZiAoZGF0YS5jbGlja1RpbWVvdXQpIGNsZWFyVGltZW91dChkYXRhLmNsaWNrVGltZW91dCk7XG4gICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwJywgZSk7XG4gICAgfVxuICB9XG5cbiAgZGF0YS5sYXN0Q2xpY2tUaW1lID0gVXRpbHMubm93KCk7XG4gIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5kZXN0cm95ZWQpIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFkYXRhLmlzVG91Y2hlZCB8fCAhZGF0YS5pc01vdmVkIHx8ICFzd2lwZXIuc3dpcGVEaXJlY3Rpb24gfHwgdG91Y2hlcy5kaWZmID09PSAwIHx8IGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9PT0gZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xuICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuXG4gIGxldCBjdXJyZW50UG9zO1xuICBpZiAocGFyYW1zLmZvbGxvd0Zpbmdlcikge1xuICAgIGN1cnJlbnRQb3MgPSBydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudFBvcyA9IC1kYXRhLmN1cnJlbnRUcmFuc2xhdGU7XG4gIH1cblxuICBpZiAocGFyYW1zLmZyZWVNb2RlKSB7XG4gICAgaWYgKGN1cnJlbnRQb3MgPCAtc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBvcyA+IC1zd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzLmxlbmd0aCA8IHNuYXBHcmlkLmxlbmd0aCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbmFwR3JpZC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtKSB7XG4gICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbGFzdE1vdmVFdmVudCA9IGRhdGEudmVsb2NpdGllcy5wb3AoKTtcbiAgICAgICAgY29uc3QgdmVsb2NpdHlFdmVudCA9IGRhdGEudmVsb2NpdGllcy5wb3AoKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGxhc3RNb3ZlRXZlbnQucG9zaXRpb24gLSB2ZWxvY2l0eUV2ZW50LnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB0aW1lID0gbGFzdE1vdmVFdmVudC50aW1lIC0gdmVsb2NpdHlFdmVudC50aW1lO1xuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSBkaXN0YW5jZSAvIHRpbWU7XG4gICAgICAgIHN3aXBlci52ZWxvY2l0eSAvPSAyO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3dpcGVyLnZlbG9jaXR5KSA8IHBhcmFtcy5mcmVlTW9kZU1pbmltdW1WZWxvY2l0eSkge1xuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpbXBsaWVzIHRoYXQgdGhlIHVzZXIgc3RvcHBlZCBtb3ZpbmcgYSBmaW5nZXIgdGhlbiByZWxlYXNlZC5cbiAgICAgICAgLy8gVGhlcmUgd291bGQgYmUgbm8gZXZlbnRzIHdpdGggZGlzdGFuY2UgemVybywgc28gdGhlIGxhc3QgZXZlbnQgaXMgc3RhbGUuXG4gICAgICAgIGlmICh0aW1lID4gMTUwIHx8IChVdGlscy5ub3coKSAtIGxhc3RNb3ZlRXZlbnQudGltZSkgPiAzMDApIHtcbiAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgfVxuICAgICAgc3dpcGVyLnZlbG9jaXR5ICo9IHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtVmVsb2NpdHlSYXRpbztcblxuICAgICAgZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9IDA7XG4gICAgICBsZXQgbW9tZW50dW1EdXJhdGlvbiA9IDEwMDAgKiBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bVJhdGlvO1xuICAgICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZSA9IHN3aXBlci52ZWxvY2l0eSAqIG1vbWVudHVtRHVyYXRpb247XG5cbiAgICAgIGxldCBuZXdQb3NpdGlvbiA9IHN3aXBlci50cmFuc2xhdGUgKyBtb21lbnR1bURpc3RhbmNlO1xuICAgICAgaWYgKHJ0bCkgbmV3UG9zaXRpb24gPSAtbmV3UG9zaXRpb247XG5cbiAgICAgIGxldCBkb0JvdW5jZSA9IGZhbHNlO1xuICAgICAgbGV0IGFmdGVyQm91bmNlUG9zaXRpb247XG4gICAgICBjb25zdCBib3VuY2VBbW91bnQgPSBNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpICogMjAgKiBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO1xuICAgICAgbGV0IG5lZWRzTG9vcEZpeDtcbiAgICAgIGlmIChuZXdQb3NpdGlvbiA8IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gKyBzd2lwZXIubWF4VHJhbnNsYXRlKCkgPCAtYm91bmNlQW1vdW50KSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIGJvdW5jZUFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWZ0ZXJCb3VuY2VQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgICBkb0JvdW5jZSA9IHRydWU7XG4gICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChuZXdQb3NpdGlvbiA+IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gLSBzd2lwZXIubWluVHJhbnNsYXRlKCkgPiBib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgYm91bmNlQW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZnRlckJvdW5jZVBvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIG5lZWRzTG9vcEZpeCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZVN0aWNreSkge1xuICAgICAgICBsZXQgbmV4dFNsaWRlO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNuYXBHcmlkLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKHNuYXBHcmlkW2pdID4gLW5ld1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBuZXh0U2xpZGUgPSBqO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNuYXBHcmlkW25leHRTbGlkZV0gLSBuZXdQb3NpdGlvbikgPCBNYXRoLmFicyhzbmFwR3JpZFtuZXh0U2xpZGUgLSAxXSAtIG5ld1Bvc2l0aW9uKSB8fCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdQb3NpdGlvbiA9IHNuYXBHcmlkW25leHRTbGlkZSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIG5ld1Bvc2l0aW9uID0gLW5ld1Bvc2l0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzTG9vcEZpeCkge1xuICAgICAgICBzd2lwZXIub25jZSgndHJhbnNpdGlvbkVuZCcsICgpID0+IHtcbiAgICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEZpeCBkdXJhdGlvblxuICAgICAgaWYgKHN3aXBlci52ZWxvY2l0eSAhPT0gMCkge1xuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKCgtbmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKChuZXdQb3NpdGlvbiAtIHN3aXBlci50cmFuc2xhdGUpIC8gc3dpcGVyLnZlbG9jaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGVTdGlja3kpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlICYmIGRvQm91bmNlKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhhZnRlckJvdW5jZVBvc2l0aW9uKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24obW9tZW50dW1EdXJhdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xuICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHRydWUsIHN3aXBlci5zd2lwZURpcmVjdGlvbik7XG4gICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIWRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSkgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdtb21lbnR1bUJvdW5jZScpO1xuXG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24ocGFyYW1zLnNwZWVkKTtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKGFmdGVyQm91bmNlUG9zaXRpb24pO1xuICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnZlbG9jaXR5KSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XG4gICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5mcmVlTW9kZU1vbWVudHVtIHx8IHRpbWVEaWZmID49IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaW5kIGN1cnJlbnQgc2xpZGVcbiAgbGV0IHN0b3BJbmRleCA9IDA7XG4gIGxldCBncm91cFNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkWzBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0gJiYgY3VycmVudFBvcyA8IHNsaWRlc0dyaWRbaSArIHBhcmFtcy5zbGlkZXNQZXJHcm91cF0pIHtcbiAgICAgICAgc3RvcEluZGV4ID0gaTtcbiAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtpICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwXSAtIHNsaWRlc0dyaWRbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0pIHtcbiAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICBncm91cFNpemUgPSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMV0gLSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMl07XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBjdXJyZW50IHNsaWRlIHNpemVcbiAgY29uc3QgcmF0aW8gPSAoY3VycmVudFBvcyAtIHNsaWRlc0dyaWRbc3RvcEluZGV4XSkgLyBncm91cFNpemU7XG5cbiAgaWYgKHRpbWVEaWZmID4gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xuICAgIC8vIExvbmcgdG91Y2hlc1xuICAgIGlmICghcGFyYW1zLmxvbmdTd2lwZXMpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgaWYgKHJhdGlvID49IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIHBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gICAgICBlbHNlIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgaWYgKHJhdGlvID4gKDEgLSBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSkgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICAgIGVsc2Ugc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2hvcnQgc3dpcGVzXG4gICAgaWYgKCFwYXJhbXMuc2hvcnRTd2lwZXMpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlc2l6ZSAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgY29uc3QgeyBwYXJhbXMsIGVsIH0gPSBzd2lwZXI7XG5cbiAgaWYgKGVsICYmIGVsLm9mZnNldFdpZHRoID09PSAwKSByZXR1cm47XG5cbiAgLy8gQnJlYWtwb2ludHNcbiAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gIH1cblxuICAvLyBTYXZlIGxvY2tzXG4gIGNvbnN0IHsgYWxsb3dTbGlkZU5leHQsIGFsbG93U2xpZGVQcmV2LCBzbmFwR3JpZCB9ID0gc3dpcGVyO1xuXG4gIC8vIERpc2FibGUgbG9ja3Mgb24gcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XG5cbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSBNYXRoLm1pbihNYXRoLm1heChzd2lwZXIudHJhbnNsYXRlLCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpLCBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfVxuICAvLyBSZXR1cm4gbG9ja3MgYWZ0ZXIgcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcblxuICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ2xpY2sgKGUpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIuYWxsb3dDbGljaykge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3MpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiYgc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcywgdG91Y2hFdmVudHMsIGVsLCB3cmFwcGVyRWwsXG4gIH0gPSBzd2lwZXI7XG5cbiAge1xuICAgIHN3aXBlci5vblRvdWNoU3RhcnQgPSBvblRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xuICAgIHN3aXBlci5vblRvdWNoTW92ZSA9IG9uVG91Y2hNb3ZlLmJpbmQoc3dpcGVyKTtcbiAgICBzd2lwZXIub25Ub3VjaEVuZCA9IG9uVG91Y2hFbmQuYmluZChzd2lwZXIpO1xuICB9XG5cbiAgc3dpcGVyLm9uQ2xpY2sgPSBvbkNsaWNrLmJpbmQoc3dpcGVyKTtcblxuICBjb25zdCB0YXJnZXQgPSBwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gZWwgOiB3cmFwcGVyRWw7XG4gIGNvbnN0IGNhcHR1cmUgPSAhIXBhcmFtcy5uZXN0ZWQ7XG5cbiAgLy8gVG91Y2ggRXZlbnRzXG4gIHtcbiAgICBpZiAoIVN1cHBvcnQudG91Y2ggJiYgKFN1cHBvcnQucG9pbnRlckV2ZW50cyB8fCBTdXBwb3J0LnByZWZpeGVkUG9pbnRlckV2ZW50cykpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gdG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0JyAmJiBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmUgfSA6IGNhcHR1cmUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKChwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhRGV2aWNlLmlvcyAmJiAhRGV2aWNlLmFuZHJvaWQpIHx8IChwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhU3VwcG9ydC50b3VjaCAmJiBEZXZpY2UuaW9zKSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJldmVudCBMaW5rcyBDbGlja3NcbiAgICBpZiAocGFyYW1zLnByZXZlbnRDbGlja3MgfHwgcGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2l6ZSBoYW5kbGVyXG4gIHN3aXBlci5vbigoRGV2aWNlLmlvcyB8fCBEZXZpY2UuYW5kcm9pZCA/ICdyZXNpemUgb3JpZW50YXRpb25jaGFuZ2Ugb2JzZXJ2ZXJVcGRhdGUnIDogJ3Jlc2l6ZSBvYnNlcnZlclVwZGF0ZScpLCBvblJlc2l6ZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGRldGFjaEV2ZW50cygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICBjb25zdCB7XG4gICAgcGFyYW1zLCB0b3VjaEV2ZW50cywgZWwsIHdyYXBwZXJFbCxcbiAgfSA9IHN3aXBlcjtcblxuICBjb25zdCB0YXJnZXQgPSBwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gZWwgOiB3cmFwcGVyRWw7XG4gIGNvbnN0IGNhcHR1cmUgPSAhIXBhcmFtcy5uZXN0ZWQ7XG5cbiAgLy8gVG91Y2ggRXZlbnRzXG4gIHtcbiAgICBpZiAoIVN1cHBvcnQudG91Y2ggJiYgKFN1cHBvcnQucG9pbnRlckV2ZW50cyB8fCBTdXBwb3J0LnByZWZpeGVkUG9pbnRlckV2ZW50cykpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gdG91Y2hFdmVudHMuc3RhcnQgPT09ICdvblRvdWNoU3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKChwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhRGV2aWNlLmlvcyAmJiAhRGV2aWNlLmFuZHJvaWQpIHx8IChwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhU3VwcG9ydC50b3VjaCAmJiBEZXZpY2UuaW9zKSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJldmVudCBMaW5rcyBDbGlja3NcbiAgICBpZiAocGFyYW1zLnByZXZlbnRDbGlja3MgfHwgcGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2l6ZSBoYW5kbGVyXG4gIHN3aXBlci5vZmYoKERldmljZS5pb3MgfHwgRGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnKSwgb25SZXNpemUpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBhdHRhY2hFdmVudHMsXG4gIGRldGFjaEV2ZW50cyxcbn07XG5cbmZ1bmN0aW9uIHNldEJyZWFrcG9pbnQgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgYWN0aXZlSW5kZXgsIGluaXRpYWxpemVkLCBsb29wZWRTbGlkZXMgPSAwLCBwYXJhbXMsXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGJyZWFrcG9pbnRzID0gcGFyYW1zLmJyZWFrcG9pbnRzO1xuICBpZiAoIWJyZWFrcG9pbnRzIHx8IChicmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhicmVha3BvaW50cykubGVuZ3RoID09PSAwKSkgcmV0dXJuO1xuXG4gIC8vIFNldCBicmVha3BvaW50IGZvciB3aW5kb3cgd2lkdGggYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG4gIGNvbnN0IGJyZWFrcG9pbnQgPSBzd2lwZXIuZ2V0QnJlYWtwb2ludChicmVha3BvaW50cyk7XG5cbiAgaWYgKGJyZWFrcG9pbnQgJiYgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ICE9PSBicmVha3BvaW50KSB7XG4gICAgY29uc3QgYnJlYWtwb2ludE9ubHlQYXJhbXMgPSBicmVha3BvaW50IGluIGJyZWFrcG9pbnRzID8gYnJlYWtwb2ludHNbYnJlYWtwb2ludF0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKGJyZWFrcG9pbnRPbmx5UGFyYW1zKSB7XG4gICAgICBbJ3NsaWRlc1BlclZpZXcnLCAnc3BhY2VCZXR3ZWVuJywgJ3NsaWRlc1Blckdyb3VwJ10uZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IGJyZWFrcG9pbnRPbmx5UGFyYW1zW3BhcmFtXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbVZhbHVlID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICBpZiAocGFyYW0gPT09ICdzbGlkZXNQZXJWaWV3JyAmJiAocGFyYW1WYWx1ZSA9PT0gJ0FVVE8nIHx8IHBhcmFtVmFsdWUgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICBicmVha3BvaW50T25seVBhcmFtc1twYXJhbV0gPSAnYXV0byc7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW0gPT09ICdzbGlkZXNQZXJWaWV3Jykge1xuICAgICAgICAgIGJyZWFrcG9pbnRPbmx5UGFyYW1zW3BhcmFtXSA9IHBhcnNlRmxvYXQocGFyYW1WYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtwb2ludE9ubHlQYXJhbXNbcGFyYW1dID0gcGFyc2VJbnQocGFyYW1WYWx1ZSwgMTApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBicmVha3BvaW50UGFyYW1zID0gYnJlYWtwb2ludE9ubHlQYXJhbXMgfHwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zO1xuICAgIGNvbnN0IGRpcmVjdGlvbkNoYW5nZWQgPSBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAmJiBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAhPT0gcGFyYW1zLmRpcmVjdGlvbjtcbiAgICBjb25zdCBuZWVkc1JlTG9vcCA9IHBhcmFtcy5sb29wICYmIChicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlclZpZXcgIT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IGRpcmVjdGlvbkNoYW5nZWQpO1xuXG4gICAgaWYgKGRpcmVjdGlvbkNoYW5nZWQgJiYgaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN3aXBlci5jaGFuZ2VEaXJlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLnBhcmFtcywgYnJlYWtwb2ludFBhcmFtcyk7XG5cbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgIGFsbG93U2xpZGVOZXh0OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxuICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgfSk7XG5cbiAgICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuXG4gICAgaWYgKG5lZWRzUmVMb29wICYmIGluaXRpYWxpemVkKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgICBzd2lwZXIuc2xpZGVUbygoYWN0aXZlSW5kZXggLSBsb29wZWRTbGlkZXMpICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHN3aXBlci5lbWl0KCdicmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QnJlYWtwb2ludCAoYnJlYWtwb2ludHMpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgLy8gR2V0IGJyZWFrcG9pbnQgZm9yIHdpbmRvdyB3aWR0aFxuICBpZiAoIWJyZWFrcG9pbnRzKSByZXR1cm4gdW5kZWZpbmVkO1xuICBsZXQgYnJlYWtwb2ludCA9IGZhbHNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICB9KTtcbiAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEsIDEwKSAtIHBhcnNlSW50KGIsIDEwKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHNJbnZlcnNlKSB7XG4gICAgICBpZiAocG9pbnQgPD0gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9pbnQgPj0gd2luZG93LmlubmVyV2lkdGggJiYgIWJyZWFrcG9pbnQpIHtcbiAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJyZWFrcG9pbnQgfHwgJ21heCc7XG59XG5cbnZhciBicmVha3BvaW50cyA9IHsgc2V0QnJlYWtwb2ludCwgZ2V0QnJlYWtwb2ludCB9O1xuXG5mdW5jdGlvbiBhZGRDbGFzc2VzICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIGNsYXNzTmFtZXMsIHBhcmFtcywgcnRsLCAkZWwsXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHN1ZmZpeGVzID0gW107XG5cbiAgc3VmZml4ZXMucHVzaCgnaW5pdGlhbGl6ZWQnKTtcbiAgc3VmZml4ZXMucHVzaChwYXJhbXMuZGlyZWN0aW9uKTtcblxuICBpZiAocGFyYW1zLmZyZWVNb2RlKSB7XG4gICAgc3VmZml4ZXMucHVzaCgnZnJlZS1tb2RlJyk7XG4gIH1cbiAgaWYgKCFTdXBwb3J0LmZsZXhib3gpIHtcbiAgICBzdWZmaXhlcy5wdXNoKCduby1mbGV4Ym94Jyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgc3VmZml4ZXMucHVzaCgnYXV0b2hlaWdodCcpO1xuICB9XG4gIGlmIChydGwpIHtcbiAgICBzdWZmaXhlcy5wdXNoKCdydGwnKTtcbiAgfVxuICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcbiAgICBzdWZmaXhlcy5wdXNoKCdtdWx0aXJvdycpO1xuICB9XG4gIGlmIChEZXZpY2UuYW5kcm9pZCkge1xuICAgIHN1ZmZpeGVzLnB1c2goJ2FuZHJvaWQnKTtcbiAgfVxuICBpZiAoRGV2aWNlLmlvcykge1xuICAgIHN1ZmZpeGVzLnB1c2goJ2lvcycpO1xuICB9XG4gIC8vIFdQOCBUb3VjaCBFdmVudHMgRml4XG4gIGlmICgoQnJvd3Nlci5pc0lFIHx8IEJyb3dzZXIuaXNFZGdlKSAmJiAoU3VwcG9ydC5wb2ludGVyRXZlbnRzIHx8IFN1cHBvcnQucHJlZml4ZWRQb2ludGVyRXZlbnRzKSkge1xuICAgIHN1ZmZpeGVzLnB1c2goYHdwOC0ke3BhcmFtcy5kaXJlY3Rpb259YCk7XG4gIH1cblxuICBzdWZmaXhlcy5mb3JFYWNoKChzdWZmaXgpID0+IHtcbiAgICBjbGFzc05hbWVzLnB1c2gocGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBzdWZmaXgpO1xuICB9KTtcblxuICAkZWwuYWRkQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzc2VzICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyAkZWwsIGNsYXNzTmFtZXMgfSA9IHN3aXBlcjtcblxuICAkZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xufVxuXG52YXIgY2xhc3NlcyA9IHsgYWRkQ2xhc3NlcywgcmVtb3ZlQ2xhc3NlcyB9O1xuXG5mdW5jdGlvbiBsb2FkSW1hZ2UgKGltYWdlRWwsIHNyYywgc3Jjc2V0LCBzaXplcywgY2hlY2tGb3JDb21wbGV0ZSwgY2FsbGJhY2spIHtcbiAgbGV0IGltYWdlO1xuICBmdW5jdGlvbiBvblJlYWR5KCkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgfVxuICBpZiAoIWltYWdlRWwuY29tcGxldGUgfHwgIWNoZWNrRm9yQ29tcGxldGUpIHtcbiAgICBpZiAoc3JjKSB7XG4gICAgICBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IG9uUmVhZHk7XG4gICAgICBpbWFnZS5vbmVycm9yID0gb25SZWFkeTtcbiAgICAgIGlmIChzaXplcykge1xuICAgICAgICBpbWFnZS5zaXplcyA9IHNpemVzO1xuICAgICAgfVxuICAgICAgaWYgKHNyY3NldCkge1xuICAgICAgICBpbWFnZS5zcmNzZXQgPSBzcmNzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25SZWFkeSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpbWFnZSBhbHJlYWR5IGxvYWRlZC4uLlxuICAgIG9uUmVhZHkoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkSW1hZ2VzICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgc3dpcGVyLmltYWdlc1RvTG9hZCA9IHN3aXBlci4kZWwuZmluZCgnaW1nJyk7XG4gIGZ1bmN0aW9uIG9uUmVhZHkoKSB7XG4gICAgaWYgKHR5cGVvZiBzd2lwZXIgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlciA9PT0gbnVsbCB8fCAhc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLmltYWdlc0xvYWRlZCAhPT0gdW5kZWZpbmVkKSBzd2lwZXIuaW1hZ2VzTG9hZGVkICs9IDE7XG4gICAgaWYgKHN3aXBlci5pbWFnZXNMb2FkZWQgPT09IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy51cGRhdGVPbkltYWdlc1JlYWR5KSBzd2lwZXIudXBkYXRlKCk7XG4gICAgICBzd2lwZXIuZW1pdCgnaW1hZ2VzUmVhZHknKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzd2lwZXIuaW1hZ2VzVG9Mb2FkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgaW1hZ2VFbCA9IHN3aXBlci5pbWFnZXNUb0xvYWRbaV07XG4gICAgc3dpcGVyLmxvYWRJbWFnZShcbiAgICAgIGltYWdlRWwsXG4gICAgICBpbWFnZUVsLmN1cnJlbnRTcmMgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpLFxuICAgICAgaW1hZ2VFbC5zcmNzZXQgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyY3NldCcpLFxuICAgICAgaW1hZ2VFbC5zaXplcyB8fCBpbWFnZUVsLmdldEF0dHJpYnV0ZSgnc2l6ZXMnKSxcbiAgICAgIHRydWUsXG4gICAgICBvblJlYWR5XG4gICAgKTtcbiAgfVxufVxuXG52YXIgaW1hZ2VzID0ge1xuICBsb2FkSW1hZ2UsXG4gIHByZWxvYWRJbWFnZXMsXG59O1xuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB3YXNMb2NrZWQgPSBzd2lwZXIuaXNMb2NrZWQ7XG5cbiAgc3dpcGVyLmlzTG9ja2VkID0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aCA9PT0gMTtcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gIXN3aXBlci5pc0xvY2tlZDtcblxuICAvLyBldmVudHNcbiAgaWYgKHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSBzd2lwZXIuZW1pdChzd2lwZXIuaXNMb2NrZWQgPyAnbG9jaycgOiAndW5sb2NrJyk7XG5cbiAgaWYgKHdhc0xvY2tlZCAmJiB3YXNMb2NrZWQgIT09IHN3aXBlci5pc0xvY2tlZCkge1xuICAgIHN3aXBlci5pc0VuZCA9IGZhbHNlO1xuICAgIHN3aXBlci5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICB9XG59XG5cbnZhciBjaGVja092ZXJmbG93JDEgPSB7IGNoZWNrT3ZlcmZsb3cgfTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBpbml0OiB0cnVlLFxuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgdG91Y2hFdmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxuICBpbml0aWFsU2xpZGU6IDAsXG4gIHNwZWVkOiAzMDAsXG4gIC8vXG4gIHByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbjogZmFsc2UsXG5cbiAgLy8gVG8gc3VwcG9ydCBpT1MncyBzd2lwZS10by1nby1iYWNrIGdlc3R1cmUgKHdoZW4gYmVpbmcgdXNlZCBpbi1hcHAsIHdpdGggVUlXZWJWaWV3KS5cbiAgZWRnZVN3aXBlRGV0ZWN0aW9uOiBmYWxzZSxcbiAgZWRnZVN3aXBlVGhyZXNob2xkOiAyMCxcblxuICAvLyBGcmVlIG1vZGVcbiAgZnJlZU1vZGU6IGZhbHNlLFxuICBmcmVlTW9kZU1vbWVudHVtOiB0cnVlLFxuICBmcmVlTW9kZU1vbWVudHVtUmF0aW86IDEsXG4gIGZyZWVNb2RlTW9tZW50dW1Cb3VuY2U6IHRydWUsXG4gIGZyZWVNb2RlTW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcbiAgZnJlZU1vZGVNb21lbnR1bVZlbG9jaXR5UmF0aW86IDEsXG4gIGZyZWVNb2RlU3RpY2t5OiBmYWxzZSxcbiAgZnJlZU1vZGVNaW5pbXVtVmVsb2NpdHk6IDAuMDIsXG5cbiAgLy8gQXV0b2hlaWdodFxuICBhdXRvSGVpZ2h0OiBmYWxzZSxcblxuICAvLyBTZXQgd3JhcHBlciB3aWR0aFxuICBzZXRXcmFwcGVyU2l6ZTogZmFsc2UsXG5cbiAgLy8gVmlydHVhbCBUcmFuc2xhdGVcbiAgdmlydHVhbFRyYW5zbGF0ZTogZmFsc2UsXG5cbiAgLy8gRWZmZWN0c1xuICBlZmZlY3Q6ICdzbGlkZScsIC8vICdzbGlkZScgb3IgJ2ZhZGUnIG9yICdjdWJlJyBvciAnY292ZXJmbG93JyBvciAnZmxpcCdcblxuICAvLyBCcmVha3BvaW50c1xuICBicmVha3BvaW50czogdW5kZWZpbmVkLFxuICBicmVha3BvaW50c0ludmVyc2U6IGZhbHNlLFxuXG4gIC8vIFNsaWRlcyBncmlkXG4gIHNwYWNlQmV0d2VlbjogMCxcbiAgc2xpZGVzUGVyVmlldzogMSxcbiAgc2xpZGVzUGVyQ29sdW1uOiAxLFxuICBzbGlkZXNQZXJDb2x1bW5GaWxsOiAnY29sdW1uJyxcbiAgc2xpZGVzUGVyR3JvdXA6IDEsXG4gIGNlbnRlcmVkU2xpZGVzOiBmYWxzZSxcbiAgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLCAvLyBpbiBweFxuICBzbGlkZXNPZmZzZXRBZnRlcjogMCwgLy8gaW4gcHhcbiAgbm9ybWFsaXplU2xpZGVJbmRleDogdHJ1ZSxcbiAgY2VudGVySW5zdWZmaWNpZW50U2xpZGVzOiBmYWxzZSxcblxuICAvLyBEaXNhYmxlIHN3aXBlciBhbmQgaGlkZSBuYXZpZ2F0aW9uIHdoZW4gY29udGFpbmVyIG5vdCBvdmVyZmxvd1xuICB3YXRjaE92ZXJmbG93OiBmYWxzZSxcblxuICAvLyBSb3VuZCBsZW5ndGhcbiAgcm91bmRMZW5ndGhzOiBmYWxzZSxcblxuICAvLyBUb3VjaGVzXG4gIHRvdWNoUmF0aW86IDEsXG4gIHRvdWNoQW5nbGU6IDQ1LFxuICBzaW11bGF0ZVRvdWNoOiB0cnVlLFxuICBzaG9ydFN3aXBlczogdHJ1ZSxcbiAgbG9uZ1N3aXBlczogdHJ1ZSxcbiAgbG9uZ1N3aXBlc1JhdGlvOiAwLjUsXG4gIGxvbmdTd2lwZXNNczogMzAwLFxuICBmb2xsb3dGaW5nZXI6IHRydWUsXG4gIGFsbG93VG91Y2hNb3ZlOiB0cnVlLFxuICB0aHJlc2hvbGQ6IDAsXG4gIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgdG91Y2hTdGFydFByZXZlbnREZWZhdWx0OiB0cnVlLFxuICB0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gIHRvdWNoUmVsZWFzZU9uRWRnZXM6IGZhbHNlLFxuXG4gIC8vIFVuaXF1ZSBOYXZpZ2F0aW9uIEVsZW1lbnRzXG4gIHVuaXF1ZU5hdkVsZW1lbnRzOiB0cnVlLFxuXG4gIC8vIFJlc2lzdGFuY2VcbiAgcmVzaXN0YW5jZTogdHJ1ZSxcbiAgcmVzaXN0YW5jZVJhdGlvOiAwLjg1LFxuXG4gIC8vIFByb2dyZXNzXG4gIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IGZhbHNlLFxuICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IGZhbHNlLFxuXG4gIC8vIEN1cnNvclxuICBncmFiQ3Vyc29yOiBmYWxzZSxcblxuICAvLyBDbGlja3NcbiAgcHJldmVudENsaWNrczogdHJ1ZSxcbiAgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiB0cnVlLFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcblxuICAvLyBJbWFnZXNcbiAgcHJlbG9hZEltYWdlczogdHJ1ZSxcbiAgdXBkYXRlT25JbWFnZXNSZWFkeTogdHJ1ZSxcblxuICAvLyBsb29wXG4gIGxvb3A6IGZhbHNlLFxuICBsb29wQWRkaXRpb25hbFNsaWRlczogMCxcbiAgbG9vcGVkU2xpZGVzOiBudWxsLFxuICBsb29wRmlsbEdyb3VwV2l0aEJsYW5rOiBmYWxzZSxcblxuICAvLyBTd2lwaW5nL25vIHN3aXBpbmdcbiAgYWxsb3dTbGlkZVByZXY6IHRydWUsXG4gIGFsbG93U2xpZGVOZXh0OiB0cnVlLFxuICBzd2lwZUhhbmRsZXI6IG51bGwsIC8vICcuc3dpcGUtaGFuZGxlcicsXG4gIG5vU3dpcGluZzogdHJ1ZSxcbiAgbm9Td2lwaW5nQ2xhc3M6ICdzd2lwZXItbm8tc3dpcGluZycsXG4gIG5vU3dpcGluZ1NlbGVjdG9yOiBudWxsLFxuXG4gIC8vIFBhc3NpdmUgTGlzdGVuZXJzXG4gIHBhc3NpdmVMaXN0ZW5lcnM6IHRydWUsXG5cbiAgLy8gTlNcbiAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3N3aXBlci1jb250YWluZXItJywgLy8gTkVXXG4gIHNsaWRlQ2xhc3M6ICdzd2lwZXItc2xpZGUnLFxuICBzbGlkZUJsYW5rQ2xhc3M6ICdzd2lwZXItc2xpZGUtaW52aXNpYmxlLWJsYW5rJyxcbiAgc2xpZGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1hY3RpdmUnLFxuICBzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1hY3RpdmUnLFxuICBzbGlkZVZpc2libGVDbGFzczogJ3N3aXBlci1zbGlkZS12aXNpYmxlJyxcbiAgc2xpZGVEdXBsaWNhdGVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUnLFxuICBzbGlkZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1uZXh0JyxcbiAgc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtZHVwbGljYXRlLW5leHQnLFxuICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcbiAgc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3M6ICdzd2lwZXItc2xpZGUtZHVwbGljYXRlLXByZXYnLFxuICB3cmFwcGVyQ2xhc3M6ICdzd2lwZXItd3JhcHBlcicsXG5cbiAgLy8gQ2FsbGJhY2tzXG4gIHJ1bkNhbGxiYWNrc09uSW5pdDogdHJ1ZSxcbn07XG5cbi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuXG5jb25zdCBwcm90b3R5cGVzID0ge1xuICB1cGRhdGUsXG4gIHRyYW5zbGF0ZSxcbiAgdHJhbnNpdGlvbixcbiAgc2xpZGUsXG4gIGxvb3AsXG4gIGdyYWJDdXJzb3IsXG4gIG1hbmlwdWxhdGlvbixcbiAgZXZlbnRzLFxuICBicmVha3BvaW50cyxcbiAgY2hlY2tPdmVyZmxvdzogY2hlY2tPdmVyZmxvdyQxLFxuICBjbGFzc2VzLFxuICBpbWFnZXMsXG59O1xuXG5jb25zdCBleHRlbmRlZERlZmF1bHRzID0ge307XG5cbmNsYXNzIFN3aXBlciBleHRlbmRzIFN3aXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGxldCBlbDtcbiAgICBsZXQgcGFyYW1zO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgcGFyYW1zID0gYXJnc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgW2VsLCBwYXJhbXNdID0gYXJncztcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuXG4gICAgcGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICAgIGlmIChlbCAmJiAhcGFyYW1zLmVsKSBwYXJhbXMuZWwgPSBlbDtcblxuICAgIHN1cGVyKHBhcmFtcyk7XG5cbiAgICBPYmplY3Qua2V5cyhwcm90b3R5cGVzKS5mb3JFYWNoKChwcm90b3R5cGVHcm91cCkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocHJvdG90eXBlc1twcm90b3R5cGVHcm91cF0pLmZvckVhY2goKHByb3RvTWV0aG9kKSA9PiB7XG4gICAgICAgIGlmICghU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0pIHtcbiAgICAgICAgICBTd2lwZXIucHJvdG90eXBlW3Byb3RvTWV0aG9kXSA9IHByb3RvdHlwZXNbcHJvdG90eXBlR3JvdXBdW3Byb3RvTWV0aG9kXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBTd2lwZXIgSW5zdGFuY2VcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyLm1vZHVsZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzd2lwZXIubW9kdWxlcyA9IHt9O1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzd2lwZXIubW9kdWxlcykuZm9yRWFjaCgobW9kdWxlTmFtZSkgPT4ge1xuICAgICAgY29uc3QgbW9kdWxlID0gc3dpcGVyLm1vZHVsZXNbbW9kdWxlTmFtZV07XG4gICAgICBpZiAobW9kdWxlLnBhcmFtcykge1xuICAgICAgICBjb25zdCBtb2R1bGVQYXJhbU5hbWUgPSBPYmplY3Qua2V5cyhtb2R1bGUucGFyYW1zKVswXTtcbiAgICAgICAgY29uc3QgbW9kdWxlUGFyYW1zID0gbW9kdWxlLnBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVBhcmFtcyAhPT0gJ29iamVjdCcgfHwgbW9kdWxlUGFyYW1zID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHJldHVybjtcbiAgICAgICAgaWYgKHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7IGVuYWJsZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSAnb2JqZWN0J1xuICAgICAgICAgICYmICEoJ2VuYWJsZWQnIGluIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKSBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgY29uc3Qgc3dpcGVyUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBkZWZhdWx0cyk7XG4gICAgc3dpcGVyLnVzZU1vZHVsZXNQYXJhbXMoc3dpcGVyUGFyYW1zKTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIHBhc3NlZCBwYXJhbXNcbiAgICBzd2lwZXIucGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBzd2lwZXJQYXJhbXMsIGV4dGVuZGVkRGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBzd2lwZXIucGFyYW1zKTtcbiAgICBzd2lwZXIucGFzc2VkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBwYXJhbXMpO1xuXG4gICAgLy8gU2F2ZSBEb20gbGliXG4gICAgc3dpcGVyLiQgPSAkO1xuXG4gICAgLy8gRmluZCBlbFxuICAgIGNvbnN0ICRlbCA9ICQoc3dpcGVyLnBhcmFtcy5lbCk7XG4gICAgZWwgPSAkZWxbMF07XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc3dpcGVycyA9IFtdO1xuICAgICAgJGVsLmVhY2goKGluZGV4LCBjb250YWluZXJFbCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBVdGlscy5leHRlbmQoe30sIHBhcmFtcywgeyBlbDogY29udGFpbmVyRWwgfSk7XG4gICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3dpcGVycztcbiAgICB9XG5cbiAgICBlbC5zd2lwZXIgPSBzd2lwZXI7XG4gICAgJGVsLmRhdGEoJ3N3aXBlcicsIHN3aXBlcik7XG5cbiAgICAvLyBGaW5kIFdyYXBwZXJcbiAgICBjb25zdCAkd3JhcHBlckVsID0gJGVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzc31gKTtcblxuICAgIC8vIEV4dGVuZCBTd2lwZXJcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICAkZWwsXG4gICAgICBlbCxcbiAgICAgICR3cmFwcGVyRWwsXG4gICAgICB3cmFwcGVyRWw6ICR3cmFwcGVyRWxbMF0sXG5cbiAgICAgIC8vIENsYXNzZXNcbiAgICAgIGNsYXNzTmFtZXM6IFtdLFxuXG4gICAgICAvLyBTbGlkZXNcbiAgICAgIHNsaWRlczogJCgpLFxuICAgICAgc2xpZGVzR3JpZDogW10sXG4gICAgICBzbmFwR3JpZDogW10sXG4gICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxuXG4gICAgICAvLyBpc0RpcmVjdGlvblxuICAgICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgIH0sXG4gICAgICBpc1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgICB9LFxuICAgICAgLy8gUlRMXG4gICAgICBydGw6IChlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSxcbiAgICAgIHJ0bFRyYW5zbGF0ZTogc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAoZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8ICRlbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJyksXG4gICAgICB3cm9uZ1JUTDogJHdyYXBwZXJFbC5jc3MoJ2Rpc3BsYXknKSA9PT0gJy13ZWJraXQtYm94JyxcblxuICAgICAgLy8gSW5kZXhlc1xuICAgICAgYWN0aXZlSW5kZXg6IDAsXG4gICAgICByZWFsSW5kZXg6IDAsXG5cbiAgICAgIC8vXG4gICAgICBpc0JlZ2lubmluZzogdHJ1ZSxcbiAgICAgIGlzRW5kOiBmYWxzZSxcblxuICAgICAgLy8gUHJvcHNcbiAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgIHByZXZpb3VzVHJhbnNsYXRlOiAwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB2ZWxvY2l0eTogMCxcbiAgICAgIGFuaW1hdGluZzogZmFsc2UsXG5cbiAgICAgIC8vIExvY2tzXG4gICAgICBhbGxvd1NsaWRlTmV4dDogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcbiAgICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2LFxuXG4gICAgICAvLyBUb3VjaCBFdmVudHNcbiAgICAgIHRvdWNoRXZlbnRzOiAoZnVuY3Rpb24gdG91Y2hFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddO1xuICAgICAgICBsZXQgZGVza3RvcCA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJ107XG4gICAgICAgIGlmIChTdXBwb3J0LnBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICBkZXNrdG9wID0gWydwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnXTtcbiAgICAgICAgfSBlbHNlIGlmIChTdXBwb3J0LnByZWZpeGVkUG9pbnRlckV2ZW50cykge1xuICAgICAgICAgIGRlc2t0b3AgPSBbJ01TUG9pbnRlckRvd24nLCAnTVNQb2ludGVyTW92ZScsICdNU1BvaW50ZXJVcCddO1xuICAgICAgICB9XG4gICAgICAgIHN3aXBlci50b3VjaEV2ZW50c1RvdWNoID0ge1xuICAgICAgICAgIHN0YXJ0OiB0b3VjaFswXSxcbiAgICAgICAgICBtb3ZlOiB0b3VjaFsxXSxcbiAgICAgICAgICBlbmQ6IHRvdWNoWzJdLFxuICAgICAgICB9O1xuICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wID0ge1xuICAgICAgICAgIHN0YXJ0OiBkZXNrdG9wWzBdLFxuICAgICAgICAgIG1vdmU6IGRlc2t0b3BbMV0sXG4gICAgICAgICAgZW5kOiBkZXNrdG9wWzJdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggOiBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wO1xuICAgICAgfSgpKSxcbiAgICAgIHRvdWNoRXZlbnRzRGF0YToge1xuICAgICAgICBpc1RvdWNoZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgIHRvdWNoU3RhcnRUaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgICAgIGN1cnJlbnRUcmFuc2xhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRUcmFuc2xhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIEZvcm0gZWxlbWVudHMgdG8gbWF0Y2hcbiAgICAgICAgZm9ybUVsZW1lbnRzOiAnaW5wdXQsIHNlbGVjdCwgb3B0aW9uLCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlbycsXG4gICAgICAgIC8vIExhc3QgY2xpY2sgdGltZVxuICAgICAgICBsYXN0Q2xpY2tUaW1lOiBVdGlscy5ub3coKSxcbiAgICAgICAgY2xpY2tUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIC8vIFZlbG9jaXRpZXNcbiAgICAgICAgdmVsb2NpdGllczogW10sXG4gICAgICAgIGFsbG93TW9tZW50dW1Cb3VuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNUb3VjaEV2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0TW92aW5nOiB1bmRlZmluZWQsXG4gICAgICB9LFxuXG4gICAgICAvLyBDbGlja3NcbiAgICAgIGFsbG93Q2xpY2s6IHRydWUsXG5cbiAgICAgIC8vIFRvdWNoZXNcbiAgICAgIGFsbG93VG91Y2hNb3ZlOiBzd2lwZXIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxuXG4gICAgICB0b3VjaGVzOiB7XG4gICAgICAgIHN0YXJ0WDogMCxcbiAgICAgICAgc3RhcnRZOiAwLFxuICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgY3VycmVudFk6IDAsXG4gICAgICAgIGRpZmY6IDAsXG4gICAgICB9LFxuXG4gICAgICAvLyBJbWFnZXNcbiAgICAgIGltYWdlc1RvTG9hZDogW10sXG4gICAgICBpbWFnZXNMb2FkZWQ6IDAsXG5cbiAgICB9KTtcblxuICAgIC8vIEluc3RhbGwgTW9kdWxlc1xuICAgIHN3aXBlci51c2VNb2R1bGVzKCk7XG5cbiAgICAvLyBJbml0XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaW5pdCkge1xuICAgICAgc3dpcGVyLmluaXQoKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYXBwIGluc3RhbmNlXG4gICAgcmV0dXJuIHN3aXBlcjtcbiAgfVxuXG4gIHNsaWRlc1BlclZpZXdEeW5hbWljKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zLCBzbGlkZXMsIHNsaWRlc0dyaWQsIHNpemU6IHN3aXBlclNpemUsIGFjdGl2ZUluZGV4LFxuICAgIH0gPSBzd2lwZXI7XG4gICAgbGV0IHNwdiA9IDE7XG4gICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgbGV0IHNsaWRlU2l6ZSA9IHNsaWRlc1thY3RpdmVJbmRleF0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgbGV0IGJyZWFrTG9vcDtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCArIDE7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgc2xpZGVTaXplICs9IHNsaWRlc1tpXS5zd2lwZXJTbGlkZVNpemU7XG4gICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCArIDE7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc0dyaWRbaV0gLSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSA8IHN3aXBlclNpemUpIHtcbiAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3B2O1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgc25hcEdyaWQsIHBhcmFtcyB9ID0gc3dpcGVyO1xuICAgIC8vIEJyZWFrcG9pbnRzXG4gICAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICB9XG4gICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcblxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgKiAtMSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSBNYXRoLm1pbihNYXRoLm1heCh0cmFuc2xhdGVWYWx1ZSwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSwgc3dpcGVyLm1pblRyYW5zbGF0ZSgpKTtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICB9XG4gICAgbGV0IHRyYW5zbGF0ZWQ7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUpIHtcbiAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nIHx8IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgndXBkYXRlJyk7XG4gIH1cblxuICBjaGFuZ2VEaXJlY3Rpb24obmV3RGlyZWN0aW9uLCBuZWVkVXBkYXRlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudERpcmVjdGlvbiA9IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uO1xuICAgIGlmICghbmV3RGlyZWN0aW9uKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5ld0RpcmVjdGlvbiA9IGN1cnJlbnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGlmICgobmV3RGlyZWN0aW9uID09PSBjdXJyZW50RGlyZWN0aW9uKSB8fCAobmV3RGlyZWN0aW9uICE9PSAnaG9yaXpvbnRhbCcgJiYgbmV3RGlyZWN0aW9uICE9PSAndmVydGljYWwnKSkge1xuICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudERpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgc3dpcGVyLiRlbFxuICAgICAgICAucmVtb3ZlQ2xhc3MoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXZlcnRpY2FsIHdwOC12ZXJ0aWNhbGApXG4gICAgICAgIC5hZGRDbGFzcyhgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtuZXdEaXJlY3Rpb259YCk7XG5cbiAgICAgIGlmICgoQnJvd3Nlci5pc0lFIHx8IEJyb3dzZXIuaXNFZGdlKSAmJiAoU3VwcG9ydC5wb2ludGVyRXZlbnRzIHx8IFN1cHBvcnQucHJlZml4ZWRQb2ludGVyRXZlbnRzKSkge1xuICAgICAgICBzd2lwZXIuJGVsLmFkZENsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc313cDgtJHtuZXdEaXJlY3Rpb259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHN3aXBlci4kZWxcbiAgICAgICAgLnJlbW92ZUNsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ob3Jpem9udGFsIHdwOC1ob3Jpem9udGFsYClcbiAgICAgICAgLmFkZENsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke25ld0RpcmVjdGlvbn1gKTtcblxuICAgICAgaWYgKChCcm93c2VyLmlzSUUgfHwgQnJvd3Nlci5pc0VkZ2UpICYmIChTdXBwb3J0LnBvaW50ZXJFdmVudHMgfHwgU3VwcG9ydC5wcmVmaXhlZFBvaW50ZXJFdmVudHMpKSB7XG4gICAgICAgIHN3aXBlci4kZWwuYWRkQ2xhc3MoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXdwOC0ke25ld0RpcmVjdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9IG5ld0RpcmVjdGlvbjtcblxuICAgIHN3aXBlci5zbGlkZXMuZWFjaCgoc2xpZGVJbmRleCwgc2xpZGVFbCkgPT4ge1xuICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBzbGlkZUVsLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZUVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3dpcGVyLmVtaXQoJ2NoYW5nZURpcmVjdGlvbicpO1xuICAgIGlmIChuZWVkVXBkYXRlKSBzd2lwZXIudXBkYXRlKCk7XG5cbiAgICByZXR1cm4gc3dpcGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVJbml0Jyk7XG5cbiAgICAvLyBTZXQgYnJlYWtwb2ludFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICAgIH1cblxuICAgIC8vIEFkZCBDbGFzc2VzXG4gICAgc3dpcGVyLmFkZENsYXNzZXMoKTtcblxuICAgIC8vIENyZWF0ZSBsb29wXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2l6ZVxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG5cbiAgICAvLyBVcGRhdGUgc2xpZGVzXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuXG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykge1xuICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgR3JhYiBDdXJzb3JcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcigpO1xuICAgIH1cblxuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZWxvYWRJbWFnZXMpIHtcbiAgICAgIHN3aXBlci5wcmVsb2FkSW1hZ2VzKCk7XG4gICAgfVxuXG4gICAgLy8gU2xpZGUgVG8gSW5pdGlhbCBTbGlkZVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucGFyYW1zLmluaXRpYWxTbGlkZSwgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCBldmVudHNcbiAgICBzd2lwZXIuYXR0YWNoRXZlbnRzKCk7XG5cbiAgICAvLyBJbml0IEZsYWdcbiAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgLy8gRW1pdFxuICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XG4gIH1cblxuICBkZXN0cm95KGRlbGV0ZUluc3RhbmNlID0gdHJ1ZSwgY2xlYW5TdHlsZXMgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwYXJhbXMsICRlbCwgJHdyYXBwZXJFbCwgc2xpZGVzLFxuICAgIH0gPSBzd2lwZXI7XG5cbiAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlci5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVEZXN0cm95Jyk7XG5cbiAgICAvLyBJbml0IEZsYWdcbiAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIC8vIERldGFjaCBldmVudHNcbiAgICBzd2lwZXIuZGV0YWNoRXZlbnRzKCk7XG5cbiAgICAvLyBEZXN0cm95IGxvb3BcbiAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8vIENsZWFudXAgc3R5bGVzXG4gICAgaWYgKGNsZWFuU3R5bGVzKSB7XG4gICAgICBzd2lwZXIucmVtb3ZlQ2xhc3NlcygpO1xuICAgICAgJGVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAkd3JhcHBlckVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICBpZiAoc2xpZGVzICYmIHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgc2xpZGVzXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKFtcbiAgICAgICAgICAgIHBhcmFtcy5zbGlkZVZpc2libGVDbGFzcyxcbiAgICAgICAgICAgIHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgcGFyYW1zLnNsaWRlTmV4dENsYXNzLFxuICAgICAgICAgICAgcGFyYW1zLnNsaWRlUHJldkNsYXNzLFxuICAgICAgICAgIF0uam9pbignICcpKVxuICAgICAgICAgIC5yZW1vdmVBdHRyKCdzdHlsZScpXG4gICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JylcbiAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItY29sdW1uJylcbiAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItcm93Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpcGVyLmVtaXQoJ2Rlc3Ryb3knKTtcblxuICAgIC8vIERldGFjaCBlbWl0dGVyIGV2ZW50c1xuICAgIE9iamVjdC5rZXlzKHN3aXBlci5ldmVudHNMaXN0ZW5lcnMpLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgc3dpcGVyLm9mZihldmVudE5hbWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRlbGV0ZUluc3RhbmNlICE9PSBmYWxzZSkge1xuICAgICAgc3dpcGVyLiRlbFswXS5zd2lwZXIgPSBudWxsO1xuICAgICAgc3dpcGVyLiRlbC5kYXRhKCdzd2lwZXInLCBudWxsKTtcbiAgICAgIFV0aWxzLmRlbGV0ZVByb3BzKHN3aXBlcik7XG4gICAgfVxuICAgIHN3aXBlci5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdGF0aWMgZXh0ZW5kRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICBVdGlscy5leHRlbmQoZXh0ZW5kZWREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICB9XG5cbiAgc3RhdGljIGdldCBleHRlbmRlZERlZmF1bHRzKCkge1xuICAgIHJldHVybiBleHRlbmRlZERlZmF1bHRzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IENsYXNzKCkge1xuICAgIHJldHVybiBTd2lwZXJDbGFzcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgJCgpIHtcbiAgICByZXR1cm4gJDtcbiAgfVxufVxuXG52YXIgRGV2aWNlJDEgPSB7XG4gIG5hbWU6ICdkZXZpY2UnLFxuICBwcm90bzoge1xuICAgIGRldmljZTogRGV2aWNlLFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBkZXZpY2U6IERldmljZSxcbiAgfSxcbn07XG5cbnZhciBTdXBwb3J0JDEgPSB7XG4gIG5hbWU6ICdzdXBwb3J0JyxcbiAgcHJvdG86IHtcbiAgICBzdXBwb3J0OiBTdXBwb3J0LFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBzdXBwb3J0OiBTdXBwb3J0LFxuICB9LFxufTtcblxudmFyIEJyb3dzZXIkMSA9IHtcbiAgbmFtZTogJ2Jyb3dzZXInLFxuICBwcm90bzoge1xuICAgIGJyb3dzZXI6IEJyb3dzZXIsXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIGJyb3dzZXI6IEJyb3dzZXIsXG4gIH0sXG59O1xuXG52YXIgUmVzaXplID0ge1xuICBuYW1lOiAncmVzaXplJyxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgcmVzaXplOiB7XG4gICAgICAgIHJlc2l6ZUhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVJlc2l6ZScpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdyZXNpemUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKCkge1xuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdvcmllbnRhdGlvbmNoYW5nZScpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIC8vIEVtaXQgcmVzaXplXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3dpcGVyLnJlc2l6ZS5yZXNpemVIYW5kbGVyKTtcblxuICAgICAgLy8gRW1pdCBvcmllbnRhdGlvbmNoYW5nZVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgc3dpcGVyLnJlc2l6ZS5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpO1xuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3dpcGVyLnJlc2l6ZS5yZXNpemVIYW5kbGVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHN3aXBlci5yZXNpemUub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgT2JzZXJ2ZXIgPSB7XG4gIGZ1bmM6IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJraXRNdXRhdGlvbk9ic2VydmVyLFxuICBhdHRhY2godGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gT2JzZXJ2ZXIuZnVuYztcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlckZ1bmMoKG11dGF0aW9ucykgPT4ge1xuICAgICAgLy8gVGhlIG9ic2VydmVyVXBkYXRlIGV2ZW50IHNob3VsZCBvbmx5IGJlIHRyaWdnZXJlZFxuICAgICAgLy8gb25jZSBkZXNwaXRlIHRoZSBudW1iZXIgb2YgbXV0YXRpb25zLiAgQWRkaXRpb25hbFxuICAgICAgLy8gdHJpZ2dlcnMgYXJlIHJlZHVuZGFudCBhbmQgYXJlIHZlcnkgY29zdGx5XG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzd2lwZXIuZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChvYnNlcnZlclVwZGF0ZSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgYXR0cmlidXRlczogdHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcyA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgY2hpbGRMaXN0OiB0eXBlb2Ygb3B0aW9ucy5jaGlsZExpc3QgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hpbGRMaXN0LFxuICAgICAgY2hhcmFjdGVyRGF0YTogdHlwZW9mIG9wdGlvbnMuY2hhcmFjdGVyRGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGFyYWN0ZXJEYXRhLFxuICAgIH0pO1xuXG4gICAgc3dpcGVyLm9ic2VydmVyLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgfSxcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghU3VwcG9ydC5vYnNlcnZlciB8fCAhc3dpcGVyLnBhcmFtcy5vYnNlcnZlcikgcmV0dXJuO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLm9ic2VydmVQYXJlbnRzKSB7XG4gICAgICBjb25zdCBjb250YWluZXJQYXJlbnRzID0gc3dpcGVyLiRlbC5wYXJlbnRzKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lclBhcmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3dpcGVyLm9ic2VydmVyLmF0dGFjaChjb250YWluZXJQYXJlbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT2JzZXJ2ZSBjb250YWluZXJcbiAgICBzd2lwZXIub2JzZXJ2ZXIuYXR0YWNoKHN3aXBlci4kZWxbMF0sIHsgY2hpbGRMaXN0OiBzd2lwZXIucGFyYW1zLm9ic2VydmVTbGlkZUNoaWxkcmVuIH0pO1xuXG4gICAgLy8gT2JzZXJ2ZSB3cmFwcGVyXG4gICAgc3dpcGVyLm9ic2VydmVyLmF0dGFjaChzd2lwZXIuJHdyYXBwZXJFbFswXSwgeyBhdHRyaWJ1dGVzOiBmYWxzZSB9KTtcbiAgfSxcbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHN3aXBlci5vYnNlcnZlci5vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBzd2lwZXIub2JzZXJ2ZXIub2JzZXJ2ZXJzID0gW107XG4gIH0sXG59O1xuXG52YXIgT2JzZXJ2ZXIkMSA9IHtcbiAgbmFtZTogJ29ic2VydmVyJyxcbiAgcGFyYW1zOiB7XG4gICAgb2JzZXJ2ZXI6IGZhbHNlLFxuICAgIG9ic2VydmVQYXJlbnRzOiBmYWxzZSxcbiAgICBvYnNlcnZlU2xpZGVDaGlsZHJlbjogZmFsc2UsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIG9ic2VydmVyOiB7XG4gICAgICAgIGluaXQ6IE9ic2VydmVyLmluaXQuYmluZChzd2lwZXIpLFxuICAgICAgICBhdHRhY2g6IE9ic2VydmVyLmF0dGFjaC5iaW5kKHN3aXBlciksXG4gICAgICAgIGRlc3Ryb3k6IE9ic2VydmVyLmRlc3Ryb3kuYmluZChzd2lwZXIpLFxuICAgICAgICBvYnNlcnZlcnM6IFtdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5vYnNlcnZlci5pbml0KCk7XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5vYnNlcnZlci5kZXN0cm95KCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFZpcnR1YWwgPSB7XG4gIHVwZGF0ZShmb3JjZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyBzbGlkZXNQZXJWaWV3LCBzbGlkZXNQZXJHcm91cCwgY2VudGVyZWRTbGlkZXMgfSA9IHN3aXBlci5wYXJhbXM7XG4gICAgY29uc3QgeyBhZGRTbGlkZXNCZWZvcmUsIGFkZFNsaWRlc0FmdGVyIH0gPSBzd2lwZXIucGFyYW1zLnZpcnR1YWw7XG4gICAgY29uc3Qge1xuICAgICAgZnJvbTogcHJldmlvdXNGcm9tLFxuICAgICAgdG86IHByZXZpb3VzVG8sXG4gICAgICBzbGlkZXMsXG4gICAgICBzbGlkZXNHcmlkOiBwcmV2aW91c1NsaWRlc0dyaWQsXG4gICAgICByZW5kZXJTbGlkZSxcbiAgICAgIG9mZnNldDogcHJldmlvdXNPZmZzZXQsXG4gICAgfSA9IHN3aXBlci52aXJ0dWFsO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IHx8IDA7XG5cbiAgICBsZXQgb2Zmc2V0UHJvcDtcbiAgICBpZiAoc3dpcGVyLnJ0bFRyYW5zbGF0ZSkgb2Zmc2V0UHJvcCA9ICdyaWdodCc7XG4gICAgZWxzZSBvZmZzZXRQcm9wID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2xlZnQnIDogJ3RvcCc7XG5cbiAgICBsZXQgc2xpZGVzQWZ0ZXI7XG4gICAgbGV0IHNsaWRlc0JlZm9yZTtcbiAgICBpZiAoY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlc0FmdGVyID0gTWF0aC5mbG9vcihzbGlkZXNQZXJWaWV3IC8gMikgKyBzbGlkZXNQZXJHcm91cCArIGFkZFNsaWRlc0JlZm9yZTtcbiAgICAgIHNsaWRlc0JlZm9yZSA9IE1hdGguZmxvb3Ioc2xpZGVzUGVyVmlldyAvIDIpICsgc2xpZGVzUGVyR3JvdXAgKyBhZGRTbGlkZXNBZnRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVzQWZ0ZXIgPSBzbGlkZXNQZXJWaWV3ICsgKHNsaWRlc1Blckdyb3VwIC0gMSkgKyBhZGRTbGlkZXNCZWZvcmU7XG4gICAgICBzbGlkZXNCZWZvcmUgPSBzbGlkZXNQZXJHcm91cCArIGFkZFNsaWRlc0FmdGVyO1xuICAgIH1cbiAgICBjb25zdCBmcm9tID0gTWF0aC5tYXgoKGFjdGl2ZUluZGV4IHx8IDApIC0gc2xpZGVzQmVmb3JlLCAwKTtcbiAgICBjb25zdCB0byA9IE1hdGgubWluKChhY3RpdmVJbmRleCB8fCAwKSArIHNsaWRlc0FmdGVyLCBzbGlkZXMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKHN3aXBlci5zbGlkZXNHcmlkW2Zyb21dIHx8IDApIC0gKHN3aXBlci5zbGlkZXNHcmlkWzBdIHx8IDApO1xuXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlci52aXJ0dWFsLCB7XG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICBvZmZzZXQsXG4gICAgICBzbGlkZXNHcmlkOiBzd2lwZXIuc2xpZGVzR3JpZCxcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uUmVuZGVyZWQoKSB7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBpZiAoc3dpcGVyLmxhenkgJiYgc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2aW91c0Zyb20gPT09IGZyb20gJiYgcHJldmlvdXNUbyA9PT0gdG8gJiYgIWZvcmNlKSB7XG4gICAgICBpZiAoc3dpcGVyLnNsaWRlc0dyaWQgIT09IHByZXZpb3VzU2xpZGVzR3JpZCAmJiBvZmZzZXQgIT09IHByZXZpb3VzT2Zmc2V0KSB7XG4gICAgICAgIHN3aXBlci5zbGlkZXMuY3NzKG9mZnNldFByb3AsIGAke29mZnNldH1weGApO1xuICAgICAgfVxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHN3aXBlci5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbC5jYWxsKHN3aXBlciwge1xuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBzbGlkZXM6IChmdW5jdGlvbiBnZXRTbGlkZXMoKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVzVG9SZW5kZXIgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8PSB0bzsgaSArPSAxKSB7XG4gICAgICAgICAgICBzbGlkZXNUb1JlbmRlci5wdXNoKHNsaWRlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzbGlkZXNUb1JlbmRlcjtcbiAgICAgICAgfSgpKSxcbiAgICAgIH0pO1xuICAgICAgb25SZW5kZXJlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmVwZW5kSW5kZXhlcyA9IFtdO1xuICAgIGNvbnN0IGFwcGVuZEluZGV4ZXMgPSBbXTtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKS5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzRnJvbTsgaSA8PSBwcmV2aW91c1RvOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPCBmcm9tIHx8IGkgPiB0bykge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdYCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChpID49IGZyb20gJiYgaSA8PSB0bykge1xuICAgICAgICBpZiAodHlwZW9mIHByZXZpb3VzVG8gPT09ICd1bmRlZmluZWQnIHx8IGZvcmNlKSB7XG4gICAgICAgICAgYXBwZW5kSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpID4gcHJldmlvdXNUbykgYXBwZW5kSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgIGlmIChpIDwgcHJldmlvdXNGcm9tKSBwcmVwZW5kSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGVuZEluZGV4ZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLmFwcGVuZChyZW5kZXJTbGlkZShzbGlkZXNbaW5kZXhdLCBpbmRleCkpO1xuICAgIH0pO1xuICAgIHByZXBlbmRJbmRleGVzLnNvcnQoKGEsIGIpID0+IGIgLSBhKS5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwucHJlcGVuZChyZW5kZXJTbGlkZShzbGlkZXNbaW5kZXhdLCBpbmRleCkpO1xuICAgIH0pO1xuICAgIHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKCcuc3dpcGVyLXNsaWRlJykuY3NzKG9mZnNldFByb3AsIGAke29mZnNldH1weGApO1xuICAgIG9uUmVuZGVyZWQoKTtcbiAgfSxcbiAgcmVuZGVyU2xpZGUoc2xpZGUsIGluZGV4KSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnZpcnR1YWw7XG4gICAgaWYgKHBhcmFtcy5jYWNoZSAmJiBzd2lwZXIudmlydHVhbC5jYWNoZVtpbmRleF0pIHtcbiAgICAgIHJldHVybiBzd2lwZXIudmlydHVhbC5jYWNoZVtpbmRleF07XG4gICAgfVxuICAgIGNvbnN0ICRzbGlkZUVsID0gcGFyYW1zLnJlbmRlclNsaWRlXG4gICAgICA/ICQocGFyYW1zLnJlbmRlclNsaWRlLmNhbGwoc3dpcGVyLCBzbGlkZSwgaW5kZXgpKVxuICAgICAgOiAkKGA8ZGl2IGNsYXNzPVwiJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9XCIgZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2luZGV4fVwiPiR7c2xpZGV9PC9kaXY+YCk7XG4gICAgaWYgKCEkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpKSAkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcbiAgICBpZiAocGFyYW1zLmNhY2hlKSBzd2lwZXIudmlydHVhbC5jYWNoZVtpbmRleF0gPSAkc2xpZGVFbDtcbiAgICByZXR1cm4gJHNsaWRlRWw7XG4gIH0sXG4gIGFwcGVuZFNsaWRlKHNsaWRlcykge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBzbGlkZXMgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIHNsaWRlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXSkgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnB1c2goc2xpZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnB1c2goc2xpZGVzKTtcbiAgICB9XG4gICAgc3dpcGVyLnZpcnR1YWwudXBkYXRlKHRydWUpO1xuICB9LFxuICBwcmVwZW5kU2xpZGUoc2xpZGVzKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgICBsZXQgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIDE7XG4gICAgbGV0IG51bWJlck9mTmV3U2xpZGVzID0gMTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWRlcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0pIHN3aXBlci52aXJ0dWFsLnNsaWRlcy51bnNoaWZ0KHNsaWRlc1tpXSk7XG4gICAgICB9XG4gICAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzLmxlbmd0aDtcbiAgICAgIG51bWJlck9mTmV3U2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoc2xpZGVzKTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgY29uc3QgY2FjaGUgPSBzd2lwZXIudmlydHVhbC5jYWNoZTtcbiAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICBPYmplY3Qua2V5cyhjYWNoZSkuZm9yRWFjaCgoY2FjaGVkSW5kZXgpID0+IHtcbiAgICAgICAgbmV3Q2FjaGVbcGFyc2VJbnQoY2FjaGVkSW5kZXgsIDEwKSArIG51bWJlck9mTmV3U2xpZGVzXSA9IGNhY2hlW2NhY2hlZEluZGV4XTtcbiAgICAgIH0pO1xuICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGUgPSBuZXdDYWNoZTtcbiAgICB9XG4gICAgc3dpcGVyLnZpcnR1YWwudXBkYXRlKHRydWUpO1xuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4LCAwKTtcbiAgfSxcbiAgcmVtb3ZlU2xpZGUoc2xpZGVzSW5kZXhlcykge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBzbGlkZXNJbmRleGVzID09PSAndW5kZWZpbmVkJyB8fCBzbGlkZXNJbmRleGVzID09PSBudWxsKSByZXR1cm47XG4gICAgbGV0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWRlc0luZGV4ZXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gc2xpZGVzSW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMuc3BsaWNlKHNsaWRlc0luZGV4ZXNbaV0sIDEpO1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmNhY2hlKSB7XG4gICAgICAgICAgZGVsZXRlIHN3aXBlci52aXJ0dWFsLmNhY2hlW3NsaWRlc0luZGV4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbGlkZXNJbmRleGVzW2ldIDwgYWN0aXZlSW5kZXgpIGFjdGl2ZUluZGV4IC09IDE7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gTWF0aC5tYXgoYWN0aXZlSW5kZXgsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMuc3BsaWNlKHNsaWRlc0luZGV4ZXMsIDEpO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgICBkZWxldGUgc3dpcGVyLnZpcnR1YWwuY2FjaGVbc2xpZGVzSW5kZXhlc107XG4gICAgICB9XG4gICAgICBpZiAoc2xpZGVzSW5kZXhlcyA8IGFjdGl2ZUluZGV4KSBhY3RpdmVJbmRleCAtPSAxO1xuICAgICAgYWN0aXZlSW5kZXggPSBNYXRoLm1heChhY3RpdmVJbmRleCwgMCk7XG4gICAgfVxuICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSh0cnVlKTtcbiAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCwgMCk7XG4gIH0sXG4gIHJlbW92ZUFsbFNsaWRlcygpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcyA9IFtdO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcbiAgICAgIHN3aXBlci52aXJ0dWFsLmNhY2hlID0ge307XG4gICAgfVxuICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSh0cnVlKTtcbiAgICBzd2lwZXIuc2xpZGVUbygwLCAwKTtcbiAgfSxcbn07XG5cbnZhciBWaXJ0dWFsJDEgPSB7XG4gIG5hbWU6ICd2aXJ0dWFsJyxcbiAgcGFyYW1zOiB7XG4gICAgdmlydHVhbDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBzbGlkZXM6IFtdLFxuICAgICAgY2FjaGU6IHRydWUsXG4gICAgICByZW5kZXJTbGlkZTogbnVsbCxcbiAgICAgIHJlbmRlckV4dGVybmFsOiBudWxsLFxuICAgICAgYWRkU2xpZGVzQmVmb3JlOiAwLFxuICAgICAgYWRkU2xpZGVzQWZ0ZXI6IDAsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgdmlydHVhbDoge1xuICAgICAgICB1cGRhdGU6IFZpcnR1YWwudXBkYXRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgYXBwZW5kU2xpZGU6IFZpcnR1YWwuYXBwZW5kU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICBwcmVwZW5kU2xpZGU6IFZpcnR1YWwucHJlcGVuZFNsaWRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgcmVtb3ZlU2xpZGU6IFZpcnR1YWwucmVtb3ZlU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICByZW1vdmVBbGxTbGlkZXM6IFZpcnR1YWwucmVtb3ZlQWxsU2xpZGVzLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgcmVuZGVyU2xpZGU6IFZpcnR1YWwucmVuZGVyU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICBzbGlkZXM6IHN3aXBlci5wYXJhbXMudmlydHVhbC5zbGlkZXMsXG4gICAgICAgIGNhY2hlOiB7fSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgYmVmb3JlSW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc312aXJ0dWFsYCk7XG4gICAgICBjb25zdCBvdmVyd3JpdGVQYXJhbXMgPSB7XG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICB9O1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XG4gICAgICBVdGlscy5leHRlbmQoc3dpcGVyLm9yaWdpbmFsUGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlKSB7XG4gICAgICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSgpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBLZXlib2FyZCA9IHtcbiAgaGFuZGxlKGV2ZW50KSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XG4gICAgbGV0IGUgPSBldmVudDtcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG4gICAgY29uc3Qga2MgPSBlLmtleUNvZGUgfHwgZS5jaGFyQ29kZTtcbiAgICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZU5leHQgJiYgKChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYga2MgPT09IDM5KSB8fCAoc3dpcGVyLmlzVmVydGljYWwoKSAmJiBrYyA9PT0gNDApKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiAoKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiBrYyA9PT0gMzcpIHx8IChzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIGtjID09PSAzOCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlLnNoaWZ0S2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgJiYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5rZXlib2FyZC5vbmx5SW5WaWV3cG9ydCAmJiAoa2MgPT09IDM3IHx8IGtjID09PSAzOSB8fCBrYyA9PT0gMzggfHwga2MgPT09IDQwKSkge1xuICAgICAgbGV0IGluVmlldyA9IGZhbHNlO1xuICAgICAgLy8gQ2hlY2sgdGhhdCBzd2lwZXIgc2hvdWxkIGJlIGluc2lkZSBvZiB2aXNpYmxlIGFyZWEgb2Ygd2luZG93XG4gICAgICBpZiAoc3dpcGVyLiRlbC5wYXJlbnRzKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCkubGVuZ3RoID4gMCAmJiBzd2lwZXIuJGVsLnBhcmVudHMoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjb25zdCBzd2lwZXJPZmZzZXQgPSBzd2lwZXIuJGVsLm9mZnNldCgpO1xuICAgICAgaWYgKHJ0bCkgc3dpcGVyT2Zmc2V0LmxlZnQgLT0gc3dpcGVyLiRlbFswXS5zY3JvbGxMZWZ0O1xuICAgICAgY29uc3Qgc3dpcGVyQ29vcmQgPSBbXG4gICAgICAgIFtzd2lwZXJPZmZzZXQubGVmdCwgc3dpcGVyT2Zmc2V0LnRvcF0sXG4gICAgICAgIFtzd2lwZXJPZmZzZXQubGVmdCArIHN3aXBlci53aWR0aCwgc3dpcGVyT2Zmc2V0LnRvcF0sXG4gICAgICAgIFtzd2lwZXJPZmZzZXQubGVmdCwgc3dpcGVyT2Zmc2V0LnRvcCArIHN3aXBlci5oZWlnaHRdLFxuICAgICAgICBbc3dpcGVyT2Zmc2V0LmxlZnQgKyBzd2lwZXIud2lkdGgsIHN3aXBlck9mZnNldC50b3AgKyBzd2lwZXIuaGVpZ2h0XSxcbiAgICAgIF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlckNvb3JkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gc3dpcGVyQ29vcmRbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwb2ludFswXSA+PSAwICYmIHBvaW50WzBdIDw9IHdpbmRvd1dpZHRoXG4gICAgICAgICAgJiYgcG9pbnRbMV0gPj0gMCAmJiBwb2ludFsxXSA8PSB3aW5kb3dIZWlnaHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpblZpZXcpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGlmIChrYyA9PT0gMzcgfHwga2MgPT09IDM5KSB7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChrYyA9PT0gMzkgJiYgIXJ0bCkgfHwgKGtjID09PSAzNyAmJiBydGwpKSBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICBpZiAoKGtjID09PSAzNyAmJiAhcnRsKSB8fCAoa2MgPT09IDM5ICYmIHJ0bCkpIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtjID09PSAzOCB8fCBrYyA9PT0gNDApIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoa2MgPT09IDQwKSBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICBpZiAoa2MgPT09IDM4KSBzd2lwZXIuc2xpZGVQcmV2KCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdrZXlQcmVzcycsIGtjKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICBlbmFibGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQpIHJldHVybjtcbiAgICAkKGRvY3VtZW50KS5vbigna2V5ZG93bicsIHN3aXBlci5rZXlib2FyZC5oYW5kbGUpO1xuICAgIHN3aXBlci5rZXlib2FyZC5lbmFibGVkID0gdHJ1ZTtcbiAgfSxcbiAgZGlzYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQpIHJldHVybjtcbiAgICAkKGRvY3VtZW50KS5vZmYoJ2tleWRvd24nLCBzd2lwZXIua2V5Ym9hcmQuaGFuZGxlKTtcbiAgICBzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCA9IGZhbHNlO1xuICB9LFxufTtcblxudmFyIEtleWJvYXJkJDEgPSB7XG4gIG5hbWU6ICdrZXlib2FyZCcsXG4gIHBhcmFtczoge1xuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG9ubHlJblZpZXdwb3J0OiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBlbmFibGU6IEtleWJvYXJkLmVuYWJsZS5iaW5kKHN3aXBlciksXG4gICAgICAgIGRpc2FibGU6IEtleWJvYXJkLmRpc2FibGUuYmluZChzd2lwZXIpLFxuICAgICAgICBoYW5kbGU6IEtleWJvYXJkLmhhbmRsZS5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMua2V5Ym9hcmQuZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIua2V5Ym9hcmQuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIua2V5Ym9hcmQuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKCkge1xuICBjb25zdCBldmVudE5hbWUgPSAnb253aGVlbCc7XG4gIGxldCBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkXG4gICAgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cbiAgICAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlXG4gICAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAgIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gICAgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlXG4gICkge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cbmNvbnN0IE1vdXNld2hlZWwgPSB7XG4gIGxhc3RTY3JvbGxUaW1lOiBVdGlscy5ub3coKSxcbiAgZXZlbnQ6IChmdW5jdGlvbiBnZXRFdmVudCgpIHtcbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignZmlyZWZveCcpID4gLTEpIHJldHVybiAnRE9NTW91c2VTY3JvbGwnO1xuICAgIHJldHVybiBpc0V2ZW50U3VwcG9ydGVkKCkgPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnO1xuICB9KCkpLFxuICBub3JtYWxpemUoZSkge1xuICAgIC8vIFJlYXNvbmFibGUgZGVmYXVsdHNcbiAgICBjb25zdCBQSVhFTF9TVEVQID0gMTA7XG4gICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICBjb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcblxuICAgIGxldCBzWCA9IDA7XG4gICAgbGV0IHNZID0gMDsgLy8gc3BpblgsIHNwaW5ZXG4gICAgbGV0IHBYID0gMDtcbiAgICBsZXQgcFkgPSAwOyAvLyBwaXhlbFgsIHBpeGVsWVxuXG4gICAgLy8gTGVnYWN5XG4gICAgaWYgKCdkZXRhaWwnIGluIGUpIHtcbiAgICAgIHNZID0gZS5kZXRhaWw7XG4gICAgfVxuICAgIGlmICgnd2hlZWxEZWx0YScgaW4gZSkge1xuICAgICAgc1kgPSAtZS53aGVlbERlbHRhIC8gMTIwO1xuICAgIH1cbiAgICBpZiAoJ3doZWVsRGVsdGFZJyBpbiBlKSB7XG4gICAgICBzWSA9IC1lLndoZWVsRGVsdGFZIC8gMTIwO1xuICAgIH1cbiAgICBpZiAoJ3doZWVsRGVsdGFYJyBpbiBlKSB7XG4gICAgICBzWCA9IC1lLndoZWVsRGVsdGFYIC8gMTIwO1xuICAgIH1cblxuICAgIC8vIHNpZGUgc2Nyb2xsaW5nIG9uIEZGIHdpdGggRE9NTW91c2VTY3JvbGxcbiAgICBpZiAoJ2F4aXMnIGluIGUgJiYgZS5heGlzID09PSBlLkhPUklaT05UQUxfQVhJUykge1xuICAgICAgc1ggPSBzWTtcbiAgICAgIHNZID0gMDtcbiAgICB9XG5cbiAgICBwWCA9IHNYICogUElYRUxfU1RFUDtcbiAgICBwWSA9IHNZICogUElYRUxfU1RFUDtcblxuICAgIGlmICgnZGVsdGFZJyBpbiBlKSB7XG4gICAgICBwWSA9IGUuZGVsdGFZO1xuICAgIH1cbiAgICBpZiAoJ2RlbHRhWCcgaW4gZSkge1xuICAgICAgcFggPSBlLmRlbHRhWDtcbiAgICB9XG5cbiAgICBpZiAoKHBYIHx8IHBZKSAmJiBlLmRlbHRhTW9kZSkge1xuICAgICAgaWYgKGUuZGVsdGFNb2RlID09PSAxKSB7IC8vIGRlbHRhIGluIExJTkUgdW5pdHNcbiAgICAgICAgcFggKj0gTElORV9IRUlHSFQ7XG4gICAgICAgIHBZICo9IExJTkVfSEVJR0hUO1xuICAgICAgfSBlbHNlIHsgLy8gZGVsdGEgaW4gUEFHRSB1bml0c1xuICAgICAgICBwWCAqPSBQQUdFX0hFSUdIVDtcbiAgICAgICAgcFkgKj0gUEFHRV9IRUlHSFQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbC1iYWNrIGlmIHNwaW4gY2Fubm90IGJlIGRldGVybWluZWRcbiAgICBpZiAocFggJiYgIXNYKSB7XG4gICAgICBzWCA9IChwWCA8IDEpID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAocFkgJiYgIXNZKSB7XG4gICAgICBzWSA9IChwWSA8IDEpID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzcGluWDogc1gsXG4gICAgICBzcGluWTogc1ksXG4gICAgICBwaXhlbFg6IHBYLFxuICAgICAgcGl4ZWxZOiBwWSxcbiAgICB9O1xuICB9LFxuICBoYW5kbGVNb3VzZUVudGVyKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IHRydWU7XG4gIH0sXG4gIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBzd2lwZXIubW91c2VFbnRlcmVkID0gZmFsc2U7XG4gIH0sXG4gIGhhbmRsZShldmVudCkge1xuICAgIGxldCBlID0gZXZlbnQ7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWw7XG5cbiAgICBpZiAoIXN3aXBlci5tb3VzZUVudGVyZWQgJiYgIXBhcmFtcy5yZWxlYXNlT25FZGdlcykgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBjb25zdCBydGxGYWN0b3IgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xuXG4gICAgY29uc3QgZGF0YSA9IE1vdXNld2hlZWwubm9ybWFsaXplKGUpO1xuXG4gICAgaWYgKHBhcmFtcy5mb3JjZVRvQXhpcykge1xuICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGF0YS5waXhlbFgpID4gTWF0aC5hYnMoZGF0YS5waXhlbFkpKSBkZWx0YSA9IGRhdGEucGl4ZWxYICogcnRsRmFjdG9yO1xuICAgICAgICBlbHNlIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkYXRhLnBpeGVsWSkgPiBNYXRoLmFicyhkYXRhLnBpeGVsWCkpIGRlbHRhID0gZGF0YS5waXhlbFk7XG4gICAgICBlbHNlIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YSA9IE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSA/IC1kYXRhLnBpeGVsWCAqIHJ0bEZhY3RvciA6IC1kYXRhLnBpeGVsWTtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgPT09IDApIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKHBhcmFtcy5pbnZlcnQpIGRlbHRhID0gLWRlbHRhO1xuXG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmZyZWVNb2RlKSB7XG4gICAgICBpZiAoVXRpbHMubm93KCkgLSBzd2lwZXIubW91c2V3aGVlbC5sYXN0U2Nyb2xsVGltZSA+IDYwKSB7XG4gICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICBpZiAoKCFzd2lwZXIuaXNFbmQgfHwgc3dpcGVyLnBhcmFtcy5sb29wKSAmJiAhc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgICAgICAgc3dpcGVyLmVtaXQoJ3Njcm9sbCcsIGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgoIXN3aXBlci5pc0JlZ2lubmluZyB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdzY3JvbGwnLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMucmVsZWFzZU9uRWRnZXMpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpcGVyLm1vdXNld2hlZWwubGFzdFNjcm9sbFRpbWUgPSAobmV3IHdpbmRvdy5EYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnJlZW1vZGUgb3Igc2Nyb2xsQ29udGFpbmVyOlxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgfVxuICAgICAgbGV0IHBvc2l0aW9uID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpICsgKGRlbHRhICogcGFyYW1zLnNlbnNpdGl2aXR5KTtcbiAgICAgIGNvbnN0IHdhc0JlZ2lubmluZyA9IHN3aXBlci5pc0JlZ2lubmluZztcbiAgICAgIGNvbnN0IHdhc0VuZCA9IHN3aXBlci5pc0VuZDtcblxuICAgICAgaWYgKHBvc2l0aW9uID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gICAgICBpZiAocG9zaXRpb24gPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSBwb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcblxuICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgICBpZiAoKCF3YXNCZWdpbm5pbmcgJiYgc3dpcGVyLmlzQmVnaW5uaW5nKSB8fCAoIXdhc0VuZCAmJiBzd2lwZXIuaXNFbmQpKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzd2lwZXIubW91c2V3aGVlbC50aW1lb3V0KTtcbiAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwudGltZW91dCA9IFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgZXZlbnRcbiAgICAgIHN3aXBlci5lbWl0KCdzY3JvbGwnLCBlKTtcblxuICAgICAgLy8gU3RvcCBhdXRvcGxheVxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkgJiYgc3dpcGVyLnBhcmFtcy5hdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uKSBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgLy8gUmV0dXJuIHBhZ2Ugc2Nyb2xsIG9uIGVkZ2UgcG9zaXRpb25zXG4gICAgICBpZiAocG9zaXRpb24gPT09IHN3aXBlci5taW5UcmFuc2xhdGUoKSB8fCBwb3NpdGlvbiA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZW5hYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFNb3VzZXdoZWVsLmV2ZW50KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdGFyZ2V0ID0gc3dpcGVyLiRlbDtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdlZCAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgIHRhcmdldCA9ICQoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdlZCk7XG4gICAgfVxuICAgIHRhcmdldC5vbignbW91c2VlbnRlcicsIHN3aXBlci5tb3VzZXdoZWVsLmhhbmRsZU1vdXNlRW50ZXIpO1xuICAgIHRhcmdldC5vbignbW91c2VsZWF2ZScsIHN3aXBlci5tb3VzZXdoZWVsLmhhbmRsZU1vdXNlTGVhdmUpO1xuICAgIHRhcmdldC5vbihNb3VzZXdoZWVsLmV2ZW50LCBzd2lwZXIubW91c2V3aGVlbC5oYW5kbGUpO1xuICAgIHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFNb3VzZXdoZWVsLmV2ZW50KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRhcmdldCA9IHN3aXBlci4kZWw7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZWQgIT09ICdjb250YWluZXInKSB7XG4gICAgICB0YXJnZXQgPSAkKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZWQpO1xuICAgIH1cbiAgICB0YXJnZXQub2ZmKE1vdXNld2hlZWwuZXZlbnQsIHN3aXBlci5tb3VzZXdoZWVsLmhhbmRsZSk7XG4gICAgc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxufTtcblxudmFyIE1vdXNld2hlZWwkMSA9IHtcbiAgbmFtZTogJ21vdXNld2hlZWwnLFxuICBwYXJhbXM6IHtcbiAgICBtb3VzZXdoZWVsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgIGludmVydDogZmFsc2UsXG4gICAgICBmb3JjZVRvQXhpczogZmFsc2UsXG4gICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgIGV2ZW50c1RhcmdlZDogJ2NvbnRhaW5lcicsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgbW91c2V3aGVlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlOiBNb3VzZXdoZWVsLmVuYWJsZS5iaW5kKHN3aXBlciksXG4gICAgICAgIGRpc2FibGU6IE1vdXNld2hlZWwuZGlzYWJsZS5iaW5kKHN3aXBlciksXG4gICAgICAgIGhhbmRsZTogTW91c2V3aGVlbC5oYW5kbGUuYmluZChzd2lwZXIpLFxuICAgICAgICBoYW5kbGVNb3VzZUVudGVyOiBNb3VzZXdoZWVsLmhhbmRsZU1vdXNlRW50ZXIuYmluZChzd2lwZXIpLFxuICAgICAgICBoYW5kbGVNb3VzZUxlYXZlOiBNb3VzZXdoZWVsLmhhbmRsZU1vdXNlTGVhdmUuYmluZChzd2lwZXIpLFxuICAgICAgICBsYXN0U2Nyb2xsVGltZTogVXRpbHMubm93KCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkKSBzd2lwZXIubW91c2V3aGVlbC5lbmFibGUoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHN3aXBlci5tb3VzZXdoZWVsLmRpc2FibGUoKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTmF2aWdhdGlvbiA9IHtcbiAgdXBkYXRlKCkge1xuICAgIC8vIFVwZGF0ZSBOYXZpZ2F0aW9uIEJ1dHRvbnNcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbjtcblxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgICBjb25zdCB7ICRuZXh0RWwsICRwcmV2RWwgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuXG4gICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgICRwcmV2RWwuYWRkQ2xhc3MocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHByZXZFbC5yZW1vdmVDbGFzcyhwYXJhbXMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICB9XG4gICAgICAkcHJldkVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgfVxuICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgICAkbmV4dEVsLmFkZENsYXNzKHBhcmFtcy5kaXNhYmxlZENsYXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRuZXh0RWwucmVtb3ZlQ2xhc3MocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgfVxuICAgICAgJG5leHRFbFtzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKHBhcmFtcy5sb2NrQ2xhc3MpO1xuICAgIH1cbiAgfSxcbiAgb25QcmV2Q2xpY2soZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICAgIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgfSxcbiAgb25OZXh0Q2xpY2soZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICAgIHN3aXBlci5zbGlkZU5leHQoKTtcbiAgfSxcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbjtcbiAgICBpZiAoIShwYXJhbXMubmV4dEVsIHx8IHBhcmFtcy5wcmV2RWwpKSByZXR1cm47XG5cbiAgICBsZXQgJG5leHRFbDtcbiAgICBsZXQgJHByZXZFbDtcbiAgICBpZiAocGFyYW1zLm5leHRFbCkge1xuICAgICAgJG5leHRFbCA9ICQocGFyYW1zLm5leHRFbCk7XG4gICAgICBpZiAoXG4gICAgICAgIHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHNcbiAgICAgICAgJiYgdHlwZW9mIHBhcmFtcy5uZXh0RWwgPT09ICdzdHJpbmcnXG4gICAgICAgICYmICRuZXh0RWwubGVuZ3RoID4gMVxuICAgICAgICAmJiBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLm5leHRFbCkubGVuZ3RoID09PSAxXG4gICAgICApIHtcbiAgICAgICAgJG5leHRFbCA9IHN3aXBlci4kZWwuZmluZChwYXJhbXMubmV4dEVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtcy5wcmV2RWwpIHtcbiAgICAgICRwcmV2RWwgPSAkKHBhcmFtcy5wcmV2RWwpO1xuICAgICAgaWYgKFxuICAgICAgICBzd2lwZXIucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzXG4gICAgICAgICYmIHR5cGVvZiBwYXJhbXMucHJldkVsID09PSAnc3RyaW5nJ1xuICAgICAgICAmJiAkcHJldkVsLmxlbmd0aCA+IDFcbiAgICAgICAgJiYgc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5wcmV2RWwpLmxlbmd0aCA9PT0gMVxuICAgICAgKSB7XG4gICAgICAgICRwcmV2RWwgPSBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLnByZXZFbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGggPiAwKSB7XG4gICAgICAkbmV4dEVsLm9uKCdjbGljaycsIHN3aXBlci5uYXZpZ2F0aW9uLm9uTmV4dENsaWNrKTtcbiAgICB9XG4gICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XG4gICAgICAkcHJldkVsLm9uKCdjbGljaycsIHN3aXBlci5uYXZpZ2F0aW9uLm9uUHJldkNsaWNrKTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLm5hdmlnYXRpb24sIHtcbiAgICAgICRuZXh0RWwsXG4gICAgICBuZXh0RWw6ICRuZXh0RWwgJiYgJG5leHRFbFswXSxcbiAgICAgICRwcmV2RWwsXG4gICAgICBwcmV2RWw6ICRwcmV2RWwgJiYgJHByZXZFbFswXSxcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgJG5leHRFbCwgJHByZXZFbCB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG4gICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGgpIHtcbiAgICAgICRuZXh0RWwub2ZmKCdjbGljaycsIHN3aXBlci5uYXZpZ2F0aW9uLm9uTmV4dENsaWNrKTtcbiAgICAgICRuZXh0RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoJHByZXZFbCAmJiAkcHJldkVsLmxlbmd0aCkge1xuICAgICAgJHByZXZFbC5vZmYoJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25QcmV2Q2xpY2spO1xuICAgICAgJHByZXZFbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uZGlzYWJsZWRDbGFzcyk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIE5hdmlnYXRpb24kMSA9IHtcbiAgbmFtZTogJ25hdmlnYXRpb24nLFxuICBwYXJhbXM6IHtcbiAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICBuZXh0RWw6IG51bGwsXG4gICAgICBwcmV2RWw6IG51bGwsXG5cbiAgICAgIGhpZGVPbkNsaWNrOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkQ2xhc3M6ICdzd2lwZXItYnV0dG9uLWRpc2FibGVkJyxcbiAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLWJ1dHRvbi1oaWRkZW4nLFxuICAgICAgbG9ja0NsYXNzOiAnc3dpcGVyLWJ1dHRvbi1sb2NrJyxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICAgIGluaXQ6IE5hdmlnYXRpb24uaW5pdC5iaW5kKHN3aXBlciksXG4gICAgICAgIHVwZGF0ZTogTmF2aWdhdGlvbi51cGRhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBkZXN0cm95OiBOYXZpZ2F0aW9uLmRlc3Ryb3kuYmluZChzd2lwZXIpLFxuICAgICAgICBvbk5leHRDbGljazogTmF2aWdhdGlvbi5vbk5leHRDbGljay5iaW5kKHN3aXBlciksXG4gICAgICAgIG9uUHJldkNsaWNrOiBOYXZpZ2F0aW9uLm9uUHJldkNsaWNrLmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi5pbml0KCk7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcbiAgICB9LFxuICAgIHRvRWRnZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcbiAgICB9LFxuICAgIGZyb21FZGdlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi5kZXN0cm95KCk7XG4gICAgfSxcbiAgICBjbGljayhlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgeyAkbmV4dEVsLCAkcHJldkVsIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcbiAgICAgIGlmIChcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrXG4gICAgICAgICYmICEkKGUudGFyZ2V0KS5pcygkcHJldkVsKVxuICAgICAgICAmJiAhJChlLnRhcmdldCkuaXMoJG5leHRFbClcbiAgICAgICkge1xuICAgICAgICBsZXQgaXNIaWRkZW47XG4gICAgICAgIGlmICgkbmV4dEVsKSB7XG4gICAgICAgICAgaXNIaWRkZW4gPSAkbmV4dEVsLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoJHByZXZFbCkge1xuICAgICAgICAgIGlzSGlkZGVuID0gJHByZXZFbC5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0hpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHN3aXBlci5lbWl0KCduYXZpZ2F0aW9uU2hvdycsIHN3aXBlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ25hdmlnYXRpb25IaWRlJywgc3dpcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJG5leHRFbCkge1xuICAgICAgICAgICRuZXh0RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHByZXZFbCkge1xuICAgICAgICAgICRwcmV2RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBQYWdpbmF0aW9uID0ge1xuICB1cGRhdGUoKSB7XG4gICAgLy8gUmVuZGVyIHx8IFVwZGF0ZSBQYWdpbmF0aW9uIGJ1bGxldHMvaXRlbXNcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHJ0bCA9IHN3aXBlci5ydGw7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgIGlmICghcGFyYW1zLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uJGVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XG4gICAgLy8gQ3VycmVudC9Ub3RhbFxuICAgIGxldCBjdXJyZW50O1xuICAgIGNvbnN0IHRvdGFsID0gc3dpcGVyLnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSAoc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICBjdXJyZW50ID0gTWF0aC5jZWlsKChzd2lwZXIuYWN0aXZlSW5kZXggLSBzd2lwZXIubG9vcGVkU2xpZGVzKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgaWYgKGN1cnJlbnQgPiBzbGlkZXNMZW5ndGggLSAxIC0gKHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSkge1xuICAgICAgICBjdXJyZW50IC09IChzbGlkZXNMZW5ndGggLSAoc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID4gdG90YWwgLSAxKSBjdXJyZW50IC09IHRvdGFsO1xuICAgICAgaWYgKGN1cnJlbnQgPCAwICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvblR5cGUgIT09ICdidWxsZXRzJykgY3VycmVudCA9IHRvdGFsICsgY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY3VycmVudCA9IHN3aXBlci5zbmFwSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcbiAgICB9XG4gICAgLy8gVHlwZXNcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVsbGV0cyA9IHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHM7XG4gICAgICBsZXQgZmlyc3RJbmRleDtcbiAgICAgIGxldCBsYXN0SW5kZXg7XG4gICAgICBsZXQgbWlkSW5kZXg7XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUgPSBidWxsZXRzLmVxKDApW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdvdXRlcldpZHRoJyA6ICdvdXRlckhlaWdodCddKHRydWUpO1xuICAgICAgICAkZWwuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0JywgYCR7c3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSAqIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzICsgNCl9cHhgKTtcbiAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPiAxICYmIHN3aXBlci5wcmV2aW91c0luZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggKz0gKGN1cnJlbnQgLSBzd2lwZXIucHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA+IChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMSkpIHtcbiAgICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4IDwgMCkge1xuICAgICAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RJbmRleCA9IGN1cnJlbnQgLSBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXg7XG4gICAgICAgIGxhc3RJbmRleCA9IGZpcnN0SW5kZXggKyAoTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMpIC0gMSk7XG4gICAgICAgIG1pZEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpIC8gMjtcbiAgICAgIH1cbiAgICAgIGJ1bGxldHMucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfSAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dCAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dC1uZXh0ICR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2ICR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2LXByZXYgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgICBidWxsZXRzLmVhY2goKGluZGV4LCBidWxsZXQpID0+IHtcbiAgICAgICAgICBjb25zdCAkYnVsbGV0ID0gJChidWxsZXQpO1xuICAgICAgICAgIGNvbnN0IGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xuICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPj0gZmlyc3RJbmRleCAmJiBidWxsZXRJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gZmlyc3RJbmRleCkge1xuICAgICAgICAgICAgICAkYnVsbGV0XG4gICAgICAgICAgICAgICAgLnByZXYoKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKVxuICAgICAgICAgICAgICAgIC5wcmV2KClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2LXByZXZgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICRidWxsZXRcbiAgICAgICAgICAgICAgICAubmV4dCgpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dGApXG4gICAgICAgICAgICAgICAgLm5leHQoKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQtbmV4dGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCAkYnVsbGV0ID0gYnVsbGV0cy5lcShjdXJyZW50KTtcbiAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgY29uc3QgJGZpcnN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShmaXJzdEluZGV4KTtcbiAgICAgICAgICBjb25zdCAkbGFzdERpc3BsYXllZEJ1bGxldCA9IGJ1bGxldHMuZXEobGFzdEluZGV4KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gZmlyc3RJbmRleDsgaSA8PSBsYXN0SW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnVsbGV0cy5lcShpKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGZpcnN0RGlzcGxheWVkQnVsbGV0XG4gICAgICAgICAgICAucHJldigpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2YClcbiAgICAgICAgICAgIC5wcmV2KClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXYtcHJldmApO1xuICAgICAgICAgICRsYXN0RGlzcGxheWVkQnVsbGV0XG4gICAgICAgICAgICAubmV4dCgpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1uZXh0YClcbiAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQtbmV4dGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNCdWxsZXRzTGVuZ3RoID0gTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KTtcbiAgICAgICAgY29uc3QgYnVsbGV0c09mZnNldCA9ICgoKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUgKiBkeW5hbWljQnVsbGV0c0xlbmd0aCkgLSAoc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSkpIC8gMikgLSAobWlkSW5kZXggKiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRTaXplKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0UHJvcCA9IHJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIGJ1bGxldHMuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/IG9mZnNldFByb3AgOiAndG9wJywgYCR7YnVsbGV0c09mZnNldH1weGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICRlbC5maW5kKGAuJHtwYXJhbXMuY3VycmVudENsYXNzfWApLnRleHQocGFyYW1zLmZvcm1hdEZyYWN0aW9uQ3VycmVudChjdXJyZW50ICsgMSkpO1xuICAgICAgJGVsLmZpbmQoYC4ke3BhcmFtcy50b3RhbENsYXNzfWApLnRleHQocGFyYW1zLmZvcm1hdEZyYWN0aW9uVG90YWwodG90YWwpKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XG4gICAgICBsZXQgcHJvZ3Jlc3NiYXJEaXJlY3Rpb247XG4gICAgICBpZiAocGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcbiAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NhbGUgPSAoY3VycmVudCArIDEpIC8gdG90YWw7XG4gICAgICBsZXQgc2NhbGVYID0gMTtcbiAgICAgIGxldCBzY2FsZVkgPSAxO1xuICAgICAgaWYgKHByb2dyZXNzYmFyRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgc2NhbGVYID0gc2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZVkgPSBzY2FsZTtcbiAgICAgIH1cbiAgICAgICRlbC5maW5kKGAuJHtwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3N9YCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGVYKCR7c2NhbGVYfSkgc2NhbGVZKCR7c2NhbGVZfSlgKS50cmFuc2l0aW9uKHN3aXBlci5wYXJhbXMuc3BlZWQpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdjdXN0b20nICYmIHBhcmFtcy5yZW5kZXJDdXN0b20pIHtcbiAgICAgICRlbC5odG1sKHBhcmFtcy5yZW5kZXJDdXN0b20oc3dpcGVyLCBjdXJyZW50ICsgMSwgdG90YWwpKTtcbiAgICAgIHN3aXBlci5lbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgc3dpcGVyLCAkZWxbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblVwZGF0ZScsIHN3aXBlciwgJGVsWzBdKTtcbiAgICB9XG4gICAgJGVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICAvLyBSZW5kZXIgQ29udGFpbmVyXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgaWYgKCFwYXJhbXMuZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi4kZWwgfHwgc3dpcGVyLnBhZ2luYXRpb24uJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IHNsaWRlc0xlbmd0aCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuXG4gICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xuICAgIGxldCBwYWdpbmF0aW9uSFRNTCA9ICcnO1xuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnKSB7XG4gICAgICBjb25zdCBudW1iZXJPZkJ1bGxldHMgPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoKHNsaWRlc0xlbmd0aCAtIChzd2lwZXIubG9vcGVkU2xpZGVzICogMikpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkJ1bGxldHM7IGkgKz0gMSkge1xuICAgICAgICBpZiAocGFyYW1zLnJlbmRlckJ1bGxldCkge1xuICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IHBhcmFtcy5yZW5kZXJCdWxsZXQuY2FsbChzd2lwZXIsIGksIHBhcmFtcy5idWxsZXRDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFnaW5hdGlvbkhUTUwgKz0gYDwke3BhcmFtcy5idWxsZXRFbGVtZW50fSBjbGFzcz1cIiR7cGFyYW1zLmJ1bGxldENsYXNzfVwiPjwvJHtwYXJhbXMuYnVsbGV0RWxlbWVudH0+YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJGVsLmh0bWwocGFnaW5hdGlvbkhUTUwpO1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyA9ICRlbC5maW5kKGAuJHtwYXJhbXMuYnVsbGV0Q2xhc3N9YCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgaWYgKHBhcmFtcy5yZW5kZXJGcmFjdGlvbikge1xuICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IHBhcmFtcy5yZW5kZXJGcmFjdGlvbi5jYWxsKHN3aXBlciwgcGFyYW1zLmN1cnJlbnRDbGFzcywgcGFyYW1zLnRvdGFsQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBgPHNwYW4gY2xhc3M9XCIke3BhcmFtcy5jdXJyZW50Q2xhc3N9XCI+PC9zcGFuPmBcbiAgICAgICAgKyAnIC8gJ1xuICAgICAgICArIGA8c3BhbiBjbGFzcz1cIiR7cGFyYW1zLnRvdGFsQ2xhc3N9XCI+PC9zcGFuPmA7XG4gICAgICB9XG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ3Byb2dyZXNzYmFyJykge1xuICAgICAgaWYgKHBhcmFtcy5yZW5kZXJQcm9ncmVzc2Jhcikge1xuICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IHBhcmFtcy5yZW5kZXJQcm9ncmVzc2Jhci5jYWxsKHN3aXBlciwgcGFyYW1zLnByb2dyZXNzYmFyRmlsbENsYXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gYDxzcGFuIGNsYXNzPVwiJHtwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3N9XCI+PC9zcGFuPmA7XG4gICAgICB9XG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ2N1c3RvbScpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgc3dpcGVyLnBhZ2luYXRpb24uJGVsWzBdKTtcbiAgICB9XG4gIH0sXG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgaWYgKCFwYXJhbXMuZWwpIHJldHVybjtcblxuICAgIGxldCAkZWwgPSAkKHBhcmFtcy5lbCk7XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGlmIChcbiAgICAgIHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHNcbiAgICAgICYmIHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnXG4gICAgICAmJiAkZWwubGVuZ3RoID4gMVxuICAgICAgJiYgc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5lbCkubGVuZ3RoID09PSAxXG4gICAgKSB7XG4gICAgICAkZWwgPSBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLmVsKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLmNsaWNrYWJsZUNsYXNzKTtcbiAgICB9XG5cbiAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XG5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMubW9kaWZpZXJDbGFzc30ke3BhcmFtcy50eXBlfS1keW5hbWljYCk7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggPSAwO1xuICAgICAgaWYgKHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPCAxKSB7XG4gICAgICAgIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicgJiYgcGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcbiAgICAgICRlbC5hZGRDbGFzcyhwYXJhbXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZUNsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmNsaWNrYWJsZSkge1xuICAgICAgJGVsLm9uKCdjbGljaycsIGAuJHtwYXJhbXMuYnVsbGV0Q2xhc3N9YCwgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gJCh0aGlzKS5pbmRleCgpICogc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgaW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYWdpbmF0aW9uLCB7XG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgIGlmICghcGFyYW1zLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uJGVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XG5cbiAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLmhpZGRlbkNsYXNzKTtcbiAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XG4gICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMpIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMucmVtb3ZlQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKTtcbiAgICBpZiAocGFyYW1zLmNsaWNrYWJsZSkge1xuICAgICAgJGVsLm9mZignY2xpY2snLCBgLiR7cGFyYW1zLmJ1bGxldENsYXNzfWApO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBQYWdpbmF0aW9uJDEgPSB7XG4gIG5hbWU6ICdwYWdpbmF0aW9uJyxcbiAgcGFyYW1zOiB7XG4gICAgcGFnaW5hdGlvbjoge1xuICAgICAgZWw6IG51bGwsXG4gICAgICBidWxsZXRFbGVtZW50OiAnc3BhbicsXG4gICAgICBjbGlja2FibGU6IGZhbHNlLFxuICAgICAgaGlkZU9uQ2xpY2s6IGZhbHNlLFxuICAgICAgcmVuZGVyQnVsbGV0OiBudWxsLFxuICAgICAgcmVuZGVyUHJvZ3Jlc3NiYXI6IG51bGwsXG4gICAgICByZW5kZXJGcmFjdGlvbjogbnVsbCxcbiAgICAgIHJlbmRlckN1c3RvbTogbnVsbCxcbiAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGU6IGZhbHNlLFxuICAgICAgdHlwZTogJ2J1bGxldHMnLCAvLyAnYnVsbGV0cycgb3IgJ3Byb2dyZXNzYmFyJyBvciAnZnJhY3Rpb24nIG9yICdjdXN0b20nXG4gICAgICBkeW5hbWljQnVsbGV0czogZmFsc2UsXG4gICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXG4gICAgICBmb3JtYXRGcmFjdGlvbkN1cnJlbnQ6IG51bWJlciA9PiBudW1iZXIsXG4gICAgICBmb3JtYXRGcmFjdGlvblRvdGFsOiBudW1iZXIgPT4gbnVtYmVyLFxuICAgICAgYnVsbGV0Q2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1idWxsZXQnLFxuICAgICAgYnVsbGV0QWN0aXZlQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlJyxcbiAgICAgIG1vZGlmaWVyQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi0nLCAvLyBORVdcbiAgICAgIGN1cnJlbnRDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWN1cnJlbnQnLFxuICAgICAgdG90YWxDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLXRvdGFsJyxcbiAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24taGlkZGVuJyxcbiAgICAgIHByb2dyZXNzYmFyRmlsbENsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItZmlsbCcsXG4gICAgICBwcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci1vcHBvc2l0ZScsXG4gICAgICBjbGlja2FibGVDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWNsaWNrYWJsZScsIC8vIE5FV1xuICAgICAgbG9ja0NsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tbG9jaycsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICBpbml0OiBQYWdpbmF0aW9uLmluaXQuYmluZChzd2lwZXIpLFxuICAgICAgICByZW5kZXI6IFBhZ2luYXRpb24ucmVuZGVyLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgdXBkYXRlOiBQYWdpbmF0aW9uLnVwZGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIGRlc3Ryb3k6IFBhZ2luYXRpb24uZGVzdHJveS5iaW5kKHN3aXBlciksXG4gICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleDogMCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5pbml0KCk7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5yZW5kZXIoKTtcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgYWN0aXZlSW5kZXhDaGFuZ2UoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN3aXBlci5zbmFwSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc25hcEluZGV4Q2hhbmdlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2xpZGVzTGVuZ3RoQ2hhbmdlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24ucmVuZGVyKCk7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc25hcEdyaWRMZW5ndGhDaGFuZ2UoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24ucmVuZGVyKCk7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5kZXN0cm95KCk7XG4gICAgfSxcbiAgICBjbGljayhlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKFxuICAgICAgICBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uZWxcbiAgICAgICAgJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGVPbkNsaWNrXG4gICAgICAgICYmIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPiAwXG4gICAgICAgICYmICEkKGUudGFyZ2V0KS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaXNIaWRkZW4gPSBzd2lwZXIucGFnaW5hdGlvbi4kZWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgaWYgKGlzSGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3BhZ2luYXRpb25TaG93Jywgc3dpcGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvbkhpZGUnLCBzd2lwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBTY3JvbGxiYXIgPSB7XG4gIHNldFRyYW5zbGF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICBjb25zdCB7IHNjcm9sbGJhciwgcnRsVHJhbnNsYXRlOiBydGwsIHByb2dyZXNzIH0gPSBzd2lwZXI7XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ1NpemUsIHRyYWNrU2l6ZSwgJGRyYWdFbCwgJGVsLFxuICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG5cbiAgICBsZXQgbmV3U2l6ZSA9IGRyYWdTaXplO1xuICAgIGxldCBuZXdQb3MgPSAodHJhY2tTaXplIC0gZHJhZ1NpemUpICogcHJvZ3Jlc3M7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgbmV3UG9zID0gLW5ld1BvcztcbiAgICAgIGlmIChuZXdQb3MgPiAwKSB7XG4gICAgICAgIG5ld1NpemUgPSBkcmFnU2l6ZSAtIG5ld1BvcztcbiAgICAgICAgbmV3UG9zID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoLW5ld1BvcyArIGRyYWdTaXplID4gdHJhY2tTaXplKSB7XG4gICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgKyBuZXdQb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXdQb3MgPCAwKSB7XG4gICAgICBuZXdTaXplID0gZHJhZ1NpemUgKyBuZXdQb3M7XG4gICAgICBuZXdQb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAobmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcbiAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgLSBuZXdQb3M7XG4gICAgfVxuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGlmIChTdXBwb3J0LnRyYW5zZm9ybXMzZCkge1xuICAgICAgICAkZHJhZ0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtuZXdQb3N9cHgsIDAsIDApYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZHJhZ0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlWCgke25ld1Bvc31weClgKTtcbiAgICAgIH1cbiAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtuZXdTaXplfXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFN1cHBvcnQudHJhbnNmb3JtczNkKSB7XG4gICAgICAgICRkcmFnRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsICR7bmV3UG9zfXB4LCAwKWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGRyYWdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZVkoJHtuZXdQb3N9cHgpYCk7XG4gICAgICB9XG4gICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemV9cHhgO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmhpZGUpIHtcbiAgICAgIGNsZWFyVGltZW91dChzd2lwZXIuc2Nyb2xsYmFyLnRpbWVvdXQpO1xuICAgICAgJGVsWzBdLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgJGVsLnRyYW5zaXRpb24oNDAwKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfSxcbiAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIHN3aXBlci5zY3JvbGxiYXIuJGRyYWdFbC50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgfSxcbiAgdXBkYXRlU2l6ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcblxuICAgIGNvbnN0IHsgc2Nyb2xsYmFyIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgeyAkZHJhZ0VsLCAkZWwgfSA9IHNjcm9sbGJhcjtcblxuICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSAnJztcbiAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgIGNvbnN0IHRyYWNrU2l6ZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICRlbFswXS5vZmZzZXRXaWR0aCA6ICRlbFswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjb25zdCBkaXZpZGVyID0gc3dpcGVyLnNpemUgLyBzd2lwZXIudmlydHVhbFNpemU7XG4gICAgY29uc3QgbW92ZURpdmlkZXIgPSBkaXZpZGVyICogKHRyYWNrU2l6ZSAvIHN3aXBlci5zaXplKTtcbiAgICBsZXQgZHJhZ1NpemU7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplID09PSAnYXV0bycpIHtcbiAgICAgIGRyYWdTaXplID0gdHJhY2tTaXplICogZGl2aWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhZ1NpemUgPSBwYXJzZUludChzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZSwgMTApO1xuICAgIH1cblxuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtkcmFnU2l6ZX1weGA7XG4gICAgfSBlbHNlIHtcbiAgICAgICRkcmFnRWxbMF0uc3R5bGUuaGVpZ2h0ID0gYCR7ZHJhZ1NpemV9cHhgO1xuICAgIH1cblxuICAgIGlmIChkaXZpZGVyID49IDEpIHtcbiAgICAgICRlbFswXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWxbMF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuaGlkZSkge1xuICAgICAgJGVsWzBdLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgICBVdGlscy5leHRlbmQoc2Nyb2xsYmFyLCB7XG4gICAgICB0cmFja1NpemUsXG4gICAgICBkaXZpZGVyLFxuICAgICAgbW92ZURpdmlkZXIsXG4gICAgICBkcmFnU2l6ZSxcbiAgICB9KTtcbiAgICBzY3JvbGxiYXIuJGVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgfSxcbiAgc2V0RHJhZ1Bvc2l0aW9uKGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgc2Nyb2xsYmFyLCBydGxUcmFuc2xhdGU6IHJ0bCB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHsgJGVsLCBkcmFnU2l6ZSwgdHJhY2tTaXplIH0gPSBzY3JvbGxiYXI7XG5cbiAgICBsZXQgcG9pbnRlclBvc2l0aW9uO1xuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHBvaW50ZXJQb3NpdGlvbiA9ICgoZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYIHx8IGUuY2xpZW50WCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJQb3NpdGlvbiA9ICgoZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZIHx8IGUuY2xpZW50WSk7XG4gICAgfVxuICAgIGxldCBwb3NpdGlvblJhdGlvO1xuICAgIHBvc2l0aW9uUmF0aW8gPSAoKHBvaW50ZXJQb3NpdGlvbikgLSAkZWwub2Zmc2V0KClbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2xlZnQnIDogJ3RvcCddIC0gKGRyYWdTaXplIC8gMikpIC8gKHRyYWNrU2l6ZSAtIGRyYWdTaXplKTtcbiAgICBwb3NpdGlvblJhdGlvID0gTWF0aC5tYXgoTWF0aC5taW4ocG9zaXRpb25SYXRpbywgMSksIDApO1xuICAgIGlmIChydGwpIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAxIC0gcG9zaXRpb25SYXRpbztcbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSArICgoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAqIHBvc2l0aW9uUmF0aW8pO1xuXG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHBvc2l0aW9uKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICB9LFxuICBvbkRyYWdTdGFydChlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICBjb25zdCB7IHNjcm9sbGJhciwgJHdyYXBwZXJFbCB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHsgJGVsLCAkZHJhZ0VsIH0gPSBzY3JvbGxiYXI7XG4gICAgc3dpcGVyLnNjcm9sbGJhci5pc1RvdWNoZWQgPSB0cnVlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKDEwMCk7XG4gICAgJGRyYWdFbC50cmFuc2l0aW9uKDEwMCk7XG4gICAgc2Nyb2xsYmFyLnNldERyYWdQb3NpdGlvbihlKTtcblxuICAgIGNsZWFyVGltZW91dChzd2lwZXIuc2Nyb2xsYmFyLmRyYWdUaW1lb3V0KTtcblxuICAgICRlbC50cmFuc2l0aW9uKDApO1xuICAgIGlmIChwYXJhbXMuaGlkZSkge1xuICAgICAgJGVsLmNzcygnb3BhY2l0eScsIDEpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnc2Nyb2xsYmFyRHJhZ1N0YXJ0JywgZSk7XG4gIH0sXG4gIG9uRHJhZ01vdmUoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyBzY3JvbGxiYXIsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcbiAgICBjb25zdCB7ICRlbCwgJGRyYWdFbCB9ID0gc2Nyb2xsYmFyO1xuXG4gICAgaWYgKCFzd2lwZXIuc2Nyb2xsYmFyLmlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgc2Nyb2xsYmFyLnNldERyYWdQb3NpdGlvbihlKTtcbiAgICAkd3JhcHBlckVsLnRyYW5zaXRpb24oMCk7XG4gICAgJGVsLnRyYW5zaXRpb24oMCk7XG4gICAgJGRyYWdFbC50cmFuc2l0aW9uKDApO1xuICAgIHN3aXBlci5lbWl0KCdzY3JvbGxiYXJEcmFnTW92ZScsIGUpO1xuICB9LFxuICBvbkRyYWdFbmQoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICBjb25zdCB7IHNjcm9sbGJhciB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHsgJGVsIH0gPSBzY3JvbGxiYXI7XG5cbiAgICBpZiAoIXN3aXBlci5zY3JvbGxiYXIuaXNUb3VjaGVkKSByZXR1cm47XG4gICAgc3dpcGVyLnNjcm9sbGJhci5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICBpZiAocGFyYW1zLmhpZGUpIHtcbiAgICAgIGNsZWFyVGltZW91dChzd2lwZXIuc2Nyb2xsYmFyLmRyYWdUaW1lb3V0KTtcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQgPSBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICRlbC5jc3MoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgJGVsLnRyYW5zaXRpb24oNDAwKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnc2Nyb2xsYmFyRHJhZ0VuZCcsIGUpO1xuICAgIGlmIChwYXJhbXMuc25hcE9uUmVsZWFzZSkge1xuICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgfVxuICB9LFxuICBlbmFibGVEcmFnZ2FibGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsYmFyLCB0b3VjaEV2ZW50c1RvdWNoLCB0b3VjaEV2ZW50c0Rlc2t0b3AsIHBhcmFtcyxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0ICRlbCA9IHNjcm9sbGJhci4kZWw7XG4gICAgY29uc3QgdGFyZ2V0ID0gJGVsWzBdO1xuICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7IHBhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XG4gICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgICBpZiAoIVN1cHBvcnQudG91Y2gpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c0Rlc2t0b3AubW92ZSwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5lbmQsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLnN0YXJ0LCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLm1vdmUsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnTW92ZSwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHNUb3VjaC5lbmQsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcbiAgZGlzYWJsZURyYWdnYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXIsIHRvdWNoRXZlbnRzVG91Y2gsIHRvdWNoRXZlbnRzRGVza3RvcCwgcGFyYW1zLFxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgJGVsID0gc2Nyb2xsYmFyLiRlbDtcbiAgICBjb25zdCB0YXJnZXQgPSAkZWxbMF07XG4gICAgY29uc3QgYWN0aXZlTGlzdGVuZXIgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgIGlmICghU3VwcG9ydC50b3VjaCkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHNEZXNrdG9wLnN0YXJ0LCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5tb3ZlLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHNEZXNrdG9wLmVuZCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzVG91Y2guc3RhcnQsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzVG91Y2gubW92ZSwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLmVuZCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuICBpbml0KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgc2Nyb2xsYmFyLCAkZWw6ICRzd2lwZXJFbCB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuXG4gICAgbGV0ICRlbCA9ICQocGFyYW1zLmVsKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJyAmJiAkZWwubGVuZ3RoID4gMSAmJiAkc3dpcGVyRWwuZmluZChwYXJhbXMuZWwpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgJGVsID0gJHN3aXBlckVsLmZpbmQocGFyYW1zLmVsKTtcbiAgICB9XG5cbiAgICBsZXQgJGRyYWdFbCA9ICRlbC5maW5kKGAuJHtzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9YCk7XG4gICAgaWYgKCRkcmFnRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAkZHJhZ0VsID0gJChgPGRpdiBjbGFzcz1cIiR7c3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzfVwiPjwvZGl2PmApO1xuICAgICAgJGVsLmFwcGVuZCgkZHJhZ0VsKTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQoc2Nyb2xsYmFyLCB7XG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgJGRyYWdFbCxcbiAgICAgIGRyYWdFbDogJGRyYWdFbFswXSxcbiAgICB9KTtcblxuICAgIGlmIChwYXJhbXMuZHJhZ2dhYmxlKSB7XG4gICAgICBzY3JvbGxiYXIuZW5hYmxlRHJhZ2dhYmxlKCk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgc3dpcGVyLnNjcm9sbGJhci5kaXNhYmxlRHJhZ2dhYmxlKCk7XG4gIH0sXG59O1xuXG52YXIgU2Nyb2xsYmFyJDEgPSB7XG4gIG5hbWU6ICdzY3JvbGxiYXInLFxuICBwYXJhbXM6IHtcbiAgICBzY3JvbGxiYXI6IHtcbiAgICAgIGVsOiBudWxsLFxuICAgICAgZHJhZ1NpemU6ICdhdXRvJyxcbiAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgIHNuYXBPblJlbGVhc2U6IHRydWUsXG4gICAgICBsb2NrQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWxvY2snLFxuICAgICAgZHJhZ0NsYXNzOiAnc3dpcGVyLXNjcm9sbGJhci1kcmFnJyxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBzY3JvbGxiYXI6IHtcbiAgICAgICAgaW5pdDogU2Nyb2xsYmFyLmluaXQuYmluZChzd2lwZXIpLFxuICAgICAgICBkZXN0cm95OiBTY3JvbGxiYXIuZGVzdHJveS5iaW5kKHN3aXBlciksXG4gICAgICAgIHVwZGF0ZVNpemU6IFNjcm9sbGJhci51cGRhdGVTaXplLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBTY3JvbGxiYXIuc2V0VHJhbnNsYXRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbjogU2Nyb2xsYmFyLnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxuICAgICAgICBlbmFibGVEcmFnZ2FibGU6IFNjcm9sbGJhci5lbmFibGVEcmFnZ2FibGUuYmluZChzd2lwZXIpLFxuICAgICAgICBkaXNhYmxlRHJhZ2dhYmxlOiBTY3JvbGxiYXIuZGlzYWJsZURyYWdnYWJsZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldERyYWdQb3NpdGlvbjogU2Nyb2xsYmFyLnNldERyYWdQb3NpdGlvbi5iaW5kKHN3aXBlciksXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiBTY3JvbGxiYXIub25EcmFnU3RhcnQuYmluZChzd2lwZXIpLFxuICAgICAgICBvbkRyYWdNb3ZlOiBTY3JvbGxiYXIub25EcmFnTW92ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIG9uRHJhZ0VuZDogU2Nyb2xsYmFyLm9uRHJhZ0VuZC5iaW5kKHN3aXBlciksXG4gICAgICAgIGlzVG91Y2hlZDogZmFsc2UsXG4gICAgICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgICAgIGRyYWdUaW1lb3V0OiBudWxsLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuaW5pdCgpO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIudXBkYXRlU2l6ZSgpO1xuICAgIH0sXG4gICAgcmVzaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIudXBkYXRlU2l6ZSgpO1xuICAgIH0sXG4gICAgb2JzZXJ2ZXJVcGRhdGUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2xhdGUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLmRlc3Ryb3koKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgUGFyYWxsYXggPSB7XG4gIHNldFRyYW5zZm9ybShlbCwgcHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgcnRsIH0gPSBzd2lwZXI7XG5cbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBjb25zdCBydGxGYWN0b3IgPSBydGwgPyAtMSA6IDE7XG5cbiAgICBjb25zdCBwID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4JykgfHwgJzAnO1xuICAgIGxldCB4ID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXgnKTtcbiAgICBsZXQgeSA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC15Jyk7XG4gICAgY29uc3Qgc2NhbGUgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGUnKTtcbiAgICBjb25zdCBvcGFjaXR5ID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHknKTtcblxuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHggPSB4IHx8ICcwJztcbiAgICAgIHkgPSB5IHx8ICcwJztcbiAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgeCA9IHA7XG4gICAgICB5ID0gJzAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gcDtcbiAgICAgIHggPSAnMCc7XG4gICAgfVxuXG4gICAgaWYgKCh4KS5pbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgeCA9IGAke3BhcnNlSW50KHgsIDEwKSAqIHByb2dyZXNzICogcnRsRmFjdG9yfSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gYCR7eCAqIHByb2dyZXNzICogcnRsRmFjdG9yfXB4YDtcbiAgICB9XG4gICAgaWYgKCh5KS5pbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgeSA9IGAke3BhcnNlSW50KHksIDEwKSAqIHByb2dyZXNzfSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gYCR7eSAqIHByb2dyZXNzfXB4YDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcGFjaXR5ID0gb3BhY2l0eSAtICgob3BhY2l0eSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpKTtcbiAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gY3VycmVudE9wYWNpdHk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2NhbGUgPT09ICd1bmRlZmluZWQnIHx8IHNjYWxlID09PSBudWxsKSB7XG4gICAgICAkZWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3h9LCAke3l9LCAwcHgpYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHNjYWxlIC0gKChzY2FsZSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpKTtcbiAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweCkgc2NhbGUoJHtjdXJyZW50U2NhbGV9KWApO1xuICAgIH1cbiAgfSxcbiAgc2V0VHJhbnNsYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgJGVsLCBzbGlkZXMsIHByb2dyZXNzLCBzbmFwR3JpZCxcbiAgICB9ID0gc3dpcGVyO1xuICAgICRlbC5jaGlsZHJlbignW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0nKVxuICAgICAgLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBzd2lwZXIucGFyYWxsYXguc2V0VHJhbnNmb3JtKGVsLCBwcm9ncmVzcyk7XG4gICAgICB9KTtcbiAgICBzbGlkZXMuZWFjaCgoc2xpZGVJbmRleCwgc2xpZGVFbCkgPT4ge1xuICAgICAgbGV0IHNsaWRlUHJvZ3Jlc3MgPSBzbGlkZUVsLnByb2dyZXNzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPiAxICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHNsaWRlUHJvZ3Jlc3MgKz0gTWF0aC5jZWlsKHNsaWRlSW5kZXggLyAyKSAtIChwcm9ncmVzcyAqIChzbmFwR3JpZC5sZW5ndGggLSAxKSk7XG4gICAgICB9XG4gICAgICBzbGlkZVByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGVQcm9ncmVzcywgLTEpLCAxKTtcbiAgICAgICQoc2xpZGVFbCkuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0nKVxuICAgICAgICAuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgICAgc3dpcGVyLnBhcmFsbGF4LnNldFRyYW5zZm9ybShlbCwgc2xpZGVQcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uID0gdGhpcy5wYXJhbXMuc3BlZWQpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgJGVsIH0gPSBzd2lwZXI7XG4gICAgJGVsLmZpbmQoJ1tkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldJylcbiAgICAgIC5lYWNoKChpbmRleCwgcGFyYWxsYXhFbCkgPT4ge1xuICAgICAgICBjb25zdCAkcGFyYWxsYXhFbCA9ICQocGFyYWxsYXhFbCk7XG4gICAgICAgIGxldCBwYXJhbGxheER1cmF0aW9uID0gcGFyc2VJbnQoJHBhcmFsbGF4RWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtZHVyYXRpb24nKSwgMTApIHx8IGR1cmF0aW9uO1xuICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApIHBhcmFsbGF4RHVyYXRpb24gPSAwO1xuICAgICAgICAkcGFyYWxsYXhFbC50cmFuc2l0aW9uKHBhcmFsbGF4RHVyYXRpb24pO1xuICAgICAgfSk7XG4gIH0sXG59O1xuXG52YXIgUGFyYWxsYXgkMSA9IHtcbiAgbmFtZTogJ3BhcmFsbGF4JyxcbiAgcGFyYW1zOiB7XG4gICAgcGFyYWxsYXg6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIHBhcmFsbGF4OiB7XG4gICAgICAgIHNldFRyYW5zZm9ybTogUGFyYWxsYXguc2V0VHJhbnNmb3JtLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBQYXJhbGxheC5zZXRUcmFuc2xhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBQYXJhbGxheC5zZXRUcmFuc2l0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgYmVmb3JlSW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICB9LFxuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLnBhcmFsbGF4LnNldFRyYW5zbGF0ZSgpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIucGFyYWxsYXguc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFpvb20gPSB7XG4gIC8vIENhbGMgU2NhbGUgRnJvbSBNdWx0aS10b3VjaGVzXG4gIGdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikgcmV0dXJuIDE7XG4gICAgY29uc3QgeDEgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgY29uc3QgeTEgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgY29uc3QgeDIgPSBlLnRhcmdldFRvdWNoZXNbMV0ucGFnZVg7XG4gICAgY29uc3QgeTIgPSBlLnRhcmdldFRvdWNoZXNbMV0ucGFnZVk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKCh4MiAtIHgxKSAqKiAyKSArICgoeTIgLSB5MSkgKiogMikpO1xuICAgIHJldHVybiBkaXN0YW5jZTtcbiAgfSxcbiAgLy8gRXZlbnRzXG4gIG9uR2VzdHVyZVN0YXJ0KGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgY29uc3QgeyBnZXN0dXJlIH0gPSB6b29tO1xuICAgIHpvb20uZmFrZUdlc3R1cmVUb3VjaGVkID0gZmFsc2U7XG4gICAgem9vbS5mYWtlR2VzdHVyZU1vdmVkID0gZmFsc2U7XG4gICAgaWYgKCFTdXBwb3J0Lmdlc3R1cmVzKSB7XG4gICAgICBpZiAoZS50eXBlICE9PSAndG91Y2hzdGFydCcgfHwgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB6b29tLmZha2VHZXN0dXJlVG91Y2hlZCA9IHRydWU7XG4gICAgICBnZXN0dXJlLnNjYWxlU3RhcnQgPSBab29tLmdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSk7XG4gICAgfVxuICAgIGlmICghZ2VzdHVyZS4kc2xpZGVFbCB8fCAhZ2VzdHVyZS4kc2xpZGVFbC5sZW5ndGgpIHtcbiAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuc3dpcGVyLXNsaWRlJyk7XG4gICAgICBpZiAoZ2VzdHVyZS4kc2xpZGVFbC5sZW5ndGggPT09IDApIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICBnZXN0dXJlLiRpbWFnZUVsID0gZ2VzdHVyZS4kc2xpZGVFbC5maW5kKCdpbWcsIHN2ZywgY2FudmFzJyk7XG4gICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbCA9IGdlc3R1cmUuJGltYWdlRWwucGFyZW50KGAuJHtwYXJhbXMuY29udGFpbmVyQ2xhc3N9YCk7XG4gICAgICBnZXN0dXJlLm1heFJhdGlvID0gZ2VzdHVyZS4kaW1hZ2VXcmFwRWwuYXR0cignZGF0YS1zd2lwZXItem9vbScpIHx8IHBhcmFtcy5tYXhSYXRpbztcbiAgICAgIGlmIChnZXN0dXJlLiRpbWFnZVdyYXBFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXN0dXJlLiRpbWFnZUVsLnRyYW5zaXRpb24oMCk7XG4gICAgc3dpcGVyLnpvb20uaXNTY2FsaW5nID0gdHJ1ZTtcbiAgfSxcbiAgb25HZXN0dXJlQ2hhbmdlKGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgY29uc3QgeyBnZXN0dXJlIH0gPSB6b29tO1xuICAgIGlmICghU3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNobW92ZScgfHwgKGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHpvb20uZmFrZUdlc3R1cmVNb3ZlZCA9IHRydWU7XG4gICAgICBnZXN0dXJlLnNjYWxlTW92ZSA9IFpvb20uZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcyhlKTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKFN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgIHpvb20uc2NhbGUgPSBlLnNjYWxlICogem9vbS5jdXJyZW50U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHpvb20uc2NhbGUgPSAoZ2VzdHVyZS5zY2FsZU1vdmUgLyBnZXN0dXJlLnNjYWxlU3RhcnQpICogem9vbS5jdXJyZW50U2NhbGU7XG4gICAgfVxuICAgIGlmICh6b29tLnNjYWxlID4gZ2VzdHVyZS5tYXhSYXRpbykge1xuICAgICAgem9vbS5zY2FsZSA9IChnZXN0dXJlLm1heFJhdGlvIC0gMSkgKyAoKCh6b29tLnNjYWxlIC0gZ2VzdHVyZS5tYXhSYXRpbykgKyAxKSAqKiAwLjUpO1xuICAgIH1cbiAgICBpZiAoem9vbS5zY2FsZSA8IHBhcmFtcy5taW5SYXRpbykge1xuICAgICAgem9vbS5zY2FsZSA9IChwYXJhbXMubWluUmF0aW8gKyAxKSAtICgoKHBhcmFtcy5taW5SYXRpbyAtIHpvb20uc2NhbGUpICsgMSkgKiogMC41KTtcbiAgICB9XG4gICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3pvb20uc2NhbGV9KWApO1xuICB9LFxuICBvbkdlc3R1cmVFbmQoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG4gICAgaWYgKCFTdXBwb3J0Lmdlc3R1cmVzKSB7XG4gICAgICBpZiAoIXpvb20uZmFrZUdlc3R1cmVUb3VjaGVkIHx8ICF6b29tLmZha2VHZXN0dXJlTW92ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNoZW5kJyB8fCAoZS50eXBlID09PSAndG91Y2hlbmQnICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDwgMiAmJiAhRGV2aWNlLmFuZHJvaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHpvb20uZmFrZUdlc3R1cmVUb3VjaGVkID0gZmFsc2U7XG4gICAgICB6b29tLmZha2VHZXN0dXJlTW92ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgem9vbS5zY2FsZSA9IE1hdGgubWF4KE1hdGgubWluKHpvb20uc2NhbGUsIGdlc3R1cmUubWF4UmF0aW8pLCBwYXJhbXMubWluUmF0aW8pO1xuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3pvb20uc2NhbGV9KWApO1xuICAgIHpvb20uY3VycmVudFNjYWxlID0gem9vbS5zY2FsZTtcbiAgICB6b29tLmlzU2NhbGluZyA9IGZhbHNlO1xuICAgIGlmICh6b29tLnNjYWxlID09PSAxKSBnZXN0dXJlLiRzbGlkZUVsID0gdW5kZWZpbmVkO1xuICB9LFxuICBvblRvdWNoU3RhcnQoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGNvbnN0IHsgZ2VzdHVyZSwgaW1hZ2UgfSA9IHpvb207XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKGltYWdlLmlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGlmIChEZXZpY2UuYW5kcm9pZCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGltYWdlLmlzVG91Y2hlZCA9IHRydWU7XG4gICAgaW1hZ2UudG91Y2hlc1N0YXJ0LnggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgaW1hZ2UudG91Y2hlc1N0YXJ0LnkgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gIH0sXG4gIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUsIGltYWdlLCB2ZWxvY2l0eSB9ID0gem9vbTtcbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICAgIGlmICghaW1hZ2UuaXNUb3VjaGVkIHx8ICFnZXN0dXJlLiRzbGlkZUVsKSByZXR1cm47XG5cbiAgICBpZiAoIWltYWdlLmlzTW92ZWQpIHtcbiAgICAgIGltYWdlLndpZHRoID0gZ2VzdHVyZS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aDtcbiAgICAgIGltYWdlLmhlaWdodCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgaW1hZ2Uuc3RhcnRYID0gVXRpbHMuZ2V0VHJhbnNsYXRlKGdlc3R1cmUuJGltYWdlV3JhcEVsWzBdLCAneCcpIHx8IDA7XG4gICAgICBpbWFnZS5zdGFydFkgPSBVdGlscy5nZXRUcmFuc2xhdGUoZ2VzdHVyZS4kaW1hZ2VXcmFwRWxbMF0sICd5JykgfHwgMDtcbiAgICAgIGdlc3R1cmUuc2xpZGVXaWR0aCA9IGdlc3R1cmUuJHNsaWRlRWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICBnZXN0dXJlLnNsaWRlSGVpZ2h0ID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDApO1xuICAgICAgaWYgKHN3aXBlci5ydGwpIHtcbiAgICAgICAgaW1hZ2Uuc3RhcnRYID0gLWltYWdlLnN0YXJ0WDtcbiAgICAgICAgaW1hZ2Uuc3RhcnRZID0gLWltYWdlLnN0YXJ0WTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGVmaW5lIGlmIHdlIG5lZWQgaW1hZ2UgZHJhZ1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gaW1hZ2Uud2lkdGggKiB6b29tLnNjYWxlO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGltYWdlLmhlaWdodCAqIHpvb20uc2NhbGU7XG5cbiAgICBpZiAoc2NhbGVkV2lkdGggPCBnZXN0dXJlLnNsaWRlV2lkdGggJiYgc2NhbGVkSGVpZ2h0IDwgZ2VzdHVyZS5zbGlkZUhlaWdodCkgcmV0dXJuO1xuXG4gICAgaW1hZ2UubWluWCA9IE1hdGgubWluKCgoZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMikgLSAoc2NhbGVkV2lkdGggLyAyKSksIDApO1xuICAgIGltYWdlLm1heFggPSAtaW1hZ2UubWluWDtcbiAgICBpbWFnZS5taW5ZID0gTWF0aC5taW4oKChnZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMikgLSAoc2NhbGVkSGVpZ2h0IC8gMikpLCAwKTtcbiAgICBpbWFnZS5tYXhZID0gLWltYWdlLm1pblk7XG5cbiAgICBpbWFnZS50b3VjaGVzQ3VycmVudC54ID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuXG4gICAgaWYgKCFpbWFnZS5pc01vdmVkICYmICF6b29tLmlzU2NhbGluZykge1xuICAgICAgaWYgKFxuICAgICAgICBzd2lwZXIuaXNIb3Jpem9udGFsKClcbiAgICAgICAgJiYgKFxuICAgICAgICAgIChNYXRoLmZsb29yKGltYWdlLm1pblgpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WCkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA8IGltYWdlLnRvdWNoZXNTdGFydC54KVxuICAgICAgICAgIHx8IChNYXRoLmZsb29yKGltYWdlLm1heFgpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WCkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA+IGltYWdlLnRvdWNoZXNTdGFydC54KVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gaWYgKFxuICAgICAgICAhc3dpcGVyLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICYmIChcbiAgICAgICAgICAoTWF0aC5mbG9vcihpbWFnZS5taW5ZKSA9PT0gTWF0aC5mbG9vcihpbWFnZS5zdGFydFkpICYmIGltYWdlLnRvdWNoZXNDdXJyZW50LnkgPCBpbWFnZS50b3VjaGVzU3RhcnQueSlcbiAgICAgICAgICB8fCAoTWF0aC5mbG9vcihpbWFnZS5tYXhZKSA9PT0gTWF0aC5mbG9vcihpbWFnZS5zdGFydFkpICYmIGltYWdlLnRvdWNoZXNDdXJyZW50LnkgPiBpbWFnZS50b3VjaGVzU3RhcnQueSlcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGltYWdlLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaW1hZ2UuaXNNb3ZlZCA9IHRydWU7XG4gICAgaW1hZ2UuY3VycmVudFggPSAoaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIGltYWdlLnRvdWNoZXNTdGFydC54KSArIGltYWdlLnN0YXJ0WDtcbiAgICBpbWFnZS5jdXJyZW50WSA9IChpbWFnZS50b3VjaGVzQ3VycmVudC55IC0gaW1hZ2UudG91Y2hlc1N0YXJ0LnkpICsgaW1hZ2Uuc3RhcnRZO1xuXG4gICAgaWYgKGltYWdlLmN1cnJlbnRYIDwgaW1hZ2UubWluWCkge1xuICAgICAgaW1hZ2UuY3VycmVudFggPSAoaW1hZ2UubWluWCArIDEpIC0gKCgoaW1hZ2UubWluWCAtIGltYWdlLmN1cnJlbnRYKSArIDEpICoqIDAuOCk7XG4gICAgfVxuICAgIGlmIChpbWFnZS5jdXJyZW50WCA+IGltYWdlLm1heFgpIHtcbiAgICAgIGltYWdlLmN1cnJlbnRYID0gKGltYWdlLm1heFggLSAxKSArICgoKGltYWdlLmN1cnJlbnRYIC0gaW1hZ2UubWF4WCkgKyAxKSAqKiAwLjgpO1xuICAgIH1cblxuICAgIGlmIChpbWFnZS5jdXJyZW50WSA8IGltYWdlLm1pblkpIHtcbiAgICAgIGltYWdlLmN1cnJlbnRZID0gKGltYWdlLm1pblkgKyAxKSAtICgoKGltYWdlLm1pblkgLSBpbWFnZS5jdXJyZW50WSkgKyAxKSAqKiAwLjgpO1xuICAgIH1cbiAgICBpZiAoaW1hZ2UuY3VycmVudFkgPiBpbWFnZS5tYXhZKSB7XG4gICAgICBpbWFnZS5jdXJyZW50WSA9IChpbWFnZS5tYXhZIC0gMSkgKyAoKChpbWFnZS5jdXJyZW50WSAtIGltYWdlLm1heFkpICsgMSkgKiogMC44KTtcbiAgICB9XG5cbiAgICAvLyBWZWxvY2l0eVxuICAgIGlmICghdmVsb2NpdHkucHJldlBvc2l0aW9uWCkgdmVsb2NpdHkucHJldlBvc2l0aW9uWCA9IGltYWdlLnRvdWNoZXNDdXJyZW50Lng7XG4gICAgaWYgKCF2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueTtcbiAgICBpZiAoIXZlbG9jaXR5LnByZXZUaW1lKSB2ZWxvY2l0eS5wcmV2VGltZSA9IERhdGUubm93KCk7XG4gICAgdmVsb2NpdHkueCA9IChpbWFnZS50b3VjaGVzQ3VycmVudC54IC0gdmVsb2NpdHkucHJldlBvc2l0aW9uWCkgLyAoRGF0ZS5ub3coKSAtIHZlbG9jaXR5LnByZXZUaW1lKSAvIDI7XG4gICAgdmVsb2NpdHkueSA9IChpbWFnZS50b3VjaGVzQ3VycmVudC55IC0gdmVsb2NpdHkucHJldlBvc2l0aW9uWSkgLyAoRGF0ZS5ub3coKSAtIHZlbG9jaXR5LnByZXZUaW1lKSAvIDI7XG4gICAgaWYgKE1hdGguYWJzKGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSA8IDIpIHZlbG9jaXR5LnggPSAwO1xuICAgIGlmIChNYXRoLmFicyhpbWFnZS50b3VjaGVzQ3VycmVudC55IC0gdmVsb2NpdHkucHJldlBvc2l0aW9uWSkgPCAyKSB2ZWxvY2l0eS55ID0gMDtcbiAgICB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueDtcbiAgICB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueTtcbiAgICB2ZWxvY2l0eS5wcmV2VGltZSA9IERhdGUubm93KCk7XG5cbiAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aW1hZ2UuY3VycmVudFh9cHgsICR7aW1hZ2UuY3VycmVudFl9cHgsMClgKTtcbiAgfSxcbiAgb25Ub3VjaEVuZCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUsIGltYWdlLCB2ZWxvY2l0eSB9ID0gem9vbTtcbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBpZiAoIWltYWdlLmlzVG91Y2hlZCB8fCAhaW1hZ2UuaXNNb3ZlZCkge1xuICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICBpbWFnZS5pc01vdmVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltYWdlLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIGltYWdlLmlzTW92ZWQgPSBmYWxzZTtcbiAgICBsZXQgbW9tZW50dW1EdXJhdGlvblggPSAzMDA7XG4gICAgbGV0IG1vbWVudHVtRHVyYXRpb25ZID0gMzAwO1xuICAgIGNvbnN0IG1vbWVudHVtRGlzdGFuY2VYID0gdmVsb2NpdHkueCAqIG1vbWVudHVtRHVyYXRpb25YO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uWCA9IGltYWdlLmN1cnJlbnRYICsgbW9tZW50dW1EaXN0YW5jZVg7XG4gICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZVkgPSB2ZWxvY2l0eS55ICogbW9tZW50dW1EdXJhdGlvblk7XG4gICAgY29uc3QgbmV3UG9zaXRpb25ZID0gaW1hZ2UuY3VycmVudFkgKyBtb21lbnR1bURpc3RhbmNlWTtcblxuICAgIC8vIEZpeCBkdXJhdGlvblxuICAgIGlmICh2ZWxvY2l0eS54ICE9PSAwKSBtb21lbnR1bUR1cmF0aW9uWCA9IE1hdGguYWJzKChuZXdQb3NpdGlvblggLSBpbWFnZS5jdXJyZW50WCkgLyB2ZWxvY2l0eS54KTtcbiAgICBpZiAodmVsb2NpdHkueSAhPT0gMCkgbW9tZW50dW1EdXJhdGlvblkgPSBNYXRoLmFicygobmV3UG9zaXRpb25ZIC0gaW1hZ2UuY3VycmVudFkpIC8gdmVsb2NpdHkueSk7XG4gICAgY29uc3QgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGgubWF4KG1vbWVudHVtRHVyYXRpb25YLCBtb21lbnR1bUR1cmF0aW9uWSk7XG5cbiAgICBpbWFnZS5jdXJyZW50WCA9IG5ld1Bvc2l0aW9uWDtcbiAgICBpbWFnZS5jdXJyZW50WSA9IG5ld1Bvc2l0aW9uWTtcblxuICAgIC8vIERlZmluZSBpZiB3ZSBuZWVkIGltYWdlIGRyYWdcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGltYWdlLndpZHRoICogem9vbS5zY2FsZTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiB6b29tLnNjYWxlO1xuICAgIGltYWdlLm1pblggPSBNYXRoLm1pbigoKGdlc3R1cmUuc2xpZGVXaWR0aCAvIDIpIC0gKHNjYWxlZFdpZHRoIC8gMikpLCAwKTtcbiAgICBpbWFnZS5tYXhYID0gLWltYWdlLm1pblg7XG4gICAgaW1hZ2UubWluWSA9IE1hdGgubWluKCgoZ2VzdHVyZS5zbGlkZUhlaWdodCAvIDIpIC0gKHNjYWxlZEhlaWdodCAvIDIpKSwgMCk7XG4gICAgaW1hZ2UubWF4WSA9IC1pbWFnZS5taW5ZO1xuICAgIGltYWdlLmN1cnJlbnRYID0gTWF0aC5tYXgoTWF0aC5taW4oaW1hZ2UuY3VycmVudFgsIGltYWdlLm1heFgpLCBpbWFnZS5taW5YKTtcbiAgICBpbWFnZS5jdXJyZW50WSA9IE1hdGgubWF4KE1hdGgubWluKGltYWdlLmN1cnJlbnRZLCBpbWFnZS5tYXhZKSwgaW1hZ2UubWluWSk7XG5cbiAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpbWFnZS5jdXJyZW50WH1weCwgJHtpbWFnZS5jdXJyZW50WX1weCwwKWApO1xuICB9LFxuICBvblRyYW5zaXRpb25FbmQoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgY29uc3QgeyBnZXN0dXJlIH0gPSB6b29tO1xuICAgIGlmIChnZXN0dXJlLiRzbGlkZUVsICYmIHN3aXBlci5wcmV2aW91c0luZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSknKTtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwwLDApJyk7XG5cbiAgICAgIHpvb20uc2NhbGUgPSAxO1xuICAgICAgem9vbS5jdXJyZW50U2NhbGUgPSAxO1xuXG4gICAgICBnZXN0dXJlLiRzbGlkZUVsID0gdW5kZWZpbmVkO1xuICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IHVuZGVmaW5lZDtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gVG9nZ2xlIFpvb21cbiAgdG9nZ2xlKGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcblxuICAgIGlmICh6b29tLnNjYWxlICYmIHpvb20uc2NhbGUgIT09IDEpIHtcbiAgICAgIC8vIFpvb20gT3V0XG4gICAgICB6b29tLm91dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBab29tIEluXG4gICAgICB6b29tLmluKGUpO1xuICAgIH1cbiAgfSxcbiAgaW4oZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHsgZ2VzdHVyZSwgaW1hZ2UgfSA9IHpvb207XG5cbiAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcbiAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuY2xpY2tlZFNsaWRlID8gJChzd2lwZXIuY2xpY2tlZFNsaWRlKSA6IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMnKTtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBnZXN0dXJlLiRzbGlkZUVsLmFkZENsYXNzKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuXG4gICAgbGV0IHRvdWNoWDtcbiAgICBsZXQgdG91Y2hZO1xuICAgIGxldCBvZmZzZXRYO1xuICAgIGxldCBvZmZzZXRZO1xuICAgIGxldCBkaWZmWDtcbiAgICBsZXQgZGlmZlk7XG4gICAgbGV0IHRyYW5zbGF0ZVg7XG4gICAgbGV0IHRyYW5zbGF0ZVk7XG4gICAgbGV0IGltYWdlV2lkdGg7XG4gICAgbGV0IGltYWdlSGVpZ2h0O1xuICAgIGxldCBzY2FsZWRXaWR0aDtcbiAgICBsZXQgc2NhbGVkSGVpZ2h0O1xuICAgIGxldCB0cmFuc2xhdGVNaW5YO1xuICAgIGxldCB0cmFuc2xhdGVNaW5ZO1xuICAgIGxldCB0cmFuc2xhdGVNYXhYO1xuICAgIGxldCB0cmFuc2xhdGVNYXhZO1xuICAgIGxldCBzbGlkZVdpZHRoO1xuICAgIGxldCBzbGlkZUhlaWdodDtcblxuICAgIGlmICh0eXBlb2YgaW1hZ2UudG91Y2hlc1N0YXJ0LnggPT09ICd1bmRlZmluZWQnICYmIGUpIHtcbiAgICAgIHRvdWNoWCA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgdG91Y2hZID0gZS50eXBlID09PSAndG91Y2hlbmQnID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvdWNoWCA9IGltYWdlLnRvdWNoZXNTdGFydC54O1xuICAgICAgdG91Y2hZID0gaW1hZ2UudG91Y2hlc1N0YXJ0Lnk7XG4gICAgfVxuXG4gICAgem9vbS5zY2FsZSA9IGdlc3R1cmUuJGltYWdlV3JhcEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XG4gICAgem9vbS5jdXJyZW50U2NhbGUgPSBnZXN0dXJlLiRpbWFnZVdyYXBFbC5hdHRyKCdkYXRhLXN3aXBlci16b29tJykgfHwgcGFyYW1zLm1heFJhdGlvO1xuICAgIGlmIChlKSB7XG4gICAgICBzbGlkZVdpZHRoID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aDtcbiAgICAgIHNsaWRlSGVpZ2h0ID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICBvZmZzZXRYID0gZ2VzdHVyZS4kc2xpZGVFbC5vZmZzZXQoKS5sZWZ0O1xuICAgICAgb2Zmc2V0WSA9IGdlc3R1cmUuJHNsaWRlRWwub2Zmc2V0KCkudG9wO1xuICAgICAgZGlmZlggPSAob2Zmc2V0WCArIChzbGlkZVdpZHRoIC8gMikpIC0gdG91Y2hYO1xuICAgICAgZGlmZlkgPSAob2Zmc2V0WSArIChzbGlkZUhlaWdodCAvIDIpKSAtIHRvdWNoWTtcblxuICAgICAgaW1hZ2VXaWR0aCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICBpbWFnZUhlaWdodCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgc2NhbGVkV2lkdGggPSBpbWFnZVdpZHRoICogem9vbS5zY2FsZTtcbiAgICAgIHNjYWxlZEhlaWdodCA9IGltYWdlSGVpZ2h0ICogem9vbS5zY2FsZTtcblxuICAgICAgdHJhbnNsYXRlTWluWCA9IE1hdGgubWluKCgoc2xpZGVXaWR0aCAvIDIpIC0gKHNjYWxlZFdpZHRoIC8gMikpLCAwKTtcbiAgICAgIHRyYW5zbGF0ZU1pblkgPSBNYXRoLm1pbigoKHNsaWRlSGVpZ2h0IC8gMikgLSAoc2NhbGVkSGVpZ2h0IC8gMikpLCAwKTtcbiAgICAgIHRyYW5zbGF0ZU1heFggPSAtdHJhbnNsYXRlTWluWDtcbiAgICAgIHRyYW5zbGF0ZU1heFkgPSAtdHJhbnNsYXRlTWluWTtcblxuICAgICAgdHJhbnNsYXRlWCA9IGRpZmZYICogem9vbS5zY2FsZTtcbiAgICAgIHRyYW5zbGF0ZVkgPSBkaWZmWSAqIHpvb20uc2NhbGU7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVYIDwgdHJhbnNsYXRlTWluWCkge1xuICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWluWDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2xhdGVYID4gdHJhbnNsYXRlTWF4WCkge1xuICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWF4WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zbGF0ZVkgPCB0cmFuc2xhdGVNaW5ZKSB7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVNaW5ZO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zbGF0ZVkgPiB0cmFuc2xhdGVNYXhZKSB7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVNYXhZO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2xhdGVYID0gMDtcbiAgICAgIHRyYW5zbGF0ZVkgPSAwO1xuICAgIH1cbiAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVh9cHgsICR7dHJhbnNsYXRlWX1weCwwKWApO1xuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7em9vbS5zY2FsZX0pYCk7XG4gIH0sXG4gIG91dCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG5cbiAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcbiAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuY2xpY2tlZFNsaWRlID8gJChzd2lwZXIuY2xpY2tlZFNsaWRlKSA6IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMnKTtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICB6b29tLnNjYWxlID0gMTtcbiAgICB6b29tLmN1cnJlbnRTY2FsZSA9IDE7XG4gICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSknKTtcbiAgICBnZXN0dXJlLiRzbGlkZUVsLnJlbW92ZUNsYXNzKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgIGdlc3R1cmUuJHNsaWRlRWwgPSB1bmRlZmluZWQ7XG4gIH0sXG4gIC8vIEF0dGFjaC9EZXRhY2ggRXZlbnRzXG4gIGVuYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBpZiAoem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgem9vbS5lbmFibGVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHN3aXBlci5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuXG4gICAgLy8gU2NhbGUgaW1hZ2VcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oJ2dlc3R1cmVzdGFydCcsICcuc3dpcGVyLXNsaWRlJywgem9vbS5vbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKCdnZXN0dXJlY2hhbmdlJywgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUNoYW5nZSwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKCdnZXN0dXJlZW5kJywgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vbihzd2lwZXIudG91Y2hFdmVudHMuc3RhcnQsICcuc3dpcGVyLXNsaWRlJywgem9vbS5vbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5tb3ZlLCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlQ2hhbmdlLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGltYWdlXG4gICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsIGAuJHtzd2lwZXIucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3N9YCwgem9vbS5vblRvdWNoTW92ZSk7XG4gIH0sXG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgaWYgKCF6b29tLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHN3aXBlci56b29tLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHN3aXBlci5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuXG4gICAgLy8gU2NhbGUgaW1hZ2VcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKCdnZXN0dXJlc3RhcnQnLCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoJ2dlc3R1cmVjaGFuZ2UnLCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlQ2hhbmdlLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKCdnZXN0dXJlZW5kJywgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLnN0YXJ0LCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsICcuc3dpcGVyLXNsaWRlJywgem9vbS5vbkdlc3R1cmVDaGFuZ2UsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGltYWdlXG4gICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5tb3ZlLCBgLiR7c3dpcGVyLnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzfWAsIHpvb20ub25Ub3VjaE1vdmUpO1xuICB9LFxufTtcblxudmFyIFpvb20kMSA9IHtcbiAgbmFtZTogJ3pvb20nLFxuICBwYXJhbXM6IHtcbiAgICB6b29tOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG1heFJhdGlvOiAzLFxuICAgICAgbWluUmF0aW86IDEsXG4gICAgICB0b2dnbGU6IHRydWUsXG4gICAgICBjb250YWluZXJDbGFzczogJ3N3aXBlci16b29tLWNvbnRhaW5lcicsXG4gICAgICB6b29tZWRTbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXpvb21lZCcsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qgem9vbSA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc2NhbGU6IDEsXG4gICAgICBjdXJyZW50U2NhbGU6IDEsXG4gICAgICBpc1NjYWxpbmc6IGZhbHNlLFxuICAgICAgZ2VzdHVyZToge1xuICAgICAgICAkc2xpZGVFbDogdW5kZWZpbmVkLFxuICAgICAgICBzbGlkZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgIHNsaWRlSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgICRpbWFnZUVsOiB1bmRlZmluZWQsXG4gICAgICAgICRpbWFnZVdyYXBFbDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhSYXRpbzogMyxcbiAgICAgIH0sXG4gICAgICBpbWFnZToge1xuICAgICAgICBpc1RvdWNoZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50WDogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50WTogdW5kZWZpbmVkLFxuICAgICAgICBtaW5YOiB1bmRlZmluZWQsXG4gICAgICAgIG1pblk6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4WDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhZOiB1bmRlZmluZWQsXG4gICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydFg6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRZOiB1bmRlZmluZWQsXG4gICAgICAgIHRvdWNoZXNTdGFydDoge30sXG4gICAgICAgIHRvdWNoZXNDdXJyZW50OiB7fSxcbiAgICAgIH0sXG4gICAgICB2ZWxvY2l0eToge1xuICAgICAgICB4OiB1bmRlZmluZWQsXG4gICAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldlBvc2l0aW9uWDogdW5kZWZpbmVkLFxuICAgICAgICBwcmV2UG9zaXRpb25ZOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZUaW1lOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICAoJ29uR2VzdHVyZVN0YXJ0IG9uR2VzdHVyZUNoYW5nZSBvbkdlc3R1cmVFbmQgb25Ub3VjaFN0YXJ0IG9uVG91Y2hNb3ZlIG9uVG91Y2hFbmQgb25UcmFuc2l0aW9uRW5kIHRvZ2dsZSBlbmFibGUgZGlzYWJsZSBpbiBvdXQnKS5zcGxpdCgnICcpLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIHpvb21bbWV0aG9kTmFtZV0gPSBab29tW21ldGhvZE5hbWVdLmJpbmQoc3dpcGVyKTtcbiAgICB9KTtcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICB6b29tLFxuICAgIH0pO1xuXG4gICAgbGV0IHNjYWxlID0gMTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3dpcGVyLnpvb20sICdzY2FsZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoc2NhbGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgaW1hZ2VFbCA9IHN3aXBlci56b29tLmdlc3R1cmUuJGltYWdlRWwgPyBzd2lwZXIuem9vbS5nZXN0dXJlLiRpbWFnZUVsWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHNsaWRlRWwgPSBzd2lwZXIuem9vbS5nZXN0dXJlLiRzbGlkZUVsID8gc3dpcGVyLnpvb20uZ2VzdHVyZS4kc2xpZGVFbFswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnem9vbUNoYW5nZScsIHZhbHVlLCBpbWFnZUVsLCBzbGlkZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBzY2FsZSA9IHZhbHVlO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuem9vbS5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnpvb20uZGlzYWJsZSgpO1xuICAgIH0sXG4gICAgdG91Y2hTdGFydChlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuem9vbS5vblRvdWNoU3RhcnQoZSk7XG4gICAgfSxcbiAgICB0b3VjaEVuZChlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuem9vbS5vblRvdWNoRW5kKGUpO1xuICAgIH0sXG4gICAgZG91YmxlVGFwKGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIucGFyYW1zLnpvb20udG9nZ2xlKSB7XG4gICAgICAgIHN3aXBlci56b29tLnRvZ2dsZShlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zaXRpb25FbmQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLnpvb20ub25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IExhenkgPSB7XG4gIGxvYWRJblNsaWRlKGluZGV4LCBsb2FkSW5EdXBsaWNhdGUgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmxhenk7XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnNsaWRlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcblxuICAgIGNvbnN0ICRzbGlkZUVsID0gaXNWaXJ0dWFsXG4gICAgICA/IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpbmRleH1cIl1gKVxuICAgICAgOiBzd2lwZXIuc2xpZGVzLmVxKGluZGV4KTtcblxuICAgIGxldCAkaW1hZ2VzID0gJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLmVsZW1lbnRDbGFzc306bm90KC4ke3BhcmFtcy5sb2FkZWRDbGFzc30pOm5vdCguJHtwYXJhbXMubG9hZGluZ0NsYXNzfSlgKTtcbiAgICBpZiAoJHNsaWRlRWwuaGFzQ2xhc3MocGFyYW1zLmVsZW1lbnRDbGFzcykgJiYgISRzbGlkZUVsLmhhc0NsYXNzKHBhcmFtcy5sb2FkZWRDbGFzcykgJiYgISRzbGlkZUVsLmhhc0NsYXNzKHBhcmFtcy5sb2FkaW5nQ2xhc3MpKSB7XG4gICAgICAkaW1hZ2VzID0gJGltYWdlcy5hZGQoJHNsaWRlRWxbMF0pO1xuICAgIH1cbiAgICBpZiAoJGltYWdlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICRpbWFnZXMuZWFjaCgoaW1hZ2VJbmRleCwgaW1hZ2VFbCkgPT4ge1xuICAgICAgY29uc3QgJGltYWdlRWwgPSAkKGltYWdlRWwpO1xuICAgICAgJGltYWdlRWwuYWRkQ2xhc3MocGFyYW1zLmxvYWRpbmdDbGFzcyk7XG5cbiAgICAgIGNvbnN0IGJhY2tncm91bmQgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLWJhY2tncm91bmQnKTtcbiAgICAgIGNvbnN0IHNyYyA9ICRpbWFnZUVsLmF0dHIoJ2RhdGEtc3JjJyk7XG4gICAgICBjb25zdCBzcmNzZXQgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLXNyY3NldCcpO1xuICAgICAgY29uc3Qgc2l6ZXMgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLXNpemVzJyk7XG5cbiAgICAgIHN3aXBlci5sb2FkSW1hZ2UoJGltYWdlRWxbMF0sIChzcmMgfHwgYmFja2dyb3VuZCksIHNyY3NldCwgc2l6ZXMsIGZhbHNlLCAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3dpcGVyID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIgPT09IG51bGwgfHwgIXN3aXBlciB8fCAoc3dpcGVyICYmICFzd2lwZXIucGFyYW1zKSB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgJGltYWdlRWwuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgYHVybChcIiR7YmFja2dyb3VuZH1cIilgKTtcbiAgICAgICAgICAkaW1hZ2VFbC5yZW1vdmVBdHRyKCdkYXRhLWJhY2tncm91bmQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3Jjc2V0KSB7XG4gICAgICAgICAgICAkaW1hZ2VFbC5hdHRyKCdzcmNzZXQnLCBzcmNzZXQpO1xuICAgICAgICAgICAgJGltYWdlRWwucmVtb3ZlQXR0cignZGF0YS1zcmNzZXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpemVzKSB7XG4gICAgICAgICAgICAkaW1hZ2VFbC5hdHRyKCdzaXplcycsIHNpemVzKTtcbiAgICAgICAgICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtc2l6ZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgJGltYWdlRWwuYXR0cignc3JjJywgc3JjKTtcbiAgICAgICAgICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtc3JjJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJGltYWdlRWwuYWRkQ2xhc3MocGFyYW1zLmxvYWRlZENsYXNzKS5yZW1vdmVDbGFzcyhwYXJhbXMubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLnByZWxvYWRlckNsYXNzfWApLnJlbW92ZSgpO1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wICYmIGxvYWRJbkR1cGxpY2F0ZSkge1xuICAgICAgICAgIGNvbnN0IHNsaWRlT3JpZ2luYWxJbmRleCA9ICRzbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgICAgICAgaWYgKCRzbGlkZUVsLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2xpZGUgPSBzd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzbGlkZU9yaWdpbmFsSW5kZXh9XCJdOm5vdCguJHtzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KWApO1xuICAgICAgICAgICAgc3dpcGVyLmxhenkubG9hZEluU2xpZGUob3JpZ2luYWxTbGlkZS5pbmRleCgpLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZWRTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzbGlkZU9yaWdpbmFsSW5kZXh9XCJdYCk7XG4gICAgICAgICAgICBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShkdXBsaWNhdGVkU2xpZGUuaW5kZXgoKSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2lwZXIuZW1pdCgnbGF6eUltYWdlUmVhZHknLCAkc2xpZGVFbFswXSwgJGltYWdlRWxbMF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHN3aXBlci5lbWl0KCdsYXp5SW1hZ2VMb2FkJywgJHNsaWRlRWxbMF0sICRpbWFnZUVsWzBdKTtcbiAgICB9KTtcbiAgfSxcbiAgbG9hZCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgICR3cmFwcGVyRWwsIHBhcmFtczogc3dpcGVyUGFyYW1zLCBzbGlkZXMsIGFjdGl2ZUluZGV4LFxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyUGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXJQYXJhbXMubGF6eTtcblxuICAgIGxldCBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyUGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgaWYgKHNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgICAgc2xpZGVzUGVyVmlldyA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2xpZGVFeGlzdChpbmRleCkge1xuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICBpZiAoJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyUGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpbmRleH1cIl1gKS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbGlkZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2xpZGVJbmRleChzbGlkZUVsKSB7XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIHJldHVybiAkKHNsaWRlRWwpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJChzbGlkZUVsKS5pbmRleCgpO1xuICAgIH1cblxuICAgIGlmICghc3dpcGVyLmxhenkuaW5pdGlhbEltYWdlTG9hZGVkKSBzd2lwZXIubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQgPSB0cnVlO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xuICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyUGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzfWApLmVhY2goKGVsSW5kZXgsIHNsaWRlRWwpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpc1ZpcnR1YWwgPyAkKHNsaWRlRWwpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgOiAkKHNsaWRlRWwpLmluZGV4KCk7XG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2xpZGVzUGVyVmlldyA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleDsgaSA8IGFjdGl2ZUluZGV4ICsgc2xpZGVzUGVyVmlldzsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZUV4aXN0KGkpKSBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLmxhenkubG9hZEluU2xpZGUoYWN0aXZlSW5kZXgpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxvYWRQcmV2TmV4dCkge1xuICAgICAgaWYgKHNsaWRlc1BlclZpZXcgPiAxIHx8IChwYXJhbXMubG9hZFByZXZOZXh0QW1vdW50ICYmIHBhcmFtcy5sb2FkUHJldk5leHRBbW91bnQgPiAxKSkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJhbXMubG9hZFByZXZOZXh0QW1vdW50O1xuICAgICAgICBjb25zdCBzcHYgPSBzbGlkZXNQZXJWaWV3O1xuICAgICAgICBjb25zdCBtYXhJbmRleCA9IE1hdGgubWluKGFjdGl2ZUluZGV4ICsgc3B2ICsgTWF0aC5tYXgoYW1vdW50LCBzcHYpLCBzbGlkZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWluSW5kZXggPSBNYXRoLm1heChhY3RpdmVJbmRleCAtIE1hdGgubWF4KHNwdiwgYW1vdW50KSwgMCk7XG4gICAgICAgIC8vIE5leHQgU2xpZGVzXG4gICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCArIHNsaWRlc1BlclZpZXc7IGkgPCBtYXhJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHNsaWRlRXhpc3QoaSkpIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXYgU2xpZGVzXG4gICAgICAgIGZvciAobGV0IGkgPSBtaW5JbmRleDsgaSA8IGFjdGl2ZUluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoc2xpZGVFeGlzdChpKSkgc3dpcGVyLmxhenkubG9hZEluU2xpZGUoaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRTbGlkZSA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlclBhcmFtcy5zbGlkZU5leHRDbGFzc31gKTtcbiAgICAgICAgaWYgKG5leHRTbGlkZS5sZW5ndGggPiAwKSBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShzbGlkZUluZGV4KG5leHRTbGlkZSkpO1xuXG4gICAgICAgIGNvbnN0IHByZXZTbGlkZSA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlclBhcmFtcy5zbGlkZVByZXZDbGFzc31gKTtcbiAgICAgICAgaWYgKHByZXZTbGlkZS5sZW5ndGggPiAwKSBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShzbGlkZUluZGV4KHByZXZTbGlkZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn07XG5cbnZhciBMYXp5JDEgPSB7XG4gIG5hbWU6ICdsYXp5JyxcbiAgcGFyYW1zOiB7XG4gICAgbGF6eToge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBsb2FkUHJldk5leHQ6IGZhbHNlLFxuICAgICAgbG9hZFByZXZOZXh0QW1vdW50OiAxLFxuICAgICAgbG9hZE9uVHJhbnNpdGlvblN0YXJ0OiBmYWxzZSxcblxuICAgICAgZWxlbWVudENsYXNzOiAnc3dpcGVyLWxhenknLFxuICAgICAgbG9hZGluZ0NsYXNzOiAnc3dpcGVyLWxhenktbG9hZGluZycsXG4gICAgICBsb2FkZWRDbGFzczogJ3N3aXBlci1sYXp5LWxvYWRlZCcsXG4gICAgICBwcmVsb2FkZXJDbGFzczogJ3N3aXBlci1sYXp5LXByZWxvYWRlcicsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgbGF6eToge1xuICAgICAgICBpbml0aWFsSW1hZ2VMb2FkZWQ6IGZhbHNlLFxuICAgICAgICBsb2FkOiBMYXp5LmxvYWQuYmluZChzd2lwZXIpLFxuICAgICAgICBsb2FkSW5TbGlkZTogTGF6eS5sb2FkSW5TbGlkZS5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGJlZm9yZUluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMucHJlbG9hZEltYWdlcykge1xuICAgICAgICBzd2lwZXIucGFyYW1zLnByZWxvYWRJbWFnZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmICFzd2lwZXIucGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2l6ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsYmFyRHJhZ01vdmUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zaXRpb25TdGFydCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQgfHwgKCFzd2lwZXIucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0ICYmICFzd2lwZXIubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQpKSB7XG4gICAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uRW5kKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxhenkuZW5hYmxlZCAmJiAhc3dpcGVyLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCkge1xuICAgICAgICBzd2lwZXIubGF6eS5sb2FkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbi8qIGVzbGludCBuby1iaXR3aXNlOiBbXCJlcnJvclwiLCB7IFwiYWxsb3dcIjogW1wiPj5cIl0gfV0gKi9cblxuY29uc3QgQ29udHJvbGxlciA9IHtcbiAgTGluZWFyU3BsaW5lOiBmdW5jdGlvbiBMaW5lYXJTcGxpbmUoeCwgeSkge1xuICAgIGNvbnN0IGJpbmFyeVNlYXJjaCA9IChmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgICBsZXQgbWF4SW5kZXg7XG4gICAgICBsZXQgbWluSW5kZXg7XG4gICAgICBsZXQgZ3Vlc3M7XG4gICAgICByZXR1cm4gKGFycmF5LCB2YWwpID0+IHtcbiAgICAgICAgbWluSW5kZXggPSAtMTtcbiAgICAgICAgbWF4SW5kZXggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChtYXhJbmRleCAtIG1pbkluZGV4ID4gMSkge1xuICAgICAgICAgIGd1ZXNzID0gbWF4SW5kZXggKyBtaW5JbmRleCA+PiAxO1xuICAgICAgICAgIGlmIChhcnJheVtndWVzc10gPD0gdmFsKSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGd1ZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGd1ZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4SW5kZXg7XG4gICAgICB9O1xuICAgIH0oKSk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMubGFzdEluZGV4ID0geC5sZW5ndGggLSAxO1xuICAgIC8vIEdpdmVuIGFuIHggdmFsdWUgKHgyKSwgcmV0dXJuIHRoZSBleHBlY3RlZCB5MiB2YWx1ZTpcbiAgICAvLyAoeDEseTEpIGlzIHRoZSBrbm93biBwb2ludCBiZWZvcmUgZ2l2ZW4gdmFsdWUsXG4gICAgLy8gKHgzLHkzKSBpcyB0aGUga25vd24gcG9pbnQgYWZ0ZXIgZ2l2ZW4gdmFsdWUuXG4gICAgbGV0IGkxO1xuICAgIGxldCBpMztcblxuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh4Mikge1xuICAgICAgaWYgKCF4MikgcmV0dXJuIDA7XG5cbiAgICAgIC8vIEdldCB0aGUgaW5kZXhlcyBvZiB4MSBhbmQgeDMgKHRoZSBhcnJheSBpbmRleGVzIGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4geDIpOlxuICAgICAgaTMgPSBiaW5hcnlTZWFyY2godGhpcy54LCB4Mik7XG4gICAgICBpMSA9IGkzIC0gMTtcblxuICAgICAgLy8gV2UgaGF2ZSBvdXIgaW5kZXhlcyBpMSAmIGkzLCBzbyB3ZSBjYW4gY2FsY3VsYXRlIGFscmVhZHk6XG4gICAgICAvLyB5MiA6PSAoKHgy4oiSeDEpIMOXICh5M+KIknkxKSkgw7cgKHgz4oiSeDEpICsgeTFcbiAgICAgIHJldHVybiAoKCh4MiAtIHRoaXMueFtpMV0pICogKHRoaXMueVtpM10gLSB0aGlzLnlbaTFdKSkgLyAodGhpcy54W2kzXSAtIHRoaXMueFtpMV0pKSArIHRoaXMueVtpMV07XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8geHh4OiBmb3Igbm93IGkgd2lsbCBqdXN0IHNhdmUgb25lIHNwbGluZSBmdW5jdGlvbiB0byB0b1xuICBnZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uKGMpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lKSB7XG4gICAgICBzd2lwZXIuY29udHJvbGxlci5zcGxpbmUgPSBzd2lwZXIucGFyYW1zLmxvb3BcbiAgICAgICAgPyBuZXcgQ29udHJvbGxlci5MaW5lYXJTcGxpbmUoc3dpcGVyLnNsaWRlc0dyaWQsIGMuc2xpZGVzR3JpZClcbiAgICAgICAgOiBuZXcgQ29udHJvbGxlci5MaW5lYXJTcGxpbmUoc3dpcGVyLnNuYXBHcmlkLCBjLnNuYXBHcmlkKTtcbiAgICB9XG4gIH0sXG4gIHNldFRyYW5zbGF0ZShzZXRUcmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgY29udHJvbGxlZCA9IHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2w7XG4gICAgbGV0IG11bHRpcGxpZXI7XG4gICAgbGV0IGNvbnRyb2xsZWRUcmFuc2xhdGU7XG4gICAgZnVuY3Rpb24gc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjKSB7XG4gICAgICAvLyB0aGlzIHdpbGwgY3JlYXRlIGFuIEludGVycG9sYXRlIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBzbmFwR3JpZHNcbiAgICAgIC8vIHggaXMgdGhlIEdyaWQgb2YgdGhlIHNjcm9sbGVkIHNjcm9sbGVyIGFuZCB5IHdpbGwgYmUgdGhlIGNvbnRyb2xsZWQgc2Nyb2xsZXJcbiAgICAgIC8vIGl0IG1ha2VzIHNlbnNlIHRvIGNyZWF0ZSB0aGlzIG9ubHkgb25jZSBhbmQgcmVjYWxsIGl0IGZvciB0aGUgaW50ZXJwb2xhdGlvblxuICAgICAgLy8gdGhlIGZ1bmN0aW9uIGRvZXMgYSBsb3Qgb2YgdmFsdWUgY2FjaGluZyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmJ5ID09PSAnc2xpZGUnKSB7XG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLmdldEludGVycG9sYXRlRnVuY3Rpb24oYyk7XG4gICAgICAgIC8vIGkgYW0gbm90IHN1cmUgd2h5IHRoZSB2YWx1ZXMgaGF2ZSB0byBiZSBtdWx0aXBsaWNhdGVkIHRoaXMgd2F5LCB0cmllZCB0byBpbnZlcnQgdGhlIHNuYXBHcmlkXG4gICAgICAgIC8vIGJ1dCBpdCBkaWQgbm90IHdvcmsgb3V0XG4gICAgICAgIGNvbnRyb2xsZWRUcmFuc2xhdGUgPSAtc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC10cmFuc2xhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbnRyb2xsZWRUcmFuc2xhdGUgfHwgc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmJ5ID09PSAnY29udGFpbmVyJykge1xuICAgICAgICBtdWx0aXBsaWVyID0gKGMubWF4VHJhbnNsYXRlKCkgLSBjLm1pblRyYW5zbGF0ZSgpKSAvIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xuICAgICAgICBjb250cm9sbGVkVHJhbnNsYXRlID0gKCh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogbXVsdGlwbGllcikgKyBjLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmludmVyc2UpIHtcbiAgICAgICAgY29udHJvbGxlZFRyYW5zbGF0ZSA9IGMubWF4VHJhbnNsYXRlKCkgLSBjb250cm9sbGVkVHJhbnNsYXRlO1xuICAgICAgfVxuICAgICAgYy51cGRhdGVQcm9ncmVzcyhjb250cm9sbGVkVHJhbnNsYXRlKTtcbiAgICAgIGMuc2V0VHJhbnNsYXRlKGNvbnRyb2xsZWRUcmFuc2xhdGUsIHN3aXBlcik7XG4gICAgICBjLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBjLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udHJvbGxlZCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNsYXRlKGNvbnRyb2xsZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVkIGluc3RhbmNlb2YgU3dpcGVyICYmIGJ5Q29udHJvbGxlciAhPT0gY29udHJvbGxlZCkge1xuICAgICAgc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjb250cm9sbGVkKTtcbiAgICB9XG4gIH0sXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgY29udHJvbGxlZCA9IHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2w7XG4gICAgbGV0IGk7XG4gICAgZnVuY3Rpb24gc2V0Q29udHJvbGxlZFRyYW5zaXRpb24oYykge1xuICAgICAgYy5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBzd2lwZXIpO1xuICAgICAgaWYgKGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgIGMudHJhbnNpdGlvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjLnBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgYy51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYy4kd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIGlmICghY29udHJvbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChjLnBhcmFtcy5sb29wICYmIHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5ieSA9PT0gJ3NsaWRlJykge1xuICAgICAgICAgICAgYy5sb29wRml4KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udHJvbGxlZCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250cm9sbGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVkW2ldICE9PSBieUNvbnRyb2xsZXIgJiYgY29udHJvbGxlZFtpXSBpbnN0YW5jZW9mIFN3aXBlcikge1xuICAgICAgICAgIHNldENvbnRyb2xsZWRUcmFuc2l0aW9uKGNvbnRyb2xsZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVkIGluc3RhbmNlb2YgU3dpcGVyICYmIGJ5Q29udHJvbGxlciAhPT0gY29udHJvbGxlZCkge1xuICAgICAgc2V0Q29udHJvbGxlZFRyYW5zaXRpb24oY29udHJvbGxlZCk7XG4gICAgfVxuICB9LFxufTtcbnZhciBDb250cm9sbGVyJDEgPSB7XG4gIG5hbWU6ICdjb250cm9sbGVyJyxcbiAgcGFyYW1zOiB7XG4gICAgY29udHJvbGxlcjoge1xuICAgICAgY29udHJvbDogdW5kZWZpbmVkLFxuICAgICAgaW52ZXJzZTogZmFsc2UsXG4gICAgICBieTogJ3NsaWRlJywgLy8gb3IgJ2NvbnRhaW5lcidcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBjb250cm9sbGVyOiB7XG4gICAgICAgIGNvbnRyb2w6IHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5jb250cm9sLFxuICAgICAgICBnZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uOiBDb250cm9sbGVyLmdldEludGVycG9sYXRlRnVuY3Rpb24uYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2xhdGU6IENvbnRyb2xsZXIuc2V0VHJhbnNsYXRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbjogQ29udHJvbGxlci5zZXRUcmFuc2l0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgdXBkYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkgcmV0dXJuO1xuICAgICAgaWYgKHN3aXBlci5jb250cm9sbGVyLnNwbGluZSkge1xuICAgICAgICBzd2lwZXIuY29udHJvbGxlci5zcGxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRlbGV0ZSBzd2lwZXIuY29udHJvbGxlci5zcGxpbmU7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNpemUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XG4gICAgICBpZiAoc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lKSB7XG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLnNwbGluZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGVsZXRlIHN3aXBlci5jb250cm9sbGVyLnNwbGluZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkgcmV0dXJuO1xuICAgICAgaWYgKHN3aXBlci5jb250cm9sbGVyLnNwbGluZSkge1xuICAgICAgICBzd2lwZXIuY29udHJvbGxlci5zcGxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRlbGV0ZSBzd2lwZXIuY29udHJvbGxlci5zcGxpbmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRUcmFuc2xhdGUodHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpIHJldHVybjtcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcik7XG4gICAgfSxcbiAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpIHJldHVybjtcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLnNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IGExMXkgPSB7XG4gIG1ha2VFbEZvY3VzYWJsZSgkZWwpIHtcbiAgICAkZWwuYXR0cigndGFiSW5kZXgnLCAnMCcpO1xuICAgIHJldHVybiAkZWw7XG4gIH0sXG4gIGFkZEVsUm9sZSgkZWwsIHJvbGUpIHtcbiAgICAkZWwuYXR0cigncm9sZScsIHJvbGUpO1xuICAgIHJldHVybiAkZWw7XG4gIH0sXG4gIGFkZEVsTGFiZWwoJGVsLCBsYWJlbCkge1xuICAgICRlbC5hdHRyKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgIHJldHVybiAkZWw7XG4gIH0sXG4gIGRpc2FibGVFbCgkZWwpIHtcbiAgICAkZWwuYXR0cignYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xuICAgIHJldHVybiAkZWw7XG4gIH0sXG4gIGVuYWJsZUVsKCRlbCkge1xuICAgICRlbC5hdHRyKCdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xuICAgIHJldHVybiAkZWw7XG4gIH0sXG4gIG9uRW50ZXJLZXkoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5hMTF5O1xuICAgIGlmIChlLmtleUNvZGUgIT09IDEzKSByZXR1cm47XG4gICAgY29uc3QgJHRhcmdldEVsID0gJChlLnRhcmdldCk7XG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWwgJiYgJHRhcmdldEVsLmlzKHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWwpKSB7XG4gICAgICBpZiAoIShzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgICBzd2lwZXIuYTExeS5ub3RpZnkocGFyYW1zLmxhc3RTbGlkZU1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLmExMXkubm90aWZ5KHBhcmFtcy5uZXh0U2xpZGVNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwgJiYgJHRhcmdldEVsLmlzKHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwpKSB7XG4gICAgICBpZiAoIShzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgfVxuICAgICAgaWYgKHN3aXBlci5pc0JlZ2lubmluZykge1xuICAgICAgICBzd2lwZXIuYTExeS5ub3RpZnkocGFyYW1zLmZpcnN0U2xpZGVNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5hMTF5Lm5vdGlmeShwYXJhbXMucHJldlNsaWRlTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiAkdGFyZ2V0RWwuaXMoYC4ke3N3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzc31gKSkge1xuICAgICAgJHRhcmdldEVsWzBdLmNsaWNrKCk7XG4gICAgfVxuICB9LFxuICBub3RpZnkobWVzc2FnZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gc3dpcGVyLmExMXkubGl2ZVJlZ2lvbjtcbiAgICBpZiAobm90aWZpY2F0aW9uLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIG5vdGlmaWNhdGlvbi5odG1sKCcnKTtcbiAgICBub3RpZmljYXRpb24uaHRtbChtZXNzYWdlKTtcbiAgfSxcbiAgdXBkYXRlTmF2aWdhdGlvbigpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgJG5leHRFbCwgJHByZXZFbCB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG5cbiAgICBpZiAoJHByZXZFbCAmJiAkcHJldkVsLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgc3dpcGVyLmExMXkuZGlzYWJsZUVsKCRwcmV2RWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLmExMXkuZW5hYmxlRWwoJHByZXZFbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgICBzd2lwZXIuYTExeS5kaXNhYmxlRWwoJG5leHRFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuYTExeS5lbmFibGVFbCgkbmV4dEVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHVwZGF0ZVBhZ2luYXRpb24oKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XG4gICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCkge1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5lYWNoKChidWxsZXRJbmRleCwgYnVsbGV0RWwpID0+IHtcbiAgICAgICAgY29uc3QgJGJ1bGxldEVsID0gJChidWxsZXRFbCk7XG4gICAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkYnVsbGV0RWwpO1xuICAgICAgICBzd2lwZXIuYTExeS5hZGRFbFJvbGUoJGJ1bGxldEVsLCAnYnV0dG9uJyk7XG4gICAgICAgIHN3aXBlci5hMTF5LmFkZEVsTGFiZWwoJGJ1bGxldEVsLCBwYXJhbXMucGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2UucmVwbGFjZSgve3tpbmRleH19LywgJGJ1bGxldEVsLmluZGV4KCkgKyAxKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgIHN3aXBlci4kZWwuYXBwZW5kKHN3aXBlci5hMTF5LmxpdmVSZWdpb24pO1xuXG4gICAgLy8gTmF2aWdhdGlvblxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuYTExeTtcbiAgICBsZXQgJG5leHRFbDtcbiAgICBsZXQgJHByZXZFbDtcbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJG5leHRFbCkge1xuICAgICAgJG5leHRFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWw7XG4gICAgfVxuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kcHJldkVsKSB7XG4gICAgICAkcHJldkVsID0gc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbDtcbiAgICB9XG4gICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkbmV4dEVsKTtcbiAgICAgIHN3aXBlci5hMTF5LmFkZEVsUm9sZSgkbmV4dEVsLCAnYnV0dG9uJyk7XG4gICAgICBzd2lwZXIuYTExeS5hZGRFbExhYmVsKCRuZXh0RWwsIHBhcmFtcy5uZXh0U2xpZGVNZXNzYWdlKTtcbiAgICAgICRuZXh0RWwub24oJ2tleWRvd24nLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcbiAgICB9XG4gICAgaWYgKCRwcmV2RWwpIHtcbiAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkcHJldkVsKTtcbiAgICAgIHN3aXBlci5hMTF5LmFkZEVsUm9sZSgkcHJldkVsLCAnYnV0dG9uJyk7XG4gICAgICBzd2lwZXIuYTExeS5hZGRFbExhYmVsKCRwcmV2RWwsIHBhcmFtcy5wcmV2U2xpZGVNZXNzYWdlKTtcbiAgICAgICRwcmV2RWwub24oJ2tleWRvd24nLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcbiAgICB9XG5cbiAgICAvLyBQYWdpbmF0aW9uXG4gICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCkge1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uJGVsLm9uKCdrZXlkb3duJywgYC4ke3N3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzc31gLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLmExMXkubGl2ZVJlZ2lvbiAmJiBzd2lwZXIuYTExeS5saXZlUmVnaW9uLmxlbmd0aCA+IDApIHN3aXBlci5hMTF5LmxpdmVSZWdpb24ucmVtb3ZlKCk7XG5cbiAgICBsZXQgJG5leHRFbDtcbiAgICBsZXQgJHByZXZFbDtcbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJG5leHRFbCkge1xuICAgICAgJG5leHRFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWw7XG4gICAgfVxuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kcHJldkVsKSB7XG4gICAgICAkcHJldkVsID0gc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbDtcbiAgICB9XG4gICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgICRuZXh0RWwub2ZmKCdrZXlkb3duJywgc3dpcGVyLmExMXkub25FbnRlcktleSk7XG4gICAgfVxuICAgIGlmICgkcHJldkVsKSB7XG4gICAgICAkcHJldkVsLm9mZigna2V5ZG93bicsIHN3aXBlci5hMTF5Lm9uRW50ZXJLZXkpO1xuICAgIH1cblxuICAgIC8vIFBhZ2luYXRpb25cbiAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24gJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZSAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoKSB7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi4kZWwub2ZmKCdrZXlkb3duJywgYC4ke3N3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzc31gLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcbiAgICB9XG4gIH0sXG59O1xudmFyIEExMXkgPSB7XG4gIG5hbWU6ICdhMTF5JyxcbiAgcGFyYW1zOiB7XG4gICAgYTExeToge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIG5vdGlmaWNhdGlvbkNsYXNzOiAnc3dpcGVyLW5vdGlmaWNhdGlvbicsXG4gICAgICBwcmV2U2xpZGVNZXNzYWdlOiAnUHJldmlvdXMgc2xpZGUnLFxuICAgICAgbmV4dFNsaWRlTWVzc2FnZTogJ05leHQgc2xpZGUnLFxuICAgICAgZmlyc3RTbGlkZU1lc3NhZ2U6ICdUaGlzIGlzIHRoZSBmaXJzdCBzbGlkZScsXG4gICAgICBsYXN0U2xpZGVNZXNzYWdlOiAnVGhpcyBpcyB0aGUgbGFzdCBzbGlkZScsXG4gICAgICBwYWdpbmF0aW9uQnVsbGV0TWVzc2FnZTogJ0dvIHRvIHNsaWRlIHt7aW5kZXh9fScsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgYTExeToge1xuICAgICAgICBsaXZlUmVnaW9uOiAkKGA8c3BhbiBjbGFzcz1cIiR7c3dpcGVyLnBhcmFtcy5hMTF5Lm5vdGlmaWNhdGlvbkNsYXNzfVwiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiPjwvc3Bhbj5gKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoYTExeSkuZm9yRWFjaCgobWV0aG9kTmFtZSkgPT4ge1xuICAgICAgc3dpcGVyLmExMXlbbWV0aG9kTmFtZV0gPSBhMTF5W21ldGhvZE5hbWVdLmJpbmQoc3dpcGVyKTtcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci5hMTF5LmluaXQoKTtcbiAgICAgIHN3aXBlci5hMTF5LnVwZGF0ZU5hdmlnYXRpb24oKTtcbiAgICB9LFxuICAgIHRvRWRnZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuYTExeS51cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBmcm9tRWRnZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuYTExeS51cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBwYWdpbmF0aW9uVXBkYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci5hMTF5LnVwZGF0ZVBhZ2luYXRpb24oKTtcbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLmExMXkuZGVzdHJveSgpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBIaXN0b3J5ID0ge1xuICBpbml0KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmhpc3RvcnkpIHJldHVybjtcbiAgICBpZiAoIXdpbmRvdy5oaXN0b3J5IHx8ICF3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcbiAgICAgIHN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkID0gZmFsc2U7XG4gICAgICBzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5ID0gc3dpcGVyLmhpc3Rvcnk7XG4gICAgaGlzdG9yeS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgaGlzdG9yeS5wYXRocyA9IEhpc3RvcnkuZ2V0UGF0aFZhbHVlcygpO1xuICAgIGlmICghaGlzdG9yeS5wYXRocy5rZXkgJiYgIWhpc3RvcnkucGF0aHMudmFsdWUpIHJldHVybjtcbiAgICBoaXN0b3J5LnNjcm9sbFRvU2xpZGUoMCwgaGlzdG9yeS5wYXRocy52YWx1ZSwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgc3dpcGVyLmhpc3Rvcnkuc2V0SGlzdG9yeVBvcFN0YXRlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHN3aXBlci5oaXN0b3J5LnNldEhpc3RvcnlQb3BTdGF0ZSk7XG4gICAgfVxuICB9LFxuICBzZXRIaXN0b3J5UG9wU3RhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBzd2lwZXIuaGlzdG9yeS5wYXRocyA9IEhpc3RvcnkuZ2V0UGF0aFZhbHVlcygpO1xuICAgIHN3aXBlci5oaXN0b3J5LnNjcm9sbFRvU2xpZGUoc3dpcGVyLnBhcmFtcy5zcGVlZCwgc3dpcGVyLmhpc3RvcnkucGF0aHMudmFsdWUsIGZhbHNlKTtcbiAgfSxcbiAgZ2V0UGF0aFZhbHVlcygpIHtcbiAgICBjb25zdCBwYXRoQXJyYXkgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc2xpY2UoMSkuc3BsaXQoJy8nKS5maWx0ZXIocGFydCA9PiBwYXJ0ICE9PSAnJyk7XG4gICAgY29uc3QgdG90YWwgPSBwYXRoQXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IGtleSA9IHBhdGhBcnJheVt0b3RhbCAtIDJdO1xuICAgIGNvbnN0IHZhbHVlID0gcGF0aEFycmF5W3RvdGFsIC0gMV07XG4gICAgcmV0dXJuIHsga2V5LCB2YWx1ZSB9O1xuICB9LFxuICBzZXRIaXN0b3J5KGtleSwgaW5kZXgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLmhpc3RvcnkuaW5pdGlhbGl6ZWQgfHwgIXN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSByZXR1cm47XG4gICAgY29uc3Qgc2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGluZGV4KTtcbiAgICBsZXQgdmFsdWUgPSBIaXN0b3J5LnNsdWdpZnkoc2xpZGUuYXR0cignZGF0YS1oaXN0b3J5JykpO1xuICAgIGlmICghd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHZhbHVlID0gYCR7a2V5fS8ke3ZhbHVlfWA7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlO1xuICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsgdmFsdWUgfSwgbnVsbCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyB2YWx1ZSB9LCBudWxsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBzbHVnaWZ5KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC50b1N0cmluZygpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvW15cXHctXSsvZywgJycpXG4gICAgICAucmVwbGFjZSgvLS0rL2csICctJylcbiAgICAgIC5yZXBsYWNlKC9eLSsvLCAnJylcbiAgICAgIC5yZXBsYWNlKC8tKyQvLCAnJyk7XG4gIH0sXG4gIHNjcm9sbFRvU2xpZGUoc3BlZWQsIHZhbHVlLCBydW5DYWxsYmFja3MpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xuICAgICAgICBjb25zdCBzbGlkZUhpc3RvcnkgPSBIaXN0b3J5LnNsdWdpZnkoc2xpZGUuYXR0cignZGF0YS1oaXN0b3J5JykpO1xuICAgICAgICBpZiAoc2xpZGVIaXN0b3J5ID09PSB2YWx1ZSAmJiAhc2xpZGUuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGUuaW5kZXgoKTtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oMCwgc3BlZWQsIHJ1bkNhbGxiYWNrcyk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIEhpc3RvcnkkMSA9IHtcbiAgbmFtZTogJ2hpc3RvcnknLFxuICBwYXJhbXM6IHtcbiAgICBoaXN0b3J5OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogZmFsc2UsXG4gICAgICBrZXk6ICdzbGlkZXMnLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgaW5pdDogSGlzdG9yeS5pbml0LmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0SGlzdG9yeTogSGlzdG9yeS5zZXRIaXN0b3J5LmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0SGlzdG9yeVBvcFN0YXRlOiBIaXN0b3J5LnNldEhpc3RvcnlQb3BTdGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNjcm9sbFRvU2xpZGU6IEhpc3Rvcnkuc2Nyb2xsVG9TbGlkZS5iaW5kKHN3aXBlciksXG4gICAgICAgIGRlc3Ryb3k6IEhpc3RvcnkuZGVzdHJveS5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5oaXN0b3J5LmluaXQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5oaXN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zaXRpb25FbmQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5oaXN0b3J5LmluaXRpYWxpemVkKSB7XG4gICAgICAgIHN3aXBlci5oaXN0b3J5LnNldEhpc3Rvcnkoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmtleSwgc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgSGFzaE5hdmlnYXRpb24gPSB7XG4gIG9uSGFzaENhbmdlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgbmV3SGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKTtcbiAgICBjb25zdCBhY3RpdmVTbGlkZUhhc2ggPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCkuYXR0cignZGF0YS1oYXNoJyk7XG4gICAgaWYgKG5ld0hhc2ggIT09IGFjdGl2ZVNsaWRlSGFzaCkge1xuICAgICAgY29uc3QgbmV3SW5kZXggPSBzd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLWhhc2g9XCIke25ld0hhc2h9XCJdYCkuaW5kZXgoKTtcbiAgICAgIGlmICh0eXBlb2YgbmV3SW5kZXggPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCk7XG4gICAgfVxuICB9LFxuICBzZXRIYXNoKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQgfHwgIXN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLnJlcGxhY2VTdGF0ZSAmJiB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCAoYCMke3N3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KS5hdHRyKCdkYXRhLWhhc2gnKX1gIHx8ICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgY29uc3QgaGFzaCA9IHNsaWRlLmF0dHIoJ2RhdGEtaGFzaCcpIHx8IHNsaWRlLmF0dHIoJ2RhdGEtaGlzdG9yeScpO1xuICAgICAgZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGhhc2ggfHwgJyc7XG4gICAgfVxuICB9LFxuICBpbml0KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgfHwgKHN3aXBlci5wYXJhbXMuaGlzdG9yeSAmJiBzd2lwZXIucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCkpIHJldHVybjtcbiAgICBzd2lwZXIuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGhhc2ggPSBkb2N1bWVudC5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgaWYgKGhhc2gpIHtcbiAgICAgIGNvbnN0IHNwZWVkID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlcy5lcShpKTtcbiAgICAgICAgY29uc3Qgc2xpZGVIYXNoID0gc2xpZGUuYXR0cignZGF0YS1oYXNoJykgfHwgc2xpZGUuYXR0cignZGF0YS1oaXN0b3J5Jyk7XG4gICAgICAgIGlmIChzbGlkZUhhc2ggPT09IGhhc2ggJiYgIXNsaWRlLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHNsaWRlLmluZGV4KCk7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSkge1xuICAgICAgJCh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlJywgc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLm9uSGFzaENhbmdlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi53YXRjaFN0YXRlKSB7XG4gICAgICAkKHdpbmRvdykub2ZmKCdoYXNoY2hhbmdlJywgc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLm9uSGFzaENhbmdlKTtcbiAgICB9XG4gIH0sXG59O1xudmFyIEhhc2hOYXZpZ2F0aW9uJDEgPSB7XG4gIG5hbWU6ICdoYXNoLW5hdmlnYXRpb24nLFxuICBwYXJhbXM6IHtcbiAgICBoYXNoTmF2aWdhdGlvbjoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICByZXBsYWNlU3RhdGU6IGZhbHNlLFxuICAgICAgd2F0Y2hTdGF0ZTogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgaGFzaE5hdmlnYXRpb246IHtcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICBpbml0OiBIYXNoTmF2aWdhdGlvbi5pbml0LmJpbmQoc3dpcGVyKSxcbiAgICAgICAgZGVzdHJveTogSGFzaE5hdmlnYXRpb24uZGVzdHJveS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldEhhc2g6IEhhc2hOYXZpZ2F0aW9uLnNldEhhc2guYmluZChzd2lwZXIpLFxuICAgICAgICBvbkhhc2hDYW5nZTogSGFzaE5hdmlnYXRpb24ub25IYXNoQ2FuZ2UuYmluZChzd2lwZXIpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLmluaXQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuaGFzaE5hdmlnYXRpb24uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHN3aXBlci5oYXNoTmF2aWdhdGlvbi5zZXRIYXNoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbi8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogXCJvZmZcIiAqL1xuXG5jb25zdCBBdXRvcGxheSA9IHtcbiAgcnVuKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgJGFjdGl2ZVNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgbGV0IGRlbGF5ID0gc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcbiAgICBpZiAoJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSkge1xuICAgICAgZGVsYXkgPSAkYWN0aXZlU2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1hdXRvcGxheScpIHx8IHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGVsYXk7XG4gICAgfVxuICAgIHN3aXBlci5hdXRvcGxheS50aW1lb3V0ID0gVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkucmV2ZXJzZURpcmVjdGlvbikge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICB9IGVsc2UgaWYgKCFzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICB9IGVsc2UgaWYgKCFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbygwLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIGRlbGF5KTtcbiAgfSxcbiAgc3RhcnQoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHN3aXBlci5hdXRvcGxheS50aW1lb3V0ICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nID0gdHJ1ZTtcbiAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXlTdGFydCcpO1xuICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgc3RvcCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHN3aXBlci5hdXRvcGxheS50aW1lb3V0ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQpO1xuICAgICAgc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nID0gZmFsc2U7XG4gICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5U3RvcCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwYXVzZShzcGVlZCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuO1xuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS50aW1lb3V0KSBjbGVhclRpbWVvdXQoc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQpO1xuICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSB0cnVlO1xuICAgIGlmIChzcGVlZCA9PT0gMCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIEF1dG9wbGF5JDEgPSB7XG4gIG5hbWU6ICdhdXRvcGxheScsXG4gIHBhcmFtczoge1xuICAgIGF1dG9wbGF5OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGRlbGF5OiAzMDAwLFxuICAgICAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXG4gICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogdHJ1ZSxcbiAgICAgIHN0b3BPbkxhc3RTbGlkZTogZmFsc2UsXG4gICAgICByZXZlcnNlRGlyZWN0aW9uOiBmYWxzZSxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBhdXRvcGxheToge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcnVuOiBBdXRvcGxheS5ydW4uYmluZChzd2lwZXIpLFxuICAgICAgICBzdGFydDogQXV0b3BsYXkuc3RhcnQuYmluZChzd2lwZXIpLFxuICAgICAgICBzdG9wOiBBdXRvcGxheS5zdG9wLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgcGF1c2U6IEF1dG9wbGF5LnBhdXNlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuJHdyYXBwZXJFbCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZVRyYW5zaXRpb25TdGFydChzcGVlZCwgaW50ZXJuYWwpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgaWYgKGludGVybmFsIHx8ICFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKHNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzbGlkZXJGaXJzdE1vdmUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgRmFkZSA9IHtcbiAgc2V0VHJhbnNsYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyBzbGlkZXMgfSA9IHN3aXBlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgJHNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gJHNsaWRlRWxbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICBsZXQgdHggPSAtb2Zmc2V0O1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHR4IC09IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBsZXQgdHkgPSAwO1xuICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgdHkgPSB0eDtcbiAgICAgICAgdHggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVPcGFjaXR5ID0gc3dpcGVyLnBhcmFtcy5mYWRlRWZmZWN0LmNyb3NzRmFkZVxuICAgICAgICA/IE1hdGgubWF4KDEgLSBNYXRoLmFicygkc2xpZGVFbFswXS5wcm9ncmVzcyksIDApXG4gICAgICAgIDogMSArIE1hdGgubWluKE1hdGgubWF4KCRzbGlkZUVsWzBdLnByb2dyZXNzLCAtMSksIDApO1xuICAgICAgJHNsaWRlRWxcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgb3BhY2l0eTogc2xpZGVPcGFjaXR5LFxuICAgICAgICB9KVxuICAgICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3R4fXB4LCAke3R5fXB4LCAwcHgpYCk7XG4gICAgfVxuICB9LFxuICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHNsaWRlcywgJHdyYXBwZXJFbCB9ID0gc3dpcGVyO1xuICAgIHNsaWRlcy50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICBsZXQgZXZlbnRUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIHNsaWRlcy50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50VHJpZ2dlcmVkKSByZXR1cm47XG4gICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgZXZlbnRUcmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJFdmVudHMgPSBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWdnZXJFdmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAkd3JhcHBlckVsLnRyaWdnZXIodHJpZ2dlckV2ZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBFZmZlY3RGYWRlID0ge1xuICBuYW1lOiAnZWZmZWN0LWZhZGUnLFxuICBwYXJhbXM6IHtcbiAgICBmYWRlRWZmZWN0OiB7XG4gICAgICBjcm9zc0ZhZGU6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGZhZGVFZmZlY3Q6IHtcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBGYWRlLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldFRyYW5zaXRpb246IEZhZGUuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGJlZm9yZUluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnZmFkZScpIHJldHVybjtcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWZhZGVgKTtcbiAgICAgIGNvbnN0IG92ZXJ3cml0ZVBhcmFtcyA9IHtcbiAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgICAgc2xpZGVzUGVyQ29sdW1uOiAxLFxuICAgICAgICBzbGlkZXNQZXJHcm91cDogMSxcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxuICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIucGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5vcmlnaW5hbFBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmYWRlJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmZhZGVFZmZlY3Quc2V0VHJhbnNsYXRlKCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnZmFkZScpIHJldHVybjtcbiAgICAgIHN3aXBlci5mYWRlRWZmZWN0LnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBDdWJlID0ge1xuICBzZXRUcmFuc2xhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICAkZWwsICR3cmFwcGVyRWwsIHNsaWRlcywgd2lkdGg6IHN3aXBlcldpZHRoLCBoZWlnaHQ6IHN3aXBlckhlaWdodCwgcnRsVHJhbnNsYXRlOiBydGwsIHNpemU6IHN3aXBlclNpemUsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmN1YmVFZmZlY3Q7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgIGxldCB3cmFwcGVyUm90YXRlID0gMDtcbiAgICBsZXQgJGN1YmVTaGFkb3dFbDtcbiAgICBpZiAocGFyYW1zLnNoYWRvdykge1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAkY3ViZVNoYWRvd0VsID0gJHdyYXBwZXJFbC5maW5kKCcuc3dpcGVyLWN1YmUtc2hhZG93Jyk7XG4gICAgICAgIGlmICgkY3ViZVNoYWRvd0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICRjdWJlU2hhZG93RWwgPSAkKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgJHdyYXBwZXJFbC5hcHBlbmQoJGN1YmVTaGFkb3dFbCk7XG4gICAgICAgIH1cbiAgICAgICAgJGN1YmVTaGFkb3dFbC5jc3MoeyBoZWlnaHQ6IGAke3N3aXBlcldpZHRofXB4YCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRjdWJlU2hhZG93RWwgPSAkZWwuZmluZCgnLnN3aXBlci1jdWJlLXNoYWRvdycpO1xuICAgICAgICBpZiAoJGN1YmVTaGFkb3dFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAkY3ViZVNoYWRvd0VsID0gJCgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpO1xuICAgICAgICAgICRlbC5hcHBlbmQoJGN1YmVTaGFkb3dFbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0ICRzbGlkZUVsID0gc2xpZGVzLmVxKGkpO1xuICAgICAgbGV0IHNsaWRlSW5kZXggPSBpO1xuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICBzbGlkZUluZGV4ID0gcGFyc2VJbnQoJHNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgICAgfVxuICAgICAgbGV0IHNsaWRlQW5nbGUgPSBzbGlkZUluZGV4ICogOTA7XG4gICAgICBsZXQgcm91bmQgPSBNYXRoLmZsb29yKHNsaWRlQW5nbGUgLyAzNjApO1xuICAgICAgaWYgKHJ0bCkge1xuICAgICAgICBzbGlkZUFuZ2xlID0gLXNsaWRlQW5nbGU7XG4gICAgICAgIHJvdW5kID0gTWF0aC5mbG9vcigtc2xpZGVBbmdsZSAvIDM2MCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCRzbGlkZUVsWzBdLnByb2dyZXNzLCAxKSwgLTEpO1xuICAgICAgbGV0IHR4ID0gMDtcbiAgICAgIGxldCB0eSA9IDA7XG4gICAgICBsZXQgdHogPSAwO1xuICAgICAgaWYgKHNsaWRlSW5kZXggJSA0ID09PSAwKSB7XG4gICAgICAgIHR4ID0gLXJvdW5kICogNCAqIHN3aXBlclNpemU7XG4gICAgICAgIHR6ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoKHNsaWRlSW5kZXggLSAxKSAlIDQgPT09IDApIHtcbiAgICAgICAgdHggPSAwO1xuICAgICAgICB0eiA9IC1yb3VuZCAqIDQgKiBzd2lwZXJTaXplO1xuICAgICAgfSBlbHNlIGlmICgoc2xpZGVJbmRleCAtIDIpICUgNCA9PT0gMCkge1xuICAgICAgICB0eCA9IHN3aXBlclNpemUgKyAocm91bmQgKiA0ICogc3dpcGVyU2l6ZSk7XG4gICAgICAgIHR6ID0gc3dpcGVyU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoKHNsaWRlSW5kZXggLSAzKSAlIDQgPT09IDApIHtcbiAgICAgICAgdHggPSAtc3dpcGVyU2l6ZTtcbiAgICAgICAgdHogPSAoMyAqIHN3aXBlclNpemUpICsgKHN3aXBlclNpemUgKiA0ICogcm91bmQpO1xuICAgICAgfVxuICAgICAgaWYgKHJ0bCkge1xuICAgICAgICB0eCA9IC10eDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHkgPSB0eDtcbiAgICAgICAgdHggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgcm90YXRlWCgke2lzSG9yaXpvbnRhbCA/IDAgOiAtc2xpZGVBbmdsZX1kZWcpIHJvdGF0ZVkoJHtpc0hvcml6b250YWwgPyBzbGlkZUFuZ2xlIDogMH1kZWcpIHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsICR7dHp9cHgpYDtcbiAgICAgIGlmIChwcm9ncmVzcyA8PSAxICYmIHByb2dyZXNzID4gLTEpIHtcbiAgICAgICAgd3JhcHBlclJvdGF0ZSA9IChzbGlkZUluZGV4ICogOTApICsgKHByb2dyZXNzICogOTApO1xuICAgICAgICBpZiAocnRsKSB3cmFwcGVyUm90YXRlID0gKC1zbGlkZUluZGV4ICogOTApIC0gKHByb2dyZXNzICogOTApO1xuICAgICAgfVxuICAgICAgJHNsaWRlRWwudHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICBpZiAocGFyYW1zLnNsaWRlU2hhZG93cykge1xuICAgICAgICAvLyBTZXQgc2hhZG93c1xuICAgICAgICBsZXQgc2hhZG93QmVmb3JlID0gaXNIb3Jpem9udGFsID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XG4gICAgICAgIGxldCBzaGFkb3dBZnRlciA9IGlzSG9yaXpvbnRhbCA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JykgOiAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20nKTtcbiAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBzaGFkb3dCZWZvcmUgPSAkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke2lzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnfVwiPjwvZGl2PmApO1xuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZChzaGFkb3dCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFkb3dBZnRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBzaGFkb3dBZnRlciA9ICQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7aXNIb3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nfVwiPjwvZGl2PmApO1xuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZChzaGFkb3dBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGgpIHNoYWRvd0JlZm9yZVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoLXByb2dyZXNzLCAwKTtcbiAgICAgICAgaWYgKHNoYWRvd0FmdGVyLmxlbmd0aCkgc2hhZG93QWZ0ZXJbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KHByb2dyZXNzLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgJHdyYXBwZXJFbC5jc3Moe1xuICAgICAgJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcbiAgICAgICctbW96LXRyYW5zZm9ybS1vcmlnaW4nOiBgNTAlIDUwJSAtJHtzd2lwZXJTaXplIC8gMn1weGAsXG4gICAgICAnLW1zLXRyYW5zZm9ybS1vcmlnaW4nOiBgNTAlIDUwJSAtJHtzd2lwZXJTaXplIC8gMn1weGAsXG4gICAgICAndHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcbiAgICB9KTtcblxuICAgIGlmIChwYXJhbXMuc2hhZG93KSB7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICRjdWJlU2hhZG93RWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsICR7KHN3aXBlcldpZHRoIC8gMikgKyBwYXJhbXMuc2hhZG93T2Zmc2V0fXB4LCAkey1zd2lwZXJXaWR0aCAvIDJ9cHgpIHJvdGF0ZVgoOTBkZWcpIHJvdGF0ZVooMGRlZykgc2NhbGUoJHtwYXJhbXMuc2hhZG93U2NhbGV9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2hhZG93QW5nbGUgPSBNYXRoLmFicyh3cmFwcGVyUm90YXRlKSAtIChNYXRoLmZsb29yKE1hdGguYWJzKHdyYXBwZXJSb3RhdGUpIC8gOTApICogOTApO1xuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gMS41IC0gKFxuICAgICAgICAgIChNYXRoLnNpbigoc2hhZG93QW5nbGUgKiAyICogTWF0aC5QSSkgLyAzNjApIC8gMilcbiAgICAgICAgICArIChNYXRoLmNvcygoc2hhZG93QW5nbGUgKiAyICogTWF0aC5QSSkgLyAzNjApIC8gMilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc2NhbGUxID0gcGFyYW1zLnNoYWRvd1NjYWxlO1xuICAgICAgICBjb25zdCBzY2FsZTIgPSBwYXJhbXMuc2hhZG93U2NhbGUgLyBtdWx0aXBsaWVyO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJhbXMuc2hhZG93T2Zmc2V0O1xuICAgICAgICAkY3ViZVNoYWRvd0VsLnRyYW5zZm9ybShgc2NhbGUzZCgke3NjYWxlMX0sIDEsICR7c2NhbGUyfSkgdHJhbnNsYXRlM2QoMHB4LCAkeyhzd2lwZXJIZWlnaHQgLyAyKSArIG9mZnNldH1weCwgJHstc3dpcGVySGVpZ2h0IC8gMiAvIHNjYWxlMn1weCkgcm90YXRlWCgtOTBkZWcpYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHpGYWN0b3IgPSAoQnJvd3Nlci5pc1NhZmFyaSB8fCBCcm93c2VyLmlzVWlXZWJWaWV3KSA/ICgtc3dpcGVyU2l6ZSAvIDIpIDogMDtcbiAgICAkd3JhcHBlckVsXG4gICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsMCwke3pGYWN0b3J9cHgpIHJvdGF0ZVgoJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAwIDogd3JhcHBlclJvdGF0ZX1kZWcpIHJvdGF0ZVkoJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAtd3JhcHBlclJvdGF0ZSA6IDB9ZGVnKWApO1xuICB9LFxuICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7ICRlbCwgc2xpZGVzIH0gPSBzd2lwZXI7XG4gICAgc2xpZGVzXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbilcbiAgICAgIC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKVxuICAgICAgLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93ICYmICFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICRlbC5maW5kKCcuc3dpcGVyLWN1YmUtc2hhZG93JykudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfVxuICB9LFxufTtcblxudmFyIEVmZmVjdEN1YmUgPSB7XG4gIG5hbWU6ICdlZmZlY3QtY3ViZScsXG4gIHBhcmFtczoge1xuICAgIGN1YmVFZmZlY3Q6IHtcbiAgICAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgICAgIHNoYWRvdzogdHJ1ZSxcbiAgICAgIHNoYWRvd09mZnNldDogMjAsXG4gICAgICBzaGFkb3dTY2FsZTogMC45NCxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBjdWJlRWZmZWN0OiB7XG4gICAgICAgIHNldFRyYW5zbGF0ZTogQ3ViZS5zZXRUcmFuc2xhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBDdWJlLnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBiZWZvcmVJbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2N1YmUnKSByZXR1cm47XG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31jdWJlYCk7XG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30zZGApO1xuICAgICAgY29uc3Qgb3ZlcndyaXRlUGFyYW1zID0ge1xuICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICBzbGlkZXNQZXJDb2x1bW46IDEsXG4gICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICByZXNpc3RhbmNlUmF0aW86IDAsXG4gICAgICAgIHNwYWNlQmV0d2VlbjogMCxcbiAgICAgICAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxuICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIucGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5vcmlnaW5hbFBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjdWJlJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmN1YmVFZmZlY3Quc2V0VHJhbnNsYXRlKCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY3ViZScpIHJldHVybjtcbiAgICAgIHN3aXBlci5jdWJlRWZmZWN0LnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBGbGlwID0ge1xuICBzZXRUcmFuc2xhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHNsaWRlcywgcnRsVHJhbnNsYXRlOiBydGwgfSA9IHN3aXBlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgJHNsaWRlRWwgPSBzbGlkZXMuZXEoaSk7XG4gICAgICBsZXQgcHJvZ3Jlc3MgPSAkc2xpZGVFbFswXS5wcm9ncmVzcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZsaXBFZmZlY3QubGltaXRSb3RhdGlvbikge1xuICAgICAgICBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCRzbGlkZUVsWzBdLnByb2dyZXNzLCAxKSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gJHNsaWRlRWxbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICBjb25zdCByb3RhdGUgPSAtMTgwICogcHJvZ3Jlc3M7XG4gICAgICBsZXQgcm90YXRlWSA9IHJvdGF0ZTtcbiAgICAgIGxldCByb3RhdGVYID0gMDtcbiAgICAgIGxldCB0eCA9IC1vZmZzZXQ7XG4gICAgICBsZXQgdHkgPSAwO1xuICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgdHkgPSB0eDtcbiAgICAgICAgdHggPSAwO1xuICAgICAgICByb3RhdGVYID0gLXJvdGF0ZVk7XG4gICAgICAgIHJvdGF0ZVkgPSAwO1xuICAgICAgfSBlbHNlIGlmIChydGwpIHtcbiAgICAgICAgcm90YXRlWSA9IC1yb3RhdGVZO1xuICAgICAgfVxuXG4gICAgICAkc2xpZGVFbFswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChwcm9ncmVzcykpICsgc2xpZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZmxpcEVmZmVjdC5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgLy8gU2V0IHNoYWRvd3NcbiAgICAgICAgbGV0IHNoYWRvd0JlZm9yZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCcpO1xuICAgICAgICBsZXQgc2hhZG93QWZ0ZXIgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJyk7XG4gICAgICAgIGlmIChzaGFkb3dCZWZvcmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc2hhZG93QmVmb3JlID0gJChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJ31cIj48L2Rpdj5gKTtcbiAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoc2hhZG93QmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhZG93QWZ0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc2hhZG93QWZ0ZXIgPSAkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdyaWdodCcgOiAnYm90dG9tJ31cIj48L2Rpdj5gKTtcbiAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoc2hhZG93QWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFkb3dCZWZvcmUubGVuZ3RoKSBzaGFkb3dCZWZvcmVbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC1wcm9ncmVzcywgMCk7XG4gICAgICAgIGlmIChzaGFkb3dBZnRlci5sZW5ndGgpIHNoYWRvd0FmdGVyWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heChwcm9ncmVzcywgMCk7XG4gICAgICB9XG4gICAgICAkc2xpZGVFbFxuICAgICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3R4fXB4LCAke3R5fXB4LCAwcHgpIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKWApO1xuICAgIH1cbiAgfSxcbiAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyBzbGlkZXMsIGFjdGl2ZUluZGV4LCAkd3JhcHBlckVsIH0gPSBzd2lwZXI7XG4gICAgc2xpZGVzXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbilcbiAgICAgIC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKVxuICAgICAgLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgZHVyYXRpb24gIT09IDApIHtcbiAgICAgIGxldCBldmVudFRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKCkge1xuICAgICAgICBpZiAoZXZlbnRUcmlnZ2VyZWQpIHJldHVybjtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAvLyBpZiAoISQodGhpcykuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKSkgcmV0dXJuO1xuICAgICAgICBldmVudFRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHJpZ2dlckV2ZW50cyA9IFsnd2Via2l0VHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICR3cmFwcGVyRWwudHJpZ2dlcih0cmlnZ2VyRXZlbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIEVmZmVjdEZsaXAgPSB7XG4gIG5hbWU6ICdlZmZlY3QtZmxpcCcsXG4gIHBhcmFtczoge1xuICAgIGZsaXBFZmZlY3Q6IHtcbiAgICAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgICAgIGxpbWl0Um90YXRpb246IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgZmxpcEVmZmVjdDoge1xuICAgICAgICBzZXRUcmFuc2xhdGU6IEZsaXAuc2V0VHJhbnNsYXRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbjogRmxpcC5zZXRUcmFuc2l0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgYmVmb3JlSW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmbGlwJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9ZmxpcGApO1xuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9M2RgKTtcbiAgICAgIGNvbnN0IG92ZXJ3cml0ZVBhcmFtcyA9IHtcbiAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgICAgc2xpZGVzUGVyQ29sdW1uOiAxLFxuICAgICAgICBzbGlkZXNQZXJHcm91cDogMSxcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxuICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIucGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5vcmlnaW5hbFBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmbGlwJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmZsaXBFZmZlY3Quc2V0VHJhbnNsYXRlKCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnZmxpcCcpIHJldHVybjtcbiAgICAgIHN3aXBlci5mbGlwRWZmZWN0LnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBDb3ZlcmZsb3cgPSB7XG4gIHNldFRyYW5zbGF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBzd2lwZXJXaWR0aCwgaGVpZ2h0OiBzd2lwZXJIZWlnaHQsIHNsaWRlcywgJHdyYXBwZXJFbCwgc2xpZGVzU2l6ZXNHcmlkLFxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3Q7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN3aXBlci50cmFuc2xhdGU7XG4gICAgY29uc3QgY2VudGVyID0gaXNIb3Jpem9udGFsID8gLXRyYW5zZm9ybSArIChzd2lwZXJXaWR0aCAvIDIpIDogLXRyYW5zZm9ybSArIChzd2lwZXJIZWlnaHQgLyAyKTtcbiAgICBjb25zdCByb3RhdGUgPSBpc0hvcml6b250YWwgPyBwYXJhbXMucm90YXRlIDogLXBhcmFtcy5yb3RhdGU7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gcGFyYW1zLmRlcHRoO1xuICAgIC8vIEVhY2ggc2xpZGUgb2Zmc2V0IGZyb20gY2VudGVyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgJHNsaWRlRWwgPSBzbGlkZXMuZXEoaSk7XG4gICAgICBjb25zdCBzbGlkZVNpemUgPSBzbGlkZXNTaXplc0dyaWRbaV07XG4gICAgICBjb25zdCBzbGlkZU9mZnNldCA9ICRzbGlkZUVsWzBdLnN3aXBlclNsaWRlT2Zmc2V0O1xuICAgICAgY29uc3Qgb2Zmc2V0TXVsdGlwbGllciA9ICgoY2VudGVyIC0gc2xpZGVPZmZzZXQgLSAoc2xpZGVTaXplIC8gMikpIC8gc2xpZGVTaXplKSAqIHBhcmFtcy5tb2RpZmllcjtcblxuICAgICAgbGV0IHJvdGF0ZVkgPSBpc0hvcml6b250YWwgPyByb3RhdGUgKiBvZmZzZXRNdWx0aXBsaWVyIDogMDtcbiAgICAgIGxldCByb3RhdGVYID0gaXNIb3Jpem9udGFsID8gMCA6IHJvdGF0ZSAqIG9mZnNldE11bHRpcGxpZXI7XG4gICAgICAvLyB2YXIgcm90YXRlWiA9IDBcbiAgICAgIGxldCB0cmFuc2xhdGVaID0gLXRyYW5zbGF0ZSAqIE1hdGguYWJzKG9mZnNldE11bHRpcGxpZXIpO1xuXG4gICAgICBsZXQgdHJhbnNsYXRlWSA9IGlzSG9yaXpvbnRhbCA/IDAgOiBwYXJhbXMuc3RyZXRjaCAqIChvZmZzZXRNdWx0aXBsaWVyKTtcbiAgICAgIGxldCB0cmFuc2xhdGVYID0gaXNIb3Jpem9udGFsID8gcGFyYW1zLnN0cmV0Y2ggKiAob2Zmc2V0TXVsdGlwbGllcikgOiAwO1xuXG4gICAgICAvLyBGaXggZm9yIHVsdHJhIHNtYWxsIHZhbHVlc1xuICAgICAgaWYgKE1hdGguYWJzKHRyYW5zbGF0ZVgpIDwgMC4wMDEpIHRyYW5zbGF0ZVggPSAwO1xuICAgICAgaWYgKE1hdGguYWJzKHRyYW5zbGF0ZVkpIDwgMC4wMDEpIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgaWYgKE1hdGguYWJzKHRyYW5zbGF0ZVopIDwgMC4wMDEpIHRyYW5zbGF0ZVogPSAwO1xuICAgICAgaWYgKE1hdGguYWJzKHJvdGF0ZVkpIDwgMC4wMDEpIHJvdGF0ZVkgPSAwO1xuICAgICAgaWYgKE1hdGguYWJzKHJvdGF0ZVgpIDwgMC4wMDEpIHJvdGF0ZVggPSAwO1xuXG4gICAgICBjb25zdCBzbGlkZVRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVh9cHgsJHt0cmFuc2xhdGVZfXB4LCR7dHJhbnNsYXRlWn1weCkgIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKWA7XG5cbiAgICAgICRzbGlkZUVsLnRyYW5zZm9ybShzbGlkZVRyYW5zZm9ybSk7XG4gICAgICAkc2xpZGVFbFswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChvZmZzZXRNdWx0aXBsaWVyKSkgKyAxO1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgLy8gU2V0IHNoYWRvd3NcbiAgICAgICAgbGV0ICRzaGFkb3dCZWZvcmVFbCA9IGlzSG9yaXpvbnRhbCA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCcpO1xuICAgICAgICBsZXQgJHNoYWRvd0FmdGVyRWwgPSBpc0hvcml6b250YWwgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJyk7XG4gICAgICAgIGlmICgkc2hhZG93QmVmb3JlRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJHNoYWRvd0JlZm9yZUVsID0gJChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJHtpc0hvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJ31cIj48L2Rpdj5gKTtcbiAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoJHNoYWRvd0JlZm9yZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNoYWRvd0FmdGVyRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJHNoYWRvd0FmdGVyRWwgPSAkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke2lzSG9yaXpvbnRhbCA/ICdyaWdodCcgOiAnYm90dG9tJ31cIj48L2Rpdj5gKTtcbiAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoJHNoYWRvd0FmdGVyRWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkc2hhZG93QmVmb3JlRWwubGVuZ3RoKSAkc2hhZG93QmVmb3JlRWxbMF0uc3R5bGUub3BhY2l0eSA9IG9mZnNldE11bHRpcGxpZXIgPiAwID8gb2Zmc2V0TXVsdGlwbGllciA6IDA7XG4gICAgICAgIGlmICgkc2hhZG93QWZ0ZXJFbC5sZW5ndGgpICRzaGFkb3dBZnRlckVsWzBdLnN0eWxlLm9wYWNpdHkgPSAoLW9mZnNldE11bHRpcGxpZXIpID4gMCA/IC1vZmZzZXRNdWx0aXBsaWVyIDogMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgY29ycmVjdCBwZXJzcGVjdGl2ZSBmb3IgSUUxMFxuICAgIGlmIChTdXBwb3J0LnBvaW50ZXJFdmVudHMgfHwgU3VwcG9ydC5wcmVmaXhlZFBvaW50ZXJFdmVudHMpIHtcbiAgICAgIGNvbnN0IHdzID0gJHdyYXBwZXJFbFswXS5zdHlsZTtcbiAgICAgIHdzLnBlcnNwZWN0aXZlT3JpZ2luID0gYCR7Y2VudGVyfXB4IDUwJWA7XG4gICAgfVxuICB9LFxuICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBzd2lwZXIuc2xpZGVzXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbilcbiAgICAgIC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKVxuICAgICAgLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICB9LFxufTtcblxudmFyIEVmZmVjdENvdmVyZmxvdyA9IHtcbiAgbmFtZTogJ2VmZmVjdC1jb3ZlcmZsb3cnLFxuICBwYXJhbXM6IHtcbiAgICBjb3ZlcmZsb3dFZmZlY3Q6IHtcbiAgICAgIHJvdGF0ZTogNTAsXG4gICAgICBzdHJldGNoOiAwLFxuICAgICAgZGVwdGg6IDEwMCxcbiAgICAgIG1vZGlmaWVyOiAxLFxuICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGNvdmVyZmxvd0VmZmVjdDoge1xuICAgICAgICBzZXRUcmFuc2xhdGU6IENvdmVyZmxvdy5zZXRUcmFuc2xhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBDb3ZlcmZsb3cuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGJlZm9yZUluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY292ZXJmbG93JykgcmV0dXJuO1xuXG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31jb3ZlcmZsb3dgKTtcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfTNkYCk7XG5cbiAgICAgIHN3aXBlci5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9IHRydWU7XG4gICAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9IHRydWU7XG4gICAgfSxcbiAgICBzZXRUcmFuc2xhdGUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY292ZXJmbG93JykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmNvdmVyZmxvd0VmZmVjdC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjb3ZlcmZsb3cnKSByZXR1cm47XG4gICAgICBzd2lwZXIuY292ZXJmbG93RWZmZWN0LnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBUaHVtYnMgPSB7XG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHRodW1iczogdGh1bWJzUGFyYW1zIH0gPSBzd2lwZXIucGFyYW1zO1xuICAgIGNvbnN0IFN3aXBlckNsYXNzID0gc3dpcGVyLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0aHVtYnNQYXJhbXMuc3dpcGVyIGluc3RhbmNlb2YgU3dpcGVyQ2xhc3MpIHtcbiAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyID0gdGh1bWJzUGFyYW1zLnN3aXBlcjtcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIudGh1bWJzLnN3aXBlci5vcmlnaW5hbFBhcmFtcywge1xuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci50aHVtYnMuc3dpcGVyLnBhcmFtcywge1xuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodGh1bWJzUGFyYW1zLnN3aXBlcikpIHtcbiAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyID0gbmV3IFN3aXBlckNsYXNzKFV0aWxzLmV4dGVuZCh7fSwgdGh1bWJzUGFyYW1zLnN3aXBlciwge1xuICAgICAgICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IHRydWUsXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlLFxuICAgICAgfSkpO1xuICAgICAgc3dpcGVyLnRodW1icy5zd2lwZXJDcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgc3dpcGVyLnRodW1icy5zd2lwZXIuJGVsLmFkZENsYXNzKHN3aXBlci5wYXJhbXMudGh1bWJzLnRodW1ic0NvbnRhaW5lckNsYXNzKTtcbiAgICBzd2lwZXIudGh1bWJzLnN3aXBlci5vbigndGFwJywgc3dpcGVyLnRodW1icy5vblRodW1iQ2xpY2spO1xuICB9LFxuICBvblRodW1iQ2xpY2soKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcbiAgICBpZiAoIXRodW1ic1N3aXBlcikgcmV0dXJuO1xuICAgIGNvbnN0IGNsaWNrZWRJbmRleCA9IHRodW1ic1N3aXBlci5jbGlja2VkSW5kZXg7XG4gICAgY29uc3QgY2xpY2tlZFNsaWRlID0gdGh1bWJzU3dpcGVyLmNsaWNrZWRTbGlkZTtcbiAgICBpZiAoY2xpY2tlZFNsaWRlICYmICQoY2xpY2tlZFNsaWRlKS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnRodW1icy5zbGlkZVRodW1iQWN0aXZlQ2xhc3MpKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBjbGlja2VkSW5kZXggPT09ICd1bmRlZmluZWQnIHx8IGNsaWNrZWRJbmRleCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGxldCBzbGlkZVRvSW5kZXg7XG4gICAgaWYgKHRodW1ic1N3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgc2xpZGVUb0luZGV4ID0gcGFyc2VJbnQoJCh0aHVtYnNTd2lwZXIuY2xpY2tlZFNsaWRlKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlVG9JbmRleCA9IGNsaWNrZWRJbmRleDtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRJbmRleCkuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcbiAgICAgICAgY3VycmVudEluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldkluZGV4ID0gc3dpcGVyLnNsaWRlcy5lcShjdXJyZW50SW5kZXgpLnByZXZBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVUb0luZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBzd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRJbmRleCkubmV4dEFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzbGlkZVRvSW5kZXh9XCJdYCkuZXEoMCkuaW5kZXgoKTtcbiAgICAgIGlmICh0eXBlb2YgcHJldkluZGV4ID09PSAndW5kZWZpbmVkJykgc2xpZGVUb0luZGV4ID0gbmV4dEluZGV4O1xuICAgICAgZWxzZSBpZiAodHlwZW9mIG5leHRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHNsaWRlVG9JbmRleCA9IHByZXZJbmRleDtcbiAgICAgIGVsc2UgaWYgKG5leHRJbmRleCAtIGN1cnJlbnRJbmRleCA8IGN1cnJlbnRJbmRleCAtIHByZXZJbmRleCkgc2xpZGVUb0luZGV4ID0gbmV4dEluZGV4O1xuICAgICAgZWxzZSBzbGlkZVRvSW5kZXggPSBwcmV2SW5kZXg7XG4gICAgfVxuICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gIH0sXG4gIHVwZGF0ZShpbml0aWFsKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcbiAgICBpZiAoIXRodW1ic1N3aXBlcikgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2xpZGVzUGVyVmlldyA9IHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nXG4gICAgICA/IHRodW1ic1N3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpXG4gICAgICA6IHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldztcblxuICAgIGlmIChzd2lwZXIucmVhbEluZGV4ICE9PSB0aHVtYnNTd2lwZXIucmVhbEluZGV4KSB7XG4gICAgICBsZXQgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgbGV0IG5ld1RodW1ic0luZGV4O1xuICAgICAgaWYgKHRodW1ic1N3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnNsaWRlcy5lcShjdXJyZW50VGh1bWJzSW5kZXgpLmhhc0NsYXNzKHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICB0aHVtYnNTd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIHRodW1ic1N3aXBlci5fY2xpZW50TGVmdCA9IHRodW1ic1N3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XG4gICAgICAgICAgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgYWN0dWFsIHRodW1icyBpbmRleCB0byBzbGlkZSB0b1xuICAgICAgICBjb25zdCBwcmV2VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkucHJldkFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIucmVhbEluZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XG4gICAgICAgIGNvbnN0IG5leHRUaHVtYnNJbmRleCA9IHRodW1ic1N3aXBlci5zbGlkZXMuZXEoY3VycmVudFRodW1ic0luZGV4KS5uZXh0QWxsKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3N3aXBlci5yZWFsSW5kZXh9XCJdYCkuZXEoMCkuaW5kZXgoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2VGh1bWJzSW5kZXggPT09ICd1bmRlZmluZWQnKSBuZXdUaHVtYnNJbmRleCA9IG5leHRUaHVtYnNJbmRleDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5leHRUaHVtYnNJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIG5ld1RodW1ic0luZGV4ID0gcHJldlRodW1ic0luZGV4O1xuICAgICAgICBlbHNlIGlmIChuZXh0VGh1bWJzSW5kZXggLSBjdXJyZW50VGh1bWJzSW5kZXggPT09IGN1cnJlbnRUaHVtYnNJbmRleCAtIHByZXZUaHVtYnNJbmRleCkgbmV3VGh1bWJzSW5kZXggPSBjdXJyZW50VGh1bWJzSW5kZXg7XG4gICAgICAgIGVsc2UgaWYgKG5leHRUaHVtYnNJbmRleCAtIGN1cnJlbnRUaHVtYnNJbmRleCA8IGN1cnJlbnRUaHVtYnNJbmRleCAtIHByZXZUaHVtYnNJbmRleCkgbmV3VGh1bWJzSW5kZXggPSBuZXh0VGh1bWJzSW5kZXg7XG4gICAgICAgIGVsc2UgbmV3VGh1bWJzSW5kZXggPSBwcmV2VGh1bWJzSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdUaHVtYnNJbmRleCA9IHN3aXBlci5yZWFsSW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAodGh1bWJzU3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLmluZGV4T2YobmV3VGh1bWJzSW5kZXgpIDwgMCkge1xuICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGlmIChuZXdUaHVtYnNJbmRleCA+IGN1cnJlbnRUaHVtYnNJbmRleCkge1xuICAgICAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBuZXdUaHVtYnNJbmRleCAtIE1hdGguZmxvb3Ioc2xpZGVzUGVyVmlldyAvIDIpICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBuZXdUaHVtYnNJbmRleCArIE1hdGguZmxvb3Ioc2xpZGVzUGVyVmlldyAvIDIpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmV3VGh1bWJzSW5kZXggPiBjdXJyZW50VGh1bWJzSW5kZXgpIHtcbiAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5ld1RodW1ic0luZGV4IC0gc2xpZGVzUGVyVmlldyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGh1bWJzU3dpcGVyLnNsaWRlVG8obmV3VGh1bWJzSW5kZXgsIGluaXRpYWwgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY3RpdmF0ZSB0aHVtYnNcbiAgICBsZXQgdGh1bWJzVG9BY3RpdmF0ZSA9IDE7XG4gICAgY29uc3QgdGh1bWJBY3RpdmVDbGFzcyA9IHN3aXBlci5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcztcblxuICAgIGlmIChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICB0aHVtYnNUb0FjdGl2YXRlID0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgIH1cblxuICAgIHRodW1ic1N3aXBlci5zbGlkZXMucmVtb3ZlQ2xhc3ModGh1bWJBY3RpdmVDbGFzcyk7XG4gICAgaWYgKHRodW1ic1N3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHVtYnNUb0FjdGl2YXRlOyBpICs9IDEpIHtcbiAgICAgICAgdGh1bWJzU3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c3dpcGVyLnJlYWxJbmRleCArIGl9XCJdYCkuYWRkQ2xhc3ModGh1bWJBY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGh1bWJzVG9BY3RpdmF0ZTsgaSArPSAxKSB7XG4gICAgICAgIHRodW1ic1N3aXBlci5zbGlkZXMuZXEoc3dpcGVyLnJlYWxJbmRleCArIGkpLmFkZENsYXNzKHRodW1iQWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn07XG52YXIgVGh1bWJzJDEgPSB7XG4gIG5hbWU6ICd0aHVtYnMnLFxuICBwYXJhbXM6IHtcbiAgICB0aHVtYnM6IHtcbiAgICAgIHN3aXBlcjogbnVsbCxcbiAgICAgIHNsaWRlVGh1bWJBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS10aHVtYi1hY3RpdmUnLFxuICAgICAgdGh1bWJzQ29udGFpbmVyQ2xhc3M6ICdzd2lwZXItY29udGFpbmVyLXRodW1icycsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgdGh1bWJzOiB7XG4gICAgICAgIHN3aXBlcjogbnVsbCxcbiAgICAgICAgaW5pdDogVGh1bWJzLmluaXQuYmluZChzd2lwZXIpLFxuICAgICAgICB1cGRhdGU6IFRodW1icy51cGRhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBvblRodW1iQ2xpY2s6IFRodW1icy5vblRodW1iQ2xpY2suYmluZChzd2lwZXIpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBiZWZvcmVJbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHsgdGh1bWJzIH0gPSBzd2lwZXIucGFyYW1zO1xuICAgICAgaWYgKCF0aHVtYnMgfHwgIXRodW1icy5zd2lwZXIpIHJldHVybjtcbiAgICAgIHN3aXBlci50aHVtYnMuaW5pdCgpO1xuICAgICAgc3dpcGVyLnRodW1icy51cGRhdGUodHJ1ZSk7XG4gICAgfSxcbiAgICBzbGlkZUNoYW5nZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci50aHVtYnMuc3dpcGVyKSByZXR1cm47XG4gICAgICBzd2lwZXIudGh1bWJzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnRodW1icy5zd2lwZXIpIHJldHVybjtcbiAgICAgIHN3aXBlci50aHVtYnMudXBkYXRlKCk7XG4gICAgfSxcbiAgICByZXNpemUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIudGh1bWJzLnN3aXBlcikgcmV0dXJuO1xuICAgICAgc3dpcGVyLnRodW1icy51cGRhdGUoKTtcbiAgICB9LFxuICAgIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnRodW1icy5zd2lwZXIpIHJldHVybjtcbiAgICAgIHN3aXBlci50aHVtYnMudXBkYXRlKCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XG4gICAgICBpZiAoIXRodW1ic1N3aXBlcikgcmV0dXJuO1xuICAgICAgdGh1bWJzU3dpcGVyLnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcbiAgICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XG4gICAgICBpZiAoc3dpcGVyLnRodW1icy5zd2lwZXJDcmVhdGVkICYmIHRodW1ic1N3aXBlcikge1xuICAgICAgICB0aHVtYnNTd2lwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG4vLyBTd2lwZXIgQ2xhc3NcblxuY29uc3QgY29tcG9uZW50cyA9IFtcbiAgRGV2aWNlJDEsXG4gIFN1cHBvcnQkMSxcbiAgQnJvd3NlciQxLFxuICBSZXNpemUsXG4gIE9ic2VydmVyJDEsXG4gIFZpcnR1YWwkMSxcbiAgS2V5Ym9hcmQkMSxcbiAgTW91c2V3aGVlbCQxLFxuICBOYXZpZ2F0aW9uJDEsXG4gIFBhZ2luYXRpb24kMSxcbiAgU2Nyb2xsYmFyJDEsXG4gIFBhcmFsbGF4JDEsXG4gIFpvb20kMSxcbiAgTGF6eSQxLFxuICBDb250cm9sbGVyJDEsXG4gIEExMXksXG4gIEhpc3RvcnkkMSxcbiAgSGFzaE5hdmlnYXRpb24kMSxcbiAgQXV0b3BsYXkkMSxcbiAgRWZmZWN0RmFkZSxcbiAgRWZmZWN0Q3ViZSxcbiAgRWZmZWN0RmxpcCxcbiAgRWZmZWN0Q292ZXJmbG93LFxuICBUaHVtYnMkMVxuXTtcblxuaWYgKHR5cGVvZiBTd2lwZXIudXNlID09PSAndW5kZWZpbmVkJykge1xuICBTd2lwZXIudXNlID0gU3dpcGVyLkNsYXNzLnVzZTtcbiAgU3dpcGVyLmluc3RhbGxNb2R1bGUgPSBTd2lwZXIuQ2xhc3MuaW5zdGFsbE1vZHVsZTtcbn1cblxuU3dpcGVyLnVzZShjb21wb25lbnRzKTtcblxuZXhwb3J0IGRlZmF1bHQgU3dpcGVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/swiper/dist/js/swiper.esm.bundle.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./resources/ts/modules/commons/components/book-now-modal.ts":
/*!*******************************************************************!*\
  !*** ./resources/ts/modules/commons/components/book-now-modal.ts ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Modal\"].init(document.getElementById('modal-book-now'));\r\n    // development only\r\n    // .open();\r\n    materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"FormSelect\"].init(document.querySelectorAll('select'));\r\n    var today = new Date();\r\n    var tommorrow = new Date();\r\n    tommorrow.setDate(today.getDate() + 1);\r\n    var initDatePicker = function (el, options) { return materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Datepicker\"].init(el, __assign({}, options, { setDefaultDate: true, container: document.body })); };\r\n    initDatePicker(document.getElementById('arrival-picker'), {\r\n        minDate: today,\r\n        defaultDate: today,\r\n        onClose: function () {\r\n            var selectedArrDate = this.date;\r\n            if (selectedArrDate.getTime() >= departurePickerInstance.date.getTime()) {\r\n                var nextDay = new Date();\r\n                nextDay.setDate(selectedArrDate.getDate() + 1);\r\n                departurePickerInstance.destroy();\r\n                departurePickerInstance = initDatePicker(departurePicker, {\r\n                    minDate: nextDay,\r\n                    defaultDate: nextDay\r\n                });\r\n            }\r\n        }\r\n    });\r\n    var departurePicker = document.getElementById('departure-picker');\r\n    var departurePickerInstance = initDatePicker(departurePicker, {\r\n        minDate: tommorrow,\r\n        defaultDate: tommorrow\r\n    });\r\n    var rooms = [];\r\n    var totalGuestCount = Number.parseInt(document.getElementById('total-guest-count').innerHTML);\r\n    var roomsCountContainer = document.getElementById('rooms__count');\r\n    var roomsConsCloned = document.querySelector('.rooms__cons').cloneNode(true);\r\n    var getCounts = function (childRange, adultRange) { return [Number.parseInt(childRange.value), Number.parseInt(adultRange.value)]; };\r\n    var getDiff = function (totalGuestCount, curCount) {\r\n        var diff = totalGuestCount - curCount;\r\n        return diff < 0 ? 0 : diff;\r\n    };\r\n    var checkEdges = function (range, totalGuestCount, substractor) {\r\n        if (substractor === void 0) { substractor = 0; }\r\n        if (Number.parseInt(range.max) > (totalGuestCount - substractor)) {\r\n            range.max = \"\" + (totalGuestCount - substractor);\r\n        }\r\n        if (Number.parseInt(range.min) < (1 - substractor)) {\r\n            range.min = \"\" + (1 - substractor);\r\n        }\r\n    };\r\n    var handleOrder = function () { return Array.from(roomsCountContainer.children)\r\n        .forEach(function (room, i) {\r\n        room.querySelector('.input-field select').name = \"room[\" + i + \"][category]\";\r\n        room.querySelector('.room__counter').innerHTML = \"\" + (i + 1);\r\n        var _a = Array.from(room.querySelectorAll('[type=\"range\"]')), adultRange = _a[0], childRange = _a[1];\r\n        adultRange.name = \"room[\" + i + \"][adults]\";\r\n        childRange.name = \"room[\" + i + \"][child]\";\r\n    }); };\r\n    var roomsCount;\r\n    var addRoom = function () {\r\n        rooms.push({\r\n            adultRange: null,\r\n            childRange: null\r\n        });\r\n        handleOrder();\r\n        roomsCount = rooms.length - 1;\r\n        var lastRoom = roomsCountContainer.children[roomsCount];\r\n        if (roomsCount > 0) {\r\n            var removeRoomBtn = lastRoom.querySelector('.btn-flat');\r\n            removeRoomBtn.onclick = function () {\r\n                rooms.splice(roomsCount--, 1);\r\n                lastRoom.remove();\r\n                handleOrder();\r\n            };\r\n        }\r\n        var _a = Array.from(lastRoom.querySelectorAll('[type=\"range\"]')), adultRange = _a[0], childRange = _a[1];\r\n        var adultCounter = adultRange.parentElement.querySelector('.adult__count');\r\n        var adultRangeHandler = function () {\r\n            var _a = getCounts(childRange, adultRange), curChildCount = _a[0], curAdultCount = _a[1];\r\n            checkEdges(adultRange, totalGuestCount);\r\n            adultCounter.innerHTML = \"\" + curAdultCount;\r\n            var diff = getDiff(totalGuestCount, curAdultCount);\r\n            if (curAdultCount + curChildCount >= totalGuestCount) {\r\n                childCounter.innerHTML = childRange.value = \"\" + diff;\r\n            }\r\n            childRange.max = \"\" + diff;\r\n            childRange.disabled = curAdultCount == totalGuestCount;\r\n        };\r\n        adultRange.onchange = adultRange.oninput = adultRangeHandler;\r\n        var childCounter = childRange.parentElement.querySelector('.child__count');\r\n        var childRangeHandler = function () {\r\n            var _a = getCounts(childRange, adultRange), curChildCount = _a[0], curAdultCount = _a[1];\r\n            checkEdges(childRange, totalGuestCount, 1);\r\n            childCounter.innerHTML = \"\" + curChildCount;\r\n            var diff = getDiff(totalGuestCount, curChildCount);\r\n            if (curAdultCount + curChildCount >= totalGuestCount) {\r\n                adultCounter.innerHTML = adultRange.value = \"\" + diff;\r\n            }\r\n            adultRange.max = \"\" + diff;\r\n            adultRange.disabled = curChildCount == (totalGuestCount - 1);\r\n        };\r\n        childRange.onchange = childRange.oninput = childRangeHandler;\r\n        rooms[roomsCount].adultRange = adultRange;\r\n        rooms[roomsCount].childRange = childRange;\r\n        materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Range\"].init(document.querySelectorAll('[type=\"range\"]'));\r\n    };\r\n    addRoom();\r\n    document.getElementById('add-room').addEventListener('click', function () {\r\n        roomsCountContainer.appendChild(roomsConsCloned.cloneNode(true));\r\n        addRoom();\r\n    });\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2NvbXBvbmVudHMvYm9vay1ub3ctbW9kYWwudHM/YjA4NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBZ0IsU0FBSSxJQUFJLFNBQUk7QUFDNUI7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VFO0FBQ3ZEO0FBQ2hCLElBQUkscURBQUs7QUFDVDtBQUNBO0FBQ0EsSUFBSSwwREFBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLDBEQUFVLHFCQUFxQixZQUFZLGlEQUFpRCxHQUFHO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtFQUErRTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyxFQUFFIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3RzL21vZHVsZXMvY29tbW9ucy9jb21wb25lbnRzL2Jvb2stbm93LW1vZGFsLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5pbXBvcnQgeyBNb2RhbCwgRm9ybVNlbGVjdCwgRGF0ZXBpY2tlciwgUmFuZ2UgfSBmcm9tICdtYXRlcmlhbGl6ZS1jc3MnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xyXG4gICAgTW9kYWwuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwtYm9vay1ub3cnKSk7XHJcbiAgICAvLyBkZXZlbG9wbWVudCBvbmx5XHJcbiAgICAvLyAub3BlbigpO1xyXG4gICAgRm9ybVNlbGVjdC5pbml0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpKTtcclxuICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICB2YXIgdG9tbW9ycm93ID0gbmV3IERhdGUoKTtcclxuICAgIHRvbW1vcnJvdy5zZXREYXRlKHRvZGF5LmdldERhdGUoKSArIDEpO1xyXG4gICAgdmFyIGluaXREYXRlUGlja2VyID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7IHJldHVybiBEYXRlcGlja2VyLmluaXQoZWwsIF9fYXNzaWduKHt9LCBvcHRpb25zLCB7IHNldERlZmF1bHREYXRlOiB0cnVlLCBjb250YWluZXI6IGRvY3VtZW50LmJvZHkgfSkpOyB9O1xyXG4gICAgaW5pdERhdGVQaWNrZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Fycml2YWwtcGlja2VyJyksIHtcclxuICAgICAgICBtaW5EYXRlOiB0b2RheSxcclxuICAgICAgICBkZWZhdWx0RGF0ZTogdG9kYXksXHJcbiAgICAgICAgb25DbG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRBcnJEYXRlID0gdGhpcy5kYXRlO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRBcnJEYXRlLmdldFRpbWUoKSA+PSBkZXBhcnR1cmVQaWNrZXJJbnN0YW5jZS5kYXRlLmdldFRpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHREYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgbmV4dERheS5zZXREYXRlKHNlbGVjdGVkQXJyRGF0ZS5nZXREYXRlKCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIGRlcGFydHVyZVBpY2tlckluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIGRlcGFydHVyZVBpY2tlckluc3RhbmNlID0gaW5pdERhdGVQaWNrZXIoZGVwYXJ0dXJlUGlja2VyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluRGF0ZTogbmV4dERheSxcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RGF0ZTogbmV4dERheVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBkZXBhcnR1cmVQaWNrZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVwYXJ0dXJlLXBpY2tlcicpO1xyXG4gICAgdmFyIGRlcGFydHVyZVBpY2tlckluc3RhbmNlID0gaW5pdERhdGVQaWNrZXIoZGVwYXJ0dXJlUGlja2VyLCB7XHJcbiAgICAgICAgbWluRGF0ZTogdG9tbW9ycm93LFxyXG4gICAgICAgIGRlZmF1bHREYXRlOiB0b21tb3Jyb3dcclxuICAgIH0pO1xyXG4gICAgdmFyIHJvb21zID0gW107XHJcbiAgICB2YXIgdG90YWxHdWVzdENvdW50ID0gTnVtYmVyLnBhcnNlSW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3RhbC1ndWVzdC1jb3VudCcpLmlubmVySFRNTCk7XHJcbiAgICB2YXIgcm9vbXNDb3VudENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb29tc19fY291bnQnKTtcclxuICAgIHZhciByb29tc0NvbnNDbG9uZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucm9vbXNfX2NvbnMnKS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICB2YXIgZ2V0Q291bnRzID0gZnVuY3Rpb24gKGNoaWxkUmFuZ2UsIGFkdWx0UmFuZ2UpIHsgcmV0dXJuIFtOdW1iZXIucGFyc2VJbnQoY2hpbGRSYW5nZS52YWx1ZSksIE51bWJlci5wYXJzZUludChhZHVsdFJhbmdlLnZhbHVlKV07IH07XHJcbiAgICB2YXIgZ2V0RGlmZiA9IGZ1bmN0aW9uICh0b3RhbEd1ZXN0Q291bnQsIGN1ckNvdW50KSB7XHJcbiAgICAgICAgdmFyIGRpZmYgPSB0b3RhbEd1ZXN0Q291bnQgLSBjdXJDb3VudDtcclxuICAgICAgICByZXR1cm4gZGlmZiA8IDAgPyAwIDogZGlmZjtcclxuICAgIH07XHJcbiAgICB2YXIgY2hlY2tFZGdlcyA9IGZ1bmN0aW9uIChyYW5nZSwgdG90YWxHdWVzdENvdW50LCBzdWJzdHJhY3Rvcikge1xyXG4gICAgICAgIGlmIChzdWJzdHJhY3RvciA9PT0gdm9pZCAwKSB7IHN1YnN0cmFjdG9yID0gMDsgfVxyXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQocmFuZ2UubWF4KSA+ICh0b3RhbEd1ZXN0Q291bnQgLSBzdWJzdHJhY3RvcikpIHtcclxuICAgICAgICAgICAgcmFuZ2UubWF4ID0gXCJcIiArICh0b3RhbEd1ZXN0Q291bnQgLSBzdWJzdHJhY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQocmFuZ2UubWluKSA8ICgxIC0gc3Vic3RyYWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHJhbmdlLm1pbiA9IFwiXCIgKyAoMSAtIHN1YnN0cmFjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGhhbmRsZU9yZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbShyb29tc0NvdW50Q29udGFpbmVyLmNoaWxkcmVuKVxyXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChyb29tLCBpKSB7XHJcbiAgICAgICAgcm9vbS5xdWVyeVNlbGVjdG9yKCcuaW5wdXQtZmllbGQgc2VsZWN0JykubmFtZSA9IFwicm9vbVtcIiArIGkgKyBcIl1bY2F0ZWdvcnldXCI7XHJcbiAgICAgICAgcm9vbS5xdWVyeVNlbGVjdG9yKCcucm9vbV9fY291bnRlcicpLmlubmVySFRNTCA9IFwiXCIgKyAoaSArIDEpO1xyXG4gICAgICAgIHZhciBfYSA9IEFycmF5LmZyb20ocm9vbS5xdWVyeVNlbGVjdG9yQWxsKCdbdHlwZT1cInJhbmdlXCJdJykpLCBhZHVsdFJhbmdlID0gX2FbMF0sIGNoaWxkUmFuZ2UgPSBfYVsxXTtcclxuICAgICAgICBhZHVsdFJhbmdlLm5hbWUgPSBcInJvb21bXCIgKyBpICsgXCJdW2FkdWx0c11cIjtcclxuICAgICAgICBjaGlsZFJhbmdlLm5hbWUgPSBcInJvb21bXCIgKyBpICsgXCJdW2NoaWxkXVwiO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgcm9vbXNDb3VudDtcclxuICAgIHZhciBhZGRSb29tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJvb21zLnB1c2goe1xyXG4gICAgICAgICAgICBhZHVsdFJhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICBjaGlsZFJhbmdlOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaGFuZGxlT3JkZXIoKTtcclxuICAgICAgICByb29tc0NvdW50ID0gcm9vbXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgbGFzdFJvb20gPSByb29tc0NvdW50Q29udGFpbmVyLmNoaWxkcmVuW3Jvb21zQ291bnRdO1xyXG4gICAgICAgIGlmIChyb29tc0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlUm9vbUJ0biA9IGxhc3RSb29tLnF1ZXJ5U2VsZWN0b3IoJy5idG4tZmxhdCcpO1xyXG4gICAgICAgICAgICByZW1vdmVSb29tQnRuLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByb29tcy5zcGxpY2Uocm9vbXNDb3VudC0tLCAxKTtcclxuICAgICAgICAgICAgICAgIGxhc3RSb29tLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlT3JkZXIoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gQXJyYXkuZnJvbShsYXN0Um9vbS5xdWVyeVNlbGVjdG9yQWxsKCdbdHlwZT1cInJhbmdlXCJdJykpLCBhZHVsdFJhbmdlID0gX2FbMF0sIGNoaWxkUmFuZ2UgPSBfYVsxXTtcclxuICAgICAgICB2YXIgYWR1bHRDb3VudGVyID0gYWR1bHRSYW5nZS5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hZHVsdF9fY291bnQnKTtcclxuICAgICAgICB2YXIgYWR1bHRSYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGdldENvdW50cyhjaGlsZFJhbmdlLCBhZHVsdFJhbmdlKSwgY3VyQ2hpbGRDb3VudCA9IF9hWzBdLCBjdXJBZHVsdENvdW50ID0gX2FbMV07XHJcbiAgICAgICAgICAgIGNoZWNrRWRnZXMoYWR1bHRSYW5nZSwgdG90YWxHdWVzdENvdW50KTtcclxuICAgICAgICAgICAgYWR1bHRDb3VudGVyLmlubmVySFRNTCA9IFwiXCIgKyBjdXJBZHVsdENvdW50O1xyXG4gICAgICAgICAgICB2YXIgZGlmZiA9IGdldERpZmYodG90YWxHdWVzdENvdW50LCBjdXJBZHVsdENvdW50KTtcclxuICAgICAgICAgICAgaWYgKGN1ckFkdWx0Q291bnQgKyBjdXJDaGlsZENvdW50ID49IHRvdGFsR3Vlc3RDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRDb3VudGVyLmlubmVySFRNTCA9IGNoaWxkUmFuZ2UudmFsdWUgPSBcIlwiICsgZGlmZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZFJhbmdlLm1heCA9IFwiXCIgKyBkaWZmO1xyXG4gICAgICAgICAgICBjaGlsZFJhbmdlLmRpc2FibGVkID0gY3VyQWR1bHRDb3VudCA9PSB0b3RhbEd1ZXN0Q291bnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBhZHVsdFJhbmdlLm9uY2hhbmdlID0gYWR1bHRSYW5nZS5vbmlucHV0ID0gYWR1bHRSYW5nZUhhbmRsZXI7XHJcbiAgICAgICAgdmFyIGNoaWxkQ291bnRlciA9IGNoaWxkUmFuZ2UucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuY2hpbGRfX2NvdW50Jyk7XHJcbiAgICAgICAgdmFyIGNoaWxkUmFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRDb3VudHMoY2hpbGRSYW5nZSwgYWR1bHRSYW5nZSksIGN1ckNoaWxkQ291bnQgPSBfYVswXSwgY3VyQWR1bHRDb3VudCA9IF9hWzFdO1xyXG4gICAgICAgICAgICBjaGVja0VkZ2VzKGNoaWxkUmFuZ2UsIHRvdGFsR3Vlc3RDb3VudCwgMSk7XHJcbiAgICAgICAgICAgIGNoaWxkQ291bnRlci5pbm5lckhUTUwgPSBcIlwiICsgY3VyQ2hpbGRDb3VudDtcclxuICAgICAgICAgICAgdmFyIGRpZmYgPSBnZXREaWZmKHRvdGFsR3Vlc3RDb3VudCwgY3VyQ2hpbGRDb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJBZHVsdENvdW50ICsgY3VyQ2hpbGRDb3VudCA+PSB0b3RhbEd1ZXN0Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIGFkdWx0Q291bnRlci5pbm5lckhUTUwgPSBhZHVsdFJhbmdlLnZhbHVlID0gXCJcIiArIGRpZmY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWR1bHRSYW5nZS5tYXggPSBcIlwiICsgZGlmZjtcclxuICAgICAgICAgICAgYWR1bHRSYW5nZS5kaXNhYmxlZCA9IGN1ckNoaWxkQ291bnQgPT0gKHRvdGFsR3Vlc3RDb3VudCAtIDEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hpbGRSYW5nZS5vbmNoYW5nZSA9IGNoaWxkUmFuZ2Uub25pbnB1dCA9IGNoaWxkUmFuZ2VIYW5kbGVyO1xyXG4gICAgICAgIHJvb21zW3Jvb21zQ291bnRdLmFkdWx0UmFuZ2UgPSBhZHVsdFJhbmdlO1xyXG4gICAgICAgIHJvb21zW3Jvb21zQ291bnRdLmNoaWxkUmFuZ2UgPSBjaGlsZFJhbmdlO1xyXG4gICAgICAgIFJhbmdlLmluaXQoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3R5cGU9XCJyYW5nZVwiXScpKTtcclxuICAgIH07XHJcbiAgICBhZGRSb29tKCk7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRkLXJvb20nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByb29tc0NvdW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHJvb21zQ29uc0Nsb25lZC5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgIGFkZFJvb20oKTtcclxuICAgIH0pO1xyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/components/book-now-modal.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/components/collapsible.ts":
/*!****************************************************************!*\
  !*** ./resources/ts/modules/commons/components/collapsible.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var collapsible = document.querySelectorAll('.collapsible');\r\n    materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Collapsible\"].init(collapsible);\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2NvbXBvbmVudHMvY29sbGFwc2libGUudHM/ZTQ3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBOEM7QUFDOUI7QUFDaEI7QUFDQSxJQUFJLDJEQUFXO0FBQ2YsQ0FBQyxFQUFFIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3RzL21vZHVsZXMvY29tbW9ucy9jb21wb25lbnRzL2NvbGxhcHNpYmxlLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sbGFwc2libGUgfSBmcm9tICdtYXRlcmlhbGl6ZS1jc3MnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNvbGxhcHNpYmxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbGxhcHNpYmxlJyk7XHJcbiAgICBDb2xsYXBzaWJsZS5pbml0KGNvbGxhcHNpYmxlKTtcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/components/collapsible.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/components/cookie-policy.ts":
/*!******************************************************************!*\
  !*** ./resources/ts/modules/commons/components/cookie-policy.ts ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/cookie */ \"./resources/ts/modules/commons/lib/cookie.ts\");\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var COOKIE_POLICY_CUR = '__cp';\r\n    var COOKIE_POLICY_SET = '__p';\r\n    var currentCookiePolicyVersion = _lib_cookie__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getItem(COOKIE_POLICY_CUR);\r\n    if (!currentCookiePolicyVersion || (currentCookiePolicyVersion !== _lib_cookie__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getItem(COOKIE_POLICY_SET))) {\r\n        setTimeout(function () {\r\n            var cookieToast = Object(materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"toast\"])({\r\n                html: \"<span>Updated Privacy Policy: We have updated our Privacy Policy and Cookies Policy to take into account the European Union General Data Protection Regulation.</span>\\n                        <button class=\\\"btn-flat toast-action\\\" href=\\\"privacy/cookie\\\" target=\\\"_blank\\\">more</button>\\n                        <button id=\\\"toast-dismiss-btn\\\" class=\\\"btn-flat toast-action\\\">ok</button>\",\r\n                displayLength: Infinity,\r\n                classes: 'cookie-policy'\r\n            });\r\n            var _a = Array.from(document.querySelectorAll('.toast-action')), moreBtn = _a[0], toastDismissBtn = _a[1];\r\n            moreBtn.onclick = function () { return window.open('/privacy/cookie', '_blank'); };\r\n            toastDismissBtn.onclick = function () {\r\n                var cookiePolicyVersion = _lib_cookie__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getItem(COOKIE_POLICY_CUR);\r\n                _lib_cookie__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setItem(COOKIE_POLICY_SET, cookiePolicyVersion || '1');\r\n                cookieToast.dismiss();\r\n            };\r\n        }, 5000);\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2NvbXBvbmVudHMvY29va2llLXBvbGljeS50cz9jMzA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdDO0FBQ0w7QUFDbkI7QUFDaEI7QUFDQTtBQUNBLHFDQUFxQyxtREFBTTtBQUMzQyx1RUFBdUUsbURBQU07QUFDN0U7QUFDQSw4QkFBOEIsNkRBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkNBQTJDLGlEQUFpRDtBQUM1RjtBQUNBLDBDQUEwQyxtREFBTTtBQUNoRCxnQkFBZ0IsbURBQU07QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUMsRUFBRSIsImZpbGUiOiIuL3Jlc291cmNlcy90cy9tb2R1bGVzL2NvbW1vbnMvY29tcG9uZW50cy9jb29raWUtcG9saWN5LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdtYXRlcmlhbGl6ZS1jc3MnO1xyXG5pbXBvcnQgQ29va2llIGZyb20gJy4uL2xpYi9jb29raWUnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIENPT0tJRV9QT0xJQ1lfQ1VSID0gJ19fY3AnO1xyXG4gICAgdmFyIENPT0tJRV9QT0xJQ1lfU0VUID0gJ19fcCc7XHJcbiAgICB2YXIgY3VycmVudENvb2tpZVBvbGljeVZlcnNpb24gPSBDb29raWUuZ2V0SXRlbShDT09LSUVfUE9MSUNZX0NVUik7XHJcbiAgICBpZiAoIWN1cnJlbnRDb29raWVQb2xpY3lWZXJzaW9uIHx8IChjdXJyZW50Q29va2llUG9saWN5VmVyc2lvbiAhPT0gQ29va2llLmdldEl0ZW0oQ09PS0lFX1BPTElDWV9TRVQpKSkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29va2llVG9hc3QgPSB0b2FzdCh7XHJcbiAgICAgICAgICAgICAgICBodG1sOiBcIjxzcGFuPlVwZGF0ZWQgUHJpdmFjeSBQb2xpY3k6IFdlIGhhdmUgdXBkYXRlZCBvdXIgUHJpdmFjeSBQb2xpY3kgYW5kIENvb2tpZXMgUG9saWN5IHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBFdXJvcGVhbiBVbmlvbiBHZW5lcmFsIERhdGEgUHJvdGVjdGlvbiBSZWd1bGF0aW9uLjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4tZmxhdCB0b2FzdC1hY3Rpb25cXFwiIGhyZWY9XFxcInByaXZhY3kvY29va2llXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+bW9yZTwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcInRvYXN0LWRpc21pc3MtYnRuXFxcIiBjbGFzcz1cXFwiYnRuLWZsYXQgdG9hc3QtYWN0aW9uXFxcIj5vazwvYnV0dG9uPlwiLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheUxlbmd0aDogSW5maW5pdHksXHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiAnY29va2llLXBvbGljeSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRvYXN0LWFjdGlvbicpKSwgbW9yZUJ0biA9IF9hWzBdLCB0b2FzdERpc21pc3NCdG4gPSBfYVsxXTtcclxuICAgICAgICAgICAgbW9yZUJ0bi5vbmNsaWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93Lm9wZW4oJy9wcml2YWN5L2Nvb2tpZScsICdfYmxhbmsnKTsgfTtcclxuICAgICAgICAgICAgdG9hc3REaXNtaXNzQnRuLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29va2llUG9saWN5VmVyc2lvbiA9IENvb2tpZS5nZXRJdGVtKENPT0tJRV9QT0xJQ1lfQ1VSKTtcclxuICAgICAgICAgICAgICAgIENvb2tpZS5zZXRJdGVtKENPT0tJRV9QT0xJQ1lfU0VULCBjb29raWVQb2xpY3lWZXJzaW9uIHx8ICcxJyk7XHJcbiAgICAgICAgICAgICAgICBjb29raWVUb2FzdC5kaXNtaXNzKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSwgNTAwMCk7XHJcbiAgICB9XHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/components/cookie-policy.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/components/nav-hint.ts":
/*!*************************************************************!*\
  !*** ./resources/ts/modules/commons/components/nav-hint.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_detect_mobile_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/detect-mobile-browser */ \"./resources/ts/modules/commons/lib/detect-mobile-browser.ts\");\n/* harmony import */ var _lib_cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/cookie */ \"./resources/ts/modules/commons/lib/cookie.ts\");\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var COOKIE_NAME = '__s';\r\n    if (Object(_lib_detect_mobile_browser__WEBPACK_IMPORTED_MODULE_1__[\"default\"])() && !_lib_cookie__WEBPACK_IMPORTED_MODULE_2__[\"default\"].hasItem(COOKIE_NAME)) {\r\n        materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"TapTarget\"].init(document.getElementById('tap-target'), {\r\n            onClose: function () { return _lib_cookie__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setItem(COOKIE_NAME, 1..toString()); }\r\n        }).open();\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2NvbXBvbmVudHMvbmF2LWhpbnQudHM/MzcyNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTRDO0FBQ1E7QUFDakI7QUFDbkI7QUFDaEI7QUFDQSxRQUFRLDBFQUFRLE9BQU8sbURBQU07QUFDN0IsUUFBUSx5REFBUztBQUNqQixrQ0FBa0MsUUFBUSxtREFBTSxxQ0FBcUM7QUFDckYsU0FBUztBQUNUO0FBQ0EsQ0FBQyxFQUFFIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3RzL21vZHVsZXMvY29tbW9ucy9jb21wb25lbnRzL25hdi1oaW50LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGFwVGFyZ2V0IH0gZnJvbSAnbWF0ZXJpYWxpemUtY3NzJztcclxuaW1wb3J0IGlzTW9iaWxlIGZyb20gJy4uL2xpYi9kZXRlY3QtbW9iaWxlLWJyb3dzZXInO1xyXG5pbXBvcnQgQ29va2llIGZyb20gJy4uL2xpYi9jb29raWUnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIENPT0tJRV9OQU1FID0gJ19fcyc7XHJcbiAgICBpZiAoaXNNb2JpbGUoKSAmJiAhQ29va2llLmhhc0l0ZW0oQ09PS0lFX05BTUUpKSB7XHJcbiAgICAgICAgVGFwVGFyZ2V0LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RhcC10YXJnZXQnKSwge1xyXG4gICAgICAgICAgICBvbkNsb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb29raWUuc2V0SXRlbShDT09LSUVfTkFNRSwgMS4udG9TdHJpbmcoKSk7IH1cclxuICAgICAgICB9KS5vcGVuKCk7XHJcbiAgICB9XHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/components/nav-hint.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/index.ts":
/*!***********************************************!*\
  !*** ./resources/ts/modules/commons/index.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_cookie_policy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/cookie-policy */ \"./resources/ts/modules/commons/components/cookie-policy.ts\");\n/* harmony import */ var _components_nav_hint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/nav-hint */ \"./resources/ts/modules/commons/components/nav-hint.ts\");\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    Object(_components_cookie_policy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\n    Object(_components_nav_hint__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\r\n    materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Sidenav\"].init(document.getElementById('slide-nav'));\r\n    materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"FloatingActionButton\"].init(document.getElementById('fixed-action-btn'), {\r\n        toolbarEnabled: true\r\n    });\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2luZGV4LnRzPzkyMTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFnRTtBQUNWO0FBQ1Y7QUFDNUI7QUFDaEIsSUFBSSx5RUFBWTtBQUNoQixJQUFJLG9FQUFPO0FBQ1gsSUFBSSx1REFBTztBQUNYLElBQUksb0VBQW9CO0FBQ3hCO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBRSIsImZpbGUiOiIuL3Jlc291cmNlcy90cy9tb2R1bGVzL2NvbW1vbnMvaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaWRlbmF2LCBGbG9hdGluZ0FjdGlvbkJ1dHRvbiB9IGZyb20gJ21hdGVyaWFsaXplLWNzcyc7XHJcbmltcG9ydCBjb29raWVQb2xpY3kgZnJvbSAnLi9jb21wb25lbnRzL2Nvb2tpZS1wb2xpY3knO1xyXG5pbXBvcnQgbmF2SGludCBmcm9tICcuL2NvbXBvbmVudHMvbmF2LWhpbnQnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xyXG4gICAgY29va2llUG9saWN5KCk7XHJcbiAgICBuYXZIaW50KCk7XHJcbiAgICBTaWRlbmF2LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NsaWRlLW5hdicpKTtcclxuICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uLmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpeGVkLWFjdGlvbi1idG4nKSwge1xyXG4gICAgICAgIHRvb2xiYXJFbmFibGVkOiB0cnVlXHJcbiAgICB9KTtcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/index.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/lib/cookie.ts":
/*!****************************************************!*\
  !*** ./resources/ts/modules/commons/lib/cookie.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    getItem: function (sKey) {\r\n        return decodeURIComponent(document.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null;\r\n    },\r\n    setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {\r\n        if (vEnd === void 0) { vEnd = Infinity; }\r\n        if (sPath === void 0) { sPath = '/'; }\r\n        if (sDomain === void 0) { sDomain = ''; }\r\n        if (bSecure === void 0) { bSecure = false; }\r\n        if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) {\r\n            return false;\r\n        }\r\n        var sExpires = \"\";\r\n        if (vEnd) {\r\n            switch (true) {\r\n                case (typeof vEnd === 'number'):\r\n                    sExpires = vEnd === Infinity ? \"; expires=Fri, 31 Dec 9999 23:59:59 GMT\" : \"; max-age=\" + vEnd;\r\n                    break;\r\n                case (typeof vEnd === 'string'):\r\n                    sExpires = \"; expires=\" + vEnd;\r\n                    break;\r\n                default:\r\n                    sExpires = \"; expires=\" + vEnd.toUTCString();\r\n                    break;\r\n            }\r\n        }\r\n        document.cookie = encodeURIComponent(sKey) + \"=\" + encodeURIComponent(sValue) + sExpires + (sDomain ? \"; domain=\" + sDomain : \"\") + (sPath ? \"; path=\" + sPath : \"\") + (bSecure ? \"; secure\" : \"\");\r\n        return true;\r\n    },\r\n    removeItem: function (sKey, sPath, sDomain) {\r\n        if (!sKey || !this.hasItem(sKey)) {\r\n            return false;\r\n        }\r\n        document.cookie = encodeURIComponent(sKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (sDomain ? \"; domain=\" + sDomain : \"\") + (sPath ? \"; path=\" + sPath : \"\");\r\n        return true;\r\n    },\r\n    hasItem: function (sKey) {\r\n        return (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(document.cookie);\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2xpYi9jb29raWUudHM/MzAzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlO0FBQ2Y7QUFDQSxpRkFBaUYsbUZBQW1GO0FBQ3BLLEtBQUs7QUFDTDtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0MsK0JBQStCLGFBQWE7QUFDNUMsaUNBQWlDLGNBQWM7QUFDL0MsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0Q0FBNEM7QUFDakc7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCx1Q0FBdUMscUNBQXFDO0FBQzVMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVEQUF1RCx1Q0FBdUM7QUFDdEo7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxDQUFDLEVBQUMiLCJmaWxlIjoiLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2xpYi9jb29raWUudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiAoc0tleSkge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuY29va2llLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/Oig/Ol58Lio7KVxcXFxzKlwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNLZXkpLnJlcGxhY2UoL1tcXC1cXC5cXCtcXCpdL2csIFwiXFxcXCQmXCIpICsgXCJcXFxccypcXFxcPVxcXFxzKihbXjtdKikuKiQpfF4uKiRcIiksIFwiJDFcIikpIHx8IG51bGw7XHJcbiAgICB9LFxyXG4gICAgc2V0SXRlbTogZnVuY3Rpb24gKHNLZXksIHNWYWx1ZSwgdkVuZCwgc1BhdGgsIHNEb21haW4sIGJTZWN1cmUpIHtcclxuICAgICAgICBpZiAodkVuZCA9PT0gdm9pZCAwKSB7IHZFbmQgPSBJbmZpbml0eTsgfVxyXG4gICAgICAgIGlmIChzUGF0aCA9PT0gdm9pZCAwKSB7IHNQYXRoID0gJy8nOyB9XHJcbiAgICAgICAgaWYgKHNEb21haW4gPT09IHZvaWQgMCkgeyBzRG9tYWluID0gJyc7IH1cclxuICAgICAgICBpZiAoYlNlY3VyZSA9PT0gdm9pZCAwKSB7IGJTZWN1cmUgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICghc0tleSB8fCAvXig/OmV4cGlyZXN8bWF4XFwtYWdlfHBhdGh8ZG9tYWlufHNlY3VyZSkkL2kudGVzdChzS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzRXhwaXJlcyA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHZFbmQpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICh0eXBlb2YgdkVuZCA9PT0gJ251bWJlcicpOlxyXG4gICAgICAgICAgICAgICAgICAgIHNFeHBpcmVzID0gdkVuZCA9PT0gSW5maW5pdHkgPyBcIjsgZXhwaXJlcz1GcmksIDMxIERlYyA5OTk5IDIzOjU5OjU5IEdNVFwiIDogXCI7IG1heC1hZ2U9XCIgKyB2RW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAodHlwZW9mIHZFbmQgPT09ICdzdHJpbmcnKTpcclxuICAgICAgICAgICAgICAgICAgICBzRXhwaXJlcyA9IFwiOyBleHBpcmVzPVwiICsgdkVuZDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc0V4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIHZFbmQudG9VVENTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoc0tleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzVmFsdWUpICsgc0V4cGlyZXMgKyAoc0RvbWFpbiA/IFwiOyBkb21haW49XCIgKyBzRG9tYWluIDogXCJcIikgKyAoc1BhdGggPyBcIjsgcGF0aD1cIiArIHNQYXRoIDogXCJcIikgKyAoYlNlY3VyZSA/IFwiOyBzZWN1cmVcIiA6IFwiXCIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChzS2V5LCBzUGF0aCwgc0RvbWFpbikge1xyXG4gICAgICAgIGlmICghc0tleSB8fCAhdGhpcy5oYXNJdGVtKHNLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHNLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UXCIgKyAoc0RvbWFpbiA/IFwiOyBkb21haW49XCIgKyBzRG9tYWluIDogXCJcIikgKyAoc1BhdGggPyBcIjsgcGF0aD1cIiArIHNQYXRoIDogXCJcIik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgaGFzSXRlbTogZnVuY3Rpb24gKHNLZXkpIHtcclxuICAgICAgICByZXR1cm4gKG5ldyBSZWdFeHAoXCIoPzpefDtcXFxccyopXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc0tleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgKyBcIlxcXFxzKlxcXFw9XCIpKS50ZXN0KGRvY3VtZW50LmNvb2tpZSk7XHJcbiAgICB9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/lib/cookie.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/lib/detect-mobile-browser.ts":
/*!*******************************************************************!*\
  !*** ./resources/ts/modules/commons/lib/detect-mobile-browser.ts ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var a = navigator.userAgent || navigator.vendor;\r\n    return (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4)));\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2xpYi9kZXRlY3QtbW9iaWxlLWJyb3dzZXIudHM/NGE4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFnQjtBQUNoQjtBQUNBO0FBQ0EsQ0FBQyxFQUFFIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3RzL21vZHVsZXMvY29tbW9ucy9saWIvZGV0ZWN0LW1vYmlsZS1icm93c2VyLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yO1xyXG4gICAgcmV0dXJuICgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdChhKSB8fCAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsIDQpKSk7XHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/lib/detect-mobile-browser.ts\n");

/***/ }),

/***/ "./resources/ts/modules/commons/lib/get-element-position.ts":
/*!******************************************************************!*\
  !*** ./resources/ts/modules/commons/lib/get-element-position.ts ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (el) {\r\n    var rect = el.getBoundingClientRect();\r\n    return {\r\n        left: rect.left + window.scrollX,\r\n        top: rect.top + window.scrollY\r\n    };\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2xpYi9nZXQtZWxlbWVudC1wb3NpdGlvbi50cz9lOTQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUiLCJmaWxlIjoiLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9jb21tb25zL2xpYi9nZXQtZWxlbWVudC1wb3NpdGlvbi50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoZWwpIHtcclxuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYLFxyXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWVxyXG4gICAgfTtcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/ts/modules/commons/lib/get-element-position.ts\n");

/***/ }),

/***/ "./resources/ts/modules/landing/components/accommodation.ts":
/*!******************************************************************!*\
  !*** ./resources/ts/modules/landing/components/accommodation.ts ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var roomTypes = document.getElementById('room-types');\r\n    var accommodationLink = document.getElementById('accommodation-link');\r\n    var accommodationSectionTabs = function (oldInstance) {\r\n        if (oldInstance) {\r\n            oldInstance.destroy();\r\n            roomTypes.querySelectorAll('.active').forEach(function (activeEl) { return activeEl.classList.remove('active'); });\r\n        }\r\n        var tabInst = materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Tabs\"].init(roomTypes, {\r\n            swipeable: true,\r\n            onShow: function (_a) {\r\n                var id = _a.id;\r\n                var index = tabInst ? tabInst.index : 0;\r\n                var child = tabContent && tabContent.children[index];\r\n                accommodationLink.href = \"/accommodation/\" + (child ? child.id : id);\r\n            }\r\n        });\r\n        var tabContent = document.querySelector('.tabs-content');\r\n        tabContent.style.height = '';\r\n        return tabInst;\r\n    };\r\n    var accommodationTabInstance = accommodationSectionTabs();\r\n    window.addEventListener('resize', function () {\r\n        accommodationTabInstance = accommodationSectionTabs(accommodationTabInstance);\r\n    });\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvYWNjb21tb2RhdGlvbi50cz9iZTE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUF1QztBQUN2QjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDRDQUE0QyxFQUFFO0FBQzdIO0FBQ0Esc0JBQXNCLG9EQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBRSIsImZpbGUiOiIuL3Jlc291cmNlcy90cy9tb2R1bGVzL2xhbmRpbmcvY29tcG9uZW50cy9hY2NvbW1vZGF0aW9uLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGFicyB9IGZyb20gJ21hdGVyaWFsaXplLWNzcyc7XHJcbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcm9vbVR5cGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb20tdHlwZXMnKTtcclxuICAgIHZhciBhY2NvbW1vZGF0aW9uTGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY2NvbW1vZGF0aW9uLWxpbmsnKTtcclxuICAgIHZhciBhY2NvbW1vZGF0aW9uU2VjdGlvblRhYnMgPSBmdW5jdGlvbiAob2xkSW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAob2xkSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgb2xkSW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICByb29tVHlwZXMucXVlcnlTZWxlY3RvckFsbCgnLmFjdGl2ZScpLmZvckVhY2goZnVuY3Rpb24gKGFjdGl2ZUVsKSB7IHJldHVybiBhY3RpdmVFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YWJJbnN0ID0gVGFicy5pbml0KHJvb21UeXBlcywge1xyXG4gICAgICAgICAgICBzd2lwZWFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYS5pZDtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRhYkluc3QgPyB0YWJJbnN0LmluZGV4IDogMDtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRhYkNvbnRlbnQgJiYgdGFiQ29udGVudC5jaGlsZHJlbltpbmRleF07XHJcbiAgICAgICAgICAgICAgICBhY2NvbW1vZGF0aW9uTGluay5ocmVmID0gXCIvYWNjb21tb2RhdGlvbi9cIiArIChjaGlsZCA/IGNoaWxkLmlkIDogaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHRhYkNvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFicy1jb250ZW50Jyk7XHJcbiAgICAgICAgdGFiQ29udGVudC5zdHlsZS5oZWlnaHQgPSAnJztcclxuICAgICAgICByZXR1cm4gdGFiSW5zdDtcclxuICAgIH07XHJcbiAgICB2YXIgYWNjb21tb2RhdGlvblRhYkluc3RhbmNlID0gYWNjb21tb2RhdGlvblNlY3Rpb25UYWJzKCk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFjY29tbW9kYXRpb25UYWJJbnN0YW5jZSA9IGFjY29tbW9kYXRpb25TZWN0aW9uVGFicyhhY2NvbW1vZGF0aW9uVGFiSW5zdGFuY2UpO1xyXG4gICAgfSk7XHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/landing/components/accommodation.ts\n");

/***/ }),

/***/ "./resources/ts/modules/landing/components/gallery.ts":
/*!************************************************************!*\
  !*** ./resources/ts/modules/landing/components/gallery.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/dist/js/swiper.esm.bundle.js\");\n/* harmony import */ var photoswipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! photoswipe */ \"./node_modules/photoswipe/dist/photoswipe.js\");\n/* harmony import */ var photoswipe__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(photoswipe__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var photoswipe_dist_photoswipe_ui_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! photoswipe/dist/photoswipe-ui-default */ \"./node_modules/photoswipe/dist/photoswipe-ui-default.js\");\n/* harmony import */ var photoswipe_dist_photoswipe_ui_default__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(photoswipe_dist_photoswipe_ui_default__WEBPACK_IMPORTED_MODULE_2__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar _this = undefined;\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () { return __awaiter(_this, void 0, void 0, function () {\r\n    var GALLERY_SELECTOR, uri, imgData, swiper_1;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                GALLERY_SELECTOR = 'gallery';\r\n                return [4 /*yield*/, getUris()];\r\n            case 1:\r\n                uri = _a.sent();\r\n                return [4 /*yield*/, loadImages(uri)];\r\n            case 2:\r\n                imgData = _a.sent();\r\n                if (imgData.length > 0) {\r\n                    markWithClassName(GALLERY_SELECTOR + \"__ready\");\r\n                    imgData.forEach(function (_a, i) {\r\n                        var src = _a.src;\r\n                        return addSlide(createSlide(src, i));\r\n                    });\r\n                    swiper_1 = new swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.swiper-container', {\r\n                        autoplay: true,\r\n                        breakpointsInverse: true,\r\n                        breakpoints: {\r\n                            0: {\r\n                                slidesPerView: 1\r\n                            },\r\n                            500: {\r\n                                slidesPerView: 2\r\n                            },\r\n                            800: {\r\n                                slidesPerView: 3\r\n                            },\r\n                            1100: {\r\n                                slidesPerView: 4\r\n                            },\r\n                            1300: {\r\n                                slidesPerView: 5\r\n                            }\r\n                        }\r\n                    });\r\n                    swiper_1.on('tap', function () {\r\n                        var args = [];\r\n                        for (var _i = 0; _i < arguments.length; _i++) {\r\n                            args[_i] = arguments[_i];\r\n                        }\r\n                        var index = args[0].target.parentNode.dataset.index;\r\n                        new photoswipe__WEBPACK_IMPORTED_MODULE_1___default.a(document.querySelector('.pswp'), photoswipe_dist_photoswipe_ui_default__WEBPACK_IMPORTED_MODULE_2___default.a, imgData, {\r\n                            index: +index,\r\n                            showHideOpacity: true,\r\n                            getThumbBoundsFn: function (num) {\r\n                                swiper_1.slideTo(num);\r\n                                var _a = document.querySelector(\".swiper-slide[data-index='\" + num + \"']\").getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width;\r\n                                return {\r\n                                    x: left,\r\n                                    y: top + (window.pageYOffset || document.documentElement.scrollTop),\r\n                                    w: width\r\n                                };\r\n                            }\r\n                        }).init();\r\n                    });\r\n                }\r\n                else {\r\n                    markWithClassName(GALLERY_SELECTOR + \"__failed\");\r\n                }\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}); });\r\nfunction markWithClassName(className) {\r\n    if (className === void 0) { className = 'gallery__ready'; }\r\n    var gallery = document.getElementById('gallery');\r\n    if (gallery !== null) {\r\n        gallery.classList.add(className);\r\n    }\r\n}\r\nfunction createSlide(url, index) {\r\n    var instaIco = document.querySelector('.fa-instagram').cloneNode();\r\n    var swiperSlide = document.createElement('div');\r\n    swiperSlide.className = 'swiper-slide';\r\n    swiperSlide.style.backgroundImage = \"url(\" + url + \")\";\r\n    swiperSlide.dataset.index = \"\" + index;\r\n    swiperSlide.appendChild(instaIco);\r\n    return swiperSlide;\r\n}\r\nfunction addSlide(slide) {\r\n    document.querySelector('.swiper-wrapper').appendChild(slide);\r\n}\r\nfunction getUris() {\r\n    // fake request\r\n    return new Promise(function (res) { return setTimeout(function () { return res([\r\n        '/images/gallery-img-1.jpg',\r\n        '/images/gallery-img-2.jpg',\r\n        '/images/gallery-img-3.jpg',\r\n        '/images/gallery-img-4.jpg',\r\n        '/images/gallery-img-5.jpg',\r\n        '/images/gallery-img-6.jpg'\r\n    ]); }, 2000); });\r\n}\r\nfunction loadImages(imageUri) {\r\n    var resolver;\r\n    var images = [];\r\n    var checkNotify = function () {\r\n        if (images.length == imageUri.length && typeof resolver === 'function') {\r\n            resolver(images);\r\n        }\r\n    };\r\n    var _loop_1 = function (i) {\r\n        var uri = imageUri[i];\r\n        var img = new Image();\r\n        img.onload = function () {\r\n            images.push({\r\n                src: uri,\r\n                w: img.width,\r\n                h: img.height\r\n            });\r\n            checkNotify();\r\n        };\r\n        img.onerror = function () {\r\n            imageUri.splice(--i, 1);\r\n            checkNotify();\r\n        };\r\n        img.src = uri;\r\n        out_i_1 = i;\r\n    };\r\n    var out_i_1;\r\n    for (var i = 0; i < imageUri.length; i++) {\r\n        _loop_1(i);\r\n        i = out_i_1;\r\n    }\r\n    return new Promise(function (res) { return resolver = res; });\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvZ2FsbGVyeS50cz85NGNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixpRUFBaUUsdUJBQXVCLEVBQUUsNEJBQTRCO0FBQ3JKO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLFNBQUksSUFBSSxTQUFJO0FBQy9CLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0EsWUFBWSxTQUFJO0FBQ1k7QUFDUTtBQUNxQztBQUN6RCw0RUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQ0FBbUMsOENBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVUsa0NBQWtDLDRFQUFvQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyxFQUFFLEVBQUUsRUFBRTtBQUNQO0FBQ0EsK0JBQStCLDhCQUE4QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQ0FBZ0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFLFFBQVEsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLEVBQUU7QUFDaEUiLCJmaWxlIjoiLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvZ2FsbGVyeS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxudmFyIF90aGlzID0gdGhpcztcclxuaW1wb3J0IFN3aXBlciBmcm9tICdzd2lwZXInO1xyXG5pbXBvcnQgUGhvdG9Td2lwZSBmcm9tICdwaG90b3N3aXBlJztcclxuaW1wb3J0IFBob3RvU3dpcGVVSV9EZWZhdWx0IGZyb20gJ3Bob3Rvc3dpcGUvZGlzdC9waG90b3N3aXBlLXVpLWRlZmF1bHQnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIEdBTExFUllfU0VMRUNUT1IsIHVyaSwgaW1nRGF0YSwgc3dpcGVyXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBHQUxMRVJZX1NFTEVDVE9SID0gJ2dhbGxlcnknO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0VXJpcygpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgdXJpID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbG9hZEltYWdlcyh1cmkpXTtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgaW1nRGF0YSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbWdEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrV2l0aENsYXNzTmFtZShHQUxMRVJZX1NFTEVDVE9SICsgXCJfX3JlYWR5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltZ0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoX2EsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IF9hLnNyYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFNsaWRlKGNyZWF0ZVNsaWRlKHNyYywgaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcl8xID0gbmV3IFN3aXBlcignLnN3aXBlci1jb250YWluZXInLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha3BvaW50c0ludmVyc2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUwMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4MDA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTEwMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMzAwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVyXzEub24oJ3RhcCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhcmdzWzBdLnRhcmdldC5wYXJlbnROb2RlLmRhdGFzZXQuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQaG90b1N3aXBlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wc3dwJyksIFBob3RvU3dpcGVVSV9EZWZhdWx0LCBpbWdEYXRhLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogK2luZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0hpZGVPcGFjaXR5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGh1bWJCb3VuZHNGbjogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlcl8xLnNsaWRlVG8obnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnN3aXBlci1zbGlkZVtkYXRhLWluZGV4PSdcIiArIG51bSArIFwiJ11cIikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5pbml0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrV2l0aENsYXNzTmFtZShHQUxMRVJZX1NFTEVDVE9SICsgXCJfX2ZhaWxlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH0pO1xyXG5mdW5jdGlvbiBtYXJrV2l0aENsYXNzTmFtZShjbGFzc05hbWUpIHtcclxuICAgIGlmIChjbGFzc05hbWUgPT09IHZvaWQgMCkgeyBjbGFzc05hbWUgPSAnZ2FsbGVyeV9fcmVhZHknOyB9XHJcbiAgICB2YXIgZ2FsbGVyeSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYWxsZXJ5Jyk7XHJcbiAgICBpZiAoZ2FsbGVyeSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGdhbGxlcnkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNsaWRlKHVybCwgaW5kZXgpIHtcclxuICAgIHZhciBpbnN0YUljbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYS1pbnN0YWdyYW0nKS5jbG9uZU5vZGUoKTtcclxuICAgIHZhciBzd2lwZXJTbGlkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgc3dpcGVyU2xpZGUuY2xhc3NOYW1lID0gJ3N3aXBlci1zbGlkZSc7XHJcbiAgICBzd2lwZXJTbGlkZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIiArIHVybCArIFwiKVwiO1xyXG4gICAgc3dpcGVyU2xpZGUuZGF0YXNldC5pbmRleCA9IFwiXCIgKyBpbmRleDtcclxuICAgIHN3aXBlclNsaWRlLmFwcGVuZENoaWxkKGluc3RhSWNvKTtcclxuICAgIHJldHVybiBzd2lwZXJTbGlkZTtcclxufVxyXG5mdW5jdGlvbiBhZGRTbGlkZShzbGlkZSkge1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN3aXBlci13cmFwcGVyJykuYXBwZW5kQ2hpbGQoc2xpZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFVyaXMoKSB7XHJcbiAgICAvLyBmYWtlIHJlcXVlc3RcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcyhbXHJcbiAgICAgICAgJy9pbWFnZXMvZ2FsbGVyeS1pbWctMS5qcGcnLFxyXG4gICAgICAgICcvaW1hZ2VzL2dhbGxlcnktaW1nLTIuanBnJyxcclxuICAgICAgICAnL2ltYWdlcy9nYWxsZXJ5LWltZy0zLmpwZycsXHJcbiAgICAgICAgJy9pbWFnZXMvZ2FsbGVyeS1pbWctNC5qcGcnLFxyXG4gICAgICAgICcvaW1hZ2VzL2dhbGxlcnktaW1nLTUuanBnJyxcclxuICAgICAgICAnL2ltYWdlcy9nYWxsZXJ5LWltZy02LmpwZydcclxuICAgIF0pOyB9LCAyMDAwKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gbG9hZEltYWdlcyhpbWFnZVVyaSkge1xyXG4gICAgdmFyIHJlc29sdmVyO1xyXG4gICAgdmFyIGltYWdlcyA9IFtdO1xyXG4gICAgdmFyIGNoZWNrTm90aWZ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoID09IGltYWdlVXJpLmxlbmd0aCAmJiB0eXBlb2YgcmVzb2x2ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZXIoaW1hZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgIHZhciB1cmkgPSBpbWFnZVVyaVtpXTtcclxuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaW1hZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3JjOiB1cmksXHJcbiAgICAgICAgICAgICAgICB3OiBpbWcud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoOiBpbWcuaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjaGVja05vdGlmeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGltYWdlVXJpLnNwbGljZSgtLWksIDEpO1xyXG4gICAgICAgICAgICBjaGVja05vdGlmeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW1nLnNyYyA9IHVyaTtcclxuICAgICAgICBvdXRfaV8xID0gaTtcclxuICAgIH07XHJcbiAgICB2YXIgb3V0X2lfMTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VVcmkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBfbG9vcF8xKGkpO1xyXG4gICAgICAgIGkgPSBvdXRfaV8xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlc29sdmVyID0gcmVzOyB9KTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/landing/components/gallery.ts\n");

/***/ }),

/***/ "./resources/ts/modules/landing/components/main-slider.ts":
/*!****************************************************************!*\
  !*** ./resources/ts/modules/landing/components/main-slider.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var navbar = document.getElementById('app-navbar');\r\n    var mainSlider = document.getElementById('main-slider');\r\n    var OFFSET = 10;\r\n    var mainSliderInitializer = function (oldInstance) {\r\n        if (oldInstance) {\r\n            oldInstance.destroy();\r\n        }\r\n        return materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Slider\"].init(mainSlider, {\r\n            height: window.innerHeight - navbar.offsetHeight - 40 - OFFSET\r\n        });\r\n    };\r\n    var mainSliderInstance = mainSliderInitializer();\r\n    window.addEventListener('resize', function () {\r\n        if (window.innerHeight < 400) {\r\n            return;\r\n        }\r\n        mainSliderInstance = mainSliderInitializer(mainSliderInstance);\r\n    });\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvbWFpbi1zbGlkZXIudHM/ZjZjZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBeUM7QUFDekI7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFNO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBRSIsImZpbGUiOiIuL3Jlc291cmNlcy90cy9tb2R1bGVzL2xhbmRpbmcvY29tcG9uZW50cy9tYWluLXNsaWRlci50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaWRlciB9IGZyb20gJ21hdGVyaWFsaXplLWNzcyc7XHJcbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbmF2YmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcC1uYXZiYXInKTtcclxuICAgIHZhciBtYWluU2xpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4tc2xpZGVyJyk7XHJcbiAgICB2YXIgT0ZGU0VUID0gMTA7XHJcbiAgICB2YXIgbWFpblNsaWRlckluaXRpYWxpemVyID0gZnVuY3Rpb24gKG9sZEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKG9sZEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIG9sZEluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNsaWRlci5pbml0KG1haW5TbGlkZXIsIHtcclxuICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBuYXZiYXIub2Zmc2V0SGVpZ2h0IC0gNDAgLSBPRkZTRVRcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgbWFpblNsaWRlckluc3RhbmNlID0gbWFpblNsaWRlckluaXRpYWxpemVyKCk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgPCA0MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYWluU2xpZGVySW5zdGFuY2UgPSBtYWluU2xpZGVySW5pdGlhbGl6ZXIobWFpblNsaWRlckluc3RhbmNlKTtcclxuICAgIH0pO1xyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/ts/modules/landing/components/main-slider.ts\n");

/***/ }),

/***/ "./resources/ts/modules/landing/components/map.ts":
/*!********************************************************!*\
  !*** ./resources/ts/modules/landing/components/map.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nif (typeof window === 'object') {\r\n    var w = window;\r\n    w.initMap = function () {\r\n        var TITLE = 'PEACE HEAVEN';\r\n        var ZOOM = 13;\r\n        var POSITION = {\r\n            lat: 47.109426,\r\n            lng: 37.648601\r\n        };\r\n        var map = new google.maps.Map(document.getElementById('map'), {\r\n            zoom: ZOOM,\r\n            center: POSITION,\r\n            mapTypeControl: true,\r\n            mapTypeControlOptions: {\r\n                style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,\r\n                position: google.maps.ControlPosition.TOP_CENTER\r\n            },\r\n            zoomControl: true,\r\n            zoomControlOptions: {\r\n                position: google.maps.ControlPosition.LEFT_CENTER\r\n            },\r\n            scaleControl: true,\r\n            streetViewControl: true,\r\n            streetViewControlOptions: {\r\n                position: google.maps.ControlPosition.LEFT_TOP\r\n            },\r\n            fullscreenControl: false\r\n        });\r\n        var marker = new google.maps.Marker({\r\n            position: POSITION,\r\n            map: map,\r\n            title: TITLE\r\n        });\r\n        var tooltip = new google.maps.InfoWindow({\r\n            content: document.getElementById('map__t'),\r\n            maxWidth: 184\r\n        });\r\n        tooltip.open(map, marker);\r\n        marker.addListener('click', function () {\r\n            tooltip.open(map, marker);\r\n        });\r\n        google.maps.event.addDomListener(window, 'resize', function () { return map.setCenter(POSITION); });\r\n    };\r\n}\r\n;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvbWFwLnRzPzAzODciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3RUFBd0UsZ0NBQWdDLEVBQUU7QUFDMUc7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3RzL21vZHVsZXMvbGFuZGluZy9jb21wb25lbnRzL21hcC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcclxuICAgIHZhciB3ID0gd2luZG93O1xyXG4gICAgdy5pbml0TWFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBUSVRMRSA9ICdQRUFDRSBIRUFWRU4nO1xyXG4gICAgICAgIHZhciBaT09NID0gMTM7XHJcbiAgICAgICAgdmFyIFBPU0lUSU9OID0ge1xyXG4gICAgICAgICAgICBsYXQ6IDQ3LjEwOTQyNixcclxuICAgICAgICAgICAgbG5nOiAzNy42NDg2MDFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXAnKSwge1xyXG4gICAgICAgICAgICB6b29tOiBaT09NLFxyXG4gICAgICAgICAgICBjZW50ZXI6IFBPU0lUSU9OLFxyXG4gICAgICAgICAgICBtYXBUeXBlQ29udHJvbDogdHJ1ZSxcclxuICAgICAgICAgICAgbWFwVHlwZUNvbnRyb2xPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogZ29vZ2xlLm1hcHMuTWFwVHlwZUNvbnRyb2xTdHlsZS5IT1JJWk9OVEFMX0JBUixcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBnb29nbGUubWFwcy5Db250cm9sUG9zaXRpb24uVE9QX0NFTlRFUlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6b29tQ29udHJvbDogdHJ1ZSxcclxuICAgICAgICAgICAgem9vbUNvbnRyb2xPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZ29vZ2xlLm1hcHMuQ29udHJvbFBvc2l0aW9uLkxFRlRfQ0VOVEVSXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNjYWxlQ29udHJvbDogdHJ1ZSxcclxuICAgICAgICAgICAgc3RyZWV0Vmlld0NvbnRyb2w6IHRydWUsXHJcbiAgICAgICAgICAgIHN0cmVldFZpZXdDb250cm9sT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbi5MRUZUX1RPUFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdWxsc2NyZWVuQ29udHJvbDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBQT1NJVElPTixcclxuICAgICAgICAgICAgbWFwOiBtYXAsXHJcbiAgICAgICAgICAgIHRpdGxlOiBUSVRMRVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciB0b29sdGlwID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coe1xyXG4gICAgICAgICAgICBjb250ZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwX190JyksXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiAxODRcclxuICAgICAgICB9KTtcclxuICAgICAgICB0b29sdGlwLm9wZW4obWFwLCBtYXJrZXIpO1xyXG4gICAgICAgIG1hcmtlci5hZGRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXAub3BlbihtYXAsIG1hcmtlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIod2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFwLnNldENlbnRlcihQT1NJVElPTik7IH0pO1xyXG4gICAgfTtcclxufVxyXG47XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/ts/modules/landing/components/map.ts\n");

/***/ }),

/***/ "./resources/ts/modules/landing/components/offers.ts":
/*!***********************************************************!*\
  !*** ./resources/ts/modules/landing/components/offers.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! materialize-css */ \"./node_modules/materialize-css/dist/js/materialize.js\");\n/* harmony import */ var materialize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(materialize_css__WEBPACK_IMPORTED_MODULE_0__);\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var offersCarousel = document.getElementById('offers-carousel');\r\n    var offersCardTitle = document.querySelector('#offers-card .card-title');\r\n    var offersCardText = document.querySelector('#offers-card .card-text');\r\n    var offersSectionCarousel = function (oldInstance) {\r\n        if (oldInstance) {\r\n            oldInstance.destroy();\r\n        }\r\n        return materialize_css__WEBPACK_IMPORTED_MODULE_0__[\"Carousel\"].init(offersCarousel, {\r\n            onCycleTo: function (el) {\r\n                offersCardTitle.innerHTML = el.querySelector('.offer__title').innerHTML;\r\n                offersCardText.innerHTML = el.querySelector('.offer__desc').innerHTML;\r\n            }\r\n        });\r\n    };\r\n    var offersSectionCarouselInstance = offersSectionCarousel();\r\n    window.addEventListener('resize', function () {\r\n        offersSectionCarouselInstance = offersSectionCarousel(offersSectionCarouselInstance);\r\n    });\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvb2ZmZXJzLnRzPzM5MGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQTJDO0FBQzNCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLEVBQUUiLCJmaWxlIjoiLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2NvbXBvbmVudHMvb2ZmZXJzLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2Fyb3VzZWwgfSBmcm9tICdtYXRlcmlhbGl6ZS1jc3MnO1xyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG9mZmVyc0Nhcm91c2VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29mZmVycy1jYXJvdXNlbCcpO1xyXG4gICAgdmFyIG9mZmVyc0NhcmRUaXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNvZmZlcnMtY2FyZCAuY2FyZC10aXRsZScpO1xyXG4gICAgdmFyIG9mZmVyc0NhcmRUZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI29mZmVycy1jYXJkIC5jYXJkLXRleHQnKTtcclxuICAgIHZhciBvZmZlcnNTZWN0aW9uQ2Fyb3VzZWwgPSBmdW5jdGlvbiAob2xkSW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAob2xkSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgb2xkSW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ2Fyb3VzZWwuaW5pdChvZmZlcnNDYXJvdXNlbCwge1xyXG4gICAgICAgICAgICBvbkN5Y2xlVG86IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgb2ZmZXJzQ2FyZFRpdGxlLmlubmVySFRNTCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5vZmZlcl9fdGl0bGUnKS5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgICAgICBvZmZlcnNDYXJkVGV4dC5pbm5lckhUTUwgPSBlbC5xdWVyeVNlbGVjdG9yKCcub2ZmZXJfX2Rlc2MnKS5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgb2ZmZXJzU2VjdGlvbkNhcm91c2VsSW5zdGFuY2UgPSBvZmZlcnNTZWN0aW9uQ2Fyb3VzZWwoKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2ZmZXJzU2VjdGlvbkNhcm91c2VsSW5zdGFuY2UgPSBvZmZlcnNTZWN0aW9uQ2Fyb3VzZWwob2ZmZXJzU2VjdGlvbkNhcm91c2VsSW5zdGFuY2UpO1xyXG4gICAgfSk7XHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/landing/components/offers.ts\n");

/***/ }),

/***/ "./resources/ts/modules/landing/index.ts":
/*!***********************************************!*\
  !*** ./resources/ts/modules/landing/index.ts ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _commons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../commons */ \"./resources/ts/modules/commons/index.ts\");\n/* harmony import */ var _commons_components_collapsible__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../commons/components/collapsible */ \"./resources/ts/modules/commons/components/collapsible.ts\");\n/* harmony import */ var _commons_components_book_now_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../commons/components/book-now-modal */ \"./resources/ts/modules/commons/components/book-now-modal.ts\");\n/* harmony import */ var _commons_lib_get_element_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../commons/lib/get-element-position */ \"./resources/ts/modules/commons/lib/get-element-position.ts\");\n/* harmony import */ var _components_main_slider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/main-slider */ \"./resources/ts/modules/landing/components/main-slider.ts\");\n/* harmony import */ var _components_accommodation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/accommodation */ \"./resources/ts/modules/landing/components/accommodation.ts\");\n/* harmony import */ var _components_offers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/offers */ \"./resources/ts/modules/landing/components/offers.ts\");\n/* harmony import */ var _components_gallery__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/gallery */ \"./resources/ts/modules/landing/components/gallery.ts\");\n/* harmony import */ var _components_map__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/map */ \"./resources/ts/modules/landing/components/map.ts\");\n/* harmony import */ var _components_map__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_components_map__WEBPACK_IMPORTED_MODULE_8__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar _this = undefined;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nwindow.addEventListener('DOMContentLoaded', function () { return __awaiter(_this, void 0, void 0, function () {\r\n    function serviceWrapperPosition() {\r\n        var offersDescription = document.getElementById('offers__desc');\r\n        document.getElementById('service-wrapper').style.top = Object(_commons_lib_get_element_position__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(offersDescription).top + offersDescription.offsetHeight + 80 + \"px\";\r\n    }\r\n    return __generator(this, function (_a) {\r\n        Object(_commons__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n        Object(_commons_components_collapsible__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\n        Object(_commons_components_book_now_modal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\r\n        Object(_components_main_slider__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\r\n        Object(_components_accommodation__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\r\n        Object(_components_offers__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\r\n        Object(_components_gallery__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\r\n        serviceWrapperPosition();\r\n        window.addEventListener('resize', serviceWrapperPosition);\r\n        window.addEventListener('load', serviceWrapperPosition);\r\n        ;\r\n        return [2 /*return*/];\r\n    });\r\n}); });\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdHMvbW9kdWxlcy9sYW5kaW5nL2luZGV4LnRzPzUyYmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixpRUFBaUUsdUJBQXVCLEVBQUUsNEJBQTRCO0FBQ3JKO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLFNBQUksSUFBSSxTQUFJO0FBQy9CLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0EsWUFBWSxTQUFJO0FBQ2lCO0FBQzJCO0FBQ0k7QUFDSztBQUNuQjtBQUNLO0FBQ2Q7QUFDRTtBQUNqQjtBQUMxQix5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLCtEQUErRCxpRkFBa0I7QUFDakY7QUFDQTtBQUNBLFFBQVEsd0RBQU87QUFDZixRQUFRLCtFQUFXO0FBQ25CLFFBQVEsa0ZBQVk7QUFDcEIsUUFBUSx1RUFBVTtBQUNsQixRQUFRLHlFQUFhO0FBQ3JCLFFBQVEsa0VBQU07QUFDZCxRQUFRLG1FQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLEVBQUUsRUFBRSIsImZpbGUiOiIuL3Jlc291cmNlcy90cy9tb2R1bGVzL2xhbmRpbmcvaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfdGhpcyA9IHRoaXM7XHJcbmltcG9ydCBjb21tb25zIGZyb20gJy4uL2NvbW1vbnMnO1xyXG5pbXBvcnQgY29sbGFwc2libGUgZnJvbSAnLi4vY29tbW9ucy9jb21wb25lbnRzL2NvbGxhcHNpYmxlJztcclxuaW1wb3J0IGJvb2tOb3dNb2RhbCBmcm9tICcuLi9jb21tb25zL2NvbXBvbmVudHMvYm9vay1ub3ctbW9kYWwnO1xyXG5pbXBvcnQgZ2V0RWxlbWVudFBvc2l0aW9uIGZyb20gJy4uL2NvbW1vbnMvbGliL2dldC1lbGVtZW50LXBvc2l0aW9uJztcclxuaW1wb3J0IG1haW5TbGlkZXIgZnJvbSAnLi9jb21wb25lbnRzL21haW4tc2xpZGVyJztcclxuaW1wb3J0IGFjY29tbW9kYXRpb24gZnJvbSAnLi9jb21wb25lbnRzL2FjY29tbW9kYXRpb24nO1xyXG5pbXBvcnQgb2ZmZXJzIGZyb20gJy4vY29tcG9uZW50cy9vZmZlcnMnO1xyXG5pbXBvcnQgZ2FsbGVyeSBmcm9tICcuL2NvbXBvbmVudHMvZ2FsbGVyeSc7XHJcbmltcG9ydCAnLi9jb21wb25lbnRzL21hcCc7XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gc2VydmljZVdyYXBwZXJQb3NpdGlvbigpIHtcclxuICAgICAgICB2YXIgb2ZmZXJzRGVzY3JpcHRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb2ZmZXJzX19kZXNjJyk7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcnZpY2Utd3JhcHBlcicpLnN0eWxlLnRvcCA9IGdldEVsZW1lbnRQb3NpdGlvbihvZmZlcnNEZXNjcmlwdGlvbikudG9wICsgb2ZmZXJzRGVzY3JpcHRpb24ub2Zmc2V0SGVpZ2h0ICsgODAgKyBcInB4XCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgY29tbW9ucygpO1xyXG4gICAgICAgIGNvbGxhcHNpYmxlKCk7XHJcbiAgICAgICAgYm9va05vd01vZGFsKCk7XHJcbiAgICAgICAgbWFpblNsaWRlcigpO1xyXG4gICAgICAgIGFjY29tbW9kYXRpb24oKTtcclxuICAgICAgICBvZmZlcnMoKTtcclxuICAgICAgICBnYWxsZXJ5KCk7XHJcbiAgICAgICAgc2VydmljZVdyYXBwZXJQb3NpdGlvbigpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZXJ2aWNlV3JhcHBlclBvc2l0aW9uKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHNlcnZpY2VXcmFwcGVyUG9zaXRpb24pO1xyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICB9KTtcclxufSk7IH0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/ts/modules/landing/index.ts\n");

/***/ }),

/***/ 1:
/*!*****************************************************!*\
  !*** multi ./resources/ts/modules/landing/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\godoggy_website\resources\ts\modules\landing\index.ts */"./resources/ts/modules/landing/index.ts");


/***/ })

/******/ });